// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension RoboMakerClientTypes {
    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arm64
        case armhf
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .armhf,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "ARM64"
            case .armhf: return "ARMHF"
            case .x8664: return "X86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
        }
    }
}

public struct BatchDeleteWorldsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteWorldsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteWorldsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteWorldsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteWorldsOutputError>
}

extension BatchDeleteWorldsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteWorldsInput(worlds: \(Swift.String(describing: worlds)))"}
}

extension BatchDeleteWorldsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case worlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arns0 in worlds {
                try worldsContainer.encode(arns0)
            }
        }
    }
}

public struct BatchDeleteWorldsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteWorldsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteWorldsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteWorldsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteWorldsOutputError>
}

public struct BatchDeleteWorldsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteWorldsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteWorldsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteWorldsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteWorldsOutputError>
}

public struct BatchDeleteWorldsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteWorldsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchDeleteWorldsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/batchDeleteWorlds"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDeleteWorldsInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteWorldsOutputError>
}

public struct BatchDeleteWorldsInput: Swift.Equatable {
    /// A list of Amazon Resource Names (arns) that correspond to worlds to delete.
    /// This member is required.
    public var worlds: [Swift.String]?

    public init (
        worlds: [Swift.String]? = nil
    )
    {
        self.worlds = worlds
    }
}

struct BatchDeleteWorldsInputBody: Swift.Equatable {
    public let worlds: [Swift.String]?
}

extension BatchDeleteWorldsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case worlds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
    }
}

extension BatchDeleteWorldsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteWorldsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteWorldsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteWorldsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteWorldsOutputResponse(unprocessedWorlds: \(Swift.String(describing: unprocessedWorlds)))"}
}

extension BatchDeleteWorldsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDeleteWorldsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedWorlds = output.unprocessedWorlds
        } else {
            self.unprocessedWorlds = nil
        }
    }
}

public struct BatchDeleteWorldsOutputResponse: Swift.Equatable {
    /// A list of unprocessed worlds associated with the call. These worlds were not
    ///          deleted.
    public var unprocessedWorlds: [Swift.String]?

    public init (
        unprocessedWorlds: [Swift.String]? = nil
    )
    {
        self.unprocessedWorlds = unprocessedWorlds
    }
}

struct BatchDeleteWorldsOutputResponseBody: Swift.Equatable {
    public let unprocessedWorlds: [Swift.String]?
}

extension BatchDeleteWorldsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedWorlds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedWorldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .unprocessedWorlds)
        var unprocessedWorldsDecoded0:[Swift.String]? = nil
        if let unprocessedWorldsContainer = unprocessedWorldsContainer {
            unprocessedWorldsDecoded0 = [Swift.String]()
            for string0 in unprocessedWorldsContainer {
                if let string0 = string0 {
                    unprocessedWorldsDecoded0?.append(string0)
                }
            }
        }
        unprocessedWorlds = unprocessedWorldsDecoded0
    }
}

public struct BatchDescribeSimulationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDescribeSimulationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDescribeSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDescribeSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDescribeSimulationJobOutputError>
}

extension BatchDescribeSimulationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDescribeSimulationJobInput(jobs: \(Swift.String(describing: jobs)))"}
}

extension BatchDescribeSimulationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobs = jobs {
            var jobsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobs)
            for arns0 in jobs {
                try jobsContainer.encode(arns0)
            }
        }
    }
}

public struct BatchDescribeSimulationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDescribeSimulationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDescribeSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDescribeSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDescribeSimulationJobOutputError>
}

public struct BatchDescribeSimulationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDescribeSimulationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDescribeSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDescribeSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDescribeSimulationJobOutputError>
}

public struct BatchDescribeSimulationJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDescribeSimulationJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchDescribeSimulationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/batchDescribeSimulationJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDescribeSimulationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDescribeSimulationJobOutputError>
}

public struct BatchDescribeSimulationJobInput: Swift.Equatable {
    /// A list of Amazon Resource Names (ARNs) of simulation jobs to describe.
    /// This member is required.
    public var jobs: [Swift.String]?

    public init (
        jobs: [Swift.String]? = nil
    )
    {
        self.jobs = jobs
    }
}

struct BatchDescribeSimulationJobInputBody: Swift.Equatable {
    public let jobs: [Swift.String]?
}

extension BatchDescribeSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobs)
        var jobsDecoded0:[Swift.String]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [Swift.String]()
            for string0 in jobsContainer {
                if let string0 = string0 {
                    jobsDecoded0?.append(string0)
                }
            }
        }
        jobs = jobsDecoded0
    }
}

extension BatchDescribeSimulationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDescribeSimulationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDescribeSimulationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDescribeSimulationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDescribeSimulationJobOutputResponse(jobs: \(Swift.String(describing: jobs)), unprocessedJobs: \(Swift.String(describing: unprocessedJobs)))"}
}

extension BatchDescribeSimulationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDescribeSimulationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.unprocessedJobs = output.unprocessedJobs
        } else {
            self.jobs = nil
            self.unprocessedJobs = nil
        }
    }
}

public struct BatchDescribeSimulationJobOutputResponse: Swift.Equatable {
    /// A list of simulation jobs.
    public var jobs: [RoboMakerClientTypes.SimulationJob]?
    /// A list of unprocessed simulation job Amazon Resource Names (ARNs).
    public var unprocessedJobs: [Swift.String]?

    public init (
        jobs: [RoboMakerClientTypes.SimulationJob]? = nil,
        unprocessedJobs: [Swift.String]? = nil
    )
    {
        self.jobs = jobs
        self.unprocessedJobs = unprocessedJobs
    }
}

struct BatchDescribeSimulationJobOutputResponseBody: Swift.Equatable {
    public let jobs: [RoboMakerClientTypes.SimulationJob]?
    public let unprocessedJobs: [Swift.String]?
}

extension BatchDescribeSimulationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case unprocessedJobs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJob?].self, forKey: .jobs)
        var jobsDecoded0:[RoboMakerClientTypes.SimulationJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [RoboMakerClientTypes.SimulationJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let unprocessedJobsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .unprocessedJobs)
        var unprocessedJobsDecoded0:[Swift.String]? = nil
        if let unprocessedJobsContainer = unprocessedJobsContainer {
            unprocessedJobsDecoded0 = [Swift.String]()
            for string0 in unprocessedJobsContainer {
                if let string0 = string0 {
                    unprocessedJobsDecoded0?.append(string0)
                }
            }
        }
        unprocessedJobs = unprocessedJobsDecoded0
    }
}

extension RoboMakerClientTypes.BatchPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxConcurrency
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let timeoutInSeconds = timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
    }
}

extension RoboMakerClientTypes.BatchPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPolicy(maxConcurrency: \(Swift.String(describing: maxConcurrency)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)))"}
}

extension RoboMakerClientTypes {
    /// Information about the batch policy.
    public struct BatchPolicy: Swift.Equatable {
        /// The number of active simulation jobs create as part of the batch that can be in an
        ///          active state at the same time.
        ///          Active states include: Pending,Preparing,
        ///          Running, Restarting, RunningFailed and
        ///             Terminating. All other states are terminal states.
        public var maxConcurrency: Swift.Int?
        /// The amount of time, in seconds, to wait for the batch to complete.
        ///
        ///
        ///          If a batch times out, and there are pending requests that were failing due to an
        ///          internal failure (like InternalServiceError), they will be moved to the failed
        ///          list and the batch status will be Failed. If the pending requests were failing
        ///          for any other reason, the failed pending requests will be moved to the failed list and the
        ///          batch status will be TimedOut.
        public var timeoutInSeconds: Swift.Int?

        public init (
            maxConcurrency: Swift.Int? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.maxConcurrency = maxConcurrency
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

public struct CancelDeploymentJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelDeploymentJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelDeploymentJobOutputError>
}

extension CancelDeploymentJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelDeploymentJobInput(job: \(Swift.String(describing: job)))"}
}

extension CancelDeploymentJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct CancelDeploymentJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelDeploymentJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelDeploymentJobOutputError>
}

public struct CancelDeploymentJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelDeploymentJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelDeploymentJobOutputError>
}

public struct CancelDeploymentJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelDeploymentJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelDeploymentJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/cancelDeploymentJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelDeploymentJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelDeploymentJobOutputError>
}

public struct CancelDeploymentJobInput: Swift.Equatable {
    /// The deployment job ARN to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelDeploymentJobInputBody: Swift.Equatable {
    public let job: Swift.String?
}

extension CancelDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelDeploymentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelDeploymentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelDeploymentJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelDeploymentJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelDeploymentJobOutputResponse()"}
}

extension CancelDeploymentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelDeploymentJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelDeploymentJobOutputResponseBody: Swift.Equatable {
}

extension CancelDeploymentJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CancelSimulationJobBatchInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelSimulationJobBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelSimulationJobBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelSimulationJobBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelSimulationJobBatchOutputError>
}

extension CancelSimulationJobBatchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelSimulationJobBatchInput(batch: \(Swift.String(describing: batch)))"}
}

extension CancelSimulationJobBatchInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batch = batch {
            try encodeContainer.encode(batch, forKey: .batch)
        }
    }
}

public struct CancelSimulationJobBatchInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelSimulationJobBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelSimulationJobBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelSimulationJobBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelSimulationJobBatchOutputError>
}

public struct CancelSimulationJobBatchInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelSimulationJobBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelSimulationJobBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelSimulationJobBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelSimulationJobBatchOutputError>
}

public struct CancelSimulationJobBatchInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelSimulationJobBatchInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelSimulationJobBatchInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/cancelSimulationJobBatch"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelSimulationJobBatchInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelSimulationJobBatchOutputError>
}

public struct CancelSimulationJobBatchInput: Swift.Equatable {
    /// The id of the batch to cancel.
    /// This member is required.
    public var batch: Swift.String?

    public init (
        batch: Swift.String? = nil
    )
    {
        self.batch = batch
    }
}

struct CancelSimulationJobBatchInputBody: Swift.Equatable {
    public let batch: Swift.String?
}

extension CancelSimulationJobBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batch)
        batch = batchDecoded
    }
}

extension CancelSimulationJobBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelSimulationJobBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelSimulationJobBatchOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelSimulationJobBatchOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelSimulationJobBatchOutputResponse()"}
}

extension CancelSimulationJobBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelSimulationJobBatchOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelSimulationJobBatchOutputResponseBody: Swift.Equatable {
}

extension CancelSimulationJobBatchOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CancelSimulationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelSimulationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelSimulationJobOutputError>
}

extension CancelSimulationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelSimulationJobInput(job: \(Swift.String(describing: job)))"}
}

extension CancelSimulationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct CancelSimulationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelSimulationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelSimulationJobOutputError>
}

public struct CancelSimulationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelSimulationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelSimulationJobOutputError>
}

public struct CancelSimulationJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelSimulationJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelSimulationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/cancelSimulationJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelSimulationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelSimulationJobOutputError>
}

public struct CancelSimulationJobInput: Swift.Equatable {
    /// The simulation job ARN to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelSimulationJobInputBody: Swift.Equatable {
    public let job: Swift.String?
}

extension CancelSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelSimulationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelSimulationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelSimulationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelSimulationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelSimulationJobOutputResponse()"}
}

extension CancelSimulationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelSimulationJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelSimulationJobOutputResponseBody: Swift.Equatable {
}

extension CancelSimulationJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CancelWorldExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelWorldExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelWorldExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelWorldExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelWorldExportJobOutputError>
}

extension CancelWorldExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelWorldExportJobInput(job: \(Swift.String(describing: job)))"}
}

extension CancelWorldExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct CancelWorldExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelWorldExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelWorldExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelWorldExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelWorldExportJobOutputError>
}

public struct CancelWorldExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelWorldExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelWorldExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelWorldExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelWorldExportJobOutputError>
}

public struct CancelWorldExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelWorldExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelWorldExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/cancelWorldExportJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelWorldExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelWorldExportJobOutputError>
}

public struct CancelWorldExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world export job to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelWorldExportJobInputBody: Swift.Equatable {
    public let job: Swift.String?
}

extension CancelWorldExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelWorldExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelWorldExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelWorldExportJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelWorldExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelWorldExportJobOutputResponse()"}
}

extension CancelWorldExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelWorldExportJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelWorldExportJobOutputResponseBody: Swift.Equatable {
}

extension CancelWorldExportJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CancelWorldGenerationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelWorldGenerationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelWorldGenerationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelWorldGenerationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelWorldGenerationJobOutputError>
}

extension CancelWorldGenerationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelWorldGenerationJobInput(job: \(Swift.String(describing: job)))"}
}

extension CancelWorldGenerationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct CancelWorldGenerationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelWorldGenerationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelWorldGenerationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelWorldGenerationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelWorldGenerationJobOutputError>
}

public struct CancelWorldGenerationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelWorldGenerationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelWorldGenerationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelWorldGenerationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelWorldGenerationJobOutputError>
}

public struct CancelWorldGenerationJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelWorldGenerationJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelWorldGenerationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/cancelWorldGenerationJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelWorldGenerationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelWorldGenerationJobOutputError>
}

public struct CancelWorldGenerationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world generator job to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelWorldGenerationJobInputBody: Swift.Equatable {
    public let job: Swift.String?
}

extension CancelWorldGenerationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelWorldGenerationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelWorldGenerationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelWorldGenerationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelWorldGenerationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelWorldGenerationJobOutputResponse()"}
}

extension CancelWorldGenerationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelWorldGenerationJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelWorldGenerationJobOutputResponseBody: Swift.Equatable {
}

extension CancelWorldGenerationJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RoboMakerClientTypes.Compute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulationUnitLimit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simulationUnitLimit = simulationUnitLimit {
            try encodeContainer.encode(simulationUnitLimit, forKey: .simulationUnitLimit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationUnitLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationUnitLimit)
        simulationUnitLimit = simulationUnitLimitDecoded
    }
}

extension RoboMakerClientTypes.Compute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Compute(simulationUnitLimit: \(Swift.String(describing: simulationUnitLimit)))"}
}

extension RoboMakerClientTypes {
    /// Compute information for the simulation job.
    public struct Compute: Swift.Equatable {
        /// The simulation unit limit. Your simulation is allocated CPU and memory proportional to
        ///          the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
        ///          only billed for the SU utilization you consume up to the maximim value provided. The
        ///          default is 15.
        public var simulationUnitLimit: Swift.Int?

        public init (
            simulationUnitLimit: Swift.Int? = nil
        )
        {
            self.simulationUnitLimit = simulationUnitLimit
        }
    }

}

extension RoboMakerClientTypes.ComputeResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulationUnitLimit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simulationUnitLimit = simulationUnitLimit {
            try encodeContainer.encode(simulationUnitLimit, forKey: .simulationUnitLimit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationUnitLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationUnitLimit)
        simulationUnitLimit = simulationUnitLimitDecoded
    }
}

extension RoboMakerClientTypes.ComputeResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComputeResponse(simulationUnitLimit: \(Swift.String(describing: simulationUnitLimit)))"}
}

extension RoboMakerClientTypes {
    /// Compute information for the simulation job
    public struct ComputeResponse: Swift.Equatable {
        /// The simulation unit limit. Your simulation is allocated CPU and memory proportional to
        ///          the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
        ///          only billed for the SU utilization you consume up to the maximim value provided. The
        ///          default is 15.
        public var simulationUnitLimit: Swift.Int?

        public init (
            simulationUnitLimit: Swift.Int? = nil
        )
        {
            self.simulationUnitLimit = simulationUnitLimit
        }
    }

}

extension ConcurrentDeploymentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentDeploymentException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentDeploymentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentDeploymentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The failure percentage threshold percentage was met.
public struct ConcurrentDeploymentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentDeploymentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentDeploymentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateDeploymentJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentJobOutputError>
}

extension CreateDeploymentJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentJobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), deploymentApplicationConfigs: \(Swift.String(describing: deploymentApplicationConfigs)), deploymentConfig: \(Swift.String(describing: deploymentConfig)), fleet: \(Swift.String(describing: fleet)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDeploymentJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deploymentApplicationConfigs
        case deploymentConfig
        case fleet
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let deploymentApplicationConfigs = deploymentApplicationConfigs {
            var deploymentApplicationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentApplicationConfigs)
            for deploymentapplicationconfigs0 in deploymentApplicationConfigs {
                try deploymentApplicationConfigsContainer.encode(deploymentapplicationconfigs0)
            }
        }
        if let deploymentConfig = deploymentConfig {
            try encodeContainer.encode(deploymentConfig, forKey: .deploymentConfig)
        }
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDeploymentJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentJobOutputError>
}

public struct CreateDeploymentJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentJobOutputError>
}

public struct CreateDeploymentJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDeploymentJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createDeploymentJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDeploymentJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentJobOutputError>
}

public struct CreateDeploymentJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The deployment application configuration.
    /// This member is required.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The requested deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The Amazon Resource Name (ARN) of the fleet to deploy.
    /// This member is required.
    public var fleet: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the deployment
    ///          job.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        fleet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.fleet = fleet
        self.tags = tags
    }
}

struct CreateDeploymentJobInputBody: Swift.Equatable {
    public let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    public let clientRequestToken: Swift.String?
    public let fleet: Swift.String?
    public let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deploymentApplicationConfigs
        case deploymentConfig
        case fleet
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeploymentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentDeploymentException" : self = .concurrentDeploymentException(try ConcurrentDeploymentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentJobOutputError: Swift.Error, Swift.Equatable {
    case concurrentDeploymentException(ConcurrentDeploymentException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentJobOutputResponse(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentApplicationConfigs: \(Swift.String(describing: deploymentApplicationConfigs)), deploymentConfig: \(Swift.String(describing: deploymentConfig)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), fleet: \(Swift.String(describing: fleet)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDeploymentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeploymentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateDeploymentJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deployment job.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// The deployment application configuration.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The failure code of the simulation job if it failed:
    ///
    ///             BadPermissionError
    ///
    ///                AWS Greengrass requires a service-level role permission to access other
    ///                   services. The role must include the <a href="https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSGreengrassResourceAccessRolePolicy$jsonEditor">
    ///                      AWSGreengrassResourceAccessRolePolicy managed policy.
    ///
    ///
    ///             ExtractingBundleFailure
    ///
    ///                The robot application could not be extracted from the bundle.
    ///
    ///             FailureThresholdBreached
    ///
    ///                The percentage of robots that could not be updated exceeded the percentage set
    ///                   for the deployment.
    ///
    ///             GreengrassDeploymentFailed
    ///
    ///                The robot application could not be deployed to the robot.
    ///
    ///             GreengrassGroupVersionDoesNotExist
    ///
    ///                The AWS Greengrass group or version associated with a robot is missing.
    ///
    ///             InternalServerError
    ///
    ///                An internal error has occurred. Retry your request, but if the problem
    ///                   persists, contact us with details.
    ///
    ///             MissingRobotApplicationArchitecture
    ///
    ///                The robot application does not have a source that matches the architecture of
    ///                   the robot.
    ///
    ///             MissingRobotDeploymentResource
    ///
    ///                One or more of the resources specified for the robot application are missing.
    ///                   For example, does the robot application have the correct launch package and launch
    ///                   file?
    ///
    ///             PostLaunchFileFailure
    ///
    ///                The post-launch script failed.
    ///
    ///             PreLaunchFileFailure
    ///
    ///                The pre-launch script failed.
    ///
    ///             ResourceNotFound
    ///
    ///                One or more deployment resources are missing. For example, do robot application
    ///                   source bundles still exist?
    ///
    ///             RobotDeploymentNoResponse
    ///
    ///                There is no response from the robot. It might not be powered on or connected to
    ///                   the internet.
    ///
    ///
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// The failure reason of the deployment job if it failed.
    public var failureReason: Swift.String?
    /// The target fleet for the deployment job.
    public var fleet: Swift.String?
    /// The status of the deployment job.
    public var status: RoboMakerClientTypes.DeploymentStatus?
    /// The list of all tags added to the deployment job.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
        self.tags = tags
    }
}

struct CreateDeploymentJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let fleet: Swift.String?
    public let status: RoboMakerClientTypes.DeploymentStatus?
    public let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    public let failureReason: Swift.String?
    public let failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    public let createdAt: ClientRuntime.Date?
    public let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateDeploymentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

extension CreateFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFleetInput(name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

public struct CreateFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

public struct CreateFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createFleet"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

public struct CreateFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the fleet.
    public var tags: [Swift.String:Swift.String]?

    public init (
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.tags = tags
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFleetOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFleetOutputResponse(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct CreateFleetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// The name of the fleet.
    public var name: Swift.String?
    /// The list of all tags added to the fleet.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.name = name
        self.tags = tags
    }
}

struct CreateFleetOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateRobotApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotApplicationOutputError>
}

extension CreateRobotApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRobotApplicationInput(environment: \(Swift.String(describing: environment)), name: \(Swift.String(describing: name)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRobotApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case robotSoftwareSuite
        case sources
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfigs0 in sources {
                try sourcesContainer.encode(sourceconfigs0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRobotApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotApplicationOutputError>
}

public struct CreateRobotApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotApplicationOutputError>
}

public struct CreateRobotApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotApplicationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateRobotApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createRobotApplication"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRobotApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotApplicationOutputError>
}

public struct CreateRobotApplicationInput: Swift.Equatable {
    /// The object that contains that URI of the Docker image that you use for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The name of the robot application.
    /// This member is required.
    public var name: Swift.String?
    /// The robot software suite (ROS distribuition) used by the robot application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?
    /// A map that contains tag keys and tag values that are attached to the robot
    ///          application.
    public var tags: [Swift.String:Swift.String]?

    public init (
        environment: RoboMakerClientTypes.Environment? = nil,
        name: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.environment = environment
        self.name = name
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
    }
}

struct CreateRobotApplicationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let sources: [RoboMakerClientTypes.SourceConfig]?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let tags: [Swift.String:Swift.String]?
    public let environment: RoboMakerClientTypes.Environment?
}

extension CreateRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case robotSoftwareSuite
        case sources
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension CreateRobotApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRobotApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRobotApplicationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRobotApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRobotApplicationOutputResponse(arn: \(Swift.String(describing: arn)), environment: \(Swift.String(describing: environment)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), version: \(Swift.String(describing: version)))"}
}

extension CreateRobotApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRobotApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct CreateRobotApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// An object that contains the Docker image URI used to a create your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the robot application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct CreateRobotApplicationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let version: Swift.String?
    public let sources: [RoboMakerClientTypes.Source]?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let revisionId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let environment: RoboMakerClientTypes.Environment?
}

extension CreateRobotApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct CreateRobotApplicationVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotApplicationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRobotApplicationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRobotApplicationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotApplicationVersionOutputError>
}

extension CreateRobotApplicationVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRobotApplicationVersionInput(application: \(Swift.String(describing: application)), currentRevisionId: \(Swift.String(describing: currentRevisionId)), imageDigest: \(Swift.String(describing: imageDigest)), s3Etags: \(Swift.String(describing: s3Etags)))"}
}

extension CreateRobotApplicationVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let s3Etags = s3Etags {
            var s3EtagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Etags)
            for s3etags0 in s3Etags {
                try s3EtagsContainer.encode(s3etags0)
            }
        }
    }
}

public struct CreateRobotApplicationVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotApplicationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRobotApplicationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRobotApplicationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotApplicationVersionOutputError>
}

public struct CreateRobotApplicationVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotApplicationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRobotApplicationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRobotApplicationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotApplicationVersionOutputError>
}

public struct CreateRobotApplicationVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotApplicationVersionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateRobotApplicationVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createRobotApplicationVersion"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRobotApplicationVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotApplicationVersionOutputError>
}

public struct CreateRobotApplicationVersionInput: Swift.Equatable {
    /// The application information for the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The current revision id for the robot application. If you provide a value and it matches
    ///          the latest revision ID, a new version will be created.
    public var currentRevisionId: Swift.String?
    /// A SHA256 identifier for the Docker image that you use for your robot application.
    public var imageDigest: Swift.String?
    /// The Amazon S3 identifier for the zip file bundle that you use for your robot application.
    public var s3Etags: [Swift.String]?

    public init (
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        imageDigest: Swift.String? = nil,
        s3Etags: [Swift.String]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.imageDigest = imageDigest
        self.s3Etags = s3Etags
    }
}

struct CreateRobotApplicationVersionInputBody: Swift.Equatable {
    public let application: Swift.String?
    public let currentRevisionId: Swift.String?
    public let s3Etags: [Swift.String]?
    public let imageDigest: Swift.String?
}

extension CreateRobotApplicationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let s3EtagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Etags)
        var s3EtagsDecoded0:[Swift.String]? = nil
        if let s3EtagsContainer = s3EtagsContainer {
            s3EtagsDecoded0 = [Swift.String]()
            for string0 in s3EtagsContainer {
                if let string0 = string0 {
                    s3EtagsDecoded0?.append(string0)
                }
            }
        }
        s3Etags = s3EtagsDecoded0
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension CreateRobotApplicationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRobotApplicationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRobotApplicationVersionOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRobotApplicationVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRobotApplicationVersionOutputResponse(arn: \(Swift.String(describing: arn)), environment: \(Swift.String(describing: environment)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), sources: \(Swift.String(describing: sources)), version: \(Swift.String(describing: version)))"}
}

extension CreateRobotApplicationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRobotApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct CreateRobotApplicationVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct CreateRobotApplicationVersionOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let version: Swift.String?
    public let sources: [RoboMakerClientTypes.Source]?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let revisionId: Swift.String?
    public let environment: RoboMakerClientTypes.Environment?
}

extension CreateRobotApplicationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct CreateRobotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotOutputError>
}

extension CreateRobotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRobotInput(architecture: \(Swift.String(describing: architecture)), greengrassGroupId: \(Swift.String(describing: greengrassGroupId)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRobotInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case greengrassGroupId
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let greengrassGroupId = greengrassGroupId {
            try encodeContainer.encode(greengrassGroupId, forKey: .greengrassGroupId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRobotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotOutputError>
}

public struct CreateRobotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotOutputError>
}

public struct CreateRobotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRobotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateRobotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createRobot"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRobotInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRobotOutputError>
}

public struct CreateRobotInput: Swift.Equatable {
    /// The target architecture of the robot.
    /// This member is required.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Greengrass group id.
    /// This member is required.
    public var greengrassGroupId: Swift.String?
    /// The name for the robot.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the robot.
    public var tags: [Swift.String:Swift.String]?

    public init (
        architecture: RoboMakerClientTypes.Architecture? = nil,
        greengrassGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.greengrassGroupId = greengrassGroupId
        self.name = name
        self.tags = tags
    }
}

struct CreateRobotInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let architecture: RoboMakerClientTypes.Architecture?
    public let greengrassGroupId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case greengrassGroupId
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRobotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRobotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRobotOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRobotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRobotOutputResponse(architecture: \(Swift.String(describing: architecture)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), greengrassGroupId: \(Swift.String(describing: greengrassGroupId)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRobotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRobotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architecture = output.architecture
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.greengrassGroupId = output.greengrassGroupId
            self.name = output.name
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.arn = nil
            self.createdAt = nil
            self.greengrassGroupId = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct CreateRobotOutputResponse: Swift.Equatable {
    /// The target architecture of the robot.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Amazon Resource Name (ARN) of the robot.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the Greengrass group associated with the robot.
    public var greengrassGroupId: Swift.String?
    /// The name of the robot.
    public var name: Swift.String?
    /// The list of all tags added to the robot.
    public var tags: [Swift.String:Swift.String]?

    public init (
        architecture: RoboMakerClientTypes.Architecture? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        greengrassGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.greengrassGroupId = greengrassGroupId
        self.name = name
        self.tags = tags
    }
}

struct CreateRobotOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let greengrassGroupId: Swift.String?
    public let architecture: RoboMakerClientTypes.Architecture?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateRobotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case arn
        case createdAt
        case greengrassGroupId
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateSimulationApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationApplicationOutputError>
}

extension CreateSimulationApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSimulationApplicationInput(environment: \(Swift.String(describing: environment)), name: \(Swift.String(describing: name)), renderingEngine: \(Swift.String(describing: renderingEngine)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(Swift.String(describing: simulationSoftwareSuite)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSimulationApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingEngine = renderingEngine {
            try encodeContainer.encode(renderingEngine, forKey: .renderingEngine)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfigs0 in sources {
                try sourcesContainer.encode(sourceconfigs0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateSimulationApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationApplicationOutputError>
}

public struct CreateSimulationApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationApplicationOutputError>
}

public struct CreateSimulationApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationApplicationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateSimulationApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createSimulationApplication"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSimulationApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationApplicationOutputError>
}

public struct CreateSimulationApplicationInput: Swift.Equatable {
    /// The object that contains the Docker image URI used to create your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The name of the simulation application.
    /// This member is required.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The robot software suite (ROS distribution) used by the simulation application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    /// This member is required.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?
    /// A map that contains tag keys and tag values that are attached to the simulation
    ///          application.
    public var tags: [Swift.String:Swift.String]?

    public init (
        environment: RoboMakerClientTypes.Environment? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.environment = environment
        self.name = name
        self.renderingEngine = renderingEngine
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
    }
}

struct CreateSimulationApplicationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let sources: [RoboMakerClientTypes.SourceConfig]?
    public let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    public let tags: [Swift.String:Swift.String]?
    public let environment: RoboMakerClientTypes.Environment?
}

extension CreateSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension CreateSimulationApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSimulationApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSimulationApplicationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSimulationApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSimulationApplicationOutputResponse(arn: \(Swift.String(describing: arn)), environment: \(Swift.String(describing: environment)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), renderingEngine: \(Swift.String(describing: renderingEngine)), revisionId: \(Swift.String(describing: revisionId)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(Swift.String(describing: simulationSoftwareSuite)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), version: \(Swift.String(describing: version)))"}
}

extension CreateSimulationApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSimulationApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct CreateSimulationApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI that you used to create your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the simulation application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct CreateSimulationApplicationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let version: Swift.String?
    public let sources: [RoboMakerClientTypes.Source]?
    public let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let revisionId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let environment: RoboMakerClientTypes.Environment?
}

extension CreateSimulationApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct CreateSimulationApplicationVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationApplicationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSimulationApplicationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSimulationApplicationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationApplicationVersionOutputError>
}

extension CreateSimulationApplicationVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSimulationApplicationVersionInput(application: \(Swift.String(describing: application)), currentRevisionId: \(Swift.String(describing: currentRevisionId)), imageDigest: \(Swift.String(describing: imageDigest)), s3Etags: \(Swift.String(describing: s3Etags)))"}
}

extension CreateSimulationApplicationVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let s3Etags = s3Etags {
            var s3EtagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Etags)
            for s3etags0 in s3Etags {
                try s3EtagsContainer.encode(s3etags0)
            }
        }
    }
}

public struct CreateSimulationApplicationVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationApplicationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSimulationApplicationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSimulationApplicationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationApplicationVersionOutputError>
}

public struct CreateSimulationApplicationVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationApplicationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSimulationApplicationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSimulationApplicationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationApplicationVersionOutputError>
}

public struct CreateSimulationApplicationVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationApplicationVersionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateSimulationApplicationVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createSimulationApplicationVersion"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSimulationApplicationVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationApplicationVersionOutputError>
}

public struct CreateSimulationApplicationVersionInput: Swift.Equatable {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The current revision id for the simulation application. If you provide a value and it
    ///          matches the latest revision ID, a new version will be created.
    public var currentRevisionId: Swift.String?
    /// The SHA256 digest used to identify the Docker image URI used to created the simulation application.
    public var imageDigest: Swift.String?
    /// The Amazon S3 eTag identifier for the zip file bundle that you use to create the simulation application.
    public var s3Etags: [Swift.String]?

    public init (
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        imageDigest: Swift.String? = nil,
        s3Etags: [Swift.String]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.imageDigest = imageDigest
        self.s3Etags = s3Etags
    }
}

struct CreateSimulationApplicationVersionInputBody: Swift.Equatable {
    public let application: Swift.String?
    public let currentRevisionId: Swift.String?
    public let s3Etags: [Swift.String]?
    public let imageDigest: Swift.String?
}

extension CreateSimulationApplicationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let s3EtagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Etags)
        var s3EtagsDecoded0:[Swift.String]? = nil
        if let s3EtagsContainer = s3EtagsContainer {
            s3EtagsDecoded0 = [Swift.String]()
            for string0 in s3EtagsContainer {
                if let string0 = string0 {
                    s3EtagsDecoded0?.append(string0)
                }
            }
        }
        s3Etags = s3EtagsDecoded0
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension CreateSimulationApplicationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSimulationApplicationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSimulationApplicationVersionOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSimulationApplicationVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSimulationApplicationVersionOutputResponse(arn: \(Swift.String(describing: arn)), environment: \(Swift.String(describing: environment)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), renderingEngine: \(Swift.String(describing: renderingEngine)), revisionId: \(Swift.String(describing: revisionId)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(Swift.String(describing: simulationSoftwareSuite)), sources: \(Swift.String(describing: sources)), version: \(Swift.String(describing: version)))"}
}

extension CreateSimulationApplicationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSimulationApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct CreateSimulationApplicationVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision ID of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct CreateSimulationApplicationVersionOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let version: Swift.String?
    public let sources: [RoboMakerClientTypes.Source]?
    public let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let revisionId: Swift.String?
    public let environment: RoboMakerClientTypes.Environment?
}

extension CreateSimulationApplicationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct CreateSimulationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationJobOutputError>
}

extension CreateSimulationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSimulationJobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), compute: \(Swift.String(describing: compute)), dataSources: \(Swift.String(describing: dataSources)), failureBehavior: \(Swift.String(describing: failureBehavior)), iamRole: \(Swift.String(describing: iamRole)), loggingConfig: \(Swift.String(describing: loggingConfig)), maxJobDurationInSeconds: \(Swift.String(describing: maxJobDurationInSeconds)), outputLocation: \(Swift.String(describing: outputLocation)), robotApplications: \(Swift.String(describing: robotApplications)), simulationApplications: \(Swift.String(describing: simulationApplications)), tags: \(Swift.String(describing: tags)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension CreateSimulationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let compute = compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourceconfigs0 in dataSources {
                try dataSourcesContainer.encode(datasourceconfigs0)
            }
        }
        if let failureBehavior = failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let loggingConfig = loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfigs0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfigs0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfigs0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfigs0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateSimulationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationJobOutputError>
}

public struct CreateSimulationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationJobOutputError>
}

public struct CreateSimulationJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSimulationJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateSimulationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createSimulationJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSimulationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSimulationJobOutputError>
}

public struct CreateSimulationJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.Compute?
    /// Specify data sources to mount read-only files from S3 into your simulation. These files
    ///          are available under /opt/robomaker/datasources/data_source_name.
    ///
    ///             There is a limit of 100 files and a combined size of 25GB for all
    ///                DataSourceConfig objects.
    ///
    public var dataSources: [RoboMakerClientTypes.DataSourceConfig]?
    /// The failure behavior the simulation job.
    ///
    ///             Continue
    ///
    ///                Leaves the instance running for its maximum timeout duration after a 4XX error code.
    ///
    ///             Fail
    ///
    ///                Stop the simulation job and terminate the instance.
    ///
    ///
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The IAM role name that allows the simulation instance to call the AWS APIs that are
    ///          specified in its associated policies on your behalf. This is how credentials are passed in
    ///          to your simulation job.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum simulation job duration in seconds (up to 14 days or 1,209,600 seconds. When
    ///             maxJobDurationInSeconds is reached, the simulation job will status will
    ///          transition to Completed.
    /// This member is required.
    public var maxJobDurationInSeconds: Swift.Int
    /// Location for output files generated by the simulation job.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The robot application to use in the simulation job.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// The simulation application to use in the simulation job.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// A map that contains tag keys and tag values that are attached to the simulation
    ///          job.
    public var tags: [Swift.String:Swift.String]?
    /// If your simulation job accesses resources in a VPC, you provide this parameter
    ///          identifying the list of security group IDs and subnet IDs. These must belong to the same
    ///          VPC. You must provide at least one security group and one subnet ID.
    public var vpcConfig: RoboMakerClientTypes.VPCConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.Compute? = nil,
        dataSources: [RoboMakerClientTypes.DataSourceConfig]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        iamRole: Swift.String? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int = 0,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.iamRole = iamRole
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateSimulationJobInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let outputLocation: RoboMakerClientTypes.OutputLocation?
    public let loggingConfig: RoboMakerClientTypes.LoggingConfig?
    public let maxJobDurationInSeconds: Swift.Int
    public let iamRole: Swift.String?
    public let failureBehavior: RoboMakerClientTypes.FailureBehavior?
    public let robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    public let simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    public let dataSources: [RoboMakerClientTypes.DataSourceConfig]?
    public let tags: [Swift.String:Swift.String]?
    public let vpcConfig: RoboMakerClientTypes.VPCConfig?
    public let compute: RoboMakerClientTypes.Compute?
}

extension CreateSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSourceConfig?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSourceConfig]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSourceConfig]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Compute.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension CreateSimulationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSimulationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSimulationJobOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSimulationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSimulationJobOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), compute: \(Swift.String(describing: compute)), dataSources: \(Swift.String(describing: dataSources)), failureBehavior: \(Swift.String(describing: failureBehavior)), failureCode: \(Swift.String(describing: failureCode)), iamRole: \(Swift.String(describing: iamRole)), lastStartedAt: \(Swift.String(describing: lastStartedAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), loggingConfig: \(Swift.String(describing: loggingConfig)), maxJobDurationInSeconds: \(Swift.String(describing: maxJobDurationInSeconds)), outputLocation: \(Swift.String(describing: outputLocation)), robotApplications: \(Swift.String(describing: robotApplications)), simulationApplications: \(Swift.String(describing: simulationApplications)), simulationTimeMillis: \(Swift.String(describing: simulationTimeMillis)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension CreateSimulationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSimulationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.compute = output.compute
            self.dataSources = output.dataSources
            self.failureBehavior = output.failureBehavior
            self.failureCode = output.failureCode
            self.iamRole = output.iamRole
            self.lastStartedAt = output.lastStartedAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.loggingConfig = output.loggingConfig
            self.maxJobDurationInSeconds = output.maxJobDurationInSeconds
            self.outputLocation = output.outputLocation
            self.robotApplications = output.robotApplications
            self.simulationApplications = output.simulationApplications
            self.simulationTimeMillis = output.simulationTimeMillis
            self.status = output.status
            self.tags = output.tags
            self.vpcConfig = output.vpcConfig
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.compute = nil
            self.dataSources = nil
            self.failureBehavior = nil
            self.failureCode = nil
            self.iamRole = nil
            self.lastStartedAt = nil
            self.lastUpdatedAt = nil
            self.loggingConfig = nil
            self.maxJobDurationInSeconds = 0
            self.outputLocation = nil
            self.robotApplications = nil
            self.simulationApplications = nil
            self.simulationTimeMillis = 0
            self.status = nil
            self.tags = nil
            self.vpcConfig = nil
        }
    }
}

public struct CreateSimulationJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.ComputeResponse?
    /// The data sources for the simulation job.
    public var dataSources: [RoboMakerClientTypes.DataSource]?
    /// the failure behavior for the simulation job.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The failure code of the simulation job if it failed:
    ///
    ///             InternalServiceError
    ///
    ///                Internal service error.
    ///
    ///             RobotApplicationCrash
    ///
    ///                Robot application exited abnormally.
    ///
    ///             SimulationApplicationCrash
    ///
    ///                 Simulation application exited abnormally.
    ///
    ///             BadPermissionsRobotApplication
    ///
    ///                Robot application bundle could not be downloaded.
    ///
    ///             BadPermissionsSimulationApplication
    ///
    ///                Simulation application bundle could not be downloaded.
    ///
    ///             BadPermissionsS3Output
    ///
    ///                Unable to publish outputs to customer-provided S3 bucket.
    ///
    ///             BadPermissionsCloudwatchLogs
    ///
    ///                Unable to publish logs to customer-provided CloudWatch Logs resource.
    ///
    ///             SubnetIpLimitExceeded
    ///
    ///                Subnet IP limit exceeded.
    ///
    ///             ENILimitExceeded
    ///
    ///                ENI limit exceeded.
    ///
    ///             BadPermissionsUserCredentials
    ///
    ///                Unable to use the Role provided.
    ///
    ///             InvalidBundleRobotApplication
    ///
    ///                Robot bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).
    ///
    ///             InvalidBundleSimulationApplication
    ///
    ///                Simulation bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).
    ///
    ///             RobotApplicationVersionMismatchedEtag
    ///
    ///                Etag for RobotApplication does not match value during version creation.
    ///
    ///             SimulationApplicationVersionMismatchedEtag
    ///
    ///                Etag for SimulationApplication does not match value during version
    ///                   creation.
    ///
    ///
    public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    /// The IAM role that allows the simulation job to call the AWS APIs that are specified in
    ///          its associated policies on your behalf.
    public var iamRole: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job was last
    ///          started.
    public var lastStartedAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the simulation job was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum simulation job duration in seconds.
    public var maxJobDurationInSeconds: Swift.Int
    /// Simulation job output files location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The robot application used by the simulation job.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// The simulation application used by the simulation job.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// The simulation job execution duration in milliseconds.
    public var simulationTimeMillis: Swift.Int
    /// The status of the simulation job.
    public var status: RoboMakerClientTypes.SimulationJobStatus?
    /// The list of all tags added to the simulation job.
    public var tags: [Swift.String:Swift.String]?
    /// Information about the vpc configuration.
    public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.ComputeResponse? = nil,
        dataSources: [RoboMakerClientTypes.DataSource]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
        iamRole: Swift.String? = nil,
        lastStartedAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int = 0,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Swift.Int = 0,
        status: RoboMakerClientTypes.SimulationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateSimulationJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let status: RoboMakerClientTypes.SimulationJobStatus?
    public let lastStartedAt: ClientRuntime.Date?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let failureBehavior: RoboMakerClientTypes.FailureBehavior?
    public let failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    public let clientRequestToken: Swift.String?
    public let outputLocation: RoboMakerClientTypes.OutputLocation?
    public let loggingConfig: RoboMakerClientTypes.LoggingConfig?
    public let maxJobDurationInSeconds: Swift.Int
    public let simulationTimeMillis: Swift.Int
    public let iamRole: Swift.String?
    public let robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    public let simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    public let dataSources: [RoboMakerClientTypes.DataSource]?
    public let tags: [Swift.String:Swift.String]?
    public let vpcConfig: RoboMakerClientTypes.VPCConfigResponse?
    public let compute: RoboMakerClientTypes.ComputeResponse?
}

extension CreateSimulationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .simulationTimeMillis)
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

public struct CreateWorldExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorldExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorldExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldExportJobOutputError>
}

extension CreateWorldExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorldExportJobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), iamRole: \(Swift.String(describing: iamRole)), outputLocation: \(Swift.String(describing: outputLocation)), tags: \(Swift.String(describing: tags)), worlds: \(Swift.String(describing: worlds)))"}
}

extension CreateWorldExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case iamRole
        case outputLocation
        case tags
        case worlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arns0 in worlds {
                try worldsContainer.encode(arns0)
            }
        }
    }
}

public struct CreateWorldExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorldExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorldExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldExportJobOutputError>
}

public struct CreateWorldExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorldExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorldExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldExportJobOutputError>
}

public struct CreateWorldExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateWorldExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createWorldExportJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWorldExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldExportJobOutputError>
}

public struct CreateWorldExportJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put
    ///          the export.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The output location.
    /// This member is required.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// A map that contains tag keys and tag values that are attached to the world export
    ///          job.
    public var tags: [Swift.String:Swift.String]?
    /// A list of Amazon Resource Names (arns) that correspond to worlds to export.
    /// This member is required.
    public var worlds: [Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        worlds: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.tags = tags
        self.worlds = worlds
    }
}

struct CreateWorldExportJobInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let worlds: [Swift.String]?
    public let outputLocation: RoboMakerClientTypes.OutputLocation?
    public let iamRole: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateWorldExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case iamRole
        case outputLocation
        case tags
        case worlds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorldExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorldExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorldExportJobOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorldExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorldExportJobOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdAt: \(Swift.String(describing: createdAt)), failureCode: \(Swift.String(describing: failureCode)), iamRole: \(Swift.String(describing: iamRole)), outputLocation: \(Swift.String(describing: outputLocation)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateWorldExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorldExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.iamRole = output.iamRole
            self.outputLocation = output.outputLocation
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.iamRole = nil
            self.outputLocation = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateWorldExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world export job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world export job was created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world export job if it failed:
    ///
    ///             InternalServiceError
    ///
    ///                Internal service error.
    ///
    ///             LimitExceeded
    ///
    ///                The requested resource exceeds the maximum number allowed, or the number of
    ///                   concurrent stream requests exceeds the maximum number allowed.
    ///
    ///             ResourceNotFound
    ///
    ///                The specified resource could not be found.
    ///
    ///             RequestThrottled
    ///
    ///                The request was throttled.
    ///
    ///             InvalidInput
    ///
    ///                An input parameter in the request is not valid.
    ///
    ///             AllWorldGenerationFailed
    ///
    ///                All of the worlds in the world generation job failed. This can happen if your
    ///                      worldCount is greater than 50 or less than 1.
    ///
    ///
    ///          For more information about troubleshooting WorldForge, see <a href="https://docs.aws.amazon.com/robomaker/latest/dg/troubleshooting-worldforge.html">Troubleshooting Simulation WorldForge.
    public var failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put
    ///          the export.
    public var iamRole: Swift.String?
    /// The output location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The status of the world export job.
    ///
    ///             Pending
    ///
    ///                The world export job request is pending.
    ///
    ///             Running
    ///
    ///                The world export job is running.
    ///
    ///             Completed
    ///
    ///                The world export job completed.
    ///
    ///             Failed
    ///
    ///                The world export job failed. See failureCode for more information.
    ///
    ///
    ///             Canceled
    ///
    ///                The world export job was cancelled.
    ///
    ///             Canceling
    ///
    ///                The world export job is being cancelled.
    ///
    ///
    public var status: RoboMakerClientTypes.WorldExportJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world export
    ///          job.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldExportJobErrorCode? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.status = status
        self.tags = tags
    }
}

struct CreateWorldExportJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let status: RoboMakerClientTypes.WorldExportJobStatus?
    public let createdAt: ClientRuntime.Date?
    public let failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    public let clientRequestToken: Swift.String?
    public let outputLocation: RoboMakerClientTypes.OutputLocation?
    public let iamRole: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateWorldExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case iamRole
        case outputLocation
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateWorldGenerationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldGenerationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorldGenerationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorldGenerationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldGenerationJobOutputError>
}

extension CreateWorldGenerationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorldGenerationJobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), tags: \(Swift.String(describing: tags)), template: \(Swift.String(describing: template)), worldCount: \(Swift.String(describing: worldCount)), worldTags: \(Swift.String(describing: worldTags)))"}
}

extension CreateWorldGenerationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case tags
        case template
        case worldCount
        case worldTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let worldCount = worldCount {
            try encodeContainer.encode(worldCount, forKey: .worldCount)
        }
        if let worldTags = worldTags {
            var worldTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .worldTags)
            for (dictKey0, tagmap0) in worldTags {
                try worldTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateWorldGenerationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldGenerationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorldGenerationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorldGenerationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldGenerationJobOutputError>
}

public struct CreateWorldGenerationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldGenerationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorldGenerationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorldGenerationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldGenerationJobOutputError>
}

public struct CreateWorldGenerationJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldGenerationJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateWorldGenerationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createWorldGenerationJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWorldGenerationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldGenerationJobOutputError>
}

public struct CreateWorldGenerationJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world generator
    ///          job.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (arn) of the world template describing the worlds you want to
    ///          create.
    /// This member is required.
    public var template: Swift.String?
    /// Information about the world count.
    /// This member is required.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated
    ///          worlds.
    public var worldTags: [Swift.String:Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct CreateWorldGenerationJobInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let template: Swift.String?
    public let worldCount: RoboMakerClientTypes.WorldCount?
    public let tags: [Swift.String:Swift.String]?
    public let worldTags: [Swift.String:Swift.String]?
}

extension CreateWorldGenerationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

extension CreateWorldGenerationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorldGenerationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorldGenerationJobOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorldGenerationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorldGenerationJobOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdAt: \(Swift.String(describing: createdAt)), failureCode: \(Swift.String(describing: failureCode)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), template: \(Swift.String(describing: template)), worldCount: \(Swift.String(describing: worldCount)), worldTags: \(Swift.String(describing: worldTags)))"}
}

extension CreateWorldGenerationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorldGenerationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.status = output.status
            self.tags = output.tags
            self.template = output.template
            self.worldCount = output.worldCount
            self.worldTags = output.worldTags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.status = nil
            self.tags = nil
            self.template = nil
            self.worldCount = nil
            self.worldTags = nil
        }
    }
}

public struct CreateWorldGenerationJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world generator job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world generator job was
    ///          created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world generator job if it failed:
    ///
    ///             InternalServiceError
    ///
    ///                Internal service error.
    ///
    ///             LimitExceeded
    ///
    ///                The requested resource exceeds the maximum number allowed, or the number of
    ///                   concurrent stream requests exceeds the maximum number allowed.
    ///
    ///             ResourceNotFound
    ///
    ///                The specified resource could not be found.
    ///
    ///             RequestThrottled
    ///
    ///                The request was throttled.
    ///
    ///             InvalidInput
    ///
    ///                An input parameter in the request is not valid.
    ///
    ///
    public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    /// The status of the world generator job.
    ///
    ///             Pending
    ///
    ///                The world generator job request is pending.
    ///
    ///             Running
    ///
    ///                The world generator job is running.
    ///
    ///             Completed
    ///
    ///                The world generator job completed.
    ///
    ///             Failed
    ///
    ///                The world generator job failed. See failureCode for more
    ///                   information.
    ///
    ///             PartialFailed
    ///
    ///                Some worlds did not generate.
    ///
    ///             Canceled
    ///
    ///                The world generator job was cancelled.
    ///
    ///             Canceling
    ///
    ///                The world generator job is being cancelled.
    ///
    ///
    public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world generator
    ///          job.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?
    /// Information about the world count.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated
    ///          worlds.
    public var worldTags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
        status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.status = status
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct CreateWorldGenerationJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let status: RoboMakerClientTypes.WorldGenerationJobStatus?
    public let createdAt: ClientRuntime.Date?
    public let failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    public let clientRequestToken: Swift.String?
    public let template: Swift.String?
    public let worldCount: RoboMakerClientTypes.WorldCount?
    public let tags: [Swift.String:Swift.String]?
    public let worldTags: [Swift.String:Swift.String]?
}

extension CreateWorldGenerationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case status
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

public struct CreateWorldTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldTemplateOutputError>
}

extension CreateWorldTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorldTemplateInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), templateBody: \(Swift.String(describing: templateBody)), templateLocation: \(Swift.String(describing: templateLocation)))"}
}

extension CreateWorldTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case name
        case tags
        case templateBody
        case templateLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateLocation = templateLocation {
            try encodeContainer.encode(templateLocation, forKey: .templateLocation)
        }
    }
}

public struct CreateWorldTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldTemplateOutputError>
}

public struct CreateWorldTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldTemplateOutputError>
}

public struct CreateWorldTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorldTemplateInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateWorldTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/createWorldTemplate"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWorldTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorldTemplateOutputError>
}

public struct CreateWorldTemplateInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world
    ///          template.
    public var tags: [Swift.String:Swift.String]?
    /// The world template body.
    public var templateBody: Swift.String?
    /// The location of the world template.
    public var templateLocation: RoboMakerClientTypes.TemplateLocation?

    public init (
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateBody: Swift.String? = nil,
        templateLocation: RoboMakerClientTypes.TemplateLocation? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.templateBody = templateBody
        self.templateLocation = templateLocation
    }
}

struct CreateWorldTemplateInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let name: Swift.String?
    public let templateBody: Swift.String?
    public let templateLocation: RoboMakerClientTypes.TemplateLocation?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case name
        case tags
        case templateBody
        case templateLocation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.TemplateLocation.self, forKey: .templateLocation)
        templateLocation = templateLocationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorldTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorldTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorldTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorldTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorldTemplateOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdAt: \(Swift.String(describing: createdAt)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateWorldTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorldTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct CreateWorldTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world template.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: ClientRuntime.Date?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world
    ///          template.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.name = name
        self.tags = tags
    }
}

struct CreateWorldTemplateOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let clientRequestToken: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let name: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateWorldTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RoboMakerClientTypes.DataSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case s3Bucket
        case s3Keys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for s3keyoutputs0 in s3Keys {
                try s3KeysContainer.encode(s3keyoutputs0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.S3KeyOutput?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[RoboMakerClientTypes.S3KeyOutput]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [RoboMakerClientTypes.S3KeyOutput]()
            for structure0 in s3KeysContainer {
                if let structure0 = structure0 {
                    s3KeysDecoded0?.append(structure0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
    }
}

extension RoboMakerClientTypes.DataSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSource(name: \(Swift.String(describing: name)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Keys: \(Swift.String(describing: s3Keys)))"}
}

extension RoboMakerClientTypes {
    /// Information about a data source.
    public struct DataSource: Swift.Equatable {
        /// The name of the data source.
        public var name: Swift.String?
        /// The S3 bucket where the data files are located.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        public var s3Keys: [RoboMakerClientTypes.S3KeyOutput]?

        public init (
            name: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [RoboMakerClientTypes.S3KeyOutput]? = nil
        )
        {
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
        }
    }

}

extension RoboMakerClientTypes.DataSourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case s3Bucket
        case s3Keys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for s3keys0 in s3Keys {
                try s3KeysContainer.encode(s3keys0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[Swift.String]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [Swift.String]()
            for string0 in s3KeysContainer {
                if let string0 = string0 {
                    s3KeysDecoded0?.append(string0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
    }
}

extension RoboMakerClientTypes.DataSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceConfig(name: \(Swift.String(describing: name)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Keys: \(Swift.String(describing: s3Keys)))"}
}

extension RoboMakerClientTypes {
    /// Information about a data source.
    public struct DataSourceConfig: Swift.Equatable {
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The S3 bucket where the data files are located.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        /// This member is required.
        public var s3Keys: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil
        )
        {
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
        }
    }

}

public struct DeleteFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

extension DeleteFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFleetInput(fleet: \(Swift.String(describing: fleet)))"}
}

extension DeleteFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

public struct DeleteFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/deleteFleet"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?

    public init (
        fleet: Swift.String? = nil
    )
    {
        self.fleet = fleet
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
    public let fleet: Swift.String?
}

extension DeleteFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension DeleteFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFleetOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFleetOutputResponse()"}
}

extension DeleteFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFleetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFleetOutputResponseBody: Swift.Equatable {
}

extension DeleteFleetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRobotApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRobotApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRobotApplicationOutputError>
}

extension DeleteRobotApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRobotApplicationInput(application: \(Swift.String(describing: application)), applicationVersion: \(Swift.String(describing: applicationVersion)))"}
}

extension DeleteRobotApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

public struct DeleteRobotApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRobotApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRobotApplicationOutputError>
}

public struct DeleteRobotApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRobotApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRobotApplicationOutputError>
}

public struct DeleteRobotApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRobotApplicationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteRobotApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/deleteRobotApplication"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRobotApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRobotApplicationOutputError>
}

public struct DeleteRobotApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the robot application to delete.
    public var applicationVersion: Swift.String?

    public init (
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DeleteRobotApplicationInputBody: Swift.Equatable {
    public let application: Swift.String?
    public let applicationVersion: Swift.String?
}

extension DeleteRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DeleteRobotApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRobotApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRobotApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRobotApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRobotApplicationOutputResponse()"}
}

extension DeleteRobotApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRobotApplicationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRobotApplicationOutputResponseBody: Swift.Equatable {
}

extension DeleteRobotApplicationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRobotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRobotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRobotOutputError>
}

extension DeleteRobotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRobotInput(robot: \(Swift.String(describing: robot)))"}
}

extension DeleteRobotInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let robot = robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

public struct DeleteRobotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRobotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRobotOutputError>
}

public struct DeleteRobotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRobotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRobotOutputError>
}

public struct DeleteRobotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRobotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteRobotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/deleteRobot"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRobotInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRobotOutputError>
}

public struct DeleteRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init (
        robot: Swift.String? = nil
    )
    {
        self.robot = robot
    }
}

struct DeleteRobotInputBody: Swift.Equatable {
    public let robot: Swift.String?
}

extension DeleteRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DeleteRobotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRobotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRobotOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRobotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRobotOutputResponse()"}
}

extension DeleteRobotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRobotOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRobotOutputResponseBody: Swift.Equatable {
}

extension DeleteRobotOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteSimulationApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSimulationApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSimulationApplicationOutputError>
}

extension DeleteSimulationApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSimulationApplicationInput(application: \(Swift.String(describing: application)), applicationVersion: \(Swift.String(describing: applicationVersion)))"}
}

extension DeleteSimulationApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

public struct DeleteSimulationApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSimulationApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSimulationApplicationOutputError>
}

public struct DeleteSimulationApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSimulationApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSimulationApplicationOutputError>
}

public struct DeleteSimulationApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSimulationApplicationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteSimulationApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/deleteSimulationApplication"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSimulationApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSimulationApplicationOutputError>
}

public struct DeleteSimulationApplicationInput: Swift.Equatable {
    /// The application information for the simulation application to delete.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the simulation application to delete.
    public var applicationVersion: Swift.String?

    public init (
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DeleteSimulationApplicationInputBody: Swift.Equatable {
    public let application: Swift.String?
    public let applicationVersion: Swift.String?
}

extension DeleteSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DeleteSimulationApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSimulationApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSimulationApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSimulationApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSimulationApplicationOutputResponse()"}
}

extension DeleteSimulationApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSimulationApplicationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSimulationApplicationOutputResponseBody: Swift.Equatable {
}

extension DeleteSimulationApplicationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteWorldTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorldTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorldTemplateOutputError>
}

extension DeleteWorldTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWorldTemplateInput(template: \(Swift.String(describing: template)))"}
}

extension DeleteWorldTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

public struct DeleteWorldTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorldTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorldTemplateOutputError>
}

public struct DeleteWorldTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorldTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorldTemplateOutputError>
}

public struct DeleteWorldTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorldTemplateInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteWorldTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/deleteWorldTemplate"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteWorldTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorldTemplateOutputError>
}

public struct DeleteWorldTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world template you want to delete.
    /// This member is required.
    public var template: Swift.String?

    public init (
        template: Swift.String? = nil
    )
    {
        self.template = template
    }
}

struct DeleteWorldTemplateInputBody: Swift.Equatable {
    public let template: Swift.String?
}

extension DeleteWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension DeleteWorldTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorldTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorldTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorldTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWorldTemplateOutputResponse()"}
}

extension DeleteWorldTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorldTemplateOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteWorldTemplateOutputResponseBody: Swift.Equatable {
}

extension DeleteWorldTemplateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RoboMakerClientTypes.DeploymentApplicationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
        case launchConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentLaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
    }
}

extension RoboMakerClientTypes.DeploymentApplicationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentApplicationConfig(application: \(Swift.String(describing: application)), applicationVersion: \(Swift.String(describing: applicationVersion)), launchConfig: \(Swift.String(describing: launchConfig)))"}
}

extension RoboMakerClientTypes {
    /// Information about a deployment application configuration.
    public struct DeploymentApplicationConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the robot application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the application.
        /// This member is required.
        public var applicationVersion: Swift.String?
        /// The launch configuration.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.DeploymentLaunchConfig?

        public init (
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.DeploymentLaunchConfig? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
        }
    }

}

extension RoboMakerClientTypes.DeploymentConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case concurrentDeploymentPercentage
        case downloadConditionFile
        case failureThresholdPercentage
        case robotDeploymentTimeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let concurrentDeploymentPercentage = concurrentDeploymentPercentage {
            try encodeContainer.encode(concurrentDeploymentPercentage, forKey: .concurrentDeploymentPercentage)
        }
        if let downloadConditionFile = downloadConditionFile {
            try encodeContainer.encode(downloadConditionFile, forKey: .downloadConditionFile)
        }
        if let failureThresholdPercentage = failureThresholdPercentage {
            try encodeContainer.encode(failureThresholdPercentage, forKey: .failureThresholdPercentage)
        }
        if let robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSeconds {
            try encodeContainer.encode(robotDeploymentTimeoutInSeconds, forKey: .robotDeploymentTimeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let concurrentDeploymentPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .concurrentDeploymentPercentage)
        concurrentDeploymentPercentage = concurrentDeploymentPercentageDecoded
        let failureThresholdPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureThresholdPercentage)
        failureThresholdPercentage = failureThresholdPercentageDecoded
        let robotDeploymentTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .robotDeploymentTimeoutInSeconds)
        robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSecondsDecoded
        let downloadConditionFileDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.S3Object.self, forKey: .downloadConditionFile)
        downloadConditionFile = downloadConditionFileDecoded
    }
}

extension RoboMakerClientTypes.DeploymentConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentConfig(concurrentDeploymentPercentage: \(Swift.String(describing: concurrentDeploymentPercentage)), downloadConditionFile: \(Swift.String(describing: downloadConditionFile)), failureThresholdPercentage: \(Swift.String(describing: failureThresholdPercentage)), robotDeploymentTimeoutInSeconds: \(Swift.String(describing: robotDeploymentTimeoutInSeconds)))"}
}

extension RoboMakerClientTypes {
    /// Information about a deployment configuration.
    public struct DeploymentConfig: Swift.Equatable {
        /// The percentage of robots receiving the deployment at the same time.
        public var concurrentDeploymentPercentage: Swift.Int?
        /// The download condition file.
        public var downloadConditionFile: RoboMakerClientTypes.S3Object?
        /// The percentage of deployments that need to fail before stopping deployment.
        public var failureThresholdPercentage: Swift.Int?
        /// The amount of time, in seconds, to wait for deployment to a single robot to complete.
        ///          Choose a time between 1 minute and 7 days. The default is 5 hours.
        public var robotDeploymentTimeoutInSeconds: Swift.Int?

        public init (
            concurrentDeploymentPercentage: Swift.Int? = nil,
            downloadConditionFile: RoboMakerClientTypes.S3Object? = nil,
            failureThresholdPercentage: Swift.Int? = nil,
            robotDeploymentTimeoutInSeconds: Swift.Int? = nil
        )
        {
            self.concurrentDeploymentPercentage = concurrentDeploymentPercentage
            self.downloadConditionFile = downloadConditionFile
            self.failureThresholdPercentage = failureThresholdPercentage
            self.robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSeconds
        }
    }

}

extension RoboMakerClientTypes.DeploymentJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deploymentApplicationConfigs = deploymentApplicationConfigs {
            var deploymentApplicationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentApplicationConfigs)
            for deploymentapplicationconfigs0 in deploymentApplicationConfigs {
                try deploymentApplicationConfigsContainer.encode(deploymentapplicationconfigs0)
            }
        }
        if let deploymentConfig = deploymentConfig {
            try encodeContainer.encode(deploymentConfig, forKey: .deploymentConfig)
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension RoboMakerClientTypes.DeploymentJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentJob(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentApplicationConfigs: \(Swift.String(describing: deploymentApplicationConfigs)), deploymentConfig: \(Swift.String(describing: deploymentConfig)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), fleet: \(Swift.String(describing: fleet)), status: \(Swift.String(describing: status)))"}
}

extension RoboMakerClientTypes {
    /// Information about a deployment job.
    public struct DeploymentJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the deployment job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the deployment job was created.
        public var createdAt: ClientRuntime.Date?
        /// The deployment application configuration.
        public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
        /// The deployment configuration.
        public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
        /// The deployment job failure code.
        public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
        /// A short description of the reason why the deployment job failed.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleet: Swift.String?
        /// The status of the deployment job.
        public var status: RoboMakerClientTypes.DeploymentStatus?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
            deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
            failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            fleet: Swift.String? = nil,
            status: RoboMakerClientTypes.DeploymentStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentApplicationConfigs = deploymentApplicationConfigs
            self.deploymentConfig = deploymentConfig
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.fleet = fleet
            self.status = status
        }
    }

}

extension RoboMakerClientTypes {
    public enum DeploymentJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badlambdaassociated
        case badpermissionerror
        case deploymentfleetdoesnotexist
        case downloadconditionfailed
        case environmentsetuperror
        case etagmismatch
        case extractingbundlefailure
        case failurethresholdbreached
        case fleetdeploymenttimeout
        case greengrassdeploymentfailed
        case greengrassgroupversiondoesnotexist
        case internalservererror
        case invalidgreengrassgroup
        case lambdadeleted
        case missingrobotapplicationarchitecture
        case missingrobotarchitecture
        case missingrobotdeploymentresource
        case postlaunchfilefailure
        case prelaunchfilefailure
        case resourcenotfound
        case robotagentconnectiontimeout
        case robotapplicationdoesnotexist
        case robotdeploymentaborted
        case robotdeploymentnoresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentJobErrorCode] {
            return [
                .badlambdaassociated,
                .badpermissionerror,
                .deploymentfleetdoesnotexist,
                .downloadconditionfailed,
                .environmentsetuperror,
                .etagmismatch,
                .extractingbundlefailure,
                .failurethresholdbreached,
                .fleetdeploymenttimeout,
                .greengrassdeploymentfailed,
                .greengrassgroupversiondoesnotexist,
                .internalservererror,
                .invalidgreengrassgroup,
                .lambdadeleted,
                .missingrobotapplicationarchitecture,
                .missingrobotarchitecture,
                .missingrobotdeploymentresource,
                .postlaunchfilefailure,
                .prelaunchfilefailure,
                .resourcenotfound,
                .robotagentconnectiontimeout,
                .robotapplicationdoesnotexist,
                .robotdeploymentaborted,
                .robotdeploymentnoresponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badlambdaassociated: return "BadLambdaAssociated"
            case .badpermissionerror: return "BadPermissionError"
            case .deploymentfleetdoesnotexist: return "DeploymentFleetDoesNotExist"
            case .downloadconditionfailed: return "DownloadConditionFailed"
            case .environmentsetuperror: return "EnvironmentSetupError"
            case .etagmismatch: return "EtagMismatch"
            case .extractingbundlefailure: return "ExtractingBundleFailure"
            case .failurethresholdbreached: return "FailureThresholdBreached"
            case .fleetdeploymenttimeout: return "FleetDeploymentTimeout"
            case .greengrassdeploymentfailed: return "GreengrassDeploymentFailed"
            case .greengrassgroupversiondoesnotexist: return "GreengrassGroupVersionDoesNotExist"
            case .internalservererror: return "InternalServerError"
            case .invalidgreengrassgroup: return "InvalidGreengrassGroup"
            case .lambdadeleted: return "LambdaDeleted"
            case .missingrobotapplicationarchitecture: return "MissingRobotApplicationArchitecture"
            case .missingrobotarchitecture: return "MissingRobotArchitecture"
            case .missingrobotdeploymentresource: return "MissingRobotDeploymentResource"
            case .postlaunchfilefailure: return "PostLaunchFileFailure"
            case .prelaunchfilefailure: return "PreLaunchFileFailure"
            case .resourcenotfound: return "ResourceNotFound"
            case .robotagentconnectiontimeout: return "RobotAgentConnectionTimeout"
            case .robotapplicationdoesnotexist: return "RobotApplicationDoesNotExist"
            case .robotdeploymentaborted: return "RobotDeploymentAborted"
            case .robotdeploymentnoresponse: return "RobotDeploymentNoResponse"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentJobErrorCode(rawValue: rawValue) ?? DeploymentJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.DeploymentLaunchConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentVariables
        case launchFile
        case packageName
        case postLaunchFile
        case preLaunchFile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariablemap0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let launchFile = launchFile {
            try encodeContainer.encode(launchFile, forKey: .launchFile)
        }
        if let packageName = packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let postLaunchFile = postLaunchFile {
            try encodeContainer.encode(postLaunchFile, forKey: .postLaunchFile)
        }
        if let preLaunchFile = preLaunchFile {
            try encodeContainer.encode(preLaunchFile, forKey: .preLaunchFile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let preLaunchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preLaunchFile)
        preLaunchFile = preLaunchFileDecoded
        let launchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchFile)
        launchFile = launchFileDecoded
        let postLaunchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postLaunchFile)
        postLaunchFile = postLaunchFileDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in environmentVariablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    environmentVariablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
    }
}

extension RoboMakerClientTypes.DeploymentLaunchConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentLaunchConfig(environmentVariables: \(Swift.String(describing: environmentVariables)), launchFile: \(Swift.String(describing: launchFile)), packageName: \(Swift.String(describing: packageName)), postLaunchFile: \(Swift.String(describing: postLaunchFile)), preLaunchFile: \(Swift.String(describing: preLaunchFile)))"}
}

extension RoboMakerClientTypes {
    /// Configuration information for a deployment launch.
    public struct DeploymentLaunchConfig: Swift.Equatable {
        /// An array of key/value pairs specifying environment variables for the robot
        ///          application
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The launch file name.
        /// This member is required.
        public var launchFile: Swift.String?
        /// The package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The deployment post-launch file. This file will be executed after the launch
        ///          file.
        public var postLaunchFile: Swift.String?
        /// The deployment pre-launch file. This file will be executed prior to the launch
        ///          file.
        public var preLaunchFile: Swift.String?

        public init (
            environmentVariables: [Swift.String:Swift.String]? = nil,
            launchFile: Swift.String? = nil,
            packageName: Swift.String? = nil,
            postLaunchFile: Swift.String? = nil,
            preLaunchFile: Swift.String? = nil
        )
        {
            self.environmentVariables = environmentVariables
            self.launchFile = launchFile
            self.packageName = packageName
            self.postLaunchFile = postLaunchFile
            self.preLaunchFile = preLaunchFile
        }
    }

}

extension RoboMakerClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case inprogress
        case pending
        case preparing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .canceled,
                .failed,
                .inprogress,
                .pending,
                .preparing,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .preparing: return "Preparing"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

public struct DeregisterRobotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterRobotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterRobotOutputError>
}

extension DeregisterRobotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterRobotInput(fleet: \(Swift.String(describing: fleet)), robot: \(Swift.String(describing: robot)))"}
}

extension DeregisterRobotInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let robot = robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

public struct DeregisterRobotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterRobotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterRobotOutputError>
}

public struct DeregisterRobotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterRobotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterRobotOutputError>
}

public struct DeregisterRobotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterRobotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeregisterRobotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/deregisterRobot"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterRobotInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterRobotOutputError>
}

public struct DeregisterRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init (
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct DeregisterRobotInputBody: Swift.Equatable {
    public let fleet: Swift.String?
    public let robot: Swift.String?
}

extension DeregisterRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DeregisterRobotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterRobotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterRobotOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterRobotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterRobotOutputResponse(fleet: \(Swift.String(describing: fleet)), robot: \(Swift.String(describing: robot)))"}
}

extension DeregisterRobotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterRobotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
            self.robot = output.robot
        } else {
            self.fleet = nil
            self.robot = nil
        }
    }
}

public struct DeregisterRobotOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    public var robot: Swift.String?

    public init (
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct DeregisterRobotOutputResponseBody: Swift.Equatable {
    public let fleet: Swift.String?
    public let robot: Swift.String?
}

extension DeregisterRobotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

public struct DescribeDeploymentJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeploymentJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeploymentJobOutputError>
}

extension DescribeDeploymentJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDeploymentJobInput(job: \(Swift.String(describing: job)))"}
}

extension DescribeDeploymentJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct DescribeDeploymentJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeploymentJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeploymentJobOutputError>
}

public struct DescribeDeploymentJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeploymentJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeploymentJobOutputError>
}

public struct DescribeDeploymentJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeploymentJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDeploymentJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeDeploymentJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDeploymentJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeploymentJobOutputError>
}

public struct DescribeDeploymentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deployment job.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeDeploymentJobInputBody: Swift.Equatable {
    public let job: Swift.String?
}

extension DescribeDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeDeploymentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeploymentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDeploymentJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeploymentJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDeploymentJobOutputResponse(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentApplicationConfigs: \(Swift.String(describing: deploymentApplicationConfigs)), deploymentConfig: \(Swift.String(describing: deploymentConfig)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), fleet: \(Swift.String(describing: fleet)), robotDeploymentSummary: \(Swift.String(describing: robotDeploymentSummary)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeDeploymentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDeploymentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.robotDeploymentSummary = output.robotDeploymentSummary
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.robotDeploymentSummary = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeDeploymentJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deployment job.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the deployment job was created.
    public var createdAt: ClientRuntime.Date?
    /// The deployment application configuration.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The deployment job failure code.
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// A short description of the reason why the deployment job failed.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// A list of robot deployment summaries.
    public var robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]?
    /// The status of the deployment job.
    public var status: RoboMakerClientTypes.DeploymentStatus?
    /// The list of all tags added to the specified deployment job.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.robotDeploymentSummary = robotDeploymentSummary
        self.status = status
        self.tags = tags
    }
}

struct DescribeDeploymentJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let fleet: Swift.String?
    public let status: RoboMakerClientTypes.DeploymentStatus?
    public let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    public let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    public let failureReason: Swift.String?
    public let failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    public let createdAt: ClientRuntime.Date?
    public let robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeDeploymentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case robotDeploymentSummary
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let robotDeploymentSummaryContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotDeployment?].self, forKey: .robotDeploymentSummary)
        var robotDeploymentSummaryDecoded0:[RoboMakerClientTypes.RobotDeployment]? = nil
        if let robotDeploymentSummaryContainer = robotDeploymentSummaryContainer {
            robotDeploymentSummaryDecoded0 = [RoboMakerClientTypes.RobotDeployment]()
            for structure0 in robotDeploymentSummaryContainer {
                if let structure0 = structure0 {
                    robotDeploymentSummaryDecoded0?.append(structure0)
                }
            }
        }
        robotDeploymentSummary = robotDeploymentSummaryDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetOutputError>
}

extension DescribeFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFleetInput(fleet: \(Swift.String(describing: fleet)))"}
}

extension DescribeFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

public struct DescribeFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetOutputError>
}

public struct DescribeFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetOutputError>
}

public struct DescribeFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeFleet"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetOutputError>
}

public struct DescribeFleetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?

    public init (
        fleet: Swift.String? = nil
    )
    {
        self.fleet = fleet
    }
}

struct DescribeFleetInputBody: Swift.Equatable {
    public let fleet: Swift.String?
}

extension DescribeFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension DescribeFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFleetOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFleetOutputResponse(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastDeploymentJob: \(Swift.String(describing: lastDeploymentJob)), lastDeploymentStatus: \(Swift.String(describing: lastDeploymentStatus)), lastDeploymentTime: \(Swift.String(describing: lastDeploymentTime)), name: \(Swift.String(describing: name)), robots: \(Swift.String(describing: robots)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.lastDeploymentJob = output.lastDeploymentJob
            self.lastDeploymentStatus = output.lastDeploymentStatus
            self.lastDeploymentTime = output.lastDeploymentTime
            self.name = output.name
            self.robots = output.robots
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.lastDeploymentJob = nil
            self.lastDeploymentStatus = nil
            self.lastDeploymentTime = nil
            self.name = nil
            self.robots = nil
            self.tags = nil
        }
    }
}

public struct DescribeFleetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the last deployment job.
    public var lastDeploymentJob: Swift.String?
    /// The status of the last deployment.
    public var lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
    /// The time of the last deployment.
    public var lastDeploymentTime: ClientRuntime.Date?
    /// The name of the fleet.
    public var name: Swift.String?
    /// A list of robots.
    public var robots: [RoboMakerClientTypes.Robot]?
    /// The list of all tags added to the specified fleet.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        lastDeploymentJob: Swift.String? = nil,
        lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus? = nil,
        lastDeploymentTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        robots: [RoboMakerClientTypes.Robot]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentStatus = lastDeploymentStatus
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.robots = robots
        self.tags = tags
    }
}

struct DescribeFleetOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let arn: Swift.String?
    public let robots: [RoboMakerClientTypes.Robot]?
    public let createdAt: ClientRuntime.Date?
    public let lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
    public let lastDeploymentJob: Swift.String?
    public let lastDeploymentTime: ClientRuntime.Date?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastDeploymentJob
        case lastDeploymentStatus
        case lastDeploymentTime
        case name
        case robots
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let robotsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Robot?].self, forKey: .robots)
        var robotsDecoded0:[RoboMakerClientTypes.Robot]? = nil
        if let robotsContainer = robotsContainer {
            robotsDecoded0 = [RoboMakerClientTypes.Robot]()
            for structure0 in robotsContainer {
                if let structure0 = structure0 {
                    robotsDecoded0?.append(structure0)
                }
            }
        }
        robots = robotsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentStatusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .lastDeploymentStatus)
        lastDeploymentStatus = lastDeploymentStatusDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeRobotApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRobotApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRobotApplicationOutputError>
}

extension DescribeRobotApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRobotApplicationInput(application: \(Swift.String(describing: application)), applicationVersion: \(Swift.String(describing: applicationVersion)))"}
}

extension DescribeRobotApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

public struct DescribeRobotApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRobotApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRobotApplicationOutputError>
}

public struct DescribeRobotApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRobotApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRobotApplicationOutputError>
}

public struct DescribeRobotApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRobotApplicationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeRobotApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeRobotApplication"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRobotApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRobotApplicationOutputError>
}

public struct DescribeRobotApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the robot application to describe.
    public var applicationVersion: Swift.String?

    public init (
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DescribeRobotApplicationInputBody: Swift.Equatable {
    public let application: Swift.String?
    public let applicationVersion: Swift.String?
}

extension DescribeRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DescribeRobotApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRobotApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRobotApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRobotApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRobotApplicationOutputResponse(arn: \(Swift.String(describing: arn)), environment: \(Swift.String(describing: environment)), imageDigest: \(Swift.String(describing: imageDigest)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), version: \(Swift.String(describing: version)))"}
}

extension DescribeRobotApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRobotApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.imageDigest = output.imageDigest
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.imageDigest = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeRobotApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// A SHA256 identifier for the Docker image that you use for your robot application.
    public var imageDigest: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot application was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the specified robot application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        imageDigest: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.imageDigest = imageDigest
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct DescribeRobotApplicationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let version: Swift.String?
    public let sources: [RoboMakerClientTypes.Source]?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let revisionId: Swift.String?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let tags: [Swift.String:Swift.String]?
    public let environment: RoboMakerClientTypes.Environment?
    public let imageDigest: Swift.String?
}

extension DescribeRobotApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case imageDigest
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

public struct DescribeRobotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRobotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRobotOutputError>
}

extension DescribeRobotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRobotInput(robot: \(Swift.String(describing: robot)))"}
}

extension DescribeRobotInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let robot = robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

public struct DescribeRobotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRobotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRobotOutputError>
}

public struct DescribeRobotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRobotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRobotOutputError>
}

public struct DescribeRobotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRobotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeRobotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeRobot"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRobotInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRobotOutputError>
}

public struct DescribeRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot to be described.
    /// This member is required.
    public var robot: Swift.String?

    public init (
        robot: Swift.String? = nil
    )
    {
        self.robot = robot
    }
}

struct DescribeRobotInputBody: Swift.Equatable {
    public let robot: Swift.String?
}

extension DescribeRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DescribeRobotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRobotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRobotOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRobotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRobotOutputResponse(architecture: \(Swift.String(describing: architecture)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), fleetArn: \(Swift.String(describing: fleetArn)), greengrassGroupId: \(Swift.String(describing: greengrassGroupId)), lastDeploymentJob: \(Swift.String(describing: lastDeploymentJob)), lastDeploymentTime: \(Swift.String(describing: lastDeploymentTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeRobotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRobotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architecture = output.architecture
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.fleetArn = output.fleetArn
            self.greengrassGroupId = output.greengrassGroupId
            self.lastDeploymentJob = output.lastDeploymentJob
            self.lastDeploymentTime = output.lastDeploymentTime
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.arn = nil
            self.createdAt = nil
            self.fleetArn = nil
            self.greengrassGroupId = nil
            self.lastDeploymentJob = nil
            self.lastDeploymentTime = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeRobotOutputResponse: Swift.Equatable {
    /// The target architecture of the robot application.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Amazon Resource Name (ARN) of the robot.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleetArn: Swift.String?
    /// The Greengrass group id.
    public var greengrassGroupId: Swift.String?
    /// The Amazon Resource Name (ARN) of the last deployment job.
    public var lastDeploymentJob: Swift.String?
    /// The time of the last deployment job.
    public var lastDeploymentTime: ClientRuntime.Date?
    /// The name of the robot.
    public var name: Swift.String?
    /// The status of the fleet.
    public var status: RoboMakerClientTypes.RobotStatus?
    /// The list of all tags added to the specified robot.
    public var tags: [Swift.String:Swift.String]?

    public init (
        architecture: RoboMakerClientTypes.Architecture? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        fleetArn: Swift.String? = nil,
        greengrassGroupId: Swift.String? = nil,
        lastDeploymentJob: Swift.String? = nil,
        lastDeploymentTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: RoboMakerClientTypes.RobotStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.fleetArn = fleetArn
        self.greengrassGroupId = greengrassGroupId
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct DescribeRobotOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let fleetArn: Swift.String?
    public let status: RoboMakerClientTypes.RobotStatus?
    public let greengrassGroupId: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let architecture: RoboMakerClientTypes.Architecture?
    public let lastDeploymentJob: Swift.String?
    public let lastDeploymentTime: ClientRuntime.Date?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeRobotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case arn
        case createdAt
        case fleetArn
        case greengrassGroupId
        case lastDeploymentJob
        case lastDeploymentTime
        case name
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotStatus.self, forKey: .status)
        status = statusDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeSimulationApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationApplicationOutputError>
}

extension DescribeSimulationApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSimulationApplicationInput(application: \(Swift.String(describing: application)), applicationVersion: \(Swift.String(describing: applicationVersion)))"}
}

extension DescribeSimulationApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

public struct DescribeSimulationApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationApplicationOutputError>
}

public struct DescribeSimulationApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationApplicationOutputError>
}

public struct DescribeSimulationApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationApplicationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeSimulationApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeSimulationApplication"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSimulationApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationApplicationOutputError>
}

public struct DescribeSimulationApplicationInput: Swift.Equatable {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the simulation application to describe.
    public var applicationVersion: Swift.String?

    public init (
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DescribeSimulationApplicationInputBody: Swift.Equatable {
    public let application: Swift.String?
    public let applicationVersion: Swift.String?
}

extension DescribeSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DescribeSimulationApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSimulationApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSimulationApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSimulationApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSimulationApplicationOutputResponse(arn: \(Swift.String(describing: arn)), environment: \(Swift.String(describing: environment)), imageDigest: \(Swift.String(describing: imageDigest)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), renderingEngine: \(Swift.String(describing: renderingEngine)), revisionId: \(Swift.String(describing: revisionId)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(Swift.String(describing: simulationSoftwareSuite)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), version: \(Swift.String(describing: version)))"}
}

extension DescribeSimulationApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSimulationApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.imageDigest = output.imageDigest
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.imageDigest = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeSimulationApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// A SHA256 identifier for the Docker image that you use for your simulation application.
    public var imageDigest: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation application was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the specified simulation application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        imageDigest: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.imageDigest = imageDigest
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct DescribeSimulationApplicationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let version: Swift.String?
    public let sources: [RoboMakerClientTypes.Source]?
    public let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    public let revisionId: Swift.String?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let tags: [Swift.String:Swift.String]?
    public let environment: RoboMakerClientTypes.Environment?
    public let imageDigest: Swift.String?
}

extension DescribeSimulationApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case imageDigest
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

public struct DescribeSimulationJobBatchInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationJobBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSimulationJobBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSimulationJobBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationJobBatchOutputError>
}

extension DescribeSimulationJobBatchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSimulationJobBatchInput(batch: \(Swift.String(describing: batch)))"}
}

extension DescribeSimulationJobBatchInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batch = batch {
            try encodeContainer.encode(batch, forKey: .batch)
        }
    }
}

public struct DescribeSimulationJobBatchInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationJobBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSimulationJobBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSimulationJobBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationJobBatchOutputError>
}

public struct DescribeSimulationJobBatchInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationJobBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSimulationJobBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSimulationJobBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationJobBatchOutputError>
}

public struct DescribeSimulationJobBatchInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationJobBatchInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeSimulationJobBatchInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeSimulationJobBatch"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSimulationJobBatchInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationJobBatchOutputError>
}

public struct DescribeSimulationJobBatchInput: Swift.Equatable {
    /// The id of the batch to describe.
    /// This member is required.
    public var batch: Swift.String?

    public init (
        batch: Swift.String? = nil
    )
    {
        self.batch = batch
    }
}

struct DescribeSimulationJobBatchInputBody: Swift.Equatable {
    public let batch: Swift.String?
}

extension DescribeSimulationJobBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batch)
        batch = batchDecoded
    }
}

extension DescribeSimulationJobBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSimulationJobBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSimulationJobBatchOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSimulationJobBatchOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSimulationJobBatchOutputResponse(arn: \(Swift.String(describing: arn)), batchPolicy: \(Swift.String(describing: batchPolicy)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdAt: \(Swift.String(describing: createdAt)), createdRequests: \(Swift.String(describing: createdRequests)), failedRequests: \(Swift.String(describing: failedRequests)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), pendingRequests: \(Swift.String(describing: pendingRequests)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeSimulationJobBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSimulationJobBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.batchPolicy = output.batchPolicy
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.createdRequests = output.createdRequests
            self.failedRequests = output.failedRequests
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.lastUpdatedAt = output.lastUpdatedAt
            self.pendingRequests = output.pendingRequests
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.batchPolicy = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.createdRequests = nil
            self.failedRequests = nil
            self.failureCode = nil
            self.failureReason = nil
            self.lastUpdatedAt = nil
            self.pendingRequests = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeSimulationJobBatchOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the batch.
    public var arn: Swift.String?
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was
    ///          created.
    public var createdAt: ClientRuntime.Date?
    /// A list of created simulation job summaries.
    public var createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    /// A list of failed create simulation job requests. The request failed to be created into a
    ///          simulation job. Failed requests do not have a simulation job ID.
    public var failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    /// The failure code of the simulation job batch.
    public var failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    /// The reason the simulation job batch failed.
    public var failureReason: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// A list of pending simulation job requests. These requests have not yet been created into
    ///          simulation jobs.
    public var pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// The status of the batch.
    ///
    ///             Pending
    ///
    ///                The simulation job batch request is pending.
    ///
    ///             InProgress
    ///
    ///                The simulation job batch is in progress.
    ///
    ///             Failed
    ///
    ///                The simulation job batch failed. One or more simulation job requests could not
    ///                   be completed due to an internal failure (like InternalServiceError).
    ///                   See failureCode and failureReason for more
    ///                   information.
    ///
    ///             Completed
    ///
    ///                The simulation batch job completed. A batch is complete when (1) there are no
    ///                   pending simulation job requests in the batch and none of the failed simulation job
    ///                   requests are due to InternalServiceError and (2) when all created
    ///                   simulation jobs have reached a terminal state (for example, Completed
    ///                   or Failed).
    ///
    ///             Canceled
    ///
    ///                The simulation batch job was cancelled.
    ///
    ///             Canceling
    ///
    ///                The simulation batch job is being cancelled.
    ///
    ///             Completing
    ///
    ///                The simulation batch job is completing.
    ///
    ///             TimingOut
    ///
    ///                The simulation job batch is timing out.
    ///                If a batch timing out, and there are pending requests that were failing due to
    ///                   an internal failure (like InternalServiceError), the batch status
    ///                   will be Failed. If there are no such failing request, the batch
    ///                   status will be TimedOut.
    ///
    ///             TimedOut
    ///
    ///                The simulation batch job timed out.
    ///
    ///
    public var status: RoboMakerClientTypes.SimulationJobBatchStatus?
    /// A map that contains tag keys and tag values that are attached to the simulation job
    ///          batch.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdRequests: [RoboMakerClientTypes.SimulationJobSummary]? = nil,
        failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode? = nil,
        failureReason: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.createdRequests = createdRequests
        self.failedRequests = failedRequests
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.lastUpdatedAt = lastUpdatedAt
        self.pendingRequests = pendingRequests
        self.status = status
        self.tags = tags
    }
}

struct DescribeSimulationJobBatchOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let status: RoboMakerClientTypes.SimulationJobBatchStatus?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let createdAt: ClientRuntime.Date?
    public let clientRequestToken: Swift.String?
    public let batchPolicy: RoboMakerClientTypes.BatchPolicy?
    public let failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    public let failureReason: Swift.String?
    public let failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    public let pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    public let createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeSimulationJobBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case batchPolicy
        case clientRequestToken
        case createdAt
        case createdRequests
        case failedRequests
        case failureCode
        case failureReason
        case lastUpdatedAt
        case pendingRequests
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failedRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.FailedCreateSimulationJobRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [RoboMakerClientTypes.FailedCreateSimulationJobRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobRequest?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[RoboMakerClientTypes.SimulationJobRequest]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobRequest]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
        let createdRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobSummary?].self, forKey: .createdRequests)
        var createdRequestsDecoded0:[RoboMakerClientTypes.SimulationJobSummary]? = nil
        if let createdRequestsContainer = createdRequestsContainer {
            createdRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobSummary]()
            for structure0 in createdRequestsContainer {
                if let structure0 = structure0 {
                    createdRequestsDecoded0?.append(structure0)
                }
            }
        }
        createdRequests = createdRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeSimulationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationJobOutputError>
}

extension DescribeSimulationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSimulationJobInput(job: \(Swift.String(describing: job)))"}
}

extension DescribeSimulationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct DescribeSimulationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationJobOutputError>
}

public struct DescribeSimulationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationJobOutputError>
}

public struct DescribeSimulationJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSimulationJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeSimulationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeSimulationJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSimulationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSimulationJobOutputError>
}

public struct DescribeSimulationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job to be described.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeSimulationJobInputBody: Swift.Equatable {
    public let job: Swift.String?
}

extension DescribeSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeSimulationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSimulationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSimulationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSimulationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSimulationJobOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), compute: \(Swift.String(describing: compute)), dataSources: \(Swift.String(describing: dataSources)), failureBehavior: \(Swift.String(describing: failureBehavior)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), iamRole: \(Swift.String(describing: iamRole)), lastStartedAt: \(Swift.String(describing: lastStartedAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), loggingConfig: \(Swift.String(describing: loggingConfig)), maxJobDurationInSeconds: \(Swift.String(describing: maxJobDurationInSeconds)), name: \(Swift.String(describing: name)), networkInterface: \(Swift.String(describing: networkInterface)), outputLocation: \(Swift.String(describing: outputLocation)), robotApplications: \(Swift.String(describing: robotApplications)), simulationApplications: \(Swift.String(describing: simulationApplications)), simulationTimeMillis: \(Swift.String(describing: simulationTimeMillis)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension DescribeSimulationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSimulationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.compute = output.compute
            self.dataSources = output.dataSources
            self.failureBehavior = output.failureBehavior
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.iamRole = output.iamRole
            self.lastStartedAt = output.lastStartedAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.loggingConfig = output.loggingConfig
            self.maxJobDurationInSeconds = output.maxJobDurationInSeconds
            self.name = output.name
            self.networkInterface = output.networkInterface
            self.outputLocation = output.outputLocation
            self.robotApplications = output.robotApplications
            self.simulationApplications = output.simulationApplications
            self.simulationTimeMillis = output.simulationTimeMillis
            self.status = output.status
            self.tags = output.tags
            self.vpcConfig = output.vpcConfig
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.compute = nil
            self.dataSources = nil
            self.failureBehavior = nil
            self.failureCode = nil
            self.failureReason = nil
            self.iamRole = nil
            self.lastStartedAt = nil
            self.lastUpdatedAt = nil
            self.loggingConfig = nil
            self.maxJobDurationInSeconds = 0
            self.name = nil
            self.networkInterface = nil
            self.outputLocation = nil
            self.robotApplications = nil
            self.simulationApplications = nil
            self.simulationTimeMillis = 0
            self.status = nil
            self.tags = nil
            self.vpcConfig = nil
        }
    }
}

public struct DescribeSimulationJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.ComputeResponse?
    /// The data sources for the simulation job.
    public var dataSources: [RoboMakerClientTypes.DataSource]?
    /// The failure behavior for the simulation job.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The failure code of the simulation job if it failed:
    ///
    ///             InternalServiceError
    ///
    ///                Internal service error.
    ///
    ///             RobotApplicationCrash
    ///
    ///                Robot application exited abnormally.
    ///
    ///             SimulationApplicationCrash
    ///
    ///                 Simulation application exited abnormally.
    ///
    ///             BadPermissionsRobotApplication
    ///
    ///                Robot application bundle could not be downloaded.
    ///
    ///             BadPermissionsSimulationApplication
    ///
    ///                Simulation application bundle could not be downloaded.
    ///
    ///             BadPermissionsS3Output
    ///
    ///                Unable to publish outputs to customer-provided S3 bucket.
    ///
    ///             BadPermissionsCloudwatchLogs
    ///
    ///                Unable to publish logs to customer-provided CloudWatch Logs resource.
    ///
    ///             SubnetIpLimitExceeded
    ///
    ///                Subnet IP limit exceeded.
    ///
    ///             ENILimitExceeded
    ///
    ///                ENI limit exceeded.
    ///
    ///             BadPermissionsUserCredentials
    ///
    ///                Unable to use the Role provided.
    ///
    ///             InvalidBundleRobotApplication
    ///
    ///                Robot bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).
    ///
    ///             InvalidBundleSimulationApplication
    ///
    ///                Simulation bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).
    ///
    ///             RobotApplicationVersionMismatchedEtag
    ///
    ///                Etag for RobotApplication does not match value during version creation.
    ///
    ///             SimulationApplicationVersionMismatchedEtag
    ///
    ///                Etag for SimulationApplication does not match value during version
    ///                   creation.
    ///
    ///
    public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    /// Details about why the simulation job failed. For more information about troubleshooting,
    ///          see <a href="https://docs.aws.amazon.com/robomaker/latest/dg/troubleshooting.html">Troubleshooting.
    public var failureReason: Swift.String?
    /// The IAM role that allows the simulation instance to call the AWS APIs that are specified
    ///          in its associated policies on your behalf.
    public var iamRole: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job was last
    ///          started.
    public var lastStartedAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the simulation job was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum job duration in seconds. The value must be 8 days (691,200 seconds) or
    ///          less.
    public var maxJobDurationInSeconds: Swift.Int
    /// The name of the simulation job.
    public var name: Swift.String?
    /// The network interface information for the simulation job.
    public var networkInterface: RoboMakerClientTypes.NetworkInterface?
    /// Location for output files generated by the simulation job.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// A list of robot applications.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// A list of simulation applications.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// The simulation job execution duration in milliseconds.
    public var simulationTimeMillis: Swift.Int
    /// The status of the simulation job.
    public var status: RoboMakerClientTypes.SimulationJobStatus?
    /// The list of all tags added to the specified simulation job.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC configuration.
    public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.ComputeResponse? = nil,
        dataSources: [RoboMakerClientTypes.DataSource]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        lastStartedAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int = 0,
        name: Swift.String? = nil,
        networkInterface: RoboMakerClientTypes.NetworkInterface? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Swift.Int = 0,
        status: RoboMakerClientTypes.SimulationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.name = name
        self.networkInterface = networkInterface
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct DescribeSimulationJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let status: RoboMakerClientTypes.SimulationJobStatus?
    public let lastStartedAt: ClientRuntime.Date?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let failureBehavior: RoboMakerClientTypes.FailureBehavior?
    public let failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    public let failureReason: Swift.String?
    public let clientRequestToken: Swift.String?
    public let outputLocation: RoboMakerClientTypes.OutputLocation?
    public let loggingConfig: RoboMakerClientTypes.LoggingConfig?
    public let maxJobDurationInSeconds: Swift.Int
    public let simulationTimeMillis: Swift.Int
    public let iamRole: Swift.String?
    public let robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    public let simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    public let dataSources: [RoboMakerClientTypes.DataSource]?
    public let tags: [Swift.String:Swift.String]?
    public let vpcConfig: RoboMakerClientTypes.VPCConfigResponse?
    public let networkInterface: RoboMakerClientTypes.NetworkInterface?
    public let compute: RoboMakerClientTypes.ComputeResponse?
}

extension DescribeSimulationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case failureReason
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case name
        case networkInterface
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .simulationTimeMillis)
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

public struct DescribeWorldExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldExportJobOutputError>
}

extension DescribeWorldExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorldExportJobInput(job: \(Swift.String(describing: job)))"}
}

extension DescribeWorldExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct DescribeWorldExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldExportJobOutputError>
}

public struct DescribeWorldExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldExportJobOutputError>
}

public struct DescribeWorldExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeWorldExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeWorldExportJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeWorldExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldExportJobOutputError>
}

public struct DescribeWorldExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world export job to describe.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeWorldExportJobInputBody: Swift.Equatable {
    public let job: Swift.String?
}

extension DescribeWorldExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeWorldExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorldExportJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorldExportJobOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdAt: \(Swift.String(describing: createdAt)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), iamRole: \(Swift.String(describing: iamRole)), outputLocation: \(Swift.String(describing: outputLocation)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), worlds: \(Swift.String(describing: worlds)))"}
}

extension DescribeWorldExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorldExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.iamRole = output.iamRole
            self.outputLocation = output.outputLocation
            self.status = output.status
            self.tags = output.tags
            self.worlds = output.worlds
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.failureReason = nil
            self.iamRole = nil
            self.outputLocation = nil
            self.status = nil
            self.tags = nil
            self.worlds = nil
        }
    }
}

public struct DescribeWorldExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world export job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world export job was created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world export job if it failed:
    ///
    ///             InternalServiceError
    ///
    ///                Internal service error.
    ///
    ///             LimitExceeded
    ///
    ///                The requested resource exceeds the maximum number allowed, or the number of
    ///                   concurrent stream requests exceeds the maximum number allowed.
    ///
    ///             ResourceNotFound
    ///
    ///                The specified resource could not be found.
    ///
    ///             RequestThrottled
    ///
    ///                The request was throttled.
    ///
    ///             InvalidInput
    ///
    ///                An input parameter in the request is not valid.
    ///
    ///
    public var failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    /// The reason why the world export job failed.
    public var failureReason: Swift.String?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put
    ///          the export.
    public var iamRole: Swift.String?
    /// The output location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The status of the world export job.
    ///
    ///             Pending
    ///
    ///                The world export job request is pending.
    ///
    ///             Running
    ///
    ///                The world export job is running.
    ///
    ///             Completed
    ///
    ///                The world export job completed.
    ///
    ///             Failed
    ///
    ///                The world export job failed. See failureCode and
    ///                      failureReason for more information.
    ///
    ///             Canceled
    ///
    ///                The world export job was cancelled.
    ///
    ///             Canceling
    ///
    ///                The world export job is being cancelled.
    ///
    ///
    public var status: RoboMakerClientTypes.WorldExportJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world export
    ///          job.
    public var tags: [Swift.String:Swift.String]?
    /// A list of Amazon Resource Names (arns) that correspond to worlds to be exported.
    public var worlds: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldExportJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        worlds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.status = status
        self.tags = tags
        self.worlds = worlds
    }
}

struct DescribeWorldExportJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let status: RoboMakerClientTypes.WorldExportJobStatus?
    public let createdAt: ClientRuntime.Date?
    public let failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    public let failureReason: Swift.String?
    public let clientRequestToken: Swift.String?
    public let worlds: [Swift.String]?
    public let outputLocation: RoboMakerClientTypes.OutputLocation?
    public let iamRole: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeWorldExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case failureReason
        case iamRole
        case outputLocation
        case status
        case tags
        case worlds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeWorldGenerationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldGenerationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldGenerationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldGenerationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldGenerationJobOutputError>
}

extension DescribeWorldGenerationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorldGenerationJobInput(job: \(Swift.String(describing: job)))"}
}

extension DescribeWorldGenerationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct DescribeWorldGenerationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldGenerationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldGenerationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldGenerationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldGenerationJobOutputError>
}

public struct DescribeWorldGenerationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldGenerationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldGenerationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldGenerationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldGenerationJobOutputError>
}

public struct DescribeWorldGenerationJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldGenerationJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeWorldGenerationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeWorldGenerationJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeWorldGenerationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldGenerationJobOutputError>
}

public struct DescribeWorldGenerationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world generation job to describe.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeWorldGenerationJobInputBody: Swift.Equatable {
    public let job: Swift.String?
}

extension DescribeWorldGenerationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeWorldGenerationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldGenerationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorldGenerationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldGenerationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorldGenerationJobOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdAt: \(Swift.String(describing: createdAt)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), finishedWorldsSummary: \(Swift.String(describing: finishedWorldsSummary)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), template: \(Swift.String(describing: template)), worldCount: \(Swift.String(describing: worldCount)), worldTags: \(Swift.String(describing: worldTags)))"}
}

extension DescribeWorldGenerationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorldGenerationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.finishedWorldsSummary = output.finishedWorldsSummary
            self.status = output.status
            self.tags = output.tags
            self.template = output.template
            self.worldCount = output.worldCount
            self.worldTags = output.worldTags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.failureReason = nil
            self.finishedWorldsSummary = nil
            self.status = nil
            self.tags = nil
            self.template = nil
            self.worldCount = nil
            self.worldTags = nil
        }
    }
}

public struct DescribeWorldGenerationJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world generation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world generation job was
    ///          created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world generation job if it failed:
    ///
    ///             InternalServiceError
    ///
    ///                Internal service error.
    ///
    ///             LimitExceeded
    ///
    ///                The requested resource exceeds the maximum number allowed, or the number of
    ///                   concurrent stream requests exceeds the maximum number allowed.
    ///
    ///             ResourceNotFound
    ///
    ///                The specified resource could not be found.
    ///
    ///             RequestThrottled
    ///
    ///                The request was throttled.
    ///
    ///             InvalidInput
    ///
    ///                An input parameter in the request is not valid.
    ///
    ///
    public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    /// The reason why the world generation job failed.
    public var failureReason: Swift.String?
    /// Summary information about finished worlds.
    public var finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary?
    /// The status of the world generation job:
    ///
    ///             Pending
    ///
    ///                The world generation job request is pending.
    ///
    ///             Running
    ///
    ///                The world generation job is running.
    ///
    ///             Completed
    ///
    ///                The world generation job completed.
    ///
    ///             Failed
    ///
    ///                The world generation job failed. See failureCode for more
    ///                   information.
    ///
    ///             PartialFailed
    ///
    ///                Some worlds did not generate.
    ///
    ///             Canceled
    ///
    ///                The world generation job was cancelled.
    ///
    ///             Canceling
    ///
    ///                The world generation job is being cancelled.
    ///
    ///
    public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world generation
    ///          job.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?
    /// Information about the world count.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated
    ///          worlds.
    public var worldTags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary? = nil,
        status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.finishedWorldsSummary = finishedWorldsSummary
        self.status = status
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct DescribeWorldGenerationJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let status: RoboMakerClientTypes.WorldGenerationJobStatus?
    public let createdAt: ClientRuntime.Date?
    public let failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    public let failureReason: Swift.String?
    public let clientRequestToken: Swift.String?
    public let template: Swift.String?
    public let worldCount: RoboMakerClientTypes.WorldCount?
    public let finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary?
    public let tags: [Swift.String:Swift.String]?
    public let worldTags: [Swift.String:Swift.String]?
}

extension DescribeWorldGenerationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case failureReason
        case finishedWorldsSummary
        case status
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let finishedWorldsSummaryDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FinishedWorldsSummary.self, forKey: .finishedWorldsSummary)
        finishedWorldsSummary = finishedWorldsSummaryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

public struct DescribeWorldInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldOutputError>
}

extension DescribeWorldInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorldInput(world: \(Swift.String(describing: world)))"}
}

extension DescribeWorldInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case world
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let world = world {
            try encodeContainer.encode(world, forKey: .world)
        }
    }
}

public struct DescribeWorldInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldOutputError>
}

public struct DescribeWorldInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldOutputError>
}

public struct DescribeWorldInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeWorldInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeWorld"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeWorldInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldOutputError>
}

public struct DescribeWorldInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world you want to describe.
    /// This member is required.
    public var world: Swift.String?

    public init (
        world: Swift.String? = nil
    )
    {
        self.world = world
    }
}

struct DescribeWorldInputBody: Swift.Equatable {
    public let world: Swift.String?
}

extension DescribeWorldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case world
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .world)
        world = worldDecoded
    }
}

extension DescribeWorldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorldOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorldOutputResponse(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), generationJob: \(Swift.String(describing: generationJob)), tags: \(Swift.String(describing: tags)), template: \(Swift.String(describing: template)), worldDescriptionBody: \(Swift.String(describing: worldDescriptionBody)))"}
}

extension DescribeWorldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.generationJob = output.generationJob
            self.tags = output.tags
            self.template = output.template
            self.worldDescriptionBody = output.worldDescriptionBody
        } else {
            self.arn = nil
            self.createdAt = nil
            self.generationJob = nil
            self.tags = nil
            self.template = nil
            self.worldDescriptionBody = nil
        }
    }
}

public struct DescribeWorldOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the world was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (arn) of the world generation job that generated the
    ///          world.
    public var generationJob: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world.
    public var tags: [Swift.String:Swift.String]?
    /// The world template.
    public var template: Swift.String?
    /// Returns the JSON formatted string that describes the contents of your world.
    public var worldDescriptionBody: Swift.String?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        generationJob: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldDescriptionBody: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.generationJob = generationJob
        self.tags = tags
        self.template = template
        self.worldDescriptionBody = worldDescriptionBody
    }
}

struct DescribeWorldOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let generationJob: Swift.String?
    public let template: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let tags: [Swift.String:Swift.String]?
    public let worldDescriptionBody: Swift.String?
}

extension DescribeWorldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case generationJob
        case tags
        case template
        case worldDescriptionBody
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldDescriptionBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .worldDescriptionBody)
        worldDescriptionBody = worldDescriptionBodyDecoded
    }
}

public struct DescribeWorldTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldTemplateOutputError>
}

extension DescribeWorldTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorldTemplateInput(template: \(Swift.String(describing: template)))"}
}

extension DescribeWorldTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

public struct DescribeWorldTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldTemplateOutputError>
}

public struct DescribeWorldTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldTemplateOutputError>
}

public struct DescribeWorldTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorldTemplateInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeWorldTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/describeWorldTemplate"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeWorldTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorldTemplateOutputError>
}

public struct DescribeWorldTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world template you want to describe.
    /// This member is required.
    public var template: Swift.String?

    public init (
        template: Swift.String? = nil
    )
    {
        self.template = template
    }
}

struct DescribeWorldTemplateInputBody: Swift.Equatable {
    public let template: Swift.String?
}

extension DescribeWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension DescribeWorldTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorldTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorldTemplateOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdAt: \(Swift.String(describing: createdAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), version: \(Swift.String(describing: version)))"}
}

extension DescribeWorldTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorldTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeWorldTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world template.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the world template was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world
    ///          template.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the world template that you're using.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.tags = tags
        self.version = version
    }
}

struct DescribeWorldTemplateOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let clientRequestToken: Swift.String?
    public let name: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let tags: [Swift.String:Swift.String]?
    public let version: Swift.String?
}

extension DescribeWorldTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case lastUpdatedAt
        case name
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes.Environment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension RoboMakerClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(uri: \(Swift.String(describing: uri)))"}
}

extension RoboMakerClientTypes {
    /// The object that contains the Docker image URI for either your robot or simulation applications.
    public struct Environment: Swift.Equatable {
        /// The Docker image URI for either your robot or simulation applications.
        public var uri: Swift.String?

        public init (
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension RoboMakerClientTypes {
    public enum ExitBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case restart
        case sdkUnknown(Swift.String)

        public static var allCases: [ExitBehavior] {
            return [
                .fail,
                .restart,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .restart: return "RESTART"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExitBehavior(rawValue: rawValue) ?? ExitBehavior.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.FailedCreateSimulationJobRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedAt
        case failureCode
        case failureReason
        case request
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedAt = failedAt {
            try encodeContainer.encode(failedAt.timeIntervalSince1970, forKey: .failedAt)
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let request = request {
            try encodeContainer.encode(request, forKey: .request)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobRequest.self, forKey: .request)
        request = requestDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .failedAt)
        failedAt = failedAtDecoded
    }
}

extension RoboMakerClientTypes.FailedCreateSimulationJobRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailedCreateSimulationJobRequest(failedAt: \(Swift.String(describing: failedAt)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), request: \(Swift.String(describing: request)))"}
}

extension RoboMakerClientTypes {
    /// Information about a failed create simulation job request.
    public struct FailedCreateSimulationJobRequest: Swift.Equatable {
        /// The time, in milliseconds since the epoch, when the simulation job batch failed.
        public var failedAt: ClientRuntime.Date?
        /// The failure code.
        public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
        /// The failure reason of the simulation job request.
        public var failureReason: Swift.String?
        /// The simulation job request.
        public var request: RoboMakerClientTypes.SimulationJobRequest?

        public init (
            failedAt: ClientRuntime.Date? = nil,
            failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            request: RoboMakerClientTypes.SimulationJobRequest? = nil
        )
        {
            self.failedAt = failedAt
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.request = request
        }
    }

}

extension RoboMakerClientTypes {
    public enum FailureBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `continue`
        case fail
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureBehavior] {
            return [
                .continue,
                .fail,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .continue: return "Continue"
            case .fail: return "Fail"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureBehavior(rawValue: rawValue) ?? FailureBehavior.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.FailureSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case totalFailureCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failures = failures {
            var failuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failures)
            for worldfailures0 in failures {
                try failuresContainer.encode(worldfailures0)
            }
        }
        if totalFailureCount != 0 {
            try encodeContainer.encode(totalFailureCount, forKey: .totalFailureCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalFailureCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalFailureCount)
        totalFailureCount = totalFailureCountDecoded
        let failuresContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldFailure?].self, forKey: .failures)
        var failuresDecoded0:[RoboMakerClientTypes.WorldFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [RoboMakerClientTypes.WorldFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension RoboMakerClientTypes.FailureSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailureSummary(failures: \(Swift.String(describing: failures)), totalFailureCount: \(Swift.String(describing: totalFailureCount)))"}
}

extension RoboMakerClientTypes {
    /// Information about worlds that failed.
    public struct FailureSummary: Swift.Equatable {
        /// The worlds that failed.
        public var failures: [RoboMakerClientTypes.WorldFailure]?
        /// The total number of failures.
        public var totalFailureCount: Swift.Int

        public init (
            failures: [RoboMakerClientTypes.WorldFailure]? = nil,
            totalFailureCount: Swift.Int = 0
        )
        {
            self.failures = failures
            self.totalFailureCount = totalFailureCount
        }
    }

}

extension RoboMakerClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension RoboMakerClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension RoboMakerClientTypes {
    /// Information about a filter.
    public struct Filter: Swift.Equatable {
        /// The name of the filter.
        public var name: Swift.String?
        /// A list of values.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension RoboMakerClientTypes.FinishedWorldsSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureSummary
        case finishedCount
        case succeededWorlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureSummary = failureSummary {
            try encodeContainer.encode(failureSummary, forKey: .failureSummary)
        }
        if finishedCount != 0 {
            try encodeContainer.encode(finishedCount, forKey: .finishedCount)
        }
        if let succeededWorlds = succeededWorlds {
            var succeededWorldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .succeededWorlds)
            for arns0 in succeededWorlds {
                try succeededWorldsContainer.encode(arns0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let finishedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .finishedCount)
        finishedCount = finishedCountDecoded
        let succeededWorldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .succeededWorlds)
        var succeededWorldsDecoded0:[Swift.String]? = nil
        if let succeededWorldsContainer = succeededWorldsContainer {
            succeededWorldsDecoded0 = [Swift.String]()
            for string0 in succeededWorldsContainer {
                if let string0 = string0 {
                    succeededWorldsDecoded0?.append(string0)
                }
            }
        }
        succeededWorlds = succeededWorldsDecoded0
        let failureSummaryDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureSummary.self, forKey: .failureSummary)
        failureSummary = failureSummaryDecoded
    }
}

extension RoboMakerClientTypes.FinishedWorldsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FinishedWorldsSummary(failureSummary: \(Swift.String(describing: failureSummary)), finishedCount: \(Swift.String(describing: finishedCount)), succeededWorlds: \(Swift.String(describing: succeededWorlds)))"}
}

extension RoboMakerClientTypes {
    /// Information about worlds that finished.
    public struct FinishedWorldsSummary: Swift.Equatable {
        /// Information about worlds that failed.
        public var failureSummary: RoboMakerClientTypes.FailureSummary?
        /// The total number of finished worlds.
        public var finishedCount: Swift.Int
        /// A list of worlds that succeeded.
        public var succeededWorlds: [Swift.String]?

        public init (
            failureSummary: RoboMakerClientTypes.FailureSummary? = nil,
            finishedCount: Swift.Int = 0,
            succeededWorlds: [Swift.String]? = nil
        )
        {
            self.failureSummary = failureSummary
            self.finishedCount = finishedCount
            self.succeededWorlds = succeededWorlds
        }
    }

}

extension RoboMakerClientTypes.Fleet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastDeploymentJob
        case lastDeploymentStatus
        case lastDeploymentTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastDeploymentJob = lastDeploymentJob {
            try encodeContainer.encode(lastDeploymentJob, forKey: .lastDeploymentJob)
        }
        if let lastDeploymentStatus = lastDeploymentStatus {
            try encodeContainer.encode(lastDeploymentStatus.rawValue, forKey: .lastDeploymentStatus)
        }
        if let lastDeploymentTime = lastDeploymentTime {
            try encodeContainer.encode(lastDeploymentTime.timeIntervalSince1970, forKey: .lastDeploymentTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentStatusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .lastDeploymentStatus)
        lastDeploymentStatus = lastDeploymentStatusDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
    }
}

extension RoboMakerClientTypes.Fleet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Fleet(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastDeploymentJob: \(Swift.String(describing: lastDeploymentJob)), lastDeploymentStatus: \(Swift.String(describing: lastDeploymentStatus)), lastDeploymentTime: \(Swift.String(describing: lastDeploymentTime)), name: \(Swift.String(describing: name)))"}
}

extension RoboMakerClientTypes {
    /// Information about a fleet.
    public struct Fleet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the fleet.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the fleet was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public var lastDeploymentJob: Swift.String?
        /// The status of the last fleet deployment.
        public var lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
        /// The time of the last deployment.
        public var lastDeploymentTime: ClientRuntime.Date?
        /// The name of the fleet.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastDeploymentJob: Swift.String? = nil,
            lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus? = nil,
            lastDeploymentTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentStatus = lastDeploymentStatus
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
        }
    }

}

public struct GetWorldTemplateBodyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorldTemplateBodyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorldTemplateBodyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorldTemplateBodyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorldTemplateBodyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorldTemplateBodyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorldTemplateBodyOutputError>
}

extension GetWorldTemplateBodyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorldTemplateBodyInput(generationJob: \(Swift.String(describing: generationJob)), template: \(Swift.String(describing: template)))"}
}

extension GetWorldTemplateBodyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationJob
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationJob = generationJob {
            try encodeContainer.encode(generationJob, forKey: .generationJob)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

public struct GetWorldTemplateBodyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorldTemplateBodyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorldTemplateBodyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorldTemplateBodyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorldTemplateBodyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorldTemplateBodyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorldTemplateBodyOutputError>
}

public struct GetWorldTemplateBodyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorldTemplateBodyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorldTemplateBodyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorldTemplateBodyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorldTemplateBodyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorldTemplateBodyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorldTemplateBodyOutputError>
}

public struct GetWorldTemplateBodyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorldTemplateBodyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetWorldTemplateBodyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorldTemplateBodyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/getWorldTemplateBody"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWorldTemplateBodyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorldTemplateBodyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorldTemplateBodyOutputError>
}

public struct GetWorldTemplateBodyInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world generator job.
    public var generationJob: Swift.String?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?

    public init (
        generationJob: Swift.String? = nil,
        template: Swift.String? = nil
    )
    {
        self.generationJob = generationJob
        self.template = template
    }
}

struct GetWorldTemplateBodyInputBody: Swift.Equatable {
    public let template: Swift.String?
    public let generationJob: Swift.String?
}

extension GetWorldTemplateBodyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationJob
        case template
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
    }
}

extension GetWorldTemplateBodyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorldTemplateBodyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorldTemplateBodyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorldTemplateBodyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorldTemplateBodyOutputResponse(templateBody: \(Swift.String(describing: templateBody)))"}
}

extension GetWorldTemplateBodyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWorldTemplateBodyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.templateBody = output.templateBody
        } else {
            self.templateBody = nil
        }
    }
}

public struct GetWorldTemplateBodyOutputResponse: Swift.Equatable {
    /// The world template body.
    public var templateBody: Swift.String?

    public init (
        templateBody: Swift.String? = nil
    )
    {
        self.templateBody = templateBody
    }
}

struct GetWorldTemplateBodyOutputResponseBody: Swift.Equatable {
    public let templateBody: Swift.String?
}

extension GetWorldTemplateBodyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateBody
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
    }
}

extension IdempotentParameterMismatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdempotentParameterMismatchException(message: \(Swift.String(describing: message)))"}
}

extension IdempotentParameterMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request uses the same client token as a previous, but non-identical request. Do not
///          reuse a client token with different requests, unless the requests are identical.
public struct IdempotentParameterMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AWS RoboMaker experienced a service issue. Try your call again.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parameter specified in a request is not valid, is unsupported, or cannot be used. The
///          returned message provides an explanation of the error value.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoboMakerClientTypes.LaunchConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentVariables
        case launchFile
        case packageName
        case portForwardingConfig
        case streamUI
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariablemap0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let launchFile = launchFile {
            try encodeContainer.encode(launchFile, forKey: .launchFile)
        }
        if let packageName = packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let portForwardingConfig = portForwardingConfig {
            try encodeContainer.encode(portForwardingConfig, forKey: .portForwardingConfig)
        }
        if streamUI != false {
            try encodeContainer.encode(streamUI, forKey: .streamUI)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let launchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchFile)
        launchFile = launchFileDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in environmentVariablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    environmentVariablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let portForwardingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.PortForwardingConfig.self, forKey: .portForwardingConfig)
        portForwardingConfig = portForwardingConfigDecoded
        let streamUIDecoded = try containerValues.decode(Swift.Bool.self, forKey: .streamUI)
        streamUI = streamUIDecoded
    }
}

extension RoboMakerClientTypes.LaunchConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchConfig(environmentVariables: \(Swift.String(describing: environmentVariables)), launchFile: \(Swift.String(describing: launchFile)), packageName: \(Swift.String(describing: packageName)), portForwardingConfig: \(Swift.String(describing: portForwardingConfig)), streamUI: \(Swift.String(describing: streamUI)))"}
}

extension RoboMakerClientTypes {
    /// Information about a launch configuration.
    public struct LaunchConfig: Swift.Equatable {
        /// The environment variables for the application launch.
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The launch file name.
        /// This member is required.
        public var launchFile: Swift.String?
        /// The package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The port forwarding configuration.
        public var portForwardingConfig: RoboMakerClientTypes.PortForwardingConfig?
        /// Boolean indicating whether a streaming session will be configured for the application.
        ///          If True, AWS RoboMaker will configure a connection so you can interact with
        ///          your application as it is running in the simulation. You must configure and launch the
        ///          component. It must have a graphical user interface.
        public var streamUI: Swift.Bool

        public init (
            environmentVariables: [Swift.String:Swift.String]? = nil,
            launchFile: Swift.String? = nil,
            packageName: Swift.String? = nil,
            portForwardingConfig: RoboMakerClientTypes.PortForwardingConfig? = nil,
            streamUI: Swift.Bool = false
        )
        {
            self.environmentVariables = environmentVariables
            self.launchFile = launchFile
            self.packageName = packageName
            self.portForwardingConfig = portForwardingConfig
            self.streamUI = streamUI
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource exceeds the maximum number allowed, or the number of concurrent
///          stream requests exceeds the maximum number allowed.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDeploymentJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeploymentJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeploymentJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentJobsOutputError>
}

extension ListDeploymentJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeploymentJobsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeploymentJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDeploymentJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeploymentJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeploymentJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentJobsOutputError>
}

public struct ListDeploymentJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeploymentJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeploymentJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentJobsOutputError>
}

public struct ListDeploymentJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDeploymentJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listDeploymentJobs"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDeploymentJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentJobsOutputError>
}

public struct ListDeploymentJobsInput: Swift.Equatable {
    /// Optional filters to limit results.
    ///          The filter names status and fleetName are supported. When
    ///          filtering, you must use the complete value of the filtered item. You can use up to three
    ///          filters, but they must be for the same named item. For example, if you are looking for
    ///          items with the status InProgress or the status Pending.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListDeploymentJobs only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListDeploymentJobs request with the returned nextToken
    ///          value. This value can be between 1 and 200. If this parameter is not used, then
    ///             ListDeploymentJobs returns up to 200 results and a nextToken
    ///          value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListDeploymentJobs again and assign that token to
    ///          the request object's nextToken parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentJobsInputBody: Swift.Equatable {
    public let filters: [RoboMakerClientTypes.Filter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDeploymentJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDeploymentJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeploymentJobsOutputResponse(deploymentJobs: \(Swift.String(describing: deploymentJobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeploymentJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeploymentJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentJobs = output.deploymentJobs
            self.nextToken = output.nextToken
        } else {
            self.deploymentJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentJobsOutputResponse: Swift.Equatable {
    /// A list of deployment jobs that meet the criteria of the request.
    public var deploymentJobs: [RoboMakerClientTypes.DeploymentJob]?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListDeploymentJobs again and assign that token to
    ///          the request object's nextToken parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        deploymentJobs: [RoboMakerClientTypes.DeploymentJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentJobs = deploymentJobs
        self.nextToken = nextToken
    }
}

struct ListDeploymentJobsOutputResponseBody: Swift.Equatable {
    public let deploymentJobs: [RoboMakerClientTypes.DeploymentJob]?
    public let nextToken: Swift.String?
}

extension ListDeploymentJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentJobsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentJob?].self, forKey: .deploymentJobs)
        var deploymentJobsDecoded0:[RoboMakerClientTypes.DeploymentJob]? = nil
        if let deploymentJobsContainer = deploymentJobsContainer {
            deploymentJobsDecoded0 = [RoboMakerClientTypes.DeploymentJob]()
            for structure0 in deploymentJobsContainer {
                if let structure0 = structure0 {
                    deploymentJobsDecoded0?.append(structure0)
                }
            }
        }
        deploymentJobs = deploymentJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFleetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFleetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFleetsOutputError>
}

extension ListFleetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFleetsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFleetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFleetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFleetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFleetsOutputError>
}

public struct ListFleetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFleetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFleetsOutputError>
}

public struct ListFleetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFleetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFleetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listFleets"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFleetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFleetsOutputError>
}

public struct ListFleetsInput: Swift.Equatable {
    /// Optional filters to limit results.
    ///          The filter name name is supported. When filtering, you must use the
    ///          complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListFleets only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListFleets request with the returned nextToken value.
    ///          This value can be between 1 and 200. If this parameter is not used, then
    ///             ListFleets returns up to 200 results and a nextToken value if
    ///          applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListFleets again and assign that token to the
    ///          request object's nextToken parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null.
    ///
    ///             This token should be treated as an opaque identifier that is only used to retrieve
    ///             the next items in a list and not for other programmatic purposes.
    ///
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [RoboMakerClientTypes.Filter]?
}

extension ListFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListFleetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFleetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFleetsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFleetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFleetsOutputResponse(fleetDetails: \(Swift.String(describing: fleetDetails)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFleetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFleetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleetDetails = output.fleetDetails
            self.nextToken = output.nextToken
        } else {
            self.fleetDetails = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsOutputResponse: Swift.Equatable {
    /// A list of fleet details meeting the request criteria.
    public var fleetDetails: [RoboMakerClientTypes.Fleet]?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListFleets again and assign that token to the
    ///          request object's nextToken parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        fleetDetails: [RoboMakerClientTypes.Fleet]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetDetails = fleetDetails
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputResponseBody: Swift.Equatable {
    public let fleetDetails: [RoboMakerClientTypes.Fleet]?
    public let nextToken: Swift.String?
}

extension ListFleetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDetailsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Fleet?].self, forKey: .fleetDetails)
        var fleetDetailsDecoded0:[RoboMakerClientTypes.Fleet]? = nil
        if let fleetDetailsContainer = fleetDetailsContainer {
            fleetDetailsDecoded0 = [RoboMakerClientTypes.Fleet]()
            for structure0 in fleetDetailsContainer {
                if let structure0 = structure0 {
                    fleetDetailsDecoded0?.append(structure0)
                }
            }
        }
        fleetDetails = fleetDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRobotApplicationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRobotApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRobotApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRobotApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRobotApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRobotApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRobotApplicationsOutputError>
}

extension ListRobotApplicationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRobotApplicationsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), versionQualifier: \(Swift.String(describing: versionQualifier)))"}
}

extension ListRobotApplicationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let versionQualifier = versionQualifier {
            try encodeContainer.encode(versionQualifier, forKey: .versionQualifier)
        }
    }
}

public struct ListRobotApplicationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRobotApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRobotApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRobotApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRobotApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRobotApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRobotApplicationsOutputError>
}

public struct ListRobotApplicationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRobotApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRobotApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRobotApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRobotApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRobotApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRobotApplicationsOutputError>
}

public struct ListRobotApplicationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRobotApplicationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListRobotApplicationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRobotApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listRobotApplications"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRobotApplicationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRobotApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRobotApplicationsOutputError>
}

public struct ListRobotApplicationsInput: Swift.Equatable {
    /// Optional filters to limit results.
    ///          The filter name name is supported. When filtering, you must use the
    ///          complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListRobotApplications only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListRobotApplications request with the returned nextToken
    ///          value. This value can be between 1 and 100. If this parameter is not used, then
    ///             ListRobotApplications returns up to 100 results and a
    ///             nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListRobotApplications again and assign that token to
    ///          the request object's nextToken parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// The version qualifier of the robot application.
    public var versionQualifier: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        versionQualifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionQualifier = versionQualifier
    }
}

struct ListRobotApplicationsInputBody: Swift.Equatable {
    public let versionQualifier: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [RoboMakerClientTypes.Filter]?
}

extension ListRobotApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionQualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionQualifier)
        versionQualifier = versionQualifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListRobotApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRobotApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRobotApplicationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRobotApplicationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRobotApplicationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), robotApplicationSummaries: \(Swift.String(describing: robotApplicationSummaries)))"}
}

extension ListRobotApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRobotApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.robotApplicationSummaries = output.robotApplicationSummaries
        } else {
            self.nextToken = nil
            self.robotApplicationSummaries = nil
        }
    }
}

public struct ListRobotApplicationsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListRobotApplications again and assign that token to
    ///          the request object's nextToken parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of robot application summaries that meet the criteria of the request.
    public var robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.robotApplicationSummaries = robotApplicationSummaries
    }
}

struct ListRobotApplicationsOutputResponseBody: Swift.Equatable {
    public let robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]?
    public let nextToken: Swift.String?
}

extension ListRobotApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case robotApplicationSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotApplicationSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationSummary?].self, forKey: .robotApplicationSummaries)
        var robotApplicationSummariesDecoded0:[RoboMakerClientTypes.RobotApplicationSummary]? = nil
        if let robotApplicationSummariesContainer = robotApplicationSummariesContainer {
            robotApplicationSummariesDecoded0 = [RoboMakerClientTypes.RobotApplicationSummary]()
            for structure0 in robotApplicationSummariesContainer {
                if let structure0 = structure0 {
                    robotApplicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        robotApplicationSummaries = robotApplicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRobotsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRobotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRobotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRobotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRobotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRobotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRobotsOutputError>
}

extension ListRobotsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRobotsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRobotsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRobotsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRobotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRobotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRobotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRobotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRobotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRobotsOutputError>
}

public struct ListRobotsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRobotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRobotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRobotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRobotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRobotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRobotsOutputError>
}

public struct ListRobotsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRobotsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListRobotsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRobotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listRobots"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRobotsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRobotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRobotsOutputError>
}

public struct ListRobotsInput: Swift.Equatable {
    /// Optional filters to limit results.
    ///          The filter names status and fleetName are supported. When
    ///          filtering, you must use the complete value of the filtered item. You can use up to three
    ///          filters, but they must be for the same named item. For example, if you are looking for
    ///          items with the status Registered or the status Available.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListRobots only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListRobots request with the returned nextToken value.
    ///          This value can be between 1 and 200. If this parameter is not used, then
    ///             ListRobots returns up to 200 results and a nextToken value if
    ///          applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListRobots again and assign that token to the
    ///          request object's nextToken parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRobotsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [RoboMakerClientTypes.Filter]?
}

extension ListRobotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListRobotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRobotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRobotsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRobotsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRobotsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), robots: \(Swift.String(describing: robots)))"}
}

extension ListRobotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRobotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.robots = output.robots
        } else {
            self.nextToken = nil
            self.robots = nil
        }
    }
}

public struct ListRobotsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListRobots again and assign that token to the
    ///          request object's nextToken parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of robots that meet the criteria of the request.
    public var robots: [RoboMakerClientTypes.Robot]?

    public init (
        nextToken: Swift.String? = nil,
        robots: [RoboMakerClientTypes.Robot]? = nil
    )
    {
        self.nextToken = nextToken
        self.robots = robots
    }
}

struct ListRobotsOutputResponseBody: Swift.Equatable {
    public let robots: [RoboMakerClientTypes.Robot]?
    public let nextToken: Swift.String?
}

extension ListRobotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case robots
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Robot?].self, forKey: .robots)
        var robotsDecoded0:[RoboMakerClientTypes.Robot]? = nil
        if let robotsContainer = robotsContainer {
            robotsDecoded0 = [RoboMakerClientTypes.Robot]()
            for structure0 in robotsContainer {
                if let structure0 = structure0 {
                    robotsDecoded0?.append(structure0)
                }
            }
        }
        robots = robotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSimulationApplicationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSimulationApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSimulationApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationApplicationsOutputError>
}

extension ListSimulationApplicationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSimulationApplicationsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), versionQualifier: \(Swift.String(describing: versionQualifier)))"}
}

extension ListSimulationApplicationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let versionQualifier = versionQualifier {
            try encodeContainer.encode(versionQualifier, forKey: .versionQualifier)
        }
    }
}

public struct ListSimulationApplicationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSimulationApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSimulationApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationApplicationsOutputError>
}

public struct ListSimulationApplicationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSimulationApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSimulationApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationApplicationsOutputError>
}

public struct ListSimulationApplicationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationApplicationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListSimulationApplicationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listSimulationApplications"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSimulationApplicationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationApplicationsOutputError>
}

public struct ListSimulationApplicationsInput: Swift.Equatable {
    /// Optional list of filters to limit results.
    ///          The filter name name is supported. When filtering, you must use the
    ///          complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationApplications only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListSimulationApplications request with the returned
    ///             nextToken value. This value can be between 1 and 100. If this parameter is
    ///          not used, then ListSimulationApplications returns up to 100 results and a
    ///             nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListSimulationApplications again and assign that
    ///          token to the request object's nextToken parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// The version qualifier of the simulation application.
    public var versionQualifier: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        versionQualifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionQualifier = versionQualifier
    }
}

struct ListSimulationApplicationsInputBody: Swift.Equatable {
    public let versionQualifier: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [RoboMakerClientTypes.Filter]?
}

extension ListSimulationApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionQualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionQualifier)
        versionQualifier = versionQualifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSimulationApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSimulationApplicationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSimulationApplicationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSimulationApplicationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), simulationApplicationSummaries: \(Swift.String(describing: simulationApplicationSummaries)))"}
}

extension ListSimulationApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSimulationApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulationApplicationSummaries = output.simulationApplicationSummaries
        } else {
            self.nextToken = nil
            self.simulationApplicationSummaries = nil
        }
    }
}

public struct ListSimulationApplicationsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListSimulationApplications again and assign that
    ///          token to the request object's nextToken parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation application summaries that meet the criteria of the request.
    public var simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationApplicationSummaries = simulationApplicationSummaries
    }
}

struct ListSimulationApplicationsOutputResponseBody: Swift.Equatable {
    public let simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]?
    public let nextToken: Swift.String?
}

extension ListSimulationApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case simulationApplicationSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationApplicationSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationSummary?].self, forKey: .simulationApplicationSummaries)
        var simulationApplicationSummariesDecoded0:[RoboMakerClientTypes.SimulationApplicationSummary]? = nil
        if let simulationApplicationSummariesContainer = simulationApplicationSummariesContainer {
            simulationApplicationSummariesDecoded0 = [RoboMakerClientTypes.SimulationApplicationSummary]()
            for structure0 in simulationApplicationSummariesContainer {
                if let structure0 = structure0 {
                    simulationApplicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationApplicationSummaries = simulationApplicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSimulationJobBatchesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationJobBatchesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSimulationJobBatchesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationJobBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSimulationJobBatchesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationJobBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationJobBatchesOutputError>
}

extension ListSimulationJobBatchesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSimulationJobBatchesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSimulationJobBatchesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSimulationJobBatchesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationJobBatchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSimulationJobBatchesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationJobBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSimulationJobBatchesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationJobBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationJobBatchesOutputError>
}

public struct ListSimulationJobBatchesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationJobBatchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSimulationJobBatchesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationJobBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSimulationJobBatchesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationJobBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationJobBatchesOutputError>
}

public struct ListSimulationJobBatchesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationJobBatchesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListSimulationJobBatchesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationJobBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listSimulationJobBatches"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSimulationJobBatchesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationJobBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationJobBatchesOutputError>
}

public struct ListSimulationJobBatchesInput: Swift.Equatable {
    /// Optional filters to limit results.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationJobBatches only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListSimulationJobBatches request with the returned
    ///             nextToken value.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListSimulationJobBatches again and assign that token
    ///          to the request object's nextToken parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSimulationJobBatchesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [RoboMakerClientTypes.Filter]?
}

extension ListSimulationJobBatchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationJobBatchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSimulationJobBatchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSimulationJobBatchesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSimulationJobBatchesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSimulationJobBatchesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), simulationJobBatchSummaries: \(Swift.String(describing: simulationJobBatchSummaries)))"}
}

extension ListSimulationJobBatchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSimulationJobBatchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulationJobBatchSummaries = output.simulationJobBatchSummaries
        } else {
            self.nextToken = nil
            self.simulationJobBatchSummaries = nil
        }
    }
}

public struct ListSimulationJobBatchesOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListSimulationJobBatches again and assign that token
    ///          to the request object's nextToken parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation job batch summaries.
    public var simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]?

    public init (
        nextToken: Swift.String? = nil,
        simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationJobBatchSummaries = simulationJobBatchSummaries
    }
}

struct ListSimulationJobBatchesOutputResponseBody: Swift.Equatable {
    public let simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]?
    public let nextToken: Swift.String?
}

extension ListSimulationJobBatchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case simulationJobBatchSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationJobBatchSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobBatchSummary?].self, forKey: .simulationJobBatchSummaries)
        var simulationJobBatchSummariesDecoded0:[RoboMakerClientTypes.SimulationJobBatchSummary]? = nil
        if let simulationJobBatchSummariesContainer = simulationJobBatchSummariesContainer {
            simulationJobBatchSummariesDecoded0 = [RoboMakerClientTypes.SimulationJobBatchSummary]()
            for structure0 in simulationJobBatchSummariesContainer {
                if let structure0 = structure0 {
                    simulationJobBatchSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationJobBatchSummaries = simulationJobBatchSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSimulationJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSimulationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSimulationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationJobsOutputError>
}

extension ListSimulationJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSimulationJobsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSimulationJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSimulationJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSimulationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSimulationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationJobsOutputError>
}

public struct ListSimulationJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSimulationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSimulationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationJobsOutputError>
}

public struct ListSimulationJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSimulationJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListSimulationJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSimulationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listSimulationJobs"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSimulationJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSimulationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSimulationJobsOutputError>
}

public struct ListSimulationJobsInput: Swift.Equatable {
    /// Optional filters to limit results.
    ///          The filter names status and simulationApplicationName and
    ///             robotApplicationName are supported. When filtering, you must use the
    ///          complete value of the filtered item. You can use up to three filters, but they must be for
    ///          the same named item. For example, if you are looking for items with the status
    ///             Preparing or the status Running.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationJobs only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListSimulationJobs request with the returned nextToken
    ///          value. This value can be between 1 and 1000. If this parameter is not used, then
    ///             ListSimulationJobs returns up to 1000 results and a nextToken
    ///          value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListSimulationJobs again and assign that token to
    ///          the request object's nextToken parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSimulationJobsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [RoboMakerClientTypes.Filter]?
}

extension ListSimulationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSimulationJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSimulationJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSimulationJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSimulationJobsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), simulationJobSummaries: \(Swift.String(describing: simulationJobSummaries)))"}
}

extension ListSimulationJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSimulationJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulationJobSummaries = output.simulationJobSummaries
        } else {
            self.nextToken = nil
            self.simulationJobSummaries = nil
        }
    }
}

public struct ListSimulationJobsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListSimulationJobs again and assign that token to
    ///          the request object's nextToken parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation job summaries that meet the criteria of the request.
    /// This member is required.
    public var simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]?

    public init (
        nextToken: Swift.String? = nil,
        simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationJobSummaries = simulationJobSummaries
    }
}

struct ListSimulationJobsOutputResponseBody: Swift.Equatable {
    public let simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]?
    public let nextToken: Swift.String?
}

extension ListSimulationJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case simulationJobSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationJobSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobSummary?].self, forKey: .simulationJobSummaries)
        var simulationJobSummariesDecoded0:[RoboMakerClientTypes.SimulationJobSummary]? = nil
        if let simulationJobSummariesContainer = simulationJobSummariesContainer {
            simulationJobSummariesDecoded0 = [RoboMakerClientTypes.SimulationJobSummary]()
            for structure0 in simulationJobSummariesContainer {
                if let structure0 = structure0 {
                    simulationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationJobSummaries = simulationJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The AWS RoboMaker Amazon Resource Name (ARN) with tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of all tags added to the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListWorldExportJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldExportJobsOutputError>
}

extension ListWorldExportJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorldExportJobsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListWorldExportJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorldExportJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldExportJobsOutputError>
}

public struct ListWorldExportJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldExportJobsOutputError>
}

public struct ListWorldExportJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldExportJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListWorldExportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listWorldExportJobs"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWorldExportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldExportJobsOutputError>
}

public struct ListWorldExportJobsInput: Swift.Equatable {
    /// Optional filters to limit results. You can use generationJobId and
    ///             templateId.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorldExportJobs only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListWorldExportJobs request with the returned nextToken
    ///          value. This value can be between 1 and 100. If this parameter is not used, then
    ///             ListWorldExportJobs returns up to 100 results and a nextToken
    ///          value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListWorldExportJobs again and assign that token to
    ///          the request object's nextToken parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldExportJobsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [RoboMakerClientTypes.Filter]?
}

extension ListWorldExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorldExportJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldExportJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorldExportJobsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), worldExportJobSummaries: \(Swift.String(describing: worldExportJobSummaries)))"}
}

extension ListWorldExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorldExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.worldExportJobSummaries = output.worldExportJobSummaries
        } else {
            self.nextToken = nil
            self.worldExportJobSummaries = nil
        }
    }
}

public struct ListWorldExportJobsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListWorldExportJobsRequest again and assign that
    ///          token to the request object's nextToken parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for world export jobs.
    /// This member is required.
    public var worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]?

    public init (
        nextToken: Swift.String? = nil,
        worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldExportJobSummaries = worldExportJobSummaries
    }
}

struct ListWorldExportJobsOutputResponseBody: Swift.Equatable {
    public let worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]?
    public let nextToken: Swift.String?
}

extension ListWorldExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case worldExportJobSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldExportJobSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldExportJobSummary?].self, forKey: .worldExportJobSummaries)
        var worldExportJobSummariesDecoded0:[RoboMakerClientTypes.WorldExportJobSummary]? = nil
        if let worldExportJobSummariesContainer = worldExportJobSummariesContainer {
            worldExportJobSummariesDecoded0 = [RoboMakerClientTypes.WorldExportJobSummary]()
            for structure0 in worldExportJobSummariesContainer {
                if let structure0 = structure0 {
                    worldExportJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldExportJobSummaries = worldExportJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWorldGenerationJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldGenerationJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldGenerationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldGenerationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldGenerationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldGenerationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldGenerationJobsOutputError>
}

extension ListWorldGenerationJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorldGenerationJobsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListWorldGenerationJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorldGenerationJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldGenerationJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldGenerationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldGenerationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldGenerationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldGenerationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldGenerationJobsOutputError>
}

public struct ListWorldGenerationJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldGenerationJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldGenerationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldGenerationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldGenerationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldGenerationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldGenerationJobsOutputError>
}

public struct ListWorldGenerationJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldGenerationJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListWorldGenerationJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldGenerationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listWorldGenerationJobs"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWorldGenerationJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldGenerationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldGenerationJobsOutputError>
}

public struct ListWorldGenerationJobsInput: Swift.Equatable {
    /// Optional filters to limit results. You can use status and
    ///             templateId.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorldGeneratorJobs only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListWorldGeneratorJobs request with the returned
    ///             nextToken value. This value can be between 1 and 100. If this parameter is
    ///          not used, then ListWorldGeneratorJobs returns up to 100 results and a
    ///             nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListWorldGenerationJobsRequest again and assign that
    ///          token to the request object's nextToken parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldGenerationJobsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [RoboMakerClientTypes.Filter]?
}

extension ListWorldGenerationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldGenerationJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldGenerationJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorldGenerationJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldGenerationJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorldGenerationJobsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), worldGenerationJobSummaries: \(Swift.String(describing: worldGenerationJobSummaries)))"}
}

extension ListWorldGenerationJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorldGenerationJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.worldGenerationJobSummaries = output.worldGenerationJobSummaries
        } else {
            self.nextToken = nil
            self.worldGenerationJobSummaries = nil
        }
    }
}

public struct ListWorldGenerationJobsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListWorldGeneratorJobsRequest again and assign that
    ///          token to the request object's nextToken parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for world generator jobs.
    /// This member is required.
    public var worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]?

    public init (
        nextToken: Swift.String? = nil,
        worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldGenerationJobSummaries = worldGenerationJobSummaries
    }
}

struct ListWorldGenerationJobsOutputResponseBody: Swift.Equatable {
    public let worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]?
    public let nextToken: Swift.String?
}

extension ListWorldGenerationJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case worldGenerationJobSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldGenerationJobSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldGenerationJobSummary?].self, forKey: .worldGenerationJobSummaries)
        var worldGenerationJobSummariesDecoded0:[RoboMakerClientTypes.WorldGenerationJobSummary]? = nil
        if let worldGenerationJobSummariesContainer = worldGenerationJobSummariesContainer {
            worldGenerationJobSummariesDecoded0 = [RoboMakerClientTypes.WorldGenerationJobSummary]()
            for structure0 in worldGenerationJobSummariesContainer {
                if let structure0 = structure0 {
                    worldGenerationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldGenerationJobSummaries = worldGenerationJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWorldTemplatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldTemplatesOutputError>
}

extension ListWorldTemplatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorldTemplatesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListWorldTemplatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorldTemplatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldTemplatesOutputError>
}

public struct ListWorldTemplatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldTemplatesOutputError>
}

public struct ListWorldTemplatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldTemplatesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListWorldTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listWorldTemplates"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWorldTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldTemplatesOutputError>
}

public struct ListWorldTemplatesInput: Swift.Equatable {
    /// When this parameter is used, ListWorldTemplates only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListWorldTemplates request with the returned nextToken
    ///          value. This value can be between 1 and 100. If this parameter is not used, then
    ///             ListWorldTemplates returns up to 100 results and a nextToken
    ///          value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListWorldTemplates again and assign that token to
    ///          the request object's nextToken parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldTemplatesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListWorldTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorldTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorldTemplatesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldTemplatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorldTemplatesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), templateSummaries: \(Swift.String(describing: templateSummaries)))"}
}

extension ListWorldTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorldTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateSummaries = output.templateSummaries
        } else {
            self.nextToken = nil
            self.templateSummaries = nil
        }
    }
}

public struct ListWorldTemplatesOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListWorldTemplates again and assign that token to
    ///          the request object's nextToken parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for templates.
    public var templateSummaries: [RoboMakerClientTypes.TemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        templateSummaries: [RoboMakerClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateSummaries = templateSummaries
    }
}

struct ListWorldTemplatesOutputResponseBody: Swift.Equatable {
    public let templateSummaries: [RoboMakerClientTypes.TemplateSummary]?
    public let nextToken: Swift.String?
}

extension ListWorldTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.TemplateSummary?].self, forKey: .templateSummaries)
        var templateSummariesDecoded0:[RoboMakerClientTypes.TemplateSummary]? = nil
        if let templateSummariesContainer = templateSummariesContainer {
            templateSummariesDecoded0 = [RoboMakerClientTypes.TemplateSummary]()
            for structure0 in templateSummariesContainer {
                if let structure0 = structure0 {
                    templateSummariesDecoded0?.append(structure0)
                }
            }
        }
        templateSummaries = templateSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWorldsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldsOutputError>
}

extension ListWorldsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorldsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListWorldsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorldsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldsOutputError>
}

public struct ListWorldsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorldsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorldsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldsOutputError>
}

public struct ListWorldsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorldsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListWorldsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/listWorlds"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWorldsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorldsOutputError>
}

public struct ListWorldsInput: Swift.Equatable {
    /// Optional filters to limit results. You can use status.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorlds only returns
    ///             maxResults results in a single page along with a nextToken
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another ListWorlds request with the returned nextToken value.
    ///          This value can be between 1 and 100. If this parameter is not used, then
    ///             ListWorlds returns up to 100 results and a nextToken value if
    ///          applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListWorlds again and assign that token to the
    ///          request object's nextToken parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [RoboMakerClientTypes.Filter]?
}

extension ListWorldsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorldsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorldsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), worldSummaries: \(Swift.String(describing: worldSummaries)))"}
}

extension ListWorldsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorldsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.worldSummaries = output.worldSummaries
        } else {
            self.nextToken = nil
            self.worldSummaries = nil
        }
    }
}

public struct ListWorldsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the
    ///          response object's nextToken parameter value is set to a token. To retrieve the
    ///          next set of results, call ListWorlds again and assign that token to the
    ///          request object's nextToken parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for worlds.
    public var worldSummaries: [RoboMakerClientTypes.WorldSummary]?

    public init (
        nextToken: Swift.String? = nil,
        worldSummaries: [RoboMakerClientTypes.WorldSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldSummaries = worldSummaries
    }
}

struct ListWorldsOutputResponseBody: Swift.Equatable {
    public let worldSummaries: [RoboMakerClientTypes.WorldSummary]?
    public let nextToken: Swift.String?
}

extension ListWorldsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case worldSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldSummary?].self, forKey: .worldSummaries)
        var worldSummariesDecoded0:[RoboMakerClientTypes.WorldSummary]? = nil
        if let worldSummariesContainer = worldSummariesContainer {
            worldSummariesDecoded0 = [RoboMakerClientTypes.WorldSummary]()
            for structure0 in worldSummariesContainer {
                if let structure0 = structure0 {
                    worldSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldSummaries = worldSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension RoboMakerClientTypes.LoggingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordAllRosTopics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordAllRosTopics = recordAllRosTopics {
            try encodeContainer.encode(recordAllRosTopics, forKey: .recordAllRosTopics)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordAllRosTopicsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .recordAllRosTopics)
        recordAllRosTopics = recordAllRosTopicsDecoded
    }
}

extension RoboMakerClientTypes.LoggingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoggingConfig(recordAllRosTopics: \(Swift.String(describing: recordAllRosTopics)))"}
}

extension RoboMakerClientTypes {
    /// The logging configuration.
    public struct LoggingConfig: Swift.Equatable {
        /// A boolean indicating whether to record all ROS topics.
        /// This member is required.
        public var recordAllRosTopics: Swift.Bool?

        public init (
            recordAllRosTopics: Swift.Bool? = nil
        )
        {
            self.recordAllRosTopics = recordAllRosTopics
        }
    }

}

extension RoboMakerClientTypes.NetworkInterface: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaceId
        case privateIpAddress
        case publicIpAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let publicIpAddress = publicIpAddress {
            try encodeContainer.encode(publicIpAddress, forKey: .publicIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let publicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIpAddress)
        publicIpAddress = publicIpAddressDecoded
    }
}

extension RoboMakerClientTypes.NetworkInterface: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkInterface(networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), privateIpAddress: \(Swift.String(describing: privateIpAddress)), publicIpAddress: \(Swift.String(describing: publicIpAddress)))"}
}

extension RoboMakerClientTypes {
    /// Describes a network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The IPv4 address of the network interface within the subnet.
        public var privateIpAddress: Swift.String?
        /// The IPv4 public address of the network interface.
        public var publicIpAddress: Swift.String?

        public init (
            networkInterfaceId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            publicIpAddress: Swift.String? = nil
        )
        {
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
        }
    }

}

extension RoboMakerClientTypes.OutputLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Prefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension RoboMakerClientTypes.OutputLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputLocation(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Prefix: \(Swift.String(describing: s3Prefix)))"}
}

extension RoboMakerClientTypes {
    /// The output location.
    public struct OutputLocation: Swift.Equatable {
        /// The S3 bucket for output.
        public var s3Bucket: Swift.String?
        /// The S3 folder in the s3Bucket where output files will be placed.
        public var s3Prefix: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }
    }

}

extension RoboMakerClientTypes.PortForwardingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portMappings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portMappings = portMappings {
            var portMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portMappings)
            for portmappinglist0 in portMappings {
                try portMappingsContainer.encode(portmappinglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.PortMapping?].self, forKey: .portMappings)
        var portMappingsDecoded0:[RoboMakerClientTypes.PortMapping]? = nil
        if let portMappingsContainer = portMappingsContainer {
            portMappingsDecoded0 = [RoboMakerClientTypes.PortMapping]()
            for structure0 in portMappingsContainer {
                if let structure0 = structure0 {
                    portMappingsDecoded0?.append(structure0)
                }
            }
        }
        portMappings = portMappingsDecoded0
    }
}

extension RoboMakerClientTypes.PortForwardingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortForwardingConfig(portMappings: \(Swift.String(describing: portMappings)))"}
}

extension RoboMakerClientTypes {
    /// Configuration information for port forwarding.
    public struct PortForwardingConfig: Swift.Equatable {
        /// The port mappings for the configuration.
        public var portMappings: [RoboMakerClientTypes.PortMapping]?

        public init (
            portMappings: [RoboMakerClientTypes.PortMapping]? = nil
        )
        {
            self.portMappings = portMappings
        }
    }

}

extension RoboMakerClientTypes.PortMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPort
        case enableOnPublicIp
        case jobPort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applicationPort != 0 {
            try encodeContainer.encode(applicationPort, forKey: .applicationPort)
        }
        if enableOnPublicIp != false {
            try encodeContainer.encode(enableOnPublicIp, forKey: .enableOnPublicIp)
        }
        if jobPort != 0 {
            try encodeContainer.encode(jobPort, forKey: .jobPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobPortDecoded = try containerValues.decode(Swift.Int.self, forKey: .jobPort)
        jobPort = jobPortDecoded
        let applicationPortDecoded = try containerValues.decode(Swift.Int.self, forKey: .applicationPort)
        applicationPort = applicationPortDecoded
        let enableOnPublicIpDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableOnPublicIp)
        enableOnPublicIp = enableOnPublicIpDecoded
    }
}

extension RoboMakerClientTypes.PortMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortMapping(applicationPort: \(Swift.String(describing: applicationPort)), enableOnPublicIp: \(Swift.String(describing: enableOnPublicIp)), jobPort: \(Swift.String(describing: jobPort)))"}
}

extension RoboMakerClientTypes {
    /// An object representing a port mapping.
    public struct PortMapping: Swift.Equatable {
        /// The port number on the application.
        /// This member is required.
        public var applicationPort: Swift.Int
        /// A Boolean indicating whether to enable this port mapping on public IP.
        public var enableOnPublicIp: Swift.Bool
        /// The port number on the simulation job instance to use as a remote connection point.
        ///
        /// This member is required.
        public var jobPort: Swift.Int

        public init (
            applicationPort: Swift.Int = 0,
            enableOnPublicIp: Swift.Bool = false,
            jobPort: Swift.Int = 0
        )
        {
            self.applicationPort = applicationPort
            self.enableOnPublicIp = enableOnPublicIp
            self.jobPort = jobPort
        }
    }

}

extension RoboMakerClientTypes.ProgressDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentProgress
        case estimatedTimeRemainingSeconds
        case percentDone
        case targetResource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentProgress = currentProgress {
            try encodeContainer.encode(currentProgress.rawValue, forKey: .currentProgress)
        }
        if let estimatedTimeRemainingSeconds = estimatedTimeRemainingSeconds {
            try encodeContainer.encode(estimatedTimeRemainingSeconds, forKey: .estimatedTimeRemainingSeconds)
        }
        if let percentDone = percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let targetResource = targetResource {
            try encodeContainer.encode(targetResource, forKey: .targetResource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentProgressDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotDeploymentStep.self, forKey: .currentProgress)
        currentProgress = currentProgressDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let estimatedTimeRemainingSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingSeconds)
        estimatedTimeRemainingSeconds = estimatedTimeRemainingSecondsDecoded
        let targetResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
    }
}

extension RoboMakerClientTypes.ProgressDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProgressDetail(currentProgress: \(Swift.String(describing: currentProgress)), estimatedTimeRemainingSeconds: \(Swift.String(describing: estimatedTimeRemainingSeconds)), percentDone: \(Swift.String(describing: percentDone)), targetResource: \(Swift.String(describing: targetResource)))"}
}

extension RoboMakerClientTypes {
    /// Information about the progress of a deployment job.
    public struct ProgressDetail: Swift.Equatable {
        /// The current progress status.
        ///
        ///             Validating
        ///
        ///                Validating the deployment.
        ///
        ///             DownloadingExtracting
        ///
        ///                Downloading and extracting the bundle on the robot.
        ///
        ///             ExecutingPreLaunch
        ///
        ///                Executing pre-launch script(s) if provided.
        ///
        ///             Launching
        ///
        ///                Launching the robot application.
        ///
        ///             ExecutingPostLaunch
        ///
        ///                Executing post-launch script(s) if provided.
        ///
        ///             Finished
        ///
        ///                Deployment is complete.
        ///
        ///
        public var currentProgress: RoboMakerClientTypes.RobotDeploymentStep?
        /// Estimated amount of time in seconds remaining in the step. This currently only applies
        ///          to the Downloading/Extracting step of the deployment. It is empty for other
        ///          steps.
        public var estimatedTimeRemainingSeconds: Swift.Int?
        /// Precentage of the step that is done. This currently only applies to the
        ///             Downloading/Extracting step of the deployment. It is empty for other
        ///          steps.
        public var percentDone: Swift.Float?
        /// The Amazon Resource Name (ARN) of the deployment job.
        public var targetResource: Swift.String?

        public init (
            currentProgress: RoboMakerClientTypes.RobotDeploymentStep? = nil,
            estimatedTimeRemainingSeconds: Swift.Int? = nil,
            percentDone: Swift.Float? = nil,
            targetResource: Swift.String? = nil
        )
        {
            self.currentProgress = currentProgress
            self.estimatedTimeRemainingSeconds = estimatedTimeRemainingSeconds
            self.percentDone = percentDone
            self.targetResource = targetResource
        }
    }

}

public struct RegisterRobotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterRobotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterRobotOutputError>
}

extension RegisterRobotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterRobotInput(fleet: \(Swift.String(describing: fleet)), robot: \(Swift.String(describing: robot)))"}
}

extension RegisterRobotInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let robot = robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

public struct RegisterRobotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterRobotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterRobotOutputError>
}

public struct RegisterRobotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterRobotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterRobotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterRobotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterRobotOutputError>
}

public struct RegisterRobotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterRobotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RegisterRobotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/registerRobot"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterRobotInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterRobotOutputError>
}

public struct RegisterRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init (
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct RegisterRobotInputBody: Swift.Equatable {
    public let fleet: Swift.String?
    public let robot: Swift.String?
}

extension RegisterRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension RegisterRobotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterRobotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterRobotOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterRobotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterRobotOutputResponse(fleet: \(Swift.String(describing: fleet)), robot: \(Swift.String(describing: robot)))"}
}

extension RegisterRobotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterRobotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
            self.robot = output.robot
        } else {
            self.fleet = nil
            self.robot = nil
        }
    }
}

public struct RegisterRobotOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet that the robot will join.
    public var fleet: Swift.String?
    /// Information about the robot registration.
    public var robot: Swift.String?

    public init (
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct RegisterRobotOutputResponseBody: Swift.Equatable {
    public let fleet: Swift.String?
    public let robot: Swift.String?
}

extension RegisterRobotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension RoboMakerClientTypes.RenderingEngine: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngineType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes.RenderingEngine: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RenderingEngine(name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension RoboMakerClientTypes {
    /// Information about a rendering engine.
    public struct RenderingEngine: Swift.Equatable {
        /// The name of the rendering engine.
        public var name: RoboMakerClientTypes.RenderingEngineType?
        /// The version of the rendering engine.
        public var version: Swift.String?

        public init (
            name: RoboMakerClientTypes.RenderingEngineType? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {
    public enum RenderingEngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ogre
        case sdkUnknown(Swift.String)

        public static var allCases: [RenderingEngineType] {
            return [
                .ogre,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ogre: return "OGRE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RenderingEngineType(rawValue: rawValue) ?? RenderingEngineType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestartSimulationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestartSimulationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestartSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestartSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestartSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestartSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestartSimulationJobOutputError>
}

extension RestartSimulationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestartSimulationJobInput(job: \(Swift.String(describing: job)))"}
}

extension RestartSimulationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct RestartSimulationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestartSimulationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestartSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestartSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestartSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestartSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestartSimulationJobOutputError>
}

public struct RestartSimulationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestartSimulationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestartSimulationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestartSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestartSimulationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestartSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestartSimulationJobOutputError>
}

public struct RestartSimulationJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestartSimulationJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RestartSimulationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestartSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/restartSimulationJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestartSimulationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestartSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestartSimulationJobOutputError>
}

public struct RestartSimulationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct RestartSimulationJobInputBody: Swift.Equatable {
    public let job: Swift.String?
}

extension RestartSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension RestartSimulationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestartSimulationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestartSimulationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestartSimulationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestartSimulationJobOutputResponse()"}
}

extension RestartSimulationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RestartSimulationJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct RestartSimulationJobOutputResponseBody: Swift.Equatable {
}

extension RestartSimulationJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RoboMakerClientTypes.Robot: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case arn
        case createdAt
        case fleetArn
        case greenGrassGroupId
        case lastDeploymentJob
        case lastDeploymentTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let greenGrassGroupId = greenGrassGroupId {
            try encodeContainer.encode(greenGrassGroupId, forKey: .greenGrassGroupId)
        }
        if let lastDeploymentJob = lastDeploymentJob {
            try encodeContainer.encode(lastDeploymentJob, forKey: .lastDeploymentJob)
        }
        if let lastDeploymentTime = lastDeploymentTime {
            try encodeContainer.encode(lastDeploymentTime.timeIntervalSince1970, forKey: .lastDeploymentTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotStatus.self, forKey: .status)
        status = statusDecoded
        let greenGrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greenGrassGroupId)
        greenGrassGroupId = greenGrassGroupIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
    }
}

extension RoboMakerClientTypes.Robot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Robot(architecture: \(Swift.String(describing: architecture)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), fleetArn: \(Swift.String(describing: fleetArn)), greenGrassGroupId: \(Swift.String(describing: greenGrassGroupId)), lastDeploymentJob: \(Swift.String(describing: lastDeploymentJob)), lastDeploymentTime: \(Swift.String(describing: lastDeploymentTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension RoboMakerClientTypes {
    /// Information about a robot.
    public struct Robot: Swift.Equatable {
        /// The architecture of the robot.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// The Amazon Resource Name (ARN) of the robot.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the robot was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleetArn: Swift.String?
        /// The Greengrass group associated with the robot.
        public var greenGrassGroupId: Swift.String?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public var lastDeploymentJob: Swift.String?
        /// The time of the last deployment.
        public var lastDeploymentTime: ClientRuntime.Date?
        /// The name of the robot.
        public var name: Swift.String?
        /// The status of the robot.
        public var status: RoboMakerClientTypes.RobotStatus?

        public init (
            architecture: RoboMakerClientTypes.Architecture? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            fleetArn: Swift.String? = nil,
            greenGrassGroupId: Swift.String? = nil,
            lastDeploymentJob: Swift.String? = nil,
            lastDeploymentTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: RoboMakerClientTypes.RobotStatus? = nil
        )
        {
            self.architecture = architecture
            self.arn = arn
            self.createdAt = createdAt
            self.fleetArn = fleetArn
            self.greenGrassGroupId = greenGrassGroupId
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
            self.status = status
        }
    }

}

extension RoboMakerClientTypes.RobotApplicationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
        case launchConfig
        case tools
        case uploadConfigurations
        case useDefaultTools
        case useDefaultUploadConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
        if let tools = tools {
            var toolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tools)
            for tools0 in tools {
                try toolsContainer.encode(tools0)
            }
        }
        if let uploadConfigurations = uploadConfigurations {
            var uploadConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .uploadConfigurations)
            for uploadconfigurations0 in uploadConfigurations {
                try uploadConfigurationsContainer.encode(uploadconfigurations0)
            }
        }
        if let useDefaultTools = useDefaultTools {
            try encodeContainer.encode(useDefaultTools, forKey: .useDefaultTools)
        }
        if let useDefaultUploadConfigurations = useDefaultUploadConfigurations {
            try encodeContainer.encode(useDefaultUploadConfigurations, forKey: .useDefaultUploadConfigurations)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
        let uploadConfigurationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.UploadConfiguration?].self, forKey: .uploadConfigurations)
        var uploadConfigurationsDecoded0:[RoboMakerClientTypes.UploadConfiguration]? = nil
        if let uploadConfigurationsContainer = uploadConfigurationsContainer {
            uploadConfigurationsDecoded0 = [RoboMakerClientTypes.UploadConfiguration]()
            for structure0 in uploadConfigurationsContainer {
                if let structure0 = structure0 {
                    uploadConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        uploadConfigurations = uploadConfigurationsDecoded0
        let useDefaultUploadConfigurationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultUploadConfigurations)
        useDefaultUploadConfigurations = useDefaultUploadConfigurationsDecoded
        let toolsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[RoboMakerClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [RoboMakerClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let useDefaultToolsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultTools)
        useDefaultTools = useDefaultToolsDecoded
    }
}

extension RoboMakerClientTypes.RobotApplicationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RobotApplicationConfig(application: \(Swift.String(describing: application)), applicationVersion: \(Swift.String(describing: applicationVersion)), launchConfig: \(Swift.String(describing: launchConfig)), tools: \(Swift.String(describing: tools)), uploadConfigurations: \(Swift.String(describing: uploadConfigurations)), useDefaultTools: \(Swift.String(describing: useDefaultTools)), useDefaultUploadConfigurations: \(Swift.String(describing: useDefaultUploadConfigurations)))"}
}

extension RoboMakerClientTypes {
    /// Application configuration information for a robot.
    public struct RobotApplicationConfig: Swift.Equatable {
        /// The application information for the robot application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the robot application.
        public var applicationVersion: Swift.String?
        /// The launch configuration for the robot application.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.LaunchConfig?
        /// Information about tools configured for the robot application.
        public var tools: [RoboMakerClientTypes.Tool]?
        /// The upload configurations for the robot application.
        public var uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]?
        /// A Boolean indicating whether to use default robot application tools.
        ///         The default tools are rviz, rqt, terminal and rosbag record.
        ///         The default is False.
        ///
        public var useDefaultTools: Swift.Bool?
        /// A Boolean indicating whether to use default upload configurations. By default,
        ///             .ros and .gazebo files are uploaded when the application
        ///          terminates and all ROS topics will be recorded.
        ///          If you set this value, you must specify an outputLocation.
        public var useDefaultUploadConfigurations: Swift.Bool?

        public init (
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.LaunchConfig? = nil,
            tools: [RoboMakerClientTypes.Tool]? = nil,
            uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]? = nil,
            useDefaultTools: Swift.Bool? = nil,
            useDefaultUploadConfigurations: Swift.Bool? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = useDefaultTools
            self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
        }
    }

}

extension RoboMakerClientTypes.RobotApplicationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case robotSoftwareSuite
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
    }
}

extension RoboMakerClientTypes.RobotApplicationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RobotApplicationSummary(arn: \(Swift.String(describing: arn)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), version: \(Swift.String(describing: version)))"}
}

extension RoboMakerClientTypes {
    /// Summary information for a robot application.
    public struct RobotApplicationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the robot.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the robot application was last
        ///          updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the robot application.
        public var name: Swift.String?
        /// Information about a robot software suite (ROS distribution).
        public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
        /// The version of the robot application.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.version = version
        }
    }

}

extension RoboMakerClientTypes.RobotDeployment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case deploymentFinishTime
        case deploymentStartTime
        case failureCode
        case failureReason
        case progressDetail
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let deploymentFinishTime = deploymentFinishTime {
            try encodeContainer.encode(deploymentFinishTime.timeIntervalSince1970, forKey: .deploymentFinishTime)
        }
        if let deploymentStartTime = deploymentStartTime {
            try encodeContainer.encode(deploymentStartTime.timeIntervalSince1970, forKey: .deploymentStartTime)
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let progressDetail = progressDetail {
            try encodeContainer.encode(progressDetail, forKey: .progressDetail)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let deploymentStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deploymentStartTime)
        deploymentStartTime = deploymentStartTimeDecoded
        let deploymentFinishTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deploymentFinishTime)
        deploymentFinishTime = deploymentFinishTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotStatus.self, forKey: .status)
        status = statusDecoded
        let progressDetailDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ProgressDetail.self, forKey: .progressDetail)
        progressDetail = progressDetailDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension RoboMakerClientTypes.RobotDeployment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RobotDeployment(arn: \(Swift.String(describing: arn)), deploymentFinishTime: \(Swift.String(describing: deploymentFinishTime)), deploymentStartTime: \(Swift.String(describing: deploymentStartTime)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), progressDetail: \(Swift.String(describing: progressDetail)), status: \(Swift.String(describing: status)))"}
}

extension RoboMakerClientTypes {
    /// Information about a robot deployment.
    public struct RobotDeployment: Swift.Equatable {
        /// The robot deployment Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the deployment finished.
        public var deploymentFinishTime: ClientRuntime.Date?
        /// The time, in milliseconds since the epoch, when the deployment was started.
        public var deploymentStartTime: ClientRuntime.Date?
        /// The robot deployment failure code.
        public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
        /// A short description of the reason why the robot deployment failed.
        public var failureReason: Swift.String?
        /// Information about how the deployment is progressing.
        public var progressDetail: RoboMakerClientTypes.ProgressDetail?
        /// The status of the robot deployment.
        public var status: RoboMakerClientTypes.RobotStatus?

        public init (
            arn: Swift.String? = nil,
            deploymentFinishTime: ClientRuntime.Date? = nil,
            deploymentStartTime: ClientRuntime.Date? = nil,
            failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            progressDetail: RoboMakerClientTypes.ProgressDetail? = nil,
            status: RoboMakerClientTypes.RobotStatus? = nil
        )
        {
            self.arn = arn
            self.deploymentFinishTime = deploymentFinishTime
            self.deploymentStartTime = deploymentStartTime
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.progressDetail = progressDetail
            self.status = status
        }
    }

}

extension RoboMakerClientTypes {
    public enum RobotDeploymentStep: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case downloadingextractingstep
        case executingdownloadcondition
        case finishedstep
        case launchingstep
        case postlaunchstep
        case prelaunchstep
        case validatingstep
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotDeploymentStep] {
            return [
                .downloadingextractingstep,
                .executingdownloadcondition,
                .finishedstep,
                .launchingstep,
                .postlaunchstep,
                .prelaunchstep,
                .validatingstep,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .downloadingextractingstep: return "DownloadingExtracting"
            case .executingdownloadcondition: return "ExecutingDownloadCondition"
            case .finishedstep: return "Finished"
            case .launchingstep: return "Launching"
            case .postlaunchstep: return "ExecutingPostLaunch"
            case .prelaunchstep: return "ExecutingPreLaunch"
            case .validatingstep: return "Validating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotDeploymentStep(rawValue: rawValue) ?? RobotDeploymentStep.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.RobotSoftwareSuite: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version.rawValue, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuiteType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuiteVersionType.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes.RobotSoftwareSuite: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RobotSoftwareSuite(name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension RoboMakerClientTypes {
    /// Information about a robot software suite (ROS distribution).
    public struct RobotSoftwareSuite: Swift.Equatable {
        /// The name of the robot software suite (ROS distribution).
        public var name: RoboMakerClientTypes.RobotSoftwareSuiteType?
        /// The version of the robot software suite (ROS distribution).
        public var version: RoboMakerClientTypes.RobotSoftwareSuiteVersionType?

        public init (
            name: RoboMakerClientTypes.RobotSoftwareSuiteType? = nil,
            version: RoboMakerClientTypes.RobotSoftwareSuiteVersionType? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {
    public enum RobotSoftwareSuiteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ros
        case ros2
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotSoftwareSuiteType] {
            return [
                .ros,
                .ros2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ros: return "ROS"
            case .ros2: return "ROS2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotSoftwareSuiteType(rawValue: rawValue) ?? RobotSoftwareSuiteType.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum RobotSoftwareSuiteVersionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dashing
        case foxy
        case kinetic
        case melodic
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotSoftwareSuiteVersionType] {
            return [
                .dashing,
                .foxy,
                .kinetic,
                .melodic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dashing: return "Dashing"
            case .foxy: return "Foxy"
            case .kinetic: return "Kinetic"
            case .melodic: return "Melodic"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotSoftwareSuiteVersionType(rawValue: rawValue) ?? RobotSoftwareSuiteVersionType.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum RobotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deploying
        case failed
        case insync
        case noresponse
        case pendingnewdeployment
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotStatus] {
            return [
                .available,
                .deploying,
                .failed,
                .insync,
                .noresponse,
                .pendingnewdeployment,
                .registered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .deploying: return "Deploying"
            case .failed: return "Failed"
            case .insync: return "InSync"
            case .noresponse: return "NoResponse"
            case .pendingnewdeployment: return "PendingNewDeployment"
            case .registered: return "Registered"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotStatus(rawValue: rawValue) ?? RobotStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.S3KeyOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case etag
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let etag = etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension RoboMakerClientTypes.S3KeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3KeyOutput(etag: \(Swift.String(describing: etag)), s3Key: \(Swift.String(describing: s3Key)))"}
}

extension RoboMakerClientTypes {
    /// Information about S3 keys.
    public struct S3KeyOutput: Swift.Equatable {
        /// The etag for the object.
        public var etag: Swift.String?
        /// The S3 key.
        public var s3Key: Swift.String?

        public init (
            etag: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.etag = etag
            self.s3Key = s3Key
        }
    }

}

extension RoboMakerClientTypes.S3Object: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case etag
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let etag = etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension RoboMakerClientTypes.S3Object: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Object(bucket: \(Swift.String(describing: bucket)), etag: \(Swift.String(describing: etag)), key: \(Swift.String(describing: key)))"}
}

extension RoboMakerClientTypes {
    /// Information about an S3 object.
    public struct S3Object: Swift.Equatable {
        /// The bucket containing the object.
        /// This member is required.
        public var bucket: Swift.String?
        /// The etag of the object.
        public var etag: Swift.String?
        /// The key of the object.
        /// This member is required.
        public var key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            etag: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.etag = etag
            self.key = key
        }
    }

}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed due to a temporary failure of the server.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoboMakerClientTypes.SimulationApplicationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
        case launchConfig
        case tools
        case uploadConfigurations
        case useDefaultTools
        case useDefaultUploadConfigurations
        case worldConfigs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
        if let tools = tools {
            var toolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tools)
            for tools0 in tools {
                try toolsContainer.encode(tools0)
            }
        }
        if let uploadConfigurations = uploadConfigurations {
            var uploadConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .uploadConfigurations)
            for uploadconfigurations0 in uploadConfigurations {
                try uploadConfigurationsContainer.encode(uploadconfigurations0)
            }
        }
        if let useDefaultTools = useDefaultTools {
            try encodeContainer.encode(useDefaultTools, forKey: .useDefaultTools)
        }
        if let useDefaultUploadConfigurations = useDefaultUploadConfigurations {
            try encodeContainer.encode(useDefaultUploadConfigurations, forKey: .useDefaultUploadConfigurations)
        }
        if let worldConfigs = worldConfigs {
            var worldConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worldConfigs)
            for worldconfigs0 in worldConfigs {
                try worldConfigsContainer.encode(worldconfigs0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
        let uploadConfigurationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.UploadConfiguration?].self, forKey: .uploadConfigurations)
        var uploadConfigurationsDecoded0:[RoboMakerClientTypes.UploadConfiguration]? = nil
        if let uploadConfigurationsContainer = uploadConfigurationsContainer {
            uploadConfigurationsDecoded0 = [RoboMakerClientTypes.UploadConfiguration]()
            for structure0 in uploadConfigurationsContainer {
                if let structure0 = structure0 {
                    uploadConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        uploadConfigurations = uploadConfigurationsDecoded0
        let worldConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldConfig?].self, forKey: .worldConfigs)
        var worldConfigsDecoded0:[RoboMakerClientTypes.WorldConfig]? = nil
        if let worldConfigsContainer = worldConfigsContainer {
            worldConfigsDecoded0 = [RoboMakerClientTypes.WorldConfig]()
            for structure0 in worldConfigsContainer {
                if let structure0 = structure0 {
                    worldConfigsDecoded0?.append(structure0)
                }
            }
        }
        worldConfigs = worldConfigsDecoded0
        let useDefaultUploadConfigurationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultUploadConfigurations)
        useDefaultUploadConfigurations = useDefaultUploadConfigurationsDecoded
        let toolsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[RoboMakerClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [RoboMakerClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let useDefaultToolsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultTools)
        useDefaultTools = useDefaultToolsDecoded
    }
}

extension RoboMakerClientTypes.SimulationApplicationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SimulationApplicationConfig(application: \(Swift.String(describing: application)), applicationVersion: \(Swift.String(describing: applicationVersion)), launchConfig: \(Swift.String(describing: launchConfig)), tools: \(Swift.String(describing: tools)), uploadConfigurations: \(Swift.String(describing: uploadConfigurations)), useDefaultTools: \(Swift.String(describing: useDefaultTools)), useDefaultUploadConfigurations: \(Swift.String(describing: useDefaultUploadConfigurations)), worldConfigs: \(Swift.String(describing: worldConfigs)))"}
}

extension RoboMakerClientTypes {
    /// Information about a simulation application configuration.
    public struct SimulationApplicationConfig: Swift.Equatable {
        /// The application information for the simulation application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the simulation application.
        public var applicationVersion: Swift.String?
        /// The launch configuration for the simulation application.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.LaunchConfig?
        /// Information about tools configured for the simulation application.
        public var tools: [RoboMakerClientTypes.Tool]?
        /// Information about upload configurations for the simulation application.
        public var uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]?
        /// A Boolean indicating whether to use default simulation application tools.
        ///         The default tools are rviz, rqt, terminal and rosbag record.
        ///         The default is False.
        ///
        public var useDefaultTools: Swift.Bool?
        /// A Boolean indicating whether to use default upload configurations. By default,
        ///             .ros and .gazebo files are uploaded when the application
        ///          terminates and all ROS topics will be recorded.
        ///          If you set this value, you must specify an outputLocation.
        public var useDefaultUploadConfigurations: Swift.Bool?
        /// A list of world configurations.
        public var worldConfigs: [RoboMakerClientTypes.WorldConfig]?

        public init (
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.LaunchConfig? = nil,
            tools: [RoboMakerClientTypes.Tool]? = nil,
            uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]? = nil,
            useDefaultTools: Swift.Bool? = nil,
            useDefaultUploadConfigurations: Swift.Bool? = nil,
            worldConfigs: [RoboMakerClientTypes.WorldConfig]? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = useDefaultTools
            self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
            self.worldConfigs = worldConfigs
        }
    }

}

extension RoboMakerClientTypes.SimulationApplicationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
    }
}

extension RoboMakerClientTypes.SimulationApplicationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SimulationApplicationSummary(arn: \(Swift.String(describing: arn)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(Swift.String(describing: simulationSoftwareSuite)), version: \(Swift.String(describing: version)))"}
}

extension RoboMakerClientTypes {
    /// Summary information for a simulation application.
    public struct SimulationApplicationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation application.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation application was last
        ///          updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the simulation application.
        public var name: Swift.String?
        /// Information about a robot software suite (ROS distribution).
        public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
        /// Information about a simulation software suite.
        public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
        /// The version of the simulation application.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
            simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.version = version
        }
    }

}

extension RoboMakerClientTypes.SimulationJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case failureReason
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case name
        case networkInterface
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let compute = compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasources0 in dataSources {
                try dataSourcesContainer.encode(datasources0)
            }
        }
        if let failureBehavior = failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let lastStartedAt = lastStartedAt {
            try encodeContainer.encode(lastStartedAt.timeIntervalSince1970, forKey: .lastStartedAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let loggingConfig = loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterface = networkInterface {
            try encodeContainer.encode(networkInterface, forKey: .networkInterface)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfigs0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfigs0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfigs0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfigs0)
            }
        }
        if simulationTimeMillis != 0 {
            try encodeContainer.encode(simulationTimeMillis, forKey: .simulationTimeMillis)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .simulationTimeMillis)
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension RoboMakerClientTypes.SimulationJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SimulationJob(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), compute: \(Swift.String(describing: compute)), dataSources: \(Swift.String(describing: dataSources)), failureBehavior: \(Swift.String(describing: failureBehavior)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), iamRole: \(Swift.String(describing: iamRole)), lastStartedAt: \(Swift.String(describing: lastStartedAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), loggingConfig: \(Swift.String(describing: loggingConfig)), maxJobDurationInSeconds: \(Swift.String(describing: maxJobDurationInSeconds)), name: \(Swift.String(describing: name)), networkInterface: \(Swift.String(describing: networkInterface)), outputLocation: \(Swift.String(describing: outputLocation)), robotApplications: \(Swift.String(describing: robotApplications)), simulationApplications: \(Swift.String(describing: simulationApplications)), simulationTimeMillis: \(Swift.String(describing: simulationTimeMillis)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension RoboMakerClientTypes {
    /// Information about a simulation job.
    public struct SimulationJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public var arn: Swift.String?
        /// A unique identifier for this SimulationJob request.
        public var clientRequestToken: Swift.String?
        /// Compute information for the simulation job
        public var compute: RoboMakerClientTypes.ComputeResponse?
        /// The data sources for the simulation job.
        public var dataSources: [RoboMakerClientTypes.DataSource]?
        /// The failure behavior the simulation job.
        ///
        ///             Continue
        ///
        ///                Leaves the host running for its maximum timeout duration after a 4XX error code.
        ///
        ///             Fail
        ///
        ///                Stop the simulation job and terminate the instance.
        ///
        ///
        public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
        /// The failure code of the simulation job if it failed.
        public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
        /// The reason why the simulation job failed.
        public var failureReason: Swift.String?
        /// The IAM role that allows the simulation instance to call the AWS APIs that are specified
        ///          in its associated policies on your behalf. This is how credentials are passed in to your
        ///          simulation job.
        public var iamRole: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation job was last
        ///          started.
        public var lastStartedAt: ClientRuntime.Date?
        /// The time, in milliseconds since the epoch, when the simulation job was last
        ///          updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The logging configuration.
        public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
        /// The maximum simulation job duration in seconds. The value must be 8 days (691,200
        ///          seconds) or less.
        public var maxJobDurationInSeconds: Swift.Int
        /// The name of the simulation job.
        public var name: Swift.String?
        /// Information about a network interface.
        public var networkInterface: RoboMakerClientTypes.NetworkInterface?
        /// Location for output files generated by the simulation job.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// A list of robot applications.
        public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
        /// A list of simulation applications.
        public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
        /// The simulation job execution duration in milliseconds.
        public var simulationTimeMillis: Swift.Int
        /// Status of the simulation job.
        public var status: RoboMakerClientTypes.SimulationJobStatus?
        /// A map that contains tag keys and tag values that are attached to the simulation
        ///          job.
        public var tags: [Swift.String:Swift.String]?
        /// VPC configuration information.
        public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

        public init (
            arn: Swift.String? = nil,
            clientRequestToken: Swift.String? = nil,
            compute: RoboMakerClientTypes.ComputeResponse? = nil,
            dataSources: [RoboMakerClientTypes.DataSource]? = nil,
            failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
            failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            iamRole: Swift.String? = nil,
            lastStartedAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
            maxJobDurationInSeconds: Swift.Int = 0,
            name: Swift.String? = nil,
            networkInterface: RoboMakerClientTypes.NetworkInterface? = nil,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
            simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
            simulationTimeMillis: Swift.Int = 0,
            status: RoboMakerClientTypes.SimulationJobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
        )
        {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.iamRole = iamRole
            self.lastStartedAt = lastStartedAt
            self.lastUpdatedAt = lastUpdatedAt
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.name = name
            self.networkInterface = networkInterface
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.simulationTimeMillis = simulationTimeMillis
            self.status = status
            self.tags = tags
            self.vpcConfig = vpcConfig
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationJobBatchErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalserviceerror
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobBatchErrorCode] {
            return [
                .internalserviceerror,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalserviceerror: return "InternalServiceError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobBatchErrorCode(rawValue: rawValue) ?? SimulationJobBatchErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum SimulationJobBatchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case completing
        case failed
        case inprogress
        case pending
        case timedout
        case timingout
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobBatchStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .completing,
                .failed,
                .inprogress,
                .pending,
                .timedout,
                .timingout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .completing: return "Completing"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .timedout: return "TimedOut"
            case .timingout: return "TimingOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobBatchStatus(rawValue: rawValue) ?? SimulationJobBatchStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.SimulationJobBatchSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdRequestCount
        case failedRequestCount
        case lastUpdatedAt
        case pendingRequestCount
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if createdRequestCount != 0 {
            try encodeContainer.encode(createdRequestCount, forKey: .createdRequestCount)
        }
        if failedRequestCount != 0 {
            try encodeContainer.encode(failedRequestCount, forKey: .failedRequestCount)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if pendingRequestCount != 0 {
            try encodeContainer.encode(pendingRequestCount, forKey: .pendingRequestCount)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let failedRequestCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .failedRequestCount)
        failedRequestCount = failedRequestCountDecoded
        let pendingRequestCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .pendingRequestCount)
        pendingRequestCount = pendingRequestCountDecoded
        let createdRequestCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .createdRequestCount)
        createdRequestCount = createdRequestCountDecoded
    }
}

extension RoboMakerClientTypes.SimulationJobBatchSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SimulationJobBatchSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), createdRequestCount: \(Swift.String(describing: createdRequestCount)), failedRequestCount: \(Swift.String(describing: failedRequestCount)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), pendingRequestCount: \(Swift.String(describing: pendingRequestCount)), status: \(Swift.String(describing: status)))"}
}

extension RoboMakerClientTypes {
    /// Information about a simulation job batch.
    public struct SimulationJobBatchSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation job batch was
        ///          created.
        public var createdAt: ClientRuntime.Date?
        /// The number of created simulation job requests.
        public var createdRequestCount: Swift.Int
        /// The number of failed simulation job requests.
        public var failedRequestCount: Swift.Int
        /// The time, in milliseconds since the epoch, when the simulation job batch was last
        ///          updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The number of pending simulation job requests.
        public var pendingRequestCount: Swift.Int
        /// The status of the simulation job batch.
        ///
        ///             Pending
        ///
        ///                The simulation job batch request is pending.
        ///
        ///             InProgress
        ///
        ///                The simulation job batch is in progress.
        ///
        ///             Failed
        ///
        ///                The simulation job batch failed. One or more simulation job requests could not
        ///                   be completed due to an internal failure (like InternalServiceError).
        ///                   See failureCode and failureReason for more
        ///                   information.
        ///
        ///             Completed
        ///
        ///                The simulation batch job completed. A batch is complete when (1) there are no
        ///                   pending simulation job requests in the batch and none of the failed simulation job
        ///                   requests are due to InternalServiceError and (2) when all created
        ///                   simulation jobs have reached a terminal state (for example, Completed
        ///                   or Failed).
        ///
        ///             Canceled
        ///
        ///                The simulation batch job was cancelled.
        ///
        ///             Canceling
        ///
        ///                The simulation batch job is being cancelled.
        ///
        ///             Completing
        ///
        ///                The simulation batch job is completing.
        ///
        ///             TimingOut
        ///
        ///                The simulation job batch is timing out.
        ///                If a batch timing out, and there are pending requests that were failing due to
        ///                   an internal failure (like InternalServiceError), the batch status
        ///                   will be Failed. If there are no such failing request, the batch
        ///                   status will be TimedOut.
        ///
        ///             TimedOut
        ///
        ///                The simulation batch job timed out.
        ///
        ///
        public var status: RoboMakerClientTypes.SimulationJobBatchStatus?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdRequestCount: Swift.Int = 0,
            failedRequestCount: Swift.Int = 0,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            pendingRequestCount: Swift.Int = 0,
            status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdRequestCount = createdRequestCount
            self.failedRequestCount = failedRequestCount
            self.lastUpdatedAt = lastUpdatedAt
            self.pendingRequestCount = pendingRequestCount
            self.status = status
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badpermissionscloudwatchlogs
        case badpermissionsrobotapplication
        case badpermissionss3object
        case badpermissionss3output
        case badpermissionssimulationapplication
        case badpermissionsusercredentials
        case batchcanceled
        case batchtimedout
        case enilimitexceeded
        case internalserviceerror
        case invalidbundlerobotapplication
        case invalidbundlesimulationapplication
        case invalidinput
        case invalids3resource
        case limitexceeded
        case mismatchedetag
        case requestthrottled
        case resourcenotfound
        case robotapplicationcrash
        case robotapplicationhealthcheckfailure
        case robotapplicationversionmismatchedetag
        case simulationapplicationcrash
        case simulationapplicationhealthcheckfailure
        case simulationapplicationversionmismatchedetag
        case subnetiplimitexceeded
        case throttlingerror
        case uploadcontentmismatcherror
        case wrongregionrobotapplication
        case wrongregions3bucket
        case wrongregions3output
        case wrongregionsimulationapplication
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobErrorCode] {
            return [
                .badpermissionscloudwatchlogs,
                .badpermissionsrobotapplication,
                .badpermissionss3object,
                .badpermissionss3output,
                .badpermissionssimulationapplication,
                .badpermissionsusercredentials,
                .batchcanceled,
                .batchtimedout,
                .enilimitexceeded,
                .internalserviceerror,
                .invalidbundlerobotapplication,
                .invalidbundlesimulationapplication,
                .invalidinput,
                .invalids3resource,
                .limitexceeded,
                .mismatchedetag,
                .requestthrottled,
                .resourcenotfound,
                .robotapplicationcrash,
                .robotapplicationhealthcheckfailure,
                .robotapplicationversionmismatchedetag,
                .simulationapplicationcrash,
                .simulationapplicationhealthcheckfailure,
                .simulationapplicationversionmismatchedetag,
                .subnetiplimitexceeded,
                .throttlingerror,
                .uploadcontentmismatcherror,
                .wrongregionrobotapplication,
                .wrongregions3bucket,
                .wrongregions3output,
                .wrongregionsimulationapplication,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badpermissionscloudwatchlogs: return "BadPermissionsCloudwatchLogs"
            case .badpermissionsrobotapplication: return "BadPermissionsRobotApplication"
            case .badpermissionss3object: return "BadPermissionsS3Object"
            case .badpermissionss3output: return "BadPermissionsS3Output"
            case .badpermissionssimulationapplication: return "BadPermissionsSimulationApplication"
            case .badpermissionsusercredentials: return "BadPermissionsUserCredentials"
            case .batchcanceled: return "BatchCanceled"
            case .batchtimedout: return "BatchTimedOut"
            case .enilimitexceeded: return "ENILimitExceeded"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidbundlerobotapplication: return "InvalidBundleRobotApplication"
            case .invalidbundlesimulationapplication: return "InvalidBundleSimulationApplication"
            case .invalidinput: return "InvalidInput"
            case .invalids3resource: return "InvalidS3Resource"
            case .limitexceeded: return "LimitExceeded"
            case .mismatchedetag: return "MismatchedEtag"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case .robotapplicationcrash: return "RobotApplicationCrash"
            case .robotapplicationhealthcheckfailure: return "RobotApplicationHealthCheckFailure"
            case .robotapplicationversionmismatchedetag: return "RobotApplicationVersionMismatchedEtag"
            case .simulationapplicationcrash: return "SimulationApplicationCrash"
            case .simulationapplicationhealthcheckfailure: return "SimulationApplicationHealthCheckFailure"
            case .simulationapplicationversionmismatchedetag: return "SimulationApplicationVersionMismatchedEtag"
            case .subnetiplimitexceeded: return "SubnetIpLimitExceeded"
            case .throttlingerror: return "ThrottlingError"
            case .uploadcontentmismatcherror: return "UploadContentMismatchError"
            case .wrongregionrobotapplication: return "WrongRegionRobotApplication"
            case .wrongregions3bucket: return "WrongRegionS3Bucket"
            case .wrongregions3output: return "WrongRegionS3Output"
            case .wrongregionsimulationapplication: return "WrongRegionSimulationApplication"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobErrorCode(rawValue: rawValue) ?? SimulationJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.SimulationJobRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case useDefaultApplications
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compute = compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourceconfigs0 in dataSources {
                try dataSourcesContainer.encode(datasourceconfigs0)
            }
        }
        if let failureBehavior = failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let loggingConfig = loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfigs0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfigs0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfigs0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfigs0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDefaultApplications = useDefaultApplications {
            try encodeContainer.encode(useDefaultApplications, forKey: .useDefaultApplications)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let useDefaultApplicationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultApplications)
        useDefaultApplications = useDefaultApplicationsDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSourceConfig?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSourceConfig]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSourceConfig]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Compute.self, forKey: .compute)
        compute = computeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RoboMakerClientTypes.SimulationJobRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SimulationJobRequest(compute: \(Swift.String(describing: compute)), dataSources: \(Swift.String(describing: dataSources)), failureBehavior: \(Swift.String(describing: failureBehavior)), iamRole: \(Swift.String(describing: iamRole)), loggingConfig: \(Swift.String(describing: loggingConfig)), maxJobDurationInSeconds: \(Swift.String(describing: maxJobDurationInSeconds)), outputLocation: \(Swift.String(describing: outputLocation)), robotApplications: \(Swift.String(describing: robotApplications)), simulationApplications: \(Swift.String(describing: simulationApplications)), tags: \(Swift.String(describing: tags)), useDefaultApplications: \(Swift.String(describing: useDefaultApplications)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension RoboMakerClientTypes {
    /// Information about a simulation job request.
    public struct SimulationJobRequest: Swift.Equatable {
        /// Compute information for the simulation job
        public var compute: RoboMakerClientTypes.Compute?
        /// Specify data sources to mount read-only files from S3 into your simulation. These files
        ///          are available under /opt/robomaker/datasources/data_source_name.
        ///
        ///             There is a limit of 100 files and a combined size of 25GB for all
        ///                DataSourceConfig objects.
        ///
        public var dataSources: [RoboMakerClientTypes.DataSourceConfig]?
        /// The failure behavior the simulation job.
        ///
        ///             Continue
        ///
        ///                Leaves the host running for its maximum timeout duration after a 4XX error code.
        ///
        ///             Fail
        ///
        ///                Stop the simulation job and terminate the instance.
        ///
        ///
        public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
        /// The IAM role name that allows the simulation instance to call the AWS APIs that are
        ///          specified in its associated policies on your behalf. This is how credentials are passed in
        ///          to your simulation job.
        public var iamRole: Swift.String?
        /// The logging configuration.
        public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
        /// The maximum simulation job duration in seconds. The value must be 8 days (691,200
        ///          seconds) or less.
        /// This member is required.
        public var maxJobDurationInSeconds: Swift.Int
        /// The output location.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// The robot applications to use in the simulation job.
        public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
        /// The simulation applications to use in the simulation job.
        public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
        /// A map that contains tag keys and tag values that are attached to the simulation job
        ///          request.
        public var tags: [Swift.String:Swift.String]?
        /// A Boolean indicating whether to use default applications in the simulation job. Default
        ///          applications include Gazebo, rqt, rviz and terminal access.
        public var useDefaultApplications: Swift.Bool?
        /// If your simulation job accesses resources in a VPC, you provide this parameter
        ///          identifying the list of security group IDs and subnet IDs. These must belong to the same
        ///          VPC. You must provide at least one security group and two subnet IDs.
        public var vpcConfig: RoboMakerClientTypes.VPCConfig?

        public init (
            compute: RoboMakerClientTypes.Compute? = nil,
            dataSources: [RoboMakerClientTypes.DataSourceConfig]? = nil,
            failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
            iamRole: Swift.String? = nil,
            loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
            maxJobDurationInSeconds: Swift.Int = 0,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
            simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            useDefaultApplications: Swift.Bool? = nil,
            vpcConfig: RoboMakerClientTypes.VPCConfig? = nil
        )
        {
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.iamRole = iamRole
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.tags = tags
            self.useDefaultApplications = useDefaultApplications
            self.vpcConfig = vpcConfig
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case pending
        case preparing
        case restarting
        case running
        case runningfailed
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .pending,
                .preparing,
                .restarting,
                .running,
                .runningfailed,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .preparing: return "Preparing"
            case .restarting: return "Restarting"
            case .running: return "Running"
            case .runningfailed: return "RunningFailed"
            case .terminated: return "Terminated"
            case .terminating: return "Terminating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobStatus(rawValue: rawValue) ?? SimulationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.SimulationJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataSourceNames
        case lastUpdatedAt
        case name
        case robotApplicationNames
        case simulationApplicationNames
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSourceNames = dataSourceNames {
            var dataSourceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSourceNames)
            for datasourcenames0 in dataSourceNames {
                try dataSourceNamesContainer.encode(datasourcenames0)
            }
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotApplicationNames = robotApplicationNames {
            var robotApplicationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplicationNames)
            for robotapplicationnames0 in robotApplicationNames {
                try robotApplicationNamesContainer.encode(robotapplicationnames0)
            }
        }
        if let simulationApplicationNames = simulationApplicationNames {
            var simulationApplicationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplicationNames)
            for simulationapplicationnames0 in simulationApplicationNames {
                try simulationApplicationNamesContainer.encode(simulationapplicationnames0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let simulationApplicationNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .simulationApplicationNames)
        var simulationApplicationNamesDecoded0:[Swift.String]? = nil
        if let simulationApplicationNamesContainer = simulationApplicationNamesContainer {
            simulationApplicationNamesDecoded0 = [Swift.String]()
            for string0 in simulationApplicationNamesContainer {
                if let string0 = string0 {
                    simulationApplicationNamesDecoded0?.append(string0)
                }
            }
        }
        simulationApplicationNames = simulationApplicationNamesDecoded0
        let robotApplicationNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .robotApplicationNames)
        var robotApplicationNamesDecoded0:[Swift.String]? = nil
        if let robotApplicationNamesContainer = robotApplicationNamesContainer {
            robotApplicationNamesDecoded0 = [Swift.String]()
            for string0 in robotApplicationNamesContainer {
                if let string0 = string0 {
                    robotApplicationNamesDecoded0?.append(string0)
                }
            }
        }
        robotApplicationNames = robotApplicationNamesDecoded0
        let dataSourceNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataSourceNames)
        var dataSourceNamesDecoded0:[Swift.String]? = nil
        if let dataSourceNamesContainer = dataSourceNamesContainer {
            dataSourceNamesDecoded0 = [Swift.String]()
            for string0 in dataSourceNamesContainer {
                if let string0 = string0 {
                    dataSourceNamesDecoded0?.append(string0)
                }
            }
        }
        dataSourceNames = dataSourceNamesDecoded0
    }
}

extension RoboMakerClientTypes.SimulationJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SimulationJobSummary(arn: \(Swift.String(describing: arn)), dataSourceNames: \(Swift.String(describing: dataSourceNames)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), robotApplicationNames: \(Swift.String(describing: robotApplicationNames)), simulationApplicationNames: \(Swift.String(describing: simulationApplicationNames)), status: \(Swift.String(describing: status)))"}
}

extension RoboMakerClientTypes {
    /// Summary information for a simulation job.
    public struct SimulationJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public var arn: Swift.String?
        /// The names of the data sources.
        public var dataSourceNames: [Swift.String]?
        /// The time, in milliseconds since the epoch, when the simulation job was last
        ///          updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the simulation job.
        public var name: Swift.String?
        /// A list of simulation job robot application names.
        public var robotApplicationNames: [Swift.String]?
        /// A list of simulation job simulation application names.
        public var simulationApplicationNames: [Swift.String]?
        /// The status of the simulation job.
        public var status: RoboMakerClientTypes.SimulationJobStatus?

        public init (
            arn: Swift.String? = nil,
            dataSourceNames: [Swift.String]? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            robotApplicationNames: [Swift.String]? = nil,
            simulationApplicationNames: [Swift.String]? = nil,
            status: RoboMakerClientTypes.SimulationJobStatus? = nil
        )
        {
            self.arn = arn
            self.dataSourceNames = dataSourceNames
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotApplicationNames = robotApplicationNames
            self.simulationApplicationNames = simulationApplicationNames
            self.status = status
        }
    }

}

extension RoboMakerClientTypes.SimulationSoftwareSuite: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuiteType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes.SimulationSoftwareSuite: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SimulationSoftwareSuite(name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension RoboMakerClientTypes {
    /// Information about a simulation software suite.
    public struct SimulationSoftwareSuite: Swift.Equatable {
        /// The name of the simulation software suite.
        public var name: RoboMakerClientTypes.SimulationSoftwareSuiteType?
        /// The version of the simulation software suite.
        public var version: Swift.String?

        public init (
            name: RoboMakerClientTypes.SimulationSoftwareSuiteType? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationSoftwareSuiteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gazebo
        case rosbagplay
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationSoftwareSuiteType] {
            return [
                .gazebo,
                .rosbagplay,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gazebo: return "Gazebo"
            case .rosbagplay: return "RosbagPlay"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationSoftwareSuiteType(rawValue: rawValue) ?? SimulationSoftwareSuiteType.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.Source: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case etag
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let etag = etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
    }
}

extension RoboMakerClientTypes.Source: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Source(architecture: \(Swift.String(describing: architecture)), etag: \(Swift.String(describing: etag)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)))"}
}

extension RoboMakerClientTypes {
    /// Information about a source.
    public struct Source: Swift.Equatable {
        /// The taget processor architecture for the application.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// A hash of the object specified by s3Bucket and s3Key.
        public var etag: Swift.String?
        /// The s3 bucket name.
        public var s3Bucket: Swift.String?
        /// The s3 object key.
        public var s3Key: Swift.String?

        public init (
            architecture: RoboMakerClientTypes.Architecture? = nil,
            etag: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.etag = etag
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension RoboMakerClientTypes.SourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
    }
}

extension RoboMakerClientTypes.SourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceConfig(architecture: \(Swift.String(describing: architecture)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)))"}
}

extension RoboMakerClientTypes {
    /// Information about a source configuration.
    public struct SourceConfig: Swift.Equatable {
        /// The target processor architecture for the application.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// The Amazon S3 bucket name.
        public var s3Bucket: Swift.String?
        /// The s3 object key.
        public var s3Key: Swift.String?

        public init (
            architecture: RoboMakerClientTypes.Architecture? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

public struct StartSimulationJobBatchInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSimulationJobBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSimulationJobBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSimulationJobBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSimulationJobBatchOutputError>
}

extension StartSimulationJobBatchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSimulationJobBatchInput(batchPolicy: \(Swift.String(describing: batchPolicy)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createSimulationJobRequests: \(Swift.String(describing: createSimulationJobRequests)), tags: \(Swift.String(describing: tags)))"}
}

extension StartSimulationJobBatchInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPolicy
        case clientRequestToken
        case createSimulationJobRequests
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchPolicy = batchPolicy {
            try encodeContainer.encode(batchPolicy, forKey: .batchPolicy)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let createSimulationJobRequests = createSimulationJobRequests {
            var createSimulationJobRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createSimulationJobRequests)
            for createsimulationjobrequests0 in createSimulationJobRequests {
                try createSimulationJobRequestsContainer.encode(createsimulationjobrequests0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartSimulationJobBatchInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSimulationJobBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSimulationJobBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSimulationJobBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSimulationJobBatchOutputError>
}

public struct StartSimulationJobBatchInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSimulationJobBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSimulationJobBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSimulationJobBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSimulationJobBatchOutputError>
}

public struct StartSimulationJobBatchInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSimulationJobBatchInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartSimulationJobBatchInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/startSimulationJobBatch"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartSimulationJobBatchInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSimulationJobBatchOutputError>
}

public struct StartSimulationJobBatchInput: Swift.Equatable {
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// A list of simulation job requests to create in the batch.
    /// This member is required.
    public var createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// A map that contains tag keys and tag values that are attached to the deployment job
    ///          batch.
    public var tags: [Swift.String:Swift.String]?

    public init (
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createSimulationJobRequests = createSimulationJobRequests
        self.tags = tags
    }
}

struct StartSimulationJobBatchInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let batchPolicy: RoboMakerClientTypes.BatchPolicy?
    public let createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    public let tags: [Swift.String:Swift.String]?
}

extension StartSimulationJobBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPolicy
        case clientRequestToken
        case createSimulationJobRequests
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let createSimulationJobRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobRequest?].self, forKey: .createSimulationJobRequests)
        var createSimulationJobRequestsDecoded0:[RoboMakerClientTypes.SimulationJobRequest]? = nil
        if let createSimulationJobRequestsContainer = createSimulationJobRequestsContainer {
            createSimulationJobRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobRequest]()
            for structure0 in createSimulationJobRequestsContainer {
                if let structure0 = structure0 {
                    createSimulationJobRequestsDecoded0?.append(structure0)
                }
            }
        }
        createSimulationJobRequests = createSimulationJobRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartSimulationJobBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSimulationJobBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSimulationJobBatchOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSimulationJobBatchOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSimulationJobBatchOutputResponse(arn: \(Swift.String(describing: arn)), batchPolicy: \(Swift.String(describing: batchPolicy)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdAt: \(Swift.String(describing: createdAt)), createdRequests: \(Swift.String(describing: createdRequests)), failedRequests: \(Swift.String(describing: failedRequests)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), pendingRequests: \(Swift.String(describing: pendingRequests)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension StartSimulationJobBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSimulationJobBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.batchPolicy = output.batchPolicy
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.createdRequests = output.createdRequests
            self.failedRequests = output.failedRequests
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.pendingRequests = output.pendingRequests
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.batchPolicy = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.createdRequests = nil
            self.failedRequests = nil
            self.failureCode = nil
            self.failureReason = nil
            self.pendingRequests = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct StartSimulationJobBatchOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the batch.
    public var arn: Swift.String?
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was
    ///          created.
    public var createdAt: ClientRuntime.Date?
    /// A list of created simulation job request summaries.
    public var createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    /// A list of failed simulation job requests. The request failed to be created into a
    ///          simulation job. Failed requests do not have a simulation job ID.
    public var failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    /// The failure code if the simulation job batch failed.
    public var failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    /// The reason the simulation job batch failed.
    public var failureReason: Swift.String?
    /// A list of pending simulation job requests. These requests have not yet been created into
    ///          simulation jobs.
    public var pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// The status of the simulation job batch.
    ///
    ///             Pending
    ///
    ///                The simulation job batch request is pending.
    ///
    ///             InProgress
    ///
    ///                The simulation job batch is in progress.
    ///
    ///             Failed
    ///
    ///                The simulation job batch failed. One or more simulation job requests could not
    ///                   be completed due to an internal failure (like InternalServiceError).
    ///                   See failureCode and failureReason for more
    ///                   information.
    ///
    ///             Completed
    ///
    ///                The simulation batch job completed. A batch is complete when (1) there are no
    ///                   pending simulation job requests in the batch and none of the failed simulation job
    ///                   requests are due to InternalServiceError and (2) when all created
    ///                   simulation jobs have reached a terminal state (for example, Completed
    ///                   or Failed).
    ///
    ///             Canceled
    ///
    ///                The simulation batch job was cancelled.
    ///
    ///             Canceling
    ///
    ///                The simulation batch job is being cancelled.
    ///
    ///             Completing
    ///
    ///                The simulation batch job is completing.
    ///
    ///             TimingOut
    ///
    ///                The simulation job batch is timing out.
    ///                If a batch timing out, and there are pending requests that were failing due to
    ///                   an internal failure (like InternalServiceError), the batch status
    ///                   will be Failed. If there are no such failing request, the batch
    ///                   status will be TimedOut.
    ///
    ///             TimedOut
    ///
    ///                The simulation batch job timed out.
    ///
    ///
    public var status: RoboMakerClientTypes.SimulationJobBatchStatus?
    /// A map that contains tag keys and tag values that are attached to the deployment job
    ///          batch.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdRequests: [RoboMakerClientTypes.SimulationJobSummary]? = nil,
        failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode? = nil,
        failureReason: Swift.String? = nil,
        pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.createdRequests = createdRequests
        self.failedRequests = failedRequests
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.pendingRequests = pendingRequests
        self.status = status
        self.tags = tags
    }
}

struct StartSimulationJobBatchOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let status: RoboMakerClientTypes.SimulationJobBatchStatus?
    public let createdAt: ClientRuntime.Date?
    public let clientRequestToken: Swift.String?
    public let batchPolicy: RoboMakerClientTypes.BatchPolicy?
    public let failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    public let failureReason: Swift.String?
    public let failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    public let pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    public let createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    public let tags: [Swift.String:Swift.String]?
}

extension StartSimulationJobBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case batchPolicy
        case clientRequestToken
        case createdAt
        case createdRequests
        case failedRequests
        case failureCode
        case failureReason
        case pendingRequests
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failedRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.FailedCreateSimulationJobRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [RoboMakerClientTypes.FailedCreateSimulationJobRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobRequest?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[RoboMakerClientTypes.SimulationJobRequest]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobRequest]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
        let createdRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobSummary?].self, forKey: .createdRequests)
        var createdRequestsDecoded0:[RoboMakerClientTypes.SimulationJobSummary]? = nil
        if let createdRequestsContainer = createdRequestsContainer {
            createdRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobSummary]()
            for structure0 in createdRequestsContainer {
                if let structure0 = structure0 {
                    createdRequestsDecoded0?.append(structure0)
                }
            }
        }
        createdRequests = createdRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct SyncDeploymentJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SyncDeploymentJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SyncDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SyncDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SyncDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SyncDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SyncDeploymentJobOutputError>
}

extension SyncDeploymentJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SyncDeploymentJobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), fleet: \(Swift.String(describing: fleet)))"}
}

extension SyncDeploymentJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case fleet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

public struct SyncDeploymentJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SyncDeploymentJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SyncDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SyncDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SyncDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SyncDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SyncDeploymentJobOutputError>
}

public struct SyncDeploymentJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SyncDeploymentJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SyncDeploymentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SyncDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SyncDeploymentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SyncDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SyncDeploymentJobOutputError>
}

public struct SyncDeploymentJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SyncDeploymentJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SyncDeploymentJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SyncDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/syncDeploymentJob"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SyncDeploymentJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<SyncDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SyncDeploymentJobOutputError>
}

public struct SyncDeploymentJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The target fleet for the synchronization.
    /// This member is required.
    public var fleet: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        fleet: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fleet = fleet
    }
}

struct SyncDeploymentJobInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let fleet: Swift.String?
}

extension SyncDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case fleet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension SyncDeploymentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SyncDeploymentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentDeploymentException" : self = .concurrentDeploymentException(try ConcurrentDeploymentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SyncDeploymentJobOutputError: Swift.Error, Swift.Equatable {
    case concurrentDeploymentException(ConcurrentDeploymentException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SyncDeploymentJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SyncDeploymentJobOutputResponse(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentApplicationConfigs: \(Swift.String(describing: deploymentApplicationConfigs)), deploymentConfig: \(Swift.String(describing: deploymentConfig)), failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), fleet: \(Swift.String(describing: fleet)), status: \(Swift.String(describing: status)))"}
}

extension SyncDeploymentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SyncDeploymentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.status = nil
        }
    }
}

public struct SyncDeploymentJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the synchronization request.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// Information about the deployment application configurations.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// Information about the deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The failure code if the job fails:
    ///
    ///             InternalServiceError
    ///
    ///                Internal service error.
    ///
    ///             RobotApplicationCrash
    ///
    ///                Robot application exited abnormally.
    ///
    ///             SimulationApplicationCrash
    ///
    ///                 Simulation application exited abnormally.
    ///
    ///             BadPermissionsRobotApplication
    ///
    ///                Robot application bundle could not be downloaded.
    ///
    ///             BadPermissionsSimulationApplication
    ///
    ///                Simulation application bundle could not be downloaded.
    ///
    ///             BadPermissionsS3Output
    ///
    ///                Unable to publish outputs to customer-provided S3 bucket.
    ///
    ///             BadPermissionsCloudwatchLogs
    ///
    ///                Unable to publish logs to customer-provided CloudWatch Logs resource.
    ///
    ///             SubnetIpLimitExceeded
    ///
    ///                Subnet IP limit exceeded.
    ///
    ///             ENILimitExceeded
    ///
    ///                ENI limit exceeded.
    ///
    ///             BadPermissionsUserCredentials
    ///
    ///                Unable to use the Role provided.
    ///
    ///             InvalidBundleRobotApplication
    ///
    ///                Robot bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).
    ///
    ///             InvalidBundleSimulationApplication
    ///
    ///                Simulation bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).
    ///
    ///             RobotApplicationVersionMismatchedEtag
    ///
    ///                Etag for RobotApplication does not match value during version creation.
    ///
    ///             SimulationApplicationVersionMismatchedEtag
    ///
    ///                Etag for SimulationApplication does not match value during version
    ///                   creation.
    ///
    ///
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// The failure reason if the job fails.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// The status of the synchronization job.
    public var status: RoboMakerClientTypes.DeploymentStatus?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
    }
}

struct SyncDeploymentJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let fleet: Swift.String?
    public let status: RoboMakerClientTypes.DeploymentStatus?
    public let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    public let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    public let failureReason: Swift.String?
    public let failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    public let createdAt: ClientRuntime.Date?
}

extension SyncDeploymentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are tagging.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RoboMakerClientTypes.TemplateLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension RoboMakerClientTypes.TemplateLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TemplateLocation(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)))"}
}

extension RoboMakerClientTypes {
    /// Information about a template location.
    public struct TemplateLocation: Swift.Equatable {
        /// The Amazon S3 bucket name.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        /// This member is required.
        public var s3Key: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension RoboMakerClientTypes.TemplateSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes.TemplateSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TemplateSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension RoboMakerClientTypes {
    /// Summary information for a template.
    public struct TemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the template.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the template was created.
        public var createdAt: ClientRuntime.Date?
        /// The time, in milliseconds since the epoch, when the template was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the template.
        public var name: Swift.String?
        /// The version of the template that you're using.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.version = version
        }
    }

}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AWS RoboMaker is temporarily unable to process the request. Try your call again.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoboMakerClientTypes.Tool: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command
        case exitBehavior
        case name
        case streamOutputToCloudWatch
        case streamUI
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let exitBehavior = exitBehavior {
            try encodeContainer.encode(exitBehavior.rawValue, forKey: .exitBehavior)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamOutputToCloudWatch = streamOutputToCloudWatch {
            try encodeContainer.encode(streamOutputToCloudWatch, forKey: .streamOutputToCloudWatch)
        }
        if let streamUI = streamUI {
            try encodeContainer.encode(streamUI, forKey: .streamUI)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamUIDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .streamUI)
        streamUI = streamUIDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let commandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .command)
        command = commandDecoded
        let streamOutputToCloudWatchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .streamOutputToCloudWatch)
        streamOutputToCloudWatch = streamOutputToCloudWatchDecoded
        let exitBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ExitBehavior.self, forKey: .exitBehavior)
        exitBehavior = exitBehaviorDecoded
    }
}

extension RoboMakerClientTypes.Tool: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tool(command: \(Swift.String(describing: command)), exitBehavior: \(Swift.String(describing: exitBehavior)), name: \(Swift.String(describing: name)), streamOutputToCloudWatch: \(Swift.String(describing: streamOutputToCloudWatch)), streamUI: \(Swift.String(describing: streamUI)))"}
}

extension RoboMakerClientTypes {
    /// Information about a tool. Tools are used in a simulation job.
    public struct Tool: Swift.Equatable {
        /// Command-line arguments for the tool. It must include the tool executable name.
        /// This member is required.
        public var command: Swift.String?
        /// Exit behavior determines what happens when your tool quits running.
        ///         RESTART will cause your tool to be restarted. FAIL
        ///         will cause your job to exit. The default is RESTART.
        ///
        public var exitBehavior: RoboMakerClientTypes.ExitBehavior?
        /// The name of the tool.
        /// This member is required.
        public var name: Swift.String?
        /// Boolean indicating whether logs will be recorded in CloudWatch for the tool.
        ///       The default is False.
        ///
        public var streamOutputToCloudWatch: Swift.Bool?
        /// Boolean indicating whether a streaming session will be configured for the tool.
        ///          If True, AWS RoboMaker will configure a connection so you can interact with
        ///          the tool as it is running in the simulation. It must have a graphical user interface.
        ///          The default is False.
        ///
        public var streamUI: Swift.Bool?

        public init (
            command: Swift.String? = nil,
            exitBehavior: RoboMakerClientTypes.ExitBehavior? = nil,
            name: Swift.String? = nil,
            streamOutputToCloudWatch: Swift.Bool? = nil,
            streamUI: Swift.Bool? = nil
        )
        {
            self.command = command
            self.exitBehavior = exitBehavior
            self.name = name
            self.streamOutputToCloudWatch = streamOutputToCloudWatch
            self.streamUI = streamUI
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are removing
    ///          tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that will be unattached from the
    ///          resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateRobotApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRobotApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRobotApplicationOutputError>
}

extension UpdateRobotApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRobotApplicationInput(application: \(Swift.String(describing: application)), currentRevisionId: \(Swift.String(describing: currentRevisionId)), environment: \(Swift.String(describing: environment)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), sources: \(Swift.String(describing: sources)))"}
}

extension UpdateRobotApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case robotSoftwareSuite
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfigs0 in sources {
                try sourcesContainer.encode(sourceconfigs0)
            }
        }
    }
}

public struct UpdateRobotApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRobotApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRobotApplicationOutputError>
}

public struct UpdateRobotApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRobotApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRobotApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRobotApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRobotApplicationOutputError>
}

public struct UpdateRobotApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRobotApplicationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateRobotApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/updateRobotApplication"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRobotApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRobotApplicationOutputError>
}

public struct UpdateRobotApplicationInput: Swift.Equatable {
    /// The application information for the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The revision id for the robot application.
    public var currentRevisionId: Swift.String?
    /// The object that contains the Docker image URI for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The robot software suite (ROS distribution) used by the robot application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?

    public init (
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.environment = environment
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
    }
}

struct UpdateRobotApplicationInputBody: Swift.Equatable {
    public let application: Swift.String?
    public let sources: [RoboMakerClientTypes.SourceConfig]?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let currentRevisionId: Swift.String?
    public let environment: RoboMakerClientTypes.Environment?
}

extension UpdateRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case robotSoftwareSuite
        case sources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension UpdateRobotApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRobotApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRobotApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRobotApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRobotApplicationOutputResponse(arn: \(Swift.String(describing: arn)), environment: \(Swift.String(describing: environment)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), sources: \(Swift.String(describing: sources)), version: \(Swift.String(describing: version)))"}
}

extension UpdateRobotApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRobotApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct UpdateRobotApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct UpdateRobotApplicationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let version: Swift.String?
    public let sources: [RoboMakerClientTypes.Source]?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let revisionId: Swift.String?
    public let environment: RoboMakerClientTypes.Environment?
}

extension UpdateRobotApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct UpdateSimulationApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSimulationApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSimulationApplicationOutputError>
}

extension UpdateSimulationApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSimulationApplicationInput(application: \(Swift.String(describing: application)), currentRevisionId: \(Swift.String(describing: currentRevisionId)), environment: \(Swift.String(describing: environment)), renderingEngine: \(Swift.String(describing: renderingEngine)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(Swift.String(describing: simulationSoftwareSuite)), sources: \(Swift.String(describing: sources)))"}
}

extension UpdateSimulationApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let renderingEngine = renderingEngine {
            try encodeContainer.encode(renderingEngine, forKey: .renderingEngine)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfigs0 in sources {
                try sourcesContainer.encode(sourceconfigs0)
            }
        }
    }
}

public struct UpdateSimulationApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSimulationApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSimulationApplicationOutputError>
}

public struct UpdateSimulationApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSimulationApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSimulationApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSimulationApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSimulationApplicationOutputError>
}

public struct UpdateSimulationApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSimulationApplicationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateSimulationApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/updateSimulationApplication"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSimulationApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSimulationApplicationOutputError>
}

public struct UpdateSimulationApplicationInput: Swift.Equatable {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The revision id for the robot application.
    public var currentRevisionId: Swift.String?
    /// The object that contains the Docker image URI for your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// Information about the robot software suite (ROS distribution).
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    /// This member is required.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?

    public init (
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.environment = environment
        self.renderingEngine = renderingEngine
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
    }
}

struct UpdateSimulationApplicationInputBody: Swift.Equatable {
    public let application: Swift.String?
    public let sources: [RoboMakerClientTypes.SourceConfig]?
    public let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    public let currentRevisionId: Swift.String?
    public let environment: RoboMakerClientTypes.Environment?
}

extension UpdateSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension UpdateSimulationApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSimulationApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSimulationApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSimulationApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSimulationApplicationOutputResponse(arn: \(Swift.String(describing: arn)), environment: \(Swift.String(describing: environment)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), renderingEngine: \(Swift.String(describing: renderingEngine)), revisionId: \(Swift.String(describing: revisionId)), robotSoftwareSuite: \(Swift.String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(Swift.String(describing: simulationSoftwareSuite)), sources: \(Swift.String(describing: sources)), version: \(Swift.String(describing: version)))"}
}

extension UpdateSimulationApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSimulationApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct UpdateSimulationApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used for your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct UpdateSimulationApplicationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let version: Swift.String?
    public let sources: [RoboMakerClientTypes.Source]?
    public let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    public let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    public let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let revisionId: Swift.String?
    public let environment: RoboMakerClientTypes.Environment?
}

extension UpdateSimulationApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct UpdateWorldTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorldTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorldTemplateOutputError>
}

extension UpdateWorldTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorldTemplateInput(name: \(Swift.String(describing: name)), template: \(Swift.String(describing: template)), templateBody: \(Swift.String(describing: templateBody)), templateLocation: \(Swift.String(describing: templateLocation)))"}
}

extension UpdateWorldTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case template
        case templateBody
        case templateLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateLocation = templateLocation {
            try encodeContainer.encode(templateLocation, forKey: .templateLocation)
        }
    }
}

public struct UpdateWorldTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorldTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorldTemplateOutputError>
}

public struct UpdateWorldTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorldTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorldTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorldTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorldTemplateOutputError>
}

public struct UpdateWorldTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorldTemplateInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateWorldTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/updateWorldTemplate"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateWorldTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorldTemplateOutputError>
}

public struct UpdateWorldTemplateInput: Swift.Equatable {
    /// The name of the template.
    public var name: Swift.String?
    /// The Amazon Resource Name (arn) of the world template to update.
    /// This member is required.
    public var template: Swift.String?
    /// The world template body.
    public var templateBody: Swift.String?
    /// The location of the world template.
    public var templateLocation: RoboMakerClientTypes.TemplateLocation?

    public init (
        name: Swift.String? = nil,
        template: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateLocation: RoboMakerClientTypes.TemplateLocation? = nil
    )
    {
        self.name = name
        self.template = template
        self.templateBody = templateBody
        self.templateLocation = templateLocation
    }
}

struct UpdateWorldTemplateInputBody: Swift.Equatable {
    public let template: Swift.String?
    public let name: Swift.String?
    public let templateBody: Swift.String?
    public let templateLocation: RoboMakerClientTypes.TemplateLocation?
}

extension UpdateWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case template
        case templateBody
        case templateLocation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.TemplateLocation.self, forKey: .templateLocation)
        templateLocation = templateLocationDecoded
    }
}

extension UpdateWorldTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorldTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorldTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorldTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorldTemplateOutputResponse(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)))"}
}

extension UpdateWorldTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateWorldTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
        } else {
            self.arn = nil
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.name = nil
        }
    }
}

public struct UpdateWorldTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world template.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the world template was last
    ///          updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the world template.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
    }
}

struct UpdateWorldTemplateOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let lastUpdatedAt: ClientRuntime.Date?
}

extension UpdateWorldTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension RoboMakerClientTypes {
    public enum UploadBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case uploadOnTerminate
        case uploadRollingAutoRemove
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadBehavior] {
            return [
                .uploadOnTerminate,
                .uploadRollingAutoRemove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .uploadOnTerminate: return "UPLOAD_ON_TERMINATE"
            case .uploadRollingAutoRemove: return "UPLOAD_ROLLING_AUTO_REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadBehavior(rawValue: rawValue) ?? UploadBehavior.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.UploadConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case path
        case uploadBehavior
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let uploadBehavior = uploadBehavior {
            try encodeContainer.encode(uploadBehavior.rawValue, forKey: .uploadBehavior)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let uploadBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.UploadBehavior.self, forKey: .uploadBehavior)
        uploadBehavior = uploadBehaviorDecoded
    }
}

extension RoboMakerClientTypes.UploadConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadConfiguration(name: \(Swift.String(describing: name)), path: \(Swift.String(describing: path)), uploadBehavior: \(Swift.String(describing: uploadBehavior)))"}
}

extension RoboMakerClientTypes {
    /// Provides upload configuration information. Files are uploaded from the simulation job to
    ///          a location you specify.
    public struct UploadConfiguration: Swift.Equatable {
        /// A prefix that specifies where files will be uploaded in Amazon S3.
        ///         It is appended to the simulation output location to determine the final path.
        ///
        ///
        ///         For example, if your simulation output location is s3://my-bucket and your upload
        ///         configuration name is robot-test, your files will be uploaded to
        ///         s3://my-bucket/<simid>/<runid>/robot-test.
        ///
        /// This member is required.
        public var name: Swift.String?
        ///  Specifies the path of the file(s) to upload. Standard Unix glob matching rules are
        ///          accepted, with the addition of ** as a super asterisk.
        ///          For example, specifying /var/log/**.log causes all .log files in the
        ///             /var/log directory tree to be collected. For more examples, see <a href="https://github.com/gobwas/glob">Glob Library.
        /// This member is required.
        public var path: Swift.String?
        /// Specifies when to upload the files:
        ///
        ///             UPLOAD_ON_TERMINATE
        ///
        ///                Matching files are uploaded once the simulation enters the
        ///                      TERMINATING state. Matching files are not uploaded until all of
        ///                   your code (including tools) have stopped.
        ///                If there is a problem uploading a file, the upload is retried. If problems
        ///                   persist, no further upload attempts will be made.
        ///
        ///             UPLOAD_ROLLING_AUTO_REMOVE
        ///
        ///                Matching files are uploaded as they are created. They are deleted after they
        ///                   are uploaded. The specified path is checked every 5 seconds. A final check is made
        ///                   when all of your code (including tools) have stopped.
        ///
        ///
        /// This member is required.
        public var uploadBehavior: RoboMakerClientTypes.UploadBehavior?

        public init (
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            uploadBehavior: RoboMakerClientTypes.UploadBehavior? = nil
        )
        {
            self.name = name
            self.path = path
            self.uploadBehavior = uploadBehavior
        }
    }

}

extension RoboMakerClientTypes.VPCConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignPublicIp
        case securityGroups
        case subnets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assignPublicIp != false {
            try encodeContainer.encode(assignPublicIp, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnets0 in subnets {
                try subnetsContainer.encode(subnets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let assignPublicIpDecoded = try containerValues.decode(Swift.Bool.self, forKey: .assignPublicIp)
        assignPublicIp = assignPublicIpDecoded
    }
}

extension RoboMakerClientTypes.VPCConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VPCConfig(assignPublicIp: \(Swift.String(describing: assignPublicIp)), securityGroups: \(Swift.String(describing: securityGroups)), subnets: \(Swift.String(describing: subnets)))"}
}

extension RoboMakerClientTypes {
    /// If your simulation job accesses resources in a VPC, you provide this parameter
    ///          identifying the list of security group IDs and subnet IDs. These must belong to the same
    ///          VPC. You must provide at least one security group and two subnet IDs.
    public struct VPCConfig: Swift.Equatable {
        /// A boolean indicating whether to assign a public IP address.
        public var assignPublicIp: Swift.Bool
        /// A list of one or more security groups IDs in your VPC.
        public var securityGroups: [Swift.String]?
        /// A list of one or more subnet IDs in your VPC.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init (
            assignPublicIp: Swift.Bool = false,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension RoboMakerClientTypes.VPCConfigResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignPublicIp
        case securityGroups
        case subnets
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assignPublicIp != false {
            try encodeContainer.encode(assignPublicIp, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnets0 in subnets {
                try subnetsContainer.encode(subnets0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let assignPublicIpDecoded = try containerValues.decode(Swift.Bool.self, forKey: .assignPublicIp)
        assignPublicIp = assignPublicIpDecoded
    }
}

extension RoboMakerClientTypes.VPCConfigResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VPCConfigResponse(assignPublicIp: \(Swift.String(describing: assignPublicIp)), securityGroups: \(Swift.String(describing: securityGroups)), subnets: \(Swift.String(describing: subnets)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension RoboMakerClientTypes {
    /// VPC configuration associated with your simulation job.
    public struct VPCConfigResponse: Swift.Equatable {
        /// A boolean indicating if a public IP was assigned.
        public var assignPublicIp: Swift.Bool
        /// A list of security group IDs associated with the simulation job.
        public var securityGroups: [Swift.String]?
        /// A list of subnet IDs associated with the simulation job.
        public var subnets: [Swift.String]?
        /// The VPC ID associated with your simulation job.
        public var vpcId: Swift.String?

        public init (
            assignPublicIp: Swift.Bool = false,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension RoboMakerClientTypes.WorldConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case world
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let world = world {
            try encodeContainer.encode(world, forKey: .world)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .world)
        world = worldDecoded
    }
}

extension RoboMakerClientTypes.WorldConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorldConfig(world: \(Swift.String(describing: world)))"}
}

extension RoboMakerClientTypes {
    /// Configuration information for a world.
    public struct WorldConfig: Swift.Equatable {
        /// The world generated by Simulation WorldForge.
        public var world: Swift.String?

        public init (
            world: Swift.String? = nil
        )
        {
            self.world = world
        }
    }

}

extension RoboMakerClientTypes.WorldCount: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case floorplanCount
        case interiorCountPerFloorplan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let floorplanCount = floorplanCount {
            try encodeContainer.encode(floorplanCount, forKey: .floorplanCount)
        }
        if let interiorCountPerFloorplan = interiorCountPerFloorplan {
            try encodeContainer.encode(interiorCountPerFloorplan, forKey: .interiorCountPerFloorplan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let floorplanCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .floorplanCount)
        floorplanCount = floorplanCountDecoded
        let interiorCountPerFloorplanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interiorCountPerFloorplan)
        interiorCountPerFloorplan = interiorCountPerFloorplanDecoded
    }
}

extension RoboMakerClientTypes.WorldCount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorldCount(floorplanCount: \(Swift.String(describing: floorplanCount)), interiorCountPerFloorplan: \(Swift.String(describing: interiorCountPerFloorplan)))"}
}

extension RoboMakerClientTypes {
    /// The number of worlds that will be created. You can configure the number of unique
    ///          floorplans and the number of unique interiors for each floor plan. For example, if you want
    ///          1 world with 20 unique interiors, you set floorplanCount = 1 and
    ///             interiorCountPerFloorplan = 20. This will result in 20 worlds
    ///             (floorplanCount * interiorCountPerFloorplan).
    ///          If you set floorplanCount = 4 and interiorCountPerFloorplan =
    ///             5, there will be 20 worlds with 5 unique floor plans.
    public struct WorldCount: Swift.Equatable {
        /// The number of unique floorplans.
        public var floorplanCount: Swift.Int?
        /// The number of unique interiors per floorplan.
        public var interiorCountPerFloorplan: Swift.Int?

        public init (
            floorplanCount: Swift.Int? = nil,
            interiorCountPerFloorplan: Swift.Int? = nil
        )
        {
            self.floorplanCount = floorplanCount
            self.interiorCountPerFloorplan = interiorCountPerFloorplan
        }
    }

}

extension RoboMakerClientTypes {
    public enum WorldExportJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case internalserviceerror
        case invalidinput
        case limitexceeded
        case requestthrottled
        case resourcenotfound
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldExportJobErrorCode] {
            return [
                .accessdenied,
                .internalserviceerror,
                .invalidinput,
                .limitexceeded,
                .requestthrottled,
                .resourcenotfound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidinput: return "InvalidInput"
            case .limitexceeded: return "LimitExceeded"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldExportJobErrorCode(rawValue: rawValue) ?? WorldExportJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum WorldExportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldExportJobStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .running: return "Running"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldExportJobStatus(rawValue: rawValue) ?? WorldExportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.WorldExportJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case status
        case worlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arns0 in worlds {
                try worldsContainer.encode(arns0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
    }
}

extension RoboMakerClientTypes.WorldExportJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorldExportJobSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), status: \(Swift.String(describing: status)), worlds: \(Swift.String(describing: worlds)))"}
}

extension RoboMakerClientTypes {
    /// Information about a world export job.
    public struct WorldExportJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the world export job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world export job was created.
        public var createdAt: ClientRuntime.Date?
        /// The status of the world export job.
        ///
        ///             Pending
        ///
        ///                The world export job request is pending.
        ///
        ///             Running
        ///
        ///                The world export job is running.
        ///
        ///             Completed
        ///
        ///                The world export job completed.
        ///
        ///             Failed
        ///
        ///                The world export job failed. See failureCode for more information.
        ///
        ///
        ///             Canceled
        ///
        ///                The world export job was cancelled.
        ///
        ///             Canceling
        ///
        ///                The world export job is being cancelled.
        ///
        ///
        public var status: RoboMakerClientTypes.WorldExportJobStatus?
        /// A list of worlds.
        public var worlds: [Swift.String]?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
            worlds: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.status = status
            self.worlds = worlds
        }
    }

}

extension RoboMakerClientTypes.WorldFailure: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureCount
        case sampleFailureReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if failureCount != 0 {
            try encodeContainer.encode(failureCount, forKey: .failureCount)
        }
        if let sampleFailureReason = sampleFailureReason {
            try encodeContainer.encode(sampleFailureReason, forKey: .sampleFailureReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let sampleFailureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleFailureReason)
        sampleFailureReason = sampleFailureReasonDecoded
        let failureCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .failureCount)
        failureCount = failureCountDecoded
    }
}

extension RoboMakerClientTypes.WorldFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorldFailure(failureCode: \(Swift.String(describing: failureCode)), failureCount: \(Swift.String(describing: failureCount)), sampleFailureReason: \(Swift.String(describing: sampleFailureReason)))"}
}

extension RoboMakerClientTypes {
    /// Information about a failed world.
    public struct WorldFailure: Swift.Equatable {
        /// The failure code of the world export job if it failed:
        ///
        ///             InternalServiceError
        ///
        ///                Internal service error.
        ///
        ///             LimitExceeded
        ///
        ///                The requested resource exceeds the maximum number allowed, or the number of
        ///                   concurrent stream requests exceeds the maximum number allowed.
        ///
        ///             ResourceNotFound
        ///
        ///                The specified resource could not be found.
        ///
        ///             RequestThrottled
        ///
        ///                The request was throttled.
        ///
        ///             InvalidInput
        ///
        ///                An input parameter in the request is not valid.
        ///
        ///
        public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
        /// The number of failed worlds.
        public var failureCount: Swift.Int
        /// The sample reason why the world failed. World errors are aggregated. A sample is used as
        ///          the sampleFailureReason.
        public var sampleFailureReason: Swift.String?

        public init (
            failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
            failureCount: Swift.Int = 0,
            sampleFailureReason: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureCount = failureCount
            self.sampleFailureReason = sampleFailureReason
        }
    }

}

extension RoboMakerClientTypes {
    public enum WorldGenerationJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allworldgenerationfailed
        case internalserviceerror
        case invalidinput
        case limitexceeded
        case requestthrottled
        case resourcenotfound
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldGenerationJobErrorCode] {
            return [
                .allworldgenerationfailed,
                .internalserviceerror,
                .invalidinput,
                .limitexceeded,
                .requestthrottled,
                .resourcenotfound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allworldgenerationfailed: return "AllWorldGenerationFailed"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidinput: return "InvalidInput"
            case .limitexceeded: return "LimitExceeded"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldGenerationJobErrorCode(rawValue: rawValue) ?? WorldGenerationJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum WorldGenerationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case failed
        case partialfailed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldGenerationJobStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .failed,
                .partialfailed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .partialfailed: return "PartialFailed"
            case .pending: return "Pending"
            case .running: return "Running"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldGenerationJobStatus(rawValue: rawValue) ?? WorldGenerationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.WorldGenerationJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case failedWorldCount
        case status
        case succeededWorldCount
        case template
        case worldCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if failedWorldCount != 0 {
            try encodeContainer.encode(failedWorldCount, forKey: .failedWorldCount)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if succeededWorldCount != 0 {
            try encodeContainer.encode(succeededWorldCount, forKey: .succeededWorldCount)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let worldCount = worldCount {
            try encodeContainer.encode(worldCount, forKey: .worldCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let succeededWorldCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .succeededWorldCount)
        succeededWorldCount = succeededWorldCountDecoded
        let failedWorldCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .failedWorldCount)
        failedWorldCount = failedWorldCountDecoded
    }
}

extension RoboMakerClientTypes.WorldGenerationJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorldGenerationJobSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), failedWorldCount: \(Swift.String(describing: failedWorldCount)), status: \(Swift.String(describing: status)), succeededWorldCount: \(Swift.String(describing: succeededWorldCount)), template: \(Swift.String(describing: template)), worldCount: \(Swift.String(describing: worldCount)))"}
}

extension RoboMakerClientTypes {
    /// Information about a world generator job.
    public struct WorldGenerationJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the world generator job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world generator job was
        ///          created.
        public var createdAt: ClientRuntime.Date?
        /// The number of worlds that failed.
        public var failedWorldCount: Swift.Int
        /// The status of the world generator job:
        ///
        ///             Pending
        ///
        ///                The world generator job request is pending.
        ///
        ///             Running
        ///
        ///                The world generator job is running.
        ///
        ///             Completed
        ///
        ///                The world generator job completed.
        ///
        ///             Failed
        ///
        ///                The world generator job failed. See failureCode for more
        ///                   information.
        ///
        ///             PartialFailed
        ///
        ///                Some worlds did not generate.
        ///
        ///             Canceled
        ///
        ///                The world generator job was cancelled.
        ///
        ///             Canceling
        ///
        ///                The world generator job is being cancelled.
        ///
        ///
        public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
        /// The number of worlds that were generated.
        public var succeededWorldCount: Swift.Int
        /// The Amazon Resource Name (arn) of the world template.
        public var template: Swift.String?
        /// Information about the world count.
        public var worldCount: RoboMakerClientTypes.WorldCount?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            failedWorldCount: Swift.Int = 0,
            status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
            succeededWorldCount: Swift.Int = 0,
            template: Swift.String? = nil,
            worldCount: RoboMakerClientTypes.WorldCount? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.failedWorldCount = failedWorldCount
            self.status = status
            self.succeededWorldCount = succeededWorldCount
            self.template = template
            self.worldCount = worldCount
        }
    }

}

extension RoboMakerClientTypes.WorldSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case generationJob
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let generationJob = generationJob {
            try encodeContainer.encode(generationJob, forKey: .generationJob)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension RoboMakerClientTypes.WorldSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorldSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), generationJob: \(Swift.String(describing: generationJob)), template: \(Swift.String(describing: template)))"}
}

extension RoboMakerClientTypes {
    /// Information about a world.
    public struct WorldSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the world.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (arn) of the world generation job.
        public var generationJob: Swift.String?
        /// The Amazon Resource Name (arn) of the world template.
        public var template: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            generationJob: Swift.String? = nil,
            template: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.generationJob = generationJob
            self.template = template
        }
    }

}
