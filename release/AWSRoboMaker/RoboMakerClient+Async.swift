// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension RoboMakerClient {
    /// Deletes one or more worlds in a batch operation.
    func batchDeleteWorlds(input: BatchDeleteWorldsInput) async throws -> BatchDeleteWorldsOutputResponse
    {
        typealias batchDeleteWorldsContinuation = CheckedContinuation<BatchDeleteWorldsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDeleteWorldsContinuation) in
            batchDeleteWorlds(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes one or more simulation jobs.
    func batchDescribeSimulationJob(input: BatchDescribeSimulationJobInput) async throws -> BatchDescribeSimulationJobOutputResponse
    {
        typealias batchDescribeSimulationJobContinuation = CheckedContinuation<BatchDescribeSimulationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDescribeSimulationJobContinuation) in
            batchDescribeSimulationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Cancels the specified deployment job.
    func cancelDeploymentJob(input: CancelDeploymentJobInput) async throws -> CancelDeploymentJobOutputResponse
    {
        typealias cancelDeploymentJobContinuation = CheckedContinuation<CancelDeploymentJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelDeploymentJobContinuation) in
            cancelDeploymentJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Cancels the specified simulation job.
    func cancelSimulationJob(input: CancelSimulationJobInput) async throws -> CancelSimulationJobOutputResponse
    {
        typealias cancelSimulationJobContinuation = CheckedContinuation<CancelSimulationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelSimulationJobContinuation) in
            cancelSimulationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Cancels a simulation job batch. When you cancel a simulation job batch, you are also cancelling all of the active simulation jobs created as part of the batch.
    func cancelSimulationJobBatch(input: CancelSimulationJobBatchInput) async throws -> CancelSimulationJobBatchOutputResponse
    {
        typealias cancelSimulationJobBatchContinuation = CheckedContinuation<CancelSimulationJobBatchOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelSimulationJobBatchContinuation) in
            cancelSimulationJobBatch(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Cancels the specified export job.
    func cancelWorldExportJob(input: CancelWorldExportJobInput) async throws -> CancelWorldExportJobOutputResponse
    {
        typealias cancelWorldExportJobContinuation = CheckedContinuation<CancelWorldExportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelWorldExportJobContinuation) in
            cancelWorldExportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Cancels the specified world generator job.
    func cancelWorldGenerationJob(input: CancelWorldGenerationJobInput) async throws -> CancelWorldGenerationJobOutputResponse
    {
        typealias cancelWorldGenerationJobContinuation = CheckedContinuation<CancelWorldGenerationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelWorldGenerationJobContinuation) in
            cancelWorldGenerationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deploys a specific version of a robot application to robots in a fleet. The robot application must have a numbered applicationVersion for consistency reasons. To create a new version, use CreateRobotApplicationVersion or see [Creating a Robot Application Version](https://docs.aws.amazon.com/robomaker/latest/dg/create-robot-application-version.html). After 90 days, deployment jobs expire and will be deleted. They will no longer be accessible.
    func createDeploymentJob(input: CreateDeploymentJobInput) async throws -> CreateDeploymentJobOutputResponse
    {
        typealias createDeploymentJobContinuation = CheckedContinuation<CreateDeploymentJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDeploymentJobContinuation) in
            createDeploymentJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a fleet, a logical group of robots running the same robot application.
    func createFleet(input: CreateFleetInput) async throws -> CreateFleetOutputResponse
    {
        typealias createFleetContinuation = CheckedContinuation<CreateFleetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFleetContinuation) in
            createFleet(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a robot.
    func createRobot(input: CreateRobotInput) async throws -> CreateRobotOutputResponse
    {
        typealias createRobotContinuation = CheckedContinuation<CreateRobotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createRobotContinuation) in
            createRobot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a robot application.
    func createRobotApplication(input: CreateRobotApplicationInput) async throws -> CreateRobotApplicationOutputResponse
    {
        typealias createRobotApplicationContinuation = CheckedContinuation<CreateRobotApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createRobotApplicationContinuation) in
            createRobotApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a version of a robot application.
    func createRobotApplicationVersion(input: CreateRobotApplicationVersionInput) async throws -> CreateRobotApplicationVersionOutputResponse
    {
        typealias createRobotApplicationVersionContinuation = CheckedContinuation<CreateRobotApplicationVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createRobotApplicationVersionContinuation) in
            createRobotApplicationVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a simulation application.
    func createSimulationApplication(input: CreateSimulationApplicationInput) async throws -> CreateSimulationApplicationOutputResponse
    {
        typealias createSimulationApplicationContinuation = CheckedContinuation<CreateSimulationApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSimulationApplicationContinuation) in
            createSimulationApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a simulation application with a specific revision id.
    func createSimulationApplicationVersion(input: CreateSimulationApplicationVersionInput) async throws -> CreateSimulationApplicationVersionOutputResponse
    {
        typealias createSimulationApplicationVersionContinuation = CheckedContinuation<CreateSimulationApplicationVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSimulationApplicationVersionContinuation) in
            createSimulationApplicationVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a simulation job. After 90 days, simulation jobs expire and will be deleted. They will no longer be accessible.
    func createSimulationJob(input: CreateSimulationJobInput) async throws -> CreateSimulationJobOutputResponse
    {
        typealias createSimulationJobContinuation = CheckedContinuation<CreateSimulationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSimulationJobContinuation) in
            createSimulationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a world export job.
    func createWorldExportJob(input: CreateWorldExportJobInput) async throws -> CreateWorldExportJobOutputResponse
    {
        typealias createWorldExportJobContinuation = CheckedContinuation<CreateWorldExportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createWorldExportJobContinuation) in
            createWorldExportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates worlds using the specified template.
    func createWorldGenerationJob(input: CreateWorldGenerationJobInput) async throws -> CreateWorldGenerationJobOutputResponse
    {
        typealias createWorldGenerationJobContinuation = CheckedContinuation<CreateWorldGenerationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createWorldGenerationJobContinuation) in
            createWorldGenerationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a world template.
    func createWorldTemplate(input: CreateWorldTemplateInput) async throws -> CreateWorldTemplateOutputResponse
    {
        typealias createWorldTemplateContinuation = CheckedContinuation<CreateWorldTemplateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createWorldTemplateContinuation) in
            createWorldTemplate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a fleet.
    func deleteFleet(input: DeleteFleetInput) async throws -> DeleteFleetOutputResponse
    {
        typealias deleteFleetContinuation = CheckedContinuation<DeleteFleetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFleetContinuation) in
            deleteFleet(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a robot.
    func deleteRobot(input: DeleteRobotInput) async throws -> DeleteRobotOutputResponse
    {
        typealias deleteRobotContinuation = CheckedContinuation<DeleteRobotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRobotContinuation) in
            deleteRobot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a robot application.
    func deleteRobotApplication(input: DeleteRobotApplicationInput) async throws -> DeleteRobotApplicationOutputResponse
    {
        typealias deleteRobotApplicationContinuation = CheckedContinuation<DeleteRobotApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRobotApplicationContinuation) in
            deleteRobotApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a simulation application.
    func deleteSimulationApplication(input: DeleteSimulationApplicationInput) async throws -> DeleteSimulationApplicationOutputResponse
    {
        typealias deleteSimulationApplicationContinuation = CheckedContinuation<DeleteSimulationApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSimulationApplicationContinuation) in
            deleteSimulationApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a world template.
    func deleteWorldTemplate(input: DeleteWorldTemplateInput) async throws -> DeleteWorldTemplateOutputResponse
    {
        typealias deleteWorldTemplateContinuation = CheckedContinuation<DeleteWorldTemplateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteWorldTemplateContinuation) in
            deleteWorldTemplate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deregisters a robot.
    func deregisterRobot(input: DeregisterRobotInput) async throws -> DeregisterRobotOutputResponse
    {
        typealias deregisterRobotContinuation = CheckedContinuation<DeregisterRobotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deregisterRobotContinuation) in
            deregisterRobot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a deployment job.
    func describeDeploymentJob(input: DescribeDeploymentJobInput) async throws -> DescribeDeploymentJobOutputResponse
    {
        typealias describeDeploymentJobContinuation = CheckedContinuation<DescribeDeploymentJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDeploymentJobContinuation) in
            describeDeploymentJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a fleet.
    func describeFleet(input: DescribeFleetInput) async throws -> DescribeFleetOutputResponse
    {
        typealias describeFleetContinuation = CheckedContinuation<DescribeFleetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeFleetContinuation) in
            describeFleet(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a robot.
    func describeRobot(input: DescribeRobotInput) async throws -> DescribeRobotOutputResponse
    {
        typealias describeRobotContinuation = CheckedContinuation<DescribeRobotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRobotContinuation) in
            describeRobot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a robot application.
    func describeRobotApplication(input: DescribeRobotApplicationInput) async throws -> DescribeRobotApplicationOutputResponse
    {
        typealias describeRobotApplicationContinuation = CheckedContinuation<DescribeRobotApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRobotApplicationContinuation) in
            describeRobotApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a simulation application.
    func describeSimulationApplication(input: DescribeSimulationApplicationInput) async throws -> DescribeSimulationApplicationOutputResponse
    {
        typealias describeSimulationApplicationContinuation = CheckedContinuation<DescribeSimulationApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSimulationApplicationContinuation) in
            describeSimulationApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a simulation job.
    func describeSimulationJob(input: DescribeSimulationJobInput) async throws -> DescribeSimulationJobOutputResponse
    {
        typealias describeSimulationJobContinuation = CheckedContinuation<DescribeSimulationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSimulationJobContinuation) in
            describeSimulationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a simulation job batch.
    func describeSimulationJobBatch(input: DescribeSimulationJobBatchInput) async throws -> DescribeSimulationJobBatchOutputResponse
    {
        typealias describeSimulationJobBatchContinuation = CheckedContinuation<DescribeSimulationJobBatchOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSimulationJobBatchContinuation) in
            describeSimulationJobBatch(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a world.
    func describeWorld(input: DescribeWorldInput) async throws -> DescribeWorldOutputResponse
    {
        typealias describeWorldContinuation = CheckedContinuation<DescribeWorldOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeWorldContinuation) in
            describeWorld(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a world export job.
    func describeWorldExportJob(input: DescribeWorldExportJobInput) async throws -> DescribeWorldExportJobOutputResponse
    {
        typealias describeWorldExportJobContinuation = CheckedContinuation<DescribeWorldExportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeWorldExportJobContinuation) in
            describeWorldExportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a world generation job.
    func describeWorldGenerationJob(input: DescribeWorldGenerationJobInput) async throws -> DescribeWorldGenerationJobOutputResponse
    {
        typealias describeWorldGenerationJobContinuation = CheckedContinuation<DescribeWorldGenerationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeWorldGenerationJobContinuation) in
            describeWorldGenerationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a world template.
    func describeWorldTemplate(input: DescribeWorldTemplateInput) async throws -> DescribeWorldTemplateOutputResponse
    {
        typealias describeWorldTemplateContinuation = CheckedContinuation<DescribeWorldTemplateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeWorldTemplateContinuation) in
            describeWorldTemplate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets the world template body.
    func getWorldTemplateBody(input: GetWorldTemplateBodyInput) async throws -> GetWorldTemplateBodyOutputResponse
    {
        typealias getWorldTemplateBodyContinuation = CheckedContinuation<GetWorldTemplateBodyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getWorldTemplateBodyContinuation) in
            getWorldTemplateBody(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of deployment jobs for a fleet. You can optionally provide filters to retrieve specific deployment jobs.
    func listDeploymentJobs(input: ListDeploymentJobsInput) async throws -> ListDeploymentJobsOutputResponse
    {
        typealias listDeploymentJobsContinuation = CheckedContinuation<ListDeploymentJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentJobsContinuation) in
            listDeploymentJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of fleets. You can optionally provide filters to retrieve specific fleets.
    func listFleets(input: ListFleetsInput) async throws -> ListFleetsOutputResponse
    {
        typealias listFleetsContinuation = CheckedContinuation<ListFleetsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFleetsContinuation) in
            listFleets(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of robot application. You can optionally provide filters to retrieve specific robot applications.
    func listRobotApplications(input: ListRobotApplicationsInput) async throws -> ListRobotApplicationsOutputResponse
    {
        typealias listRobotApplicationsContinuation = CheckedContinuation<ListRobotApplicationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRobotApplicationsContinuation) in
            listRobotApplications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of robots. You can optionally provide filters to retrieve specific robots.
    func listRobots(input: ListRobotsInput) async throws -> ListRobotsOutputResponse
    {
        typealias listRobotsContinuation = CheckedContinuation<ListRobotsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRobotsContinuation) in
            listRobots(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of simulation applications. You can optionally provide filters to retrieve specific simulation applications.
    func listSimulationApplications(input: ListSimulationApplicationsInput) async throws -> ListSimulationApplicationsOutputResponse
    {
        typealias listSimulationApplicationsContinuation = CheckedContinuation<ListSimulationApplicationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSimulationApplicationsContinuation) in
            listSimulationApplications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list simulation job batches. You can optionally provide filters to retrieve specific simulation batch jobs.
    func listSimulationJobBatches(input: ListSimulationJobBatchesInput) async throws -> ListSimulationJobBatchesOutputResponse
    {
        typealias listSimulationJobBatchesContinuation = CheckedContinuation<ListSimulationJobBatchesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSimulationJobBatchesContinuation) in
            listSimulationJobBatches(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of simulation jobs. You can optionally provide filters to retrieve specific simulation jobs.
    func listSimulationJobs(input: ListSimulationJobsInput) async throws -> ListSimulationJobsOutputResponse
    {
        typealias listSimulationJobsContinuation = CheckedContinuation<ListSimulationJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSimulationJobsContinuation) in
            listSimulationJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists all tags on a AWS RoboMaker resource.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists world export jobs.
    func listWorldExportJobs(input: ListWorldExportJobsInput) async throws -> ListWorldExportJobsOutputResponse
    {
        typealias listWorldExportJobsContinuation = CheckedContinuation<ListWorldExportJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorldExportJobsContinuation) in
            listWorldExportJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists world generator jobs.
    func listWorldGenerationJobs(input: ListWorldGenerationJobsInput) async throws -> ListWorldGenerationJobsOutputResponse
    {
        typealias listWorldGenerationJobsContinuation = CheckedContinuation<ListWorldGenerationJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorldGenerationJobsContinuation) in
            listWorldGenerationJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists world templates.
    func listWorldTemplates(input: ListWorldTemplatesInput) async throws -> ListWorldTemplatesOutputResponse
    {
        typealias listWorldTemplatesContinuation = CheckedContinuation<ListWorldTemplatesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorldTemplatesContinuation) in
            listWorldTemplates(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists worlds.
    func listWorlds(input: ListWorldsInput) async throws -> ListWorldsOutputResponse
    {
        typealias listWorldsContinuation = CheckedContinuation<ListWorldsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorldsContinuation) in
            listWorlds(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Registers a robot with a fleet.
    func registerRobot(input: RegisterRobotInput) async throws -> RegisterRobotOutputResponse
    {
        typealias registerRobotContinuation = CheckedContinuation<RegisterRobotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: registerRobotContinuation) in
            registerRobot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Restarts a running simulation job.
    func restartSimulationJob(input: RestartSimulationJobInput) async throws -> RestartSimulationJobOutputResponse
    {
        typealias restartSimulationJobContinuation = CheckedContinuation<RestartSimulationJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: restartSimulationJobContinuation) in
            restartSimulationJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts a new simulation job batch. The batch is defined using one or more SimulationJobRequest objects.
    func startSimulationJobBatch(input: StartSimulationJobBatchInput) async throws -> StartSimulationJobBatchOutputResponse
    {
        typealias startSimulationJobBatchContinuation = CheckedContinuation<StartSimulationJobBatchOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startSimulationJobBatchContinuation) in
            startSimulationJobBatch(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Syncrhonizes robots in a fleet to the latest deployment. This is helpful if robots were added after a deployment.
    func syncDeploymentJob(input: SyncDeploymentJobInput) async throws -> SyncDeploymentJobOutputResponse
    {
        typealias syncDeploymentJobContinuation = CheckedContinuation<SyncDeploymentJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: syncDeploymentJobContinuation) in
            syncDeploymentJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds or edits tags for a AWS RoboMaker resource. Each tag consists of a tag key and a tag value. Tag keys and tag values are both required, but tag values can be empty strings. For information about the rules that apply to tag keys and tag values, see [User-Defined Tag Restrictions](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/allocation-tag-restrictions.html) in the AWS Billing and Cost Management User Guide.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes the specified tags from the specified AWS RoboMaker resource. To remove a tag, specify the tag key. To change the tag value of an existing tag key, use [TagResource](https://docs.aws.amazon.com/robomaker/latest/dg/API_TagResource.html).
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a robot application.
    func updateRobotApplication(input: UpdateRobotApplicationInput) async throws -> UpdateRobotApplicationOutputResponse
    {
        typealias updateRobotApplicationContinuation = CheckedContinuation<UpdateRobotApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateRobotApplicationContinuation) in
            updateRobotApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a simulation application.
    func updateSimulationApplication(input: UpdateSimulationApplicationInput) async throws -> UpdateSimulationApplicationOutputResponse
    {
        typealias updateSimulationApplicationContinuation = CheckedContinuation<UpdateSimulationApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateSimulationApplicationContinuation) in
            updateSimulationApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a world template.
    func updateWorldTemplate(input: UpdateWorldTemplateInput) async throws -> UpdateWorldTemplateOutputResponse
    {
        typealias updateWorldTemplateContinuation = CheckedContinuation<UpdateWorldTemplateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateWorldTemplateContinuation) in
            updateWorldTemplate(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
