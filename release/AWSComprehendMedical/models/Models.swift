// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ComprehendMedicalClientTypes.Attribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case relationshipType = "RelationshipType"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let relationshipType = relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for traitlist0 in traits {
                try traitsContainer.encode(traitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntitySubType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntityType.self, forKey: .category)
        category = categoryDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Trait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.Trait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.Trait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
    }
}

extension ComprehendMedicalClientTypes.Attribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attribute(beginOffset: \(Swift.String(describing: beginOffset)), category: \(Swift.String(describing: category)), endOffset: \(Swift.String(describing: endOffset)), id: \(Swift.String(describing: id)), relationshipScore: \(Swift.String(describing: relationshipScore)), relationshipType: \(Swift.String(describing: relationshipType)), score: \(Swift.String(describing: score)), text: \(Swift.String(describing: text)), traits: \(Swift.String(describing: traits)), type: \(Swift.String(describing: type)))"}
}

extension ComprehendMedicalClientTypes {
    /// An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the dosage of a medication taken. It contains information about the attribute such as id, begin and end offset within the input text, and the segment of the input text.
    public struct Attribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of attribute.
        public var category: ComprehendMedicalClientTypes.EntityType?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public var relationshipScore: Swift.Float?
        /// The type of relationship between the entity and attribute. Type for the relationship is OVERLAP, indicating that the entity occurred at the same time as the Date_Expression.
        public var relationshipType: ComprehendMedicalClientTypes.RelationshipType?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The segment of input text extracted as this attribute.
        public var text: Swift.String?
        /// Contextual information for this attribute.
        public var traits: [ComprehendMedicalClientTypes.Trait]?
        /// The type of attribute.
        public var type: ComprehendMedicalClientTypes.EntitySubType?

        public init (
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.EntityType? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            relationshipType: ComprehendMedicalClientTypes.RelationshipType? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.Trait]? = nil,
            type: ComprehendMedicalClientTypes.EntitySubType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum AttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnosis
        case negation
        case sign
        case symptom
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeName] {
            return [
                .diagnosis,
                .negation,
                .sign,
                .symptom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnosis: return "DIAGNOSIS"
            case .negation: return "NEGATION"
            case .sign: return "SIGN"
            case .symptom: return "SYMPTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeName(rawValue: rawValue) ?? AttributeName.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = submitTimeAfter {
            try encodeContainer.encode(submitTimeAfter.timeIntervalSince1970, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = submitTimeBefore {
            try encodeContainer.encode(submitTimeBefore.timeIntervalSince1970, forKey: .submitTimeBefore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComprehendMedicalAsyncJobFilter(jobName: \(Swift.String(describing: jobName)), jobStatus: \(Swift.String(describing: jobStatus)), submitTimeAfter: \(Swift.String(describing: submitTimeAfter)), submitTimeBefore: \(Swift.String(describing: submitTimeBefore)))"}
}

extension ComprehendMedicalClientTypes {
    /// Provides information for filtering a list of detection jobs.
    public struct ComprehendMedicalAsyncJobFilter: Swift.Equatable {
        /// Filters on the name of the job.
        public var jobName: Swift.String?
        /// Filters the list of jobs based on job status. Returns only jobs with the specified status.
        public var jobStatus: ComprehendMedicalClientTypes.JobStatus?
        /// Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.
        public var submitTimeAfter: ClientRuntime.Date?
        /// Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.
        public var submitTimeBefore: ClientRuntime.Date?

        public init (
            jobName: Swift.String? = nil,
            jobStatus: ComprehendMedicalClientTypes.JobStatus? = nil,
            submitTimeAfter: ClientRuntime.Date? = nil,
            submitTimeBefore: ClientRuntime.Date? = nil
        )
        {
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.submitTimeAfter = submitTimeAfter
            self.submitTimeBefore = submitTimeBefore
        }
    }

}

extension ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case expirationTime = "ExpirationTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case manifestFilePath = "ManifestFilePath"
        case message = "Message"
        case modelVersion = "ModelVersion"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime.timeIntervalSince1970, forKey: .expirationTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let manifestFilePath = manifestFilePath {
            try encodeContainer.encode(manifestFilePath, forKey: .manifestFilePath)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let manifestFilePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestFilePath)
        manifestFilePath = manifestFilePathDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComprehendMedicalAsyncJobProperties(dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), endTime: \(Swift.String(describing: endTime)), expirationTime: \(Swift.String(describing: expirationTime)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobName: \(Swift.String(describing: jobName)), jobStatus: \(Swift.String(describing: jobStatus)), kMSKey: \(Swift.String(describing: kMSKey)), languageCode: \(Swift.String(describing: languageCode)), manifestFilePath: \(Swift.String(describing: manifestFilePath)), message: \(Swift.String(describing: message)), modelVersion: \(Swift.String(describing: modelVersion)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), submitTime: \(Swift.String(describing: submitTime)))"}
}

extension ComprehendMedicalClientTypes {
    /// Provides information about a detection job.
    public struct ComprehendMedicalAsyncJobProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that gives Amazon Comprehend Medical read access to your input data.
        public var dataAccessRoleArn: Swift.String?
        /// The time that the detection job completed.
        public var endTime: ClientRuntime.Date?
        /// The date and time that job metadata is deleted from the server. Output files in your S3 bucket will not be deleted. After the metadata is deleted, the job will no longer appear in the results of the ListEntitiesDetectionV2Job or the ListPHIDetectionJobs operation.
        public var expirationTime: ClientRuntime.Date?
        /// The input data configuration that you supplied when you created the detection job.
        public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
        /// The identifier assigned to the detection job.
        public var jobId: Swift.String?
        /// The name that you assigned to the detection job.
        public var jobName: Swift.String?
        /// The current status of the detection job. If the status is FAILED, the Message field shows the reason for the failure.
        public var jobStatus: ComprehendMedicalClientTypes.JobStatus?
        /// The AWS Key Management Service key, if any, used to encrypt the output files.
        public var kMSKey: Swift.String?
        /// The language code of the input documents.
        public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
        /// The path to the file that describes the results of a batch job.
        public var manifestFilePath: Swift.String?
        /// A description of the status of a job.
        public var message: Swift.String?
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public var modelVersion: Swift.String?
        /// The output data configuration that you supplied when you created the detection job.
        public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
        /// The time that the detection job was submitted for processing.
        public var submitTime: ClientRuntime.Date?

        public init (
            dataAccessRoleArn: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: ComprehendMedicalClientTypes.JobStatus? = nil,
            kMSKey: Swift.String? = nil,
            languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
            manifestFilePath: Swift.String? = nil,
            message: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.endTime = endTime
            self.expirationTime = expirationTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.kMSKey = kMSKey
            self.languageCode = languageCode
            self.manifestFilePath = manifestFilePath
            self.message = message
            self.modelVersion = modelVersion
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }
    }

}

public struct DescribeEntitiesDetectionV2JobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEntitiesDetectionV2JobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEntitiesDetectionV2JobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEntitiesDetectionV2JobOutputError>
}

extension DescribeEntitiesDetectionV2JobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEntitiesDetectionV2JobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeEntitiesDetectionV2JobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeEntitiesDetectionV2JobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEntitiesDetectionV2JobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEntitiesDetectionV2JobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEntitiesDetectionV2JobOutputError>
}

public struct DescribeEntitiesDetectionV2JobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEntitiesDetectionV2JobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEntitiesDetectionV2JobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEntitiesDetectionV2JobOutputError>
}

public struct DescribeEntitiesDetectionV2JobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEntitiesDetectionV2JobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeEntitiesDetectionV2JobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEntitiesDetectionV2JobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEntitiesDetectionV2JobOutputError>
}

public struct DescribeEntitiesDetectionV2JobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEntitiesDetectionV2JobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeEntitiesDetectionV2JobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEntitiesDetectionV2JobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEntitiesDetectionV2JobOutputError>
}

public struct DescribeEntitiesDetectionV2JobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartEntitiesDetectionV2Job operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeEntitiesDetectionV2JobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension DescribeEntitiesDetectionV2JobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeEntitiesDetectionV2JobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEntitiesDetectionV2JobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEntitiesDetectionV2JobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEntitiesDetectionV2JobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEntitiesDetectionV2JobOutputResponse(comprehendMedicalAsyncJobProperties: \(Swift.String(describing: comprehendMedicalAsyncJobProperties)))"}
}

extension DescribeEntitiesDetectionV2JobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEntitiesDetectionV2JobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeEntitiesDetectionV2JobOutputResponse: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeEntitiesDetectionV2JobOutputResponseBody: Swift.Equatable {
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeEntitiesDetectionV2JobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

public struct DescribeICD10CMInferenceJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeICD10CMInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeICD10CMInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeICD10CMInferenceJobOutputError>
}

extension DescribeICD10CMInferenceJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeICD10CMInferenceJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeICD10CMInferenceJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeICD10CMInferenceJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeICD10CMInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeICD10CMInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeICD10CMInferenceJobOutputError>
}

public struct DescribeICD10CMInferenceJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeICD10CMInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeICD10CMInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeICD10CMInferenceJobOutputError>
}

public struct DescribeICD10CMInferenceJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeICD10CMInferenceJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeICD10CMInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeICD10CMInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeICD10CMInferenceJobOutputError>
}

public struct DescribeICD10CMInferenceJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeICD10CMInferenceJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeICD10CMInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeICD10CMInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeICD10CMInferenceJobOutputError>
}

public struct DescribeICD10CMInferenceJobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartICD10CMInferenceJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeICD10CMInferenceJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension DescribeICD10CMInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeICD10CMInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeICD10CMInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeICD10CMInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeICD10CMInferenceJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeICD10CMInferenceJobOutputResponse(comprehendMedicalAsyncJobProperties: \(Swift.String(describing: comprehendMedicalAsyncJobProperties)))"}
}

extension DescribeICD10CMInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeICD10CMInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeICD10CMInferenceJobOutputResponse: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeICD10CMInferenceJobOutputResponseBody: Swift.Equatable {
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeICD10CMInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

public struct DescribePHIDetectionJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePHIDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePHIDetectionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePHIDetectionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePHIDetectionJobOutputError>
}

extension DescribePHIDetectionJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePHIDetectionJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribePHIDetectionJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribePHIDetectionJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePHIDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePHIDetectionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePHIDetectionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePHIDetectionJobOutputError>
}

public struct DescribePHIDetectionJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePHIDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePHIDetectionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePHIDetectionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePHIDetectionJobOutputError>
}

public struct DescribePHIDetectionJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePHIDetectionJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribePHIDetectionJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePHIDetectionJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePHIDetectionJobOutputError>
}

public struct DescribePHIDetectionJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePHIDetectionJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribePHIDetectionJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePHIDetectionJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePHIDetectionJobOutputError>
}

public struct DescribePHIDetectionJobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartPHIDetectionJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribePHIDetectionJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension DescribePHIDetectionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribePHIDetectionJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePHIDetectionJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePHIDetectionJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePHIDetectionJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePHIDetectionJobOutputResponse(comprehendMedicalAsyncJobProperties: \(Swift.String(describing: comprehendMedicalAsyncJobProperties)))"}
}

extension DescribePHIDetectionJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePHIDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribePHIDetectionJobOutputResponse: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribePHIDetectionJobOutputResponseBody: Swift.Equatable {
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribePHIDetectionJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

public struct DescribeRxNormInferenceJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRxNormInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRxNormInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRxNormInferenceJobOutputError>
}

extension DescribeRxNormInferenceJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRxNormInferenceJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeRxNormInferenceJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeRxNormInferenceJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRxNormInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRxNormInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRxNormInferenceJobOutputError>
}

public struct DescribeRxNormInferenceJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRxNormInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRxNormInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRxNormInferenceJobOutputError>
}

public struct DescribeRxNormInferenceJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRxNormInferenceJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeRxNormInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRxNormInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRxNormInferenceJobOutputError>
}

public struct DescribeRxNormInferenceJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRxNormInferenceJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeRxNormInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRxNormInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRxNormInferenceJobOutputError>
}

public struct DescribeRxNormInferenceJobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartRxNormInferenceJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeRxNormInferenceJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension DescribeRxNormInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeRxNormInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRxNormInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRxNormInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRxNormInferenceJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRxNormInferenceJobOutputResponse(comprehendMedicalAsyncJobProperties: \(Swift.String(describing: comprehendMedicalAsyncJobProperties)))"}
}

extension DescribeRxNormInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRxNormInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeRxNormInferenceJobOutputResponse: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init (
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeRxNormInferenceJobOutputResponseBody: Swift.Equatable {
    public let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeRxNormInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

public struct DetectEntitiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectEntitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectEntitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectEntitiesOutputError>
}

extension DetectEntitiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectEntitiesInput(text: \(Swift.String(describing: text)))"}
}

extension DetectEntitiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectEntitiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectEntitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectEntitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectEntitiesOutputError>
}

public struct DetectEntitiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectEntitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectEntitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectEntitiesOutputError>
}

public struct DetectEntitiesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectEntitiesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DetectEntitiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetectEntitiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectEntitiesOutputError>
}

public struct DetectEntitiesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectEntitiesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DetectEntitiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetectEntitiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetectEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectEntitiesOutputError>
}

public struct DetectEntitiesInput: Swift.Equatable {
    /// A UTF-8 text string containing the clinical content being examined for entities. Each string must contain fewer than 20,000 bytes of characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct DetectEntitiesInputBody: Swift.Equatable {
    public let text: Swift.String?
}

extension DetectEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectEntitiesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectEntitiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectEntitiesOutputResponse(entities: \(Swift.String(describing: entities)), modelVersion: \(Swift.String(describing: modelVersion)), paginationToken: \(Swift.String(describing: paginationToken)), unmappedAttributes: \(Swift.String(describing: unmappedAttributes)))"}
}

extension DetectEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetectEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
            self.unmappedAttributes = output.unmappedAttributes
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
            self.unmappedAttributes = nil
        }
    }
}

public struct DetectEntitiesOutputResponse: Swift.Equatable {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.Entity]?
    /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to DetectEntities was truncated, include the PaginationToken to fetch the next page of entities.
    public var paginationToken: Swift.String?
    /// Attributes extracted from the input text that we were unable to relate to an entity.
    public var unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?

    public init (
        entities: [ComprehendMedicalClientTypes.Entity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil,
        unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
        self.unmappedAttributes = unmappedAttributes
    }
}

struct DetectEntitiesOutputResponseBody: Swift.Equatable {
    public let entities: [ComprehendMedicalClientTypes.Entity]?
    public let unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?
    public let paginationToken: Swift.String?
    public let modelVersion: Swift.String?
}

extension DetectEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
        case unmappedAttributes = "UnmappedAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let unmappedAttributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.UnmappedAttribute?].self, forKey: .unmappedAttributes)
        var unmappedAttributesDecoded0:[ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
        if let unmappedAttributesContainer = unmappedAttributesContainer {
            unmappedAttributesDecoded0 = [ComprehendMedicalClientTypes.UnmappedAttribute]()
            for structure0 in unmappedAttributesContainer {
                if let structure0 = structure0 {
                    unmappedAttributesDecoded0?.append(structure0)
                }
            }
        }
        unmappedAttributes = unmappedAttributesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

public struct DetectEntitiesV2InputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectEntitiesV2InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectEntitiesV2Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectEntitiesV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectEntitiesV2Input>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectEntitiesV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectEntitiesV2OutputError>
}

extension DetectEntitiesV2Input: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectEntitiesV2Input(text: \(Swift.String(describing: text)))"}
}

extension DetectEntitiesV2Input: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectEntitiesV2InputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectEntitiesV2InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectEntitiesV2Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectEntitiesV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectEntitiesV2Input>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectEntitiesV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectEntitiesV2OutputError>
}

public struct DetectEntitiesV2InputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectEntitiesV2InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectEntitiesV2Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectEntitiesV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectEntitiesV2Input>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectEntitiesV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectEntitiesV2OutputError>
}

public struct DetectEntitiesV2InputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectEntitiesV2InputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DetectEntitiesV2Input,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectEntitiesV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetectEntitiesV2Input
    public typealias MOutput = ClientRuntime.OperationOutput<DetectEntitiesV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectEntitiesV2OutputError>
}

public struct DetectEntitiesV2InputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectEntitiesV2InputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DetectEntitiesV2Input,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectEntitiesV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetectEntitiesV2Input
    public typealias MOutput = ClientRuntime.OperationOutput<DetectEntitiesV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectEntitiesV2OutputError>
}

public struct DetectEntitiesV2Input: Swift.Equatable {
    /// A UTF-8 string containing the clinical content being examined for entities. Each string must contain fewer than 20,000 bytes of characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct DetectEntitiesV2InputBody: Swift.Equatable {
    public let text: Swift.String?
}

extension DetectEntitiesV2InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectEntitiesV2OutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectEntitiesV2OutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectEntitiesV2OutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectEntitiesV2OutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectEntitiesV2OutputResponse(entities: \(Swift.String(describing: entities)), modelVersion: \(Swift.String(describing: modelVersion)), paginationToken: \(Swift.String(describing: paginationToken)), unmappedAttributes: \(Swift.String(describing: unmappedAttributes)))"}
}

extension DetectEntitiesV2OutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetectEntitiesV2OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
            self.unmappedAttributes = output.unmappedAttributes
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
            self.unmappedAttributes = nil
        }
    }
}

public struct DetectEntitiesV2OutputResponse: Swift.Equatable {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence in the detection and analysis. Attributes and traits of the entity are also returned.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.Entity]?
    /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// If the result to the DetectEntitiesV2 operation was truncated, include the PaginationToken to fetch the next page of entities.
    public var paginationToken: Swift.String?
    /// Attributes extracted from the input text that couldn't be related to an entity.
    public var unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?

    public init (
        entities: [ComprehendMedicalClientTypes.Entity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil,
        unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
        self.unmappedAttributes = unmappedAttributes
    }
}

struct DetectEntitiesV2OutputResponseBody: Swift.Equatable {
    public let entities: [ComprehendMedicalClientTypes.Entity]?
    public let unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?
    public let paginationToken: Swift.String?
    public let modelVersion: Swift.String?
}

extension DetectEntitiesV2OutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
        case unmappedAttributes = "UnmappedAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let unmappedAttributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.UnmappedAttribute?].self, forKey: .unmappedAttributes)
        var unmappedAttributesDecoded0:[ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
        if let unmappedAttributesContainer = unmappedAttributesContainer {
            unmappedAttributesDecoded0 = [ComprehendMedicalClientTypes.UnmappedAttribute]()
            for structure0 in unmappedAttributesContainer {
                if let structure0 = structure0 {
                    unmappedAttributesDecoded0?.append(structure0)
                }
            }
        }
        unmappedAttributes = unmappedAttributesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

public struct DetectPHIInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectPHIInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectPHIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectPHIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectPHIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectPHIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectPHIOutputError>
}

extension DetectPHIInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectPHIInput(text: \(Swift.String(describing: text)))"}
}

extension DetectPHIInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct DetectPHIInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectPHIInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectPHIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectPHIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectPHIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectPHIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectPHIOutputError>
}

public struct DetectPHIInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectPHIInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectPHIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectPHIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectPHIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectPHIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectPHIOutputError>
}

public struct DetectPHIInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectPHIInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DetectPHIInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectPHIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetectPHIInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetectPHIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectPHIOutputError>
}

public struct DetectPHIInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectPHIInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DetectPHIInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectPHIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetectPHIInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetectPHIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectPHIOutputError>
}

public struct DetectPHIInput: Swift.Equatable {
    /// A UTF-8 text string containing the clinical content being examined for PHI entities. Each string must contain fewer than 20,000 bytes of characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct DetectPHIInputBody: Swift.Equatable {
    public let text: Swift.String?
}

extension DetectPHIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectPHIOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectPHIOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectPHIOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectPHIOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectPHIOutputResponse(entities: \(Swift.String(describing: entities)), modelVersion: \(Swift.String(describing: modelVersion)), paginationToken: \(Swift.String(describing: paginationToken)))"}
}

extension DetectPHIOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetectPHIOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct DetectPHIOutputResponse: Swift.Equatable {
    /// The collection of PHI entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in its detection.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.Entity]?
    /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to DetectPHI was truncated, include the PaginationToken to fetch the next page of PHI entities.
    public var paginationToken: Swift.String?

    public init (
        entities: [ComprehendMedicalClientTypes.Entity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct DetectPHIOutputResponseBody: Swift.Equatable {
    public let entities: [ComprehendMedicalClientTypes.Entity]?
    public let paginationToken: Swift.String?
    public let modelVersion: Swift.String?
}

extension DetectPHIOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension ComprehendMedicalClientTypes.Entity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for traitlist0 in traits {
                try traitsContainer.encode(traitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntityType.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntitySubType.self, forKey: .type)
        type = typeDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Trait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.Trait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.Trait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ComprehendMedicalClientTypes.Entity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Entity(attributes: \(Swift.String(describing: attributes)), beginOffset: \(Swift.String(describing: beginOffset)), category: \(Swift.String(describing: category)), endOffset: \(Swift.String(describing: endOffset)), id: \(Swift.String(describing: id)), score: \(Swift.String(describing: score)), text: \(Swift.String(describing: text)), traits: \(Swift.String(describing: traits)), type: \(Swift.String(describing: type)))"}
}

extension ComprehendMedicalClientTypes {
    /// Provides information about an extracted medical entity.
    public struct Entity: Swift.Equatable {
        /// The extracted attributes that relate to this entity.
        public var attributes: [ComprehendMedicalClientTypes.Attribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the entity.
        public var category: ComprehendMedicalClientTypes.EntityType?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.
        public var score: Swift.Float?
        /// The segment of input text extracted as this entity.
        public var text: Swift.String?
        /// Contextual information for the entity.
        public var traits: [ComprehendMedicalClientTypes.Trait]?
        /// Describes the specific type of entity with category of entities.
        public var type: ComprehendMedicalClientTypes.EntitySubType?

        public init (
            attributes: [ComprehendMedicalClientTypes.Attribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.EntityType? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.Trait]? = nil,
            type: ComprehendMedicalClientTypes.EntitySubType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum EntitySubType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case address
        case age
        case brandName
        case contactPoint
        case date
        case direction
        case dosage
        case duration
        case email
        case form
        case frequency
        case genericName
        case identifier
        case name
        case procedureName
        case profession
        case quality
        case quantity
        case rate
        case routeOrMode
        case strength
        case systemOrganSite
        case testName
        case testUnits
        case testValue
        case timeExpression
        case timeToDxName
        case timeToMedicationName
        case timeToProcedureName
        case timeToTestName
        case timeToTreatmentName
        case treatmentName
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitySubType] {
            return [
                .acuity,
                .address,
                .age,
                .brandName,
                .contactPoint,
                .date,
                .direction,
                .dosage,
                .duration,
                .email,
                .form,
                .frequency,
                .genericName,
                .identifier,
                .name,
                .procedureName,
                .profession,
                .quality,
                .quantity,
                .rate,
                .routeOrMode,
                .strength,
                .systemOrganSite,
                .testName,
                .testUnits,
                .testValue,
                .timeExpression,
                .timeToDxName,
                .timeToMedicationName,
                .timeToProcedureName,
                .timeToTestName,
                .timeToTreatmentName,
                .treatmentName,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .brandName: return "BRAND_NAME"
            case .contactPoint: return "CONTACT_POINT"
            case .date: return "DATE"
            case .direction: return "DIRECTION"
            case .dosage: return "DOSAGE"
            case .duration: return "DURATION"
            case .email: return "EMAIL"
            case .form: return "FORM"
            case .frequency: return "FREQUENCY"
            case .genericName: return "GENERIC_NAME"
            case .identifier: return "IDENTIFIER"
            case .name: return "NAME"
            case .procedureName: return "PROCEDURE_NAME"
            case .profession: return "PROFESSION"
            case .quality: return "QUALITY"
            case .quantity: return "QUANTITY"
            case .rate: return "RATE"
            case .routeOrMode: return "ROUTE_OR_MODE"
            case .strength: return "STRENGTH"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .testName: return "TEST_NAME"
            case .testUnits: return "TEST_UNITS"
            case .testValue: return "TEST_VALUE"
            case .timeExpression: return "TIME_EXPRESSION"
            case .timeToDxName: return "TIME_TO_DX_NAME"
            case .timeToMedicationName: return "TIME_TO_MEDICATION_NAME"
            case .timeToProcedureName: return "TIME_TO_PROCEDURE_NAME"
            case .timeToTestName: return "TIME_TO_TEST_NAME"
            case .timeToTreatmentName: return "TIME_TO_TREATMENT_NAME"
            case .treatmentName: return "TREATMENT_NAME"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntitySubType(rawValue: rawValue) ?? EntitySubType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anatomy
        case medicalCondition
        case medication
        case protectedHealthInformation
        case testTreatmentProcedure
        case timeExpression
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .anatomy,
                .medicalCondition,
                .medication,
                .protectedHealthInformation,
                .testTreatmentProcedure,
                .timeExpression,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anatomy: return "ANATOMY"
            case .medicalCondition: return "MEDICAL_CONDITION"
            case .medication: return "MEDICATION"
            case .protectedHealthInformation: return "PROTECTED_HEALTH_INFORMATION"
            case .testTreatmentProcedure: return "TEST_TREATMENT_PROCEDURE"
            case .timeExpression: return "TIME_EXPRESSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.ICD10CMAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case relationshipType = "RelationshipType"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let relationshipType = relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for icd10cmtraitlist0 in traits {
                try traitsContainer.encode(icd10cmtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMAttributeType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.ICD10CMTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.ICD10CMTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMEntityType.self, forKey: .category)
        category = categoryDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMRelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension ComprehendMedicalClientTypes.ICD10CMAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ICD10CMAttribute(beginOffset: \(Swift.String(describing: beginOffset)), category: \(Swift.String(describing: category)), endOffset: \(Swift.String(describing: endOffset)), id: \(Swift.String(describing: id)), relationshipScore: \(Swift.String(describing: relationshipScore)), relationshipType: \(Swift.String(describing: relationshipType)), score: \(Swift.String(describing: score)), text: \(Swift.String(describing: text)), traits: \(Swift.String(describing: traits)), type: \(Swift.String(describing: type)))"}
}

extension ComprehendMedicalClientTypes {
    /// The detected attributes that relate to an entity. This includes an extracted segment of the text that is an attribute of an entity, or otherwise related to an entity. InferICD10CM detects the following attributes: Direction, System, Organ or Site, and Acuity.
    public struct ICD10CMAttribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of attribute. Can be either of DX_NAME or TIME_EXPRESSION.
        public var category: ComprehendMedicalClientTypes.ICD10CMEntityType?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public var relationshipScore: Swift.Float?
        /// The type of relationship between the entity and attribute. Type for the relationship can be either of OVERLAP or SYSTEM_ORGAN_SITE.
        public var relationshipType: ComprehendMedicalClientTypes.ICD10CMRelationshipType?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The segment of input text which contains the detected attribute.
        public var text: Swift.String?
        /// The contextual information for the attribute. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
        public var traits: [ComprehendMedicalClientTypes.ICD10CMTrait]?
        /// The type of attribute. InferICD10CM detects entities of the type DX_NAME.
        public var type: ComprehendMedicalClientTypes.ICD10CMAttributeType?

        public init (
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.ICD10CMEntityType? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            relationshipType: ComprehendMedicalClientTypes.ICD10CMRelationshipType? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.ICD10CMTrait]? = nil,
            type: ComprehendMedicalClientTypes.ICD10CMAttributeType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case direction
        case quality
        case quantity
        case systemOrganSite
        case timeExpression
        case timeToDxName
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMAttributeType] {
            return [
                .acuity,
                .direction,
                .quality,
                .quantity,
                .systemOrganSite,
                .timeExpression,
                .timeToDxName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .direction: return "DIRECTION"
            case .quality: return "QUALITY"
            case .quantity: return "QUANTITY"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .timeExpression: return "TIME_EXPRESSION"
            case .timeToDxName: return "TIME_TO_DX_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMAttributeType(rawValue: rawValue) ?? ICD10CMAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.ICD10CMConcept: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case description = "Description"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes.ICD10CMConcept: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ICD10CMConcept(code: \(Swift.String(describing: code)), description: \(Swift.String(describing: description)), score: \(Swift.String(describing: score)))"}
}

extension ComprehendMedicalClientTypes {
    /// The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.
    public struct ICD10CMConcept: Swift.Equatable {
        /// The ICD-10-CM code that identifies the concept found in the knowledge base from the Centers for Disease Control.
        public var code: Swift.String?
        /// The long description of the ICD-10-CM code in the ontology.
        public var description: Swift.String?
        /// The level of confidence that Amazon Comprehend Medical has that the entity is accurately linked to an ICD-10-CM concept.
        public var score: Swift.Float?

        public init (
            code: Swift.String? = nil,
            description: Swift.String? = nil,
            score: Swift.Float? = nil
        )
        {
            self.code = code
            self.description = description
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.ICD10CMEntity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case iCD10CMConcepts = "ICD10CMConcepts"
        case id = "Id"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for icd10cmattributelist0 in attributes {
                try attributesContainer.encode(icd10cmattributelist0)
            }
        }
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let iCD10CMConcepts = iCD10CMConcepts {
            var iCD10CMConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iCD10CMConcepts)
            for icd10cmconceptlist0 in iCD10CMConcepts {
                try iCD10CMConceptsContainer.encode(icd10cmconceptlist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for icd10cmtraitlist0 in traits {
                try traitsContainer.encode(icd10cmtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMEntityType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.ICD10CMAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.ICD10CMAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.ICD10CMTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.ICD10CMTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let iCD10CMConceptsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMConcept?].self, forKey: .iCD10CMConcepts)
        var iCD10CMConceptsDecoded0:[ComprehendMedicalClientTypes.ICD10CMConcept]? = nil
        if let iCD10CMConceptsContainer = iCD10CMConceptsContainer {
            iCD10CMConceptsDecoded0 = [ComprehendMedicalClientTypes.ICD10CMConcept]()
            for structure0 in iCD10CMConceptsContainer {
                if let structure0 = structure0 {
                    iCD10CMConceptsDecoded0?.append(structure0)
                }
            }
        }
        iCD10CMConcepts = iCD10CMConceptsDecoded0
    }
}

extension ComprehendMedicalClientTypes.ICD10CMEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ICD10CMEntity(attributes: \(Swift.String(describing: attributes)), beginOffset: \(Swift.String(describing: beginOffset)), category: \(Swift.String(describing: category)), endOffset: \(Swift.String(describing: endOffset)), iCD10CMConcepts: \(Swift.String(describing: iCD10CMConcepts)), id: \(Swift.String(describing: id)), score: \(Swift.String(describing: score)), text: \(Swift.String(describing: text)), traits: \(Swift.String(describing: traits)), type: \(Swift.String(describing: type)))"}
}

extension ComprehendMedicalClientTypes {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    public struct ICD10CMEntity: Swift.Equatable {
        /// The detected attributes that relate to the entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the nature of a medical condition.
        public var attributes: [ComprehendMedicalClientTypes.ICD10CMAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the entity. InferICD10CM detects entities in the MEDICAL_CONDITION category.
        public var category: ComprehendMedicalClientTypes.ICD10CMEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public var iCD10CMConcepts: [ComprehendMedicalClientTypes.ICD10CMConcept]?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.
        public var score: Swift.Float?
        /// The segment of input text that is matched to the detected entity.
        public var text: Swift.String?
        /// Provides Contextual information for the entity. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
        public var traits: [ComprehendMedicalClientTypes.ICD10CMTrait]?
        /// Describes the specific type of entity with category of entities. InferICD10CM detects entities of the type DX_NAME and TIME_EXPRESSION.
        public var type: ComprehendMedicalClientTypes.ICD10CMEntityType?

        public init (
            attributes: [ComprehendMedicalClientTypes.ICD10CMAttribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.ICD10CMEntityCategory? = nil,
            endOffset: Swift.Int? = nil,
            iCD10CMConcepts: [ComprehendMedicalClientTypes.ICD10CMConcept]? = nil,
            id: Swift.Int? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.ICD10CMTrait]? = nil,
            type: ComprehendMedicalClientTypes.ICD10CMEntityType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.iCD10CMConcepts = iCD10CMConcepts
            self.id = id
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMEntityCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case medicalCondition
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMEntityCategory] {
            return [
                .medicalCondition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .medicalCondition: return "MEDICAL_CONDITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMEntityCategory(rawValue: rawValue) ?? ICD10CMEntityCategory.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dxName
        case timeExpression
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMEntityType] {
            return [
                .dxName,
                .timeExpression,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dxName: return "DX_NAME"
            case .timeExpression: return "TIME_EXPRESSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMEntityType(rawValue: rawValue) ?? ICD10CMEntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case overlap
        case systemOrganSite
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMRelationshipType] {
            return [
                .overlap,
                .systemOrganSite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .overlap: return "OVERLAP"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMRelationshipType(rawValue: rawValue) ?? ICD10CMRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.ICD10CMTrait: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMTraitName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes.ICD10CMTrait: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ICD10CMTrait(name: \(Swift.String(describing: name)), score: \(Swift.String(describing: score)))"}
}

extension ComprehendMedicalClientTypes {
    /// Contextual information for the entity. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
    public struct ICD10CMTrait: Swift.Equatable {
        /// Provides a name or contextual description about the trait.
        public var name: ComprehendMedicalClientTypes.ICD10CMTraitName?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as a trait.
        public var score: Swift.Float?

        public init (
            name: ComprehendMedicalClientTypes.ICD10CMTraitName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMTraitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnosis
        case negation
        case sign
        case symptom
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMTraitName] {
            return [
                .diagnosis,
                .negation,
                .sign,
                .symptom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnosis: return "DIAGNOSIS"
            case .negation: return "NEGATION"
            case .sign: return "SIGN"
            case .symptom: return "SYMPTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMTraitName(rawValue: rawValue) ?? ICD10CMTraitName.sdkUnknown(rawValue)
        }
    }
}

public struct InferICD10CMInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InferICD10CMInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InferICD10CMInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InferICD10CMOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InferICD10CMInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InferICD10CMOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InferICD10CMOutputError>
}

extension InferICD10CMInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InferICD10CMInput(text: \(Swift.String(describing: text)))"}
}

extension InferICD10CMInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct InferICD10CMInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InferICD10CMInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InferICD10CMInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InferICD10CMOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InferICD10CMInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InferICD10CMOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InferICD10CMOutputError>
}

public struct InferICD10CMInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InferICD10CMInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InferICD10CMInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InferICD10CMOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InferICD10CMInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InferICD10CMOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InferICD10CMOutputError>
}

public struct InferICD10CMInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InferICD10CMInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: InferICD10CMInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InferICD10CMOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InferICD10CMInput
    public typealias MOutput = ClientRuntime.OperationOutput<InferICD10CMOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InferICD10CMOutputError>
}

public struct InferICD10CMInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InferICD10CMInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: InferICD10CMInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InferICD10CMOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InferICD10CMInput
    public typealias MOutput = ClientRuntime.OperationOutput<InferICD10CMOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InferICD10CMOutputError>
}

public struct InferICD10CMInput: Swift.Equatable {
    /// The input text used for analysis. The input for InferICD10CM is a string from 1 to 10000 characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct InferICD10CMInputBody: Swift.Equatable {
    public let text: Swift.String?
}

extension InferICD10CMInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension InferICD10CMOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InferICD10CMOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InferICD10CMOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InferICD10CMOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InferICD10CMOutputResponse(entities: \(Swift.String(describing: entities)), modelVersion: \(Swift.String(describing: modelVersion)), paginationToken: \(Swift.String(describing: paginationToken)))"}
}

extension InferICD10CMOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InferICD10CMOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct InferICD10CMOutputResponse: Swift.Equatable {
    /// The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.ICD10CMEntity]?
    /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to InferICD10CM was truncated, include the PaginationToken to fetch the next page of medical condition entities.
    public var paginationToken: Swift.String?

    public init (
        entities: [ComprehendMedicalClientTypes.ICD10CMEntity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct InferICD10CMOutputResponseBody: Swift.Equatable {
    public let entities: [ComprehendMedicalClientTypes.ICD10CMEntity]?
    public let paginationToken: Swift.String?
    public let modelVersion: Swift.String?
}

extension InferICD10CMOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMEntity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.ICD10CMEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.ICD10CMEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

public struct InferRxNormInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InferRxNormInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InferRxNormInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InferRxNormOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InferRxNormInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InferRxNormOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InferRxNormOutputError>
}

extension InferRxNormInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InferRxNormInput(text: \(Swift.String(describing: text)))"}
}

extension InferRxNormInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct InferRxNormInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InferRxNormInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InferRxNormInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InferRxNormOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InferRxNormInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InferRxNormOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InferRxNormOutputError>
}

public struct InferRxNormInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InferRxNormInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InferRxNormInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InferRxNormOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InferRxNormInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InferRxNormOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InferRxNormOutputError>
}

public struct InferRxNormInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InferRxNormInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: InferRxNormInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InferRxNormOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InferRxNormInput
    public typealias MOutput = ClientRuntime.OperationOutput<InferRxNormOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InferRxNormOutputError>
}

public struct InferRxNormInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InferRxNormInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: InferRxNormInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InferRxNormOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InferRxNormInput
    public typealias MOutput = ClientRuntime.OperationOutput<InferRxNormOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InferRxNormOutputError>
}

public struct InferRxNormInput: Swift.Equatable {
    /// The input text used for analysis. The input for InferRxNorm is a string from 1 to 10000 characters.
    /// This member is required.
    public var text: Swift.String?

    public init (
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct InferRxNormInputBody: Swift.Equatable {
    public let text: Swift.String?
}

extension InferRxNormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension InferRxNormOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InferRxNormOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEncodingException" : self = .invalidEncodingException(try InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InferRxNormOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidEncodingException(InvalidEncodingException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InferRxNormOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InferRxNormOutputResponse(entities: \(Swift.String(describing: entities)), modelVersion: \(Swift.String(describing: modelVersion)), paginationToken: \(Swift.String(describing: paginationToken)))"}
}

extension InferRxNormOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InferRxNormOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct InferRxNormOutputResponse: Swift.Equatable {
    /// The medication entities detected in the text linked to RxNorm concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.RxNormEntity]?
    /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to InferRxNorm was truncated, include the PaginationToken to fetch the next page of medication entities.
    public var paginationToken: Swift.String?

    public init (
        entities: [ComprehendMedicalClientTypes.RxNormEntity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct InferRxNormOutputResponseBody: Swift.Equatable {
    public let entities: [ComprehendMedicalClientTypes.RxNormEntity]?
    public let paginationToken: Swift.String?
    public let modelVersion: Swift.String?
}

extension InferRxNormOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormEntity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.RxNormEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.RxNormEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension ComprehendMedicalClientTypes.InputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension ComprehendMedicalClientTypes.InputDataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputDataConfig(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)))"}
}

extension ComprehendMedicalClientTypes {
    /// The input properties for an entities detection job. This includes the name of the S3 bucket and the path to the files to be analyzed.
    public struct InputDataConfig: Swift.Equatable {
        /// The URI of the S3 bucket that contains the input data. The bucket must be in the same region as the API endpoint that you are calling. Each file in the document collection must be less than 40 KB. You can store a maximum of 30 GB in the bucket.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The path to the input data files in the S3 bucket.
        public var s3Key: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEncodingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidEncodingException(message: \(Swift.String(describing: message)))"}
}

extension InvalidEncodingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidEncodingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input text was not in valid UTF-8 character encoding. Check your text then retry your request.
public struct InvalidEncodingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEncodingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidEncodingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request that you made is invalid. Check your request to determine why it's invalid and then retry the request.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ComprehendMedicalClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case partialSuccess
        case stopped
        case stopRequested
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .partialSuccess,
                .stopped,
                .stopRequested,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .partialSuccess: return "PARTIAL_SUCCESS"
            case .stopped: return "STOPPED"
            case .stopRequested: return "STOP_REQUESTED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case en
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .en,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .en: return "en"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
        }
    }
}

public struct ListEntitiesDetectionV2JobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEntitiesDetectionV2JobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEntitiesDetectionV2JobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEntitiesDetectionV2JobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEntitiesDetectionV2JobsOutputError>
}

extension ListEntitiesDetectionV2JobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEntitiesDetectionV2JobsInput(filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEntitiesDetectionV2JobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEntitiesDetectionV2JobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEntitiesDetectionV2JobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEntitiesDetectionV2JobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEntitiesDetectionV2JobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEntitiesDetectionV2JobsOutputError>
}

public struct ListEntitiesDetectionV2JobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEntitiesDetectionV2JobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEntitiesDetectionV2JobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEntitiesDetectionV2JobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEntitiesDetectionV2JobsOutputError>
}

public struct ListEntitiesDetectionV2JobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEntitiesDetectionV2JobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEntitiesDetectionV2JobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEntitiesDetectionV2JobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEntitiesDetectionV2JobsOutputError>
}

public struct ListEntitiesDetectionV2JobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEntitiesDetectionV2JobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEntitiesDetectionV2JobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEntitiesDetectionV2JobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEntitiesDetectionV2JobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEntitiesDetectionV2JobsOutputError>
}

public struct ListEntitiesDetectionV2JobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEntitiesDetectionV2JobsInputBody: Swift.Equatable {
    public let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListEntitiesDetectionV2JobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEntitiesDetectionV2JobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntitiesDetectionV2JobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEntitiesDetectionV2JobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitiesDetectionV2JobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEntitiesDetectionV2JobsOutputResponse(comprehendMedicalAsyncJobPropertiesList: \(Swift.String(describing: comprehendMedicalAsyncJobPropertiesList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEntitiesDetectionV2JobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEntitiesDetectionV2JobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesDetectionV2JobsOutputResponse: Swift.Equatable {
    /// A list containing the properties of each job returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListEntitiesDetectionV2JobsOutputResponseBody: Swift.Equatable {
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    public let nextToken: Swift.String?
}

extension ListEntitiesDetectionV2JobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListICD10CMInferenceJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListICD10CMInferenceJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListICD10CMInferenceJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListICD10CMInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListICD10CMInferenceJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListICD10CMInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListICD10CMInferenceJobsOutputError>
}

extension ListICD10CMInferenceJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListICD10CMInferenceJobsInput(filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListICD10CMInferenceJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListICD10CMInferenceJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListICD10CMInferenceJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListICD10CMInferenceJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListICD10CMInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListICD10CMInferenceJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListICD10CMInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListICD10CMInferenceJobsOutputError>
}

public struct ListICD10CMInferenceJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListICD10CMInferenceJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListICD10CMInferenceJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListICD10CMInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListICD10CMInferenceJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListICD10CMInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListICD10CMInferenceJobsOutputError>
}

public struct ListICD10CMInferenceJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListICD10CMInferenceJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListICD10CMInferenceJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListICD10CMInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListICD10CMInferenceJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListICD10CMInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListICD10CMInferenceJobsOutputError>
}

public struct ListICD10CMInferenceJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListICD10CMInferenceJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListICD10CMInferenceJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListICD10CMInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListICD10CMInferenceJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListICD10CMInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListICD10CMInferenceJobsOutputError>
}

public struct ListICD10CMInferenceJobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListICD10CMInferenceJobsInputBody: Swift.Equatable {
    public let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListICD10CMInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListICD10CMInferenceJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListICD10CMInferenceJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListICD10CMInferenceJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListICD10CMInferenceJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListICD10CMInferenceJobsOutputResponse(comprehendMedicalAsyncJobPropertiesList: \(Swift.String(describing: comprehendMedicalAsyncJobPropertiesList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListICD10CMInferenceJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListICD10CMInferenceJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListICD10CMInferenceJobsOutputResponse: Swift.Equatable {
    /// A list containing the properties of each job that is returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListICD10CMInferenceJobsOutputResponseBody: Swift.Equatable {
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    public let nextToken: Swift.String?
}

extension ListICD10CMInferenceJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPHIDetectionJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPHIDetectionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPHIDetectionJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPHIDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPHIDetectionJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPHIDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPHIDetectionJobsOutputError>
}

extension ListPHIDetectionJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPHIDetectionJobsInput(filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPHIDetectionJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPHIDetectionJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPHIDetectionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPHIDetectionJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPHIDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPHIDetectionJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPHIDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPHIDetectionJobsOutputError>
}

public struct ListPHIDetectionJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPHIDetectionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPHIDetectionJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPHIDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPHIDetectionJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPHIDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPHIDetectionJobsOutputError>
}

public struct ListPHIDetectionJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPHIDetectionJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPHIDetectionJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPHIDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPHIDetectionJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPHIDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPHIDetectionJobsOutputError>
}

public struct ListPHIDetectionJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPHIDetectionJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPHIDetectionJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPHIDetectionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPHIDetectionJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPHIDetectionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPHIDetectionJobsOutputError>
}

public struct ListPHIDetectionJobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPHIDetectionJobsInputBody: Swift.Equatable {
    public let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPHIDetectionJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPHIDetectionJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPHIDetectionJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPHIDetectionJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPHIDetectionJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPHIDetectionJobsOutputResponse(comprehendMedicalAsyncJobPropertiesList: \(Swift.String(describing: comprehendMedicalAsyncJobPropertiesList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPHIDetectionJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPHIDetectionJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListPHIDetectionJobsOutputResponse: Swift.Equatable {
    /// A list containing the properties of each job returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListPHIDetectionJobsOutputResponseBody: Swift.Equatable {
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    public let nextToken: Swift.String?
}

extension ListPHIDetectionJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRxNormInferenceJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRxNormInferenceJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRxNormInferenceJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRxNormInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRxNormInferenceJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRxNormInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRxNormInferenceJobsOutputError>
}

extension ListRxNormInferenceJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRxNormInferenceJobsInput(filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRxNormInferenceJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRxNormInferenceJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRxNormInferenceJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRxNormInferenceJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRxNormInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRxNormInferenceJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRxNormInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRxNormInferenceJobsOutputError>
}

public struct ListRxNormInferenceJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRxNormInferenceJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRxNormInferenceJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRxNormInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRxNormInferenceJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRxNormInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRxNormInferenceJobsOutputError>
}

public struct ListRxNormInferenceJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRxNormInferenceJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRxNormInferenceJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRxNormInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRxNormInferenceJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRxNormInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRxNormInferenceJobsOutputError>
}

public struct ListRxNormInferenceJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRxNormInferenceJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRxNormInferenceJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRxNormInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRxNormInferenceJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRxNormInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRxNormInferenceJobsOutputError>
}

public struct ListRxNormInferenceJobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// Identifies the next page of results to return.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRxNormInferenceJobsInputBody: Swift.Equatable {
    public let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListRxNormInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRxNormInferenceJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRxNormInferenceJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRxNormInferenceJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRxNormInferenceJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRxNormInferenceJobsOutputResponse(comprehendMedicalAsyncJobPropertiesList: \(Swift.String(describing: comprehendMedicalAsyncJobPropertiesList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRxNormInferenceJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRxNormInferenceJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListRxNormInferenceJobsOutputResponse: Swift.Equatable {
    /// The maximum number of results to return in each page. The default is 100.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init (
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListRxNormInferenceJobsOutputResponseBody: Swift.Equatable {
    public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    public let nextToken: Swift.String?
}

extension ListRxNormInferenceJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ComprehendMedicalClientTypes.OutputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension ComprehendMedicalClientTypes.OutputDataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputDataConfig(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)))"}
}

extension ComprehendMedicalClientTypes {
    /// The output properties for a detection job.
    public struct OutputDataConfig: Swift.Equatable {
        /// When you use the OutputDataConfig object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of the output.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The path to the output data files in the S3 bucket. Amazon Comprehend Medical creates an output directory using the job ID so that the output from one job does not overwrite the output of another.
        public var s3Key: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case administeredVia
        case direction
        case dosage
        case duration
        case every
        case `for`
        case form
        case frequency
        case negative
        case overlap
        case rate
        case routeOrMode
        case strength
        case systemOrganSite
        case testUnits
        case testValue
        case withDosage
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationshipType] {
            return [
                .acuity,
                .administeredVia,
                .direction,
                .dosage,
                .duration,
                .every,
                .for,
                .form,
                .frequency,
                .negative,
                .overlap,
                .rate,
                .routeOrMode,
                .strength,
                .systemOrganSite,
                .testUnits,
                .testValue,
                .withDosage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .administeredVia: return "ADMINISTERED_VIA"
            case .direction: return "DIRECTION"
            case .dosage: return "DOSAGE"
            case .duration: return "DURATION"
            case .every: return "EVERY"
            case .for: return "FOR"
            case .form: return "FORM"
            case .frequency: return "FREQUENCY"
            case .negative: return "NEGATIVE"
            case .overlap: return "OVERLAP"
            case .rate: return "RATE"
            case .routeOrMode: return "ROUTE_OR_MODE"
            case .strength: return "STRENGTH"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .testUnits: return "TEST_UNITS"
            case .testValue: return "TEST_VALUE"
            case .withDosage: return "WITH_DOSAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationshipType(rawValue: rawValue) ?? RelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource identified by the specified Amazon Resource Name (ARN) was not found. Check the ARN and try your request again.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ComprehendMedicalClientTypes.RxNormAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for rxnormtraitlist0 in traits {
                try traitsContainer.encode(rxnormtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormAttributeType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.RxNormTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.RxNormTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
    }
}

extension ComprehendMedicalClientTypes.RxNormAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RxNormAttribute(beginOffset: \(Swift.String(describing: beginOffset)), endOffset: \(Swift.String(describing: endOffset)), id: \(Swift.String(describing: id)), relationshipScore: \(Swift.String(describing: relationshipScore)), score: \(Swift.String(describing: score)), text: \(Swift.String(describing: text)), traits: \(Swift.String(describing: traits)), type: \(Swift.String(describing: type)))"}
}

extension ComprehendMedicalClientTypes {
    /// The extracted attributes that relate to this entity. The attributes recognized by InferRxNorm are DOSAGE, DURATION, FORM, FREQUENCY, RATE, ROUTE_OR_MODE.
    public struct RxNormAttribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has that the attribute is accurately linked to an entity.
        public var relationshipScore: Swift.Float?
        /// The level of confidence that Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The segment of input text which corresponds to the detected attribute.
        public var text: Swift.String?
        /// Contextual information for the attribute. InferRxNorm recognizes the trait NEGATION for attributes, i.e. that the patient is not taking a specific dose or form of a medication.
        public var traits: [ComprehendMedicalClientTypes.RxNormTrait]?
        /// The type of attribute. The types of attributes recognized by InferRxNorm are BRAND_NAME and GENERIC_NAME.
        public var type: ComprehendMedicalClientTypes.RxNormAttributeType?

        public init (
            beginOffset: Swift.Int? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.RxNormTrait]? = nil,
            type: ComprehendMedicalClientTypes.RxNormAttributeType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RxNormAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dosage
        case duration
        case form
        case frequency
        case rate
        case routeOrMode
        case strength
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormAttributeType] {
            return [
                .dosage,
                .duration,
                .form,
                .frequency,
                .rate,
                .routeOrMode,
                .strength,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dosage: return "DOSAGE"
            case .duration: return "DURATION"
            case .form: return "FORM"
            case .frequency: return "FREQUENCY"
            case .rate: return "RATE"
            case .routeOrMode: return "ROUTE_OR_MODE"
            case .strength: return "STRENGTH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormAttributeType(rawValue: rawValue) ?? RxNormAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.RxNormConcept: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case description = "Description"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes.RxNormConcept: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RxNormConcept(code: \(Swift.String(describing: code)), description: \(Swift.String(describing: description)), score: \(Swift.String(describing: score)))"}
}

extension ComprehendMedicalClientTypes {
    /// The RxNorm concept that the entity could refer to, along with a score indicating the likelihood of the match.
    public struct RxNormConcept: Swift.Equatable {
        /// RxNorm concept ID, also known as the RxCUI.
        public var code: Swift.String?
        /// The description of the RxNorm concept.
        public var description: Swift.String?
        /// The level of confidence that Amazon Comprehend Medical has that the entity is accurately linked to the reported RxNorm concept.
        public var score: Swift.Float?

        public init (
            code: Swift.String? = nil,
            description: Swift.String? = nil,
            score: Swift.Float? = nil
        )
        {
            self.code = code
            self.description = description
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.RxNormEntity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case rxNormConcepts = "RxNormConcepts"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for rxnormattributelist0 in attributes {
                try attributesContainer.encode(rxnormattributelist0)
            }
        }
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let rxNormConcepts = rxNormConcepts {
            var rxNormConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rxNormConcepts)
            for rxnormconceptlist0 in rxNormConcepts {
                try rxNormConceptsContainer.encode(rxnormconceptlist0)
            }
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for rxnormtraitlist0 in traits {
                try traitsContainer.encode(rxnormtraitlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormEntityType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.RxNormAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.RxNormAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.RxNormTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.RxNormTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let rxNormConceptsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormConcept?].self, forKey: .rxNormConcepts)
        var rxNormConceptsDecoded0:[ComprehendMedicalClientTypes.RxNormConcept]? = nil
        if let rxNormConceptsContainer = rxNormConceptsContainer {
            rxNormConceptsDecoded0 = [ComprehendMedicalClientTypes.RxNormConcept]()
            for structure0 in rxNormConceptsContainer {
                if let structure0 = structure0 {
                    rxNormConceptsDecoded0?.append(structure0)
                }
            }
        }
        rxNormConcepts = rxNormConceptsDecoded0
    }
}

extension ComprehendMedicalClientTypes.RxNormEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RxNormEntity(attributes: \(Swift.String(describing: attributes)), beginOffset: \(Swift.String(describing: beginOffset)), category: \(Swift.String(describing: category)), endOffset: \(Swift.String(describing: endOffset)), id: \(Swift.String(describing: id)), rxNormConcepts: \(Swift.String(describing: rxNormConcepts)), score: \(Swift.String(describing: score)), text: \(Swift.String(describing: text)), traits: \(Swift.String(describing: traits)), type: \(Swift.String(describing: type)))"}
}

extension ComprehendMedicalClientTypes {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    public struct RxNormEntity: Swift.Equatable {
        /// The extracted attributes that relate to the entity. The attributes recognized by InferRxNorm are DOSAGE, DURATION, FORM, FREQUENCY, RATE, ROUTE_OR_MODE, and STRENGTH.
        public var attributes: [ComprehendMedicalClientTypes.RxNormAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the entity. The recognized categories are GENERIC or BRAND_NAME.
        public var category: ComprehendMedicalClientTypes.RxNormEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The RxNorm concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public var rxNormConcepts: [ComprehendMedicalClientTypes.RxNormConcept]?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.
        public var score: Swift.Float?
        /// The segment of input text extracted from which the entity was detected.
        public var text: Swift.String?
        /// Contextual information for the entity.
        public var traits: [ComprehendMedicalClientTypes.RxNormTrait]?
        /// Describes the specific type of entity. For InferRxNorm, the recognized entity type is MEDICATION.
        public var type: ComprehendMedicalClientTypes.RxNormEntityType?

        public init (
            attributes: [ComprehendMedicalClientTypes.RxNormAttribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.RxNormEntityCategory? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            rxNormConcepts: [ComprehendMedicalClientTypes.RxNormConcept]? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.RxNormTrait]? = nil,
            type: ComprehendMedicalClientTypes.RxNormEntityType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.rxNormConcepts = rxNormConcepts
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RxNormEntityCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case medication
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormEntityCategory] {
            return [
                .medication,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .medication: return "MEDICATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormEntityCategory(rawValue: rawValue) ?? RxNormEntityCategory.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum RxNormEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case brandName
        case genericName
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormEntityType] {
            return [
                .brandName,
                .genericName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .brandName: return "BRAND_NAME"
            case .genericName: return "GENERIC_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormEntityType(rawValue: rawValue) ?? RxNormEntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.RxNormTrait: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormTraitName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes.RxNormTrait: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RxNormTrait(name: \(Swift.String(describing: name)), score: \(Swift.String(describing: score)))"}
}

extension ComprehendMedicalClientTypes {
    /// The contextual information for the entity. InferRxNorm recognizes the trait NEGATION, which is any indication that the patient is not taking a medication.
    public struct RxNormTrait: Swift.Equatable {
        /// Provides a name or contextual description about the trait.
        public var name: ComprehendMedicalClientTypes.RxNormTraitName?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected trait.
        public var score: Swift.Float?

        public init (
            name: ComprehendMedicalClientTypes.RxNormTraitName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RxNormTraitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case negation
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormTraitName] {
            return [
                .negation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .negation: return "NEGATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormTraitName(rawValue: rawValue) ?? RxNormTraitName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Comprehend Medical service is temporarily unavailable. Please wait and then retry your request.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartEntitiesDetectionV2JobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartEntitiesDetectionV2JobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartEntitiesDetectionV2JobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartEntitiesDetectionV2JobOutputError>
}

extension StartEntitiesDetectionV2JobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartEntitiesDetectionV2JobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobName: \(Swift.String(describing: jobName)), kMSKey: \(Swift.String(describing: kMSKey)), languageCode: \(Swift.String(describing: languageCode)), outputDataConfig: \(Swift.String(describing: outputDataConfig)))"}
}

extension StartEntitiesDetectionV2JobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartEntitiesDetectionV2JobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartEntitiesDetectionV2JobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartEntitiesDetectionV2JobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartEntitiesDetectionV2JobOutputError>
}

public struct StartEntitiesDetectionV2JobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartEntitiesDetectionV2JobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartEntitiesDetectionV2JobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartEntitiesDetectionV2JobOutputError>
}

public struct StartEntitiesDetectionV2JobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartEntitiesDetectionV2JobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartEntitiesDetectionV2JobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartEntitiesDetectionV2JobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartEntitiesDetectionV2JobOutputError>
}

public struct StartEntitiesDetectionV2JobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartEntitiesDetectionV2JobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartEntitiesDetectionV2JobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartEntitiesDetectionV2JobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartEntitiesDetectionV2JobOutputError>
}

public struct StartEntitiesDetectionV2JobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// Specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kMSKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// Specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kMSKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartEntitiesDetectionV2JobInputBody: Swift.Equatable {
    public let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    public let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    public let dataAccessRoleArn: Swift.String?
    public let jobName: Swift.String?
    public let clientRequestToken: Swift.String?
    public let kMSKey: Swift.String?
    public let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartEntitiesDetectionV2JobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartEntitiesDetectionV2JobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartEntitiesDetectionV2JobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartEntitiesDetectionV2JobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartEntitiesDetectionV2JobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartEntitiesDetectionV2JobOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StartEntitiesDetectionV2JobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartEntitiesDetectionV2JobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartEntitiesDetectionV2JobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the DescribeEntitiesDetectionV2Job operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartEntitiesDetectionV2JobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StartEntitiesDetectionV2JobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StartICD10CMInferenceJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartICD10CMInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartICD10CMInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartICD10CMInferenceJobOutputError>
}

extension StartICD10CMInferenceJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartICD10CMInferenceJobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobName: \(Swift.String(describing: jobName)), kMSKey: \(Swift.String(describing: kMSKey)), languageCode: \(Swift.String(describing: languageCode)), outputDataConfig: \(Swift.String(describing: outputDataConfig)))"}
}

extension StartICD10CMInferenceJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartICD10CMInferenceJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartICD10CMInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartICD10CMInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartICD10CMInferenceJobOutputError>
}

public struct StartICD10CMInferenceJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartICD10CMInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartICD10CMInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartICD10CMInferenceJobOutputError>
}

public struct StartICD10CMInferenceJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartICD10CMInferenceJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartICD10CMInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartICD10CMInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartICD10CMInferenceJobOutputError>
}

public struct StartICD10CMInferenceJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartICD10CMInferenceJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartICD10CMInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartICD10CMInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartICD10CMInferenceJobOutputError>
}

public struct StartICD10CMInferenceJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// Specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kMSKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// Specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kMSKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartICD10CMInferenceJobInputBody: Swift.Equatable {
    public let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    public let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    public let dataAccessRoleArn: Swift.String?
    public let jobName: Swift.String?
    public let clientRequestToken: Swift.String?
    public let kMSKey: Swift.String?
    public let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartICD10CMInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartICD10CMInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartICD10CMInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartICD10CMInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartICD10CMInferenceJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartICD10CMInferenceJobOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StartICD10CMInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartICD10CMInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartICD10CMInferenceJobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the StartICD10CMInferenceJob operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartICD10CMInferenceJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StartICD10CMInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StartPHIDetectionJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPHIDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPHIDetectionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPHIDetectionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPHIDetectionJobOutputError>
}

extension StartPHIDetectionJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartPHIDetectionJobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobName: \(Swift.String(describing: jobName)), kMSKey: \(Swift.String(describing: kMSKey)), languageCode: \(Swift.String(describing: languageCode)), outputDataConfig: \(Swift.String(describing: outputDataConfig)))"}
}

extension StartPHIDetectionJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartPHIDetectionJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPHIDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPHIDetectionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPHIDetectionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPHIDetectionJobOutputError>
}

public struct StartPHIDetectionJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPHIDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPHIDetectionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPHIDetectionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPHIDetectionJobOutputError>
}

public struct StartPHIDetectionJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPHIDetectionJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartPHIDetectionJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartPHIDetectionJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPHIDetectionJobOutputError>
}

public struct StartPHIDetectionJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPHIDetectionJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartPHIDetectionJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartPHIDetectionJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPHIDetectionJobOutputError>
}

public struct StartPHIDetectionJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// Specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kMSKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// Specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kMSKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartPHIDetectionJobInputBody: Swift.Equatable {
    public let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    public let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    public let dataAccessRoleArn: Swift.String?
    public let jobName: Swift.String?
    public let clientRequestToken: Swift.String?
    public let kMSKey: Swift.String?
    public let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartPHIDetectionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartPHIDetectionJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPHIDetectionJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartPHIDetectionJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPHIDetectionJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartPHIDetectionJobOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StartPHIDetectionJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartPHIDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartPHIDetectionJobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the DescribePHIDetectionJob operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartPHIDetectionJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StartPHIDetectionJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StartRxNormInferenceJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRxNormInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartRxNormInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRxNormInferenceJobOutputError>
}

extension StartRxNormInferenceJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartRxNormInferenceJobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobName: \(Swift.String(describing: jobName)), kMSKey: \(Swift.String(describing: kMSKey)), languageCode: \(Swift.String(describing: languageCode)), outputDataConfig: \(Swift.String(describing: outputDataConfig)))"}
}

extension StartRxNormInferenceJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartRxNormInferenceJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRxNormInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartRxNormInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRxNormInferenceJobOutputError>
}

public struct StartRxNormInferenceJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRxNormInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartRxNormInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRxNormInferenceJobOutputError>
}

public struct StartRxNormInferenceJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRxNormInferenceJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartRxNormInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartRxNormInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRxNormInferenceJobOutputError>
}

public struct StartRxNormInferenceJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRxNormInferenceJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartRxNormInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartRxNormInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRxNormInferenceJobOutputError>
}

public struct StartRxNormInferenceJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// Specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kMSKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// Specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kMSKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kMSKey = kMSKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartRxNormInferenceJobInputBody: Swift.Equatable {
    public let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    public let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    public let dataAccessRoleArn: Swift.String?
    public let jobName: Swift.String?
    public let clientRequestToken: Swift.String?
    public let kMSKey: Swift.String?
    public let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartRxNormInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kMSKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartRxNormInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRxNormInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartRxNormInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRxNormInferenceJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartRxNormInferenceJobOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StartRxNormInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartRxNormInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartRxNormInferenceJobOutputResponse: Swift.Equatable {
    /// The identifier of the job.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartRxNormInferenceJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StartRxNormInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StopEntitiesDetectionV2JobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopEntitiesDetectionV2JobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopEntitiesDetectionV2JobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopEntitiesDetectionV2JobOutputError>
}

extension StopEntitiesDetectionV2JobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopEntitiesDetectionV2JobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension StopEntitiesDetectionV2JobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopEntitiesDetectionV2JobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopEntitiesDetectionV2JobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopEntitiesDetectionV2JobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopEntitiesDetectionV2JobOutputError>
}

public struct StopEntitiesDetectionV2JobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopEntitiesDetectionV2JobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopEntitiesDetectionV2JobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopEntitiesDetectionV2JobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopEntitiesDetectionV2JobOutputError>
}

public struct StopEntitiesDetectionV2JobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopEntitiesDetectionV2JobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopEntitiesDetectionV2JobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopEntitiesDetectionV2JobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopEntitiesDetectionV2JobOutputError>
}

public struct StopEntitiesDetectionV2JobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopEntitiesDetectionV2JobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopEntitiesDetectionV2JobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopEntitiesDetectionV2JobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopEntitiesDetectionV2JobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopEntitiesDetectionV2JobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopEntitiesDetectionV2JobOutputError>
}

public struct StopEntitiesDetectionV2JobInput: Swift.Equatable {
    /// The identifier of the medical entities job to stop.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopEntitiesDetectionV2JobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StopEntitiesDetectionV2JobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopEntitiesDetectionV2JobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopEntitiesDetectionV2JobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopEntitiesDetectionV2JobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopEntitiesDetectionV2JobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopEntitiesDetectionV2JobOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StopEntitiesDetectionV2JobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopEntitiesDetectionV2JobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopEntitiesDetectionV2JobOutputResponse: Swift.Equatable {
    /// The identifier of the medical entities detection job that was stopped.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopEntitiesDetectionV2JobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StopEntitiesDetectionV2JobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StopICD10CMInferenceJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopICD10CMInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopICD10CMInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopICD10CMInferenceJobOutputError>
}

extension StopICD10CMInferenceJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopICD10CMInferenceJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension StopICD10CMInferenceJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopICD10CMInferenceJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopICD10CMInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopICD10CMInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopICD10CMInferenceJobOutputError>
}

public struct StopICD10CMInferenceJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopICD10CMInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopICD10CMInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopICD10CMInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopICD10CMInferenceJobOutputError>
}

public struct StopICD10CMInferenceJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopICD10CMInferenceJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopICD10CMInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopICD10CMInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopICD10CMInferenceJobOutputError>
}

public struct StopICD10CMInferenceJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopICD10CMInferenceJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopICD10CMInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopICD10CMInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopICD10CMInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopICD10CMInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopICD10CMInferenceJobOutputError>
}

public struct StopICD10CMInferenceJobInput: Swift.Equatable {
    /// The identifier of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopICD10CMInferenceJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StopICD10CMInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopICD10CMInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopICD10CMInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopICD10CMInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopICD10CMInferenceJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopICD10CMInferenceJobOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StopICD10CMInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopICD10CMInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopICD10CMInferenceJobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeICD10CMInferenceJob operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopICD10CMInferenceJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StopICD10CMInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StopPHIDetectionJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopPHIDetectionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopPHIDetectionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopPHIDetectionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopPHIDetectionJobOutputError>
}

extension StopPHIDetectionJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopPHIDetectionJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension StopPHIDetectionJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopPHIDetectionJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopPHIDetectionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopPHIDetectionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopPHIDetectionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopPHIDetectionJobOutputError>
}

public struct StopPHIDetectionJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopPHIDetectionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopPHIDetectionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopPHIDetectionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopPHIDetectionJobOutputError>
}

public struct StopPHIDetectionJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopPHIDetectionJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopPHIDetectionJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopPHIDetectionJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopPHIDetectionJobOutputError>
}

public struct StopPHIDetectionJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopPHIDetectionJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopPHIDetectionJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopPHIDetectionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopPHIDetectionJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopPHIDetectionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopPHIDetectionJobOutputError>
}

public struct StopPHIDetectionJobInput: Swift.Equatable {
    /// The identifier of the PHI detection job to stop.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopPHIDetectionJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StopPHIDetectionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopPHIDetectionJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopPHIDetectionJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopPHIDetectionJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopPHIDetectionJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopPHIDetectionJobOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StopPHIDetectionJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopPHIDetectionJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopPHIDetectionJobOutputResponse: Swift.Equatable {
    /// The identifier of the PHI detection job that was stopped.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopPHIDetectionJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StopPHIDetectionJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StopRxNormInferenceJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRxNormInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopRxNormInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRxNormInferenceJobOutputError>
}

extension StopRxNormInferenceJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopRxNormInferenceJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension StopRxNormInferenceJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopRxNormInferenceJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRxNormInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopRxNormInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRxNormInferenceJobOutputError>
}

public struct StopRxNormInferenceJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRxNormInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopRxNormInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopRxNormInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRxNormInferenceJobOutputError>
}

public struct StopRxNormInferenceJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRxNormInferenceJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopRxNormInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopRxNormInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRxNormInferenceJobOutputError>
}

public struct StopRxNormInferenceJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRxNormInferenceJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopRxNormInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRxNormInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopRxNormInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopRxNormInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRxNormInferenceJobOutputError>
}

public struct StopRxNormInferenceJobInput: Swift.Equatable {
    /// The identifier of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopRxNormInferenceJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StopRxNormInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopRxNormInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopRxNormInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopRxNormInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopRxNormInferenceJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopRxNormInferenceJobOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StopRxNormInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopRxNormInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopRxNormInferenceJobOutputResponse: Swift.Equatable {
    /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeRxNormInferenceJob operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopRxNormInferenceJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StopRxNormInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension TextSizeLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextSizeLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension TextSizeLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TextSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The size of the text you submitted exceeds the size limit. Reduce the size of the text or use a smaller document and then retry your request.
public struct TextSizeLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TextSizeLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TextSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have made too many requests within a short period of time. Wait for a short time and then try your request again. Contact customer support for more information about a service limit increase.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ComprehendMedicalClientTypes.Trait: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.AttributeName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes.Trait: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Trait(name: \(Swift.String(describing: name)), score: \(Swift.String(describing: score)))"}
}

extension ComprehendMedicalClientTypes {
    /// Provides contextual information about the extracted entity.
    public struct Trait: Swift.Equatable {
        /// Provides a name or contextual description about the trait.
        public var name: ComprehendMedicalClientTypes.AttributeName?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of this trait.
        public var score: Swift.Float?

        public init (
            name: ComprehendMedicalClientTypes.AttributeName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.UnmappedAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntityType.self, forKey: .type)
        type = typeDecoded
        let attributeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
    }
}

extension ComprehendMedicalClientTypes.UnmappedAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnmappedAttribute(attribute: \(Swift.String(describing: attribute)), type: \(Swift.String(describing: type)))"}
}

extension ComprehendMedicalClientTypes {
    /// An attribute that we extracted, but were unable to relate to an entity.
    public struct UnmappedAttribute: Swift.Equatable {
        /// The specific attribute that has been extracted but not mapped to an entity.
        public var attribute: ComprehendMedicalClientTypes.Attribute?
        /// The type of the attribute, could be one of the following values: "MEDICATION", "MEDICAL_CONDITION", "ANATOMY", "TEST_AND_TREATMENT_PROCEDURE" or "PROTECTED_HEALTH_INFORMATION".
        public var type: ComprehendMedicalClientTypes.EntityType?

        public init (
            attribute: ComprehendMedicalClientTypes.Attribute? = nil,
            type: ComprehendMedicalClientTypes.EntityType? = nil
        )
        {
            self.attribute = attribute
            self.type = type
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The filter that you specified for the operation is invalid. Check the filter values that you entered and try your request again.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
