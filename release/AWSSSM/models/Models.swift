// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SsmClientTypes.AccountSharingInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case sharedDocumentVersion = "SharedDocumentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let sharedDocumentVersion = sharedDocumentVersion {
            try encodeContainer.encode(sharedDocumentVersion, forKey: .sharedDocumentVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let sharedDocumentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedDocumentVersion)
        sharedDocumentVersion = sharedDocumentVersionDecoded
    }
}

extension SsmClientTypes.AccountSharingInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountSharingInfo(accountId: \(Swift.String(describing: accountId)), sharedDocumentVersion: \(Swift.String(describing: sharedDocumentVersion)))"}
}

extension SsmClientTypes {
    /// Information includes the Amazon Web Services account ID where the current document is shared and the version shared with that account.
    public struct AccountSharingInfo: Swift.Equatable {
        /// The Amazon Web Services account ID where the current document is shared.
        public var accountId: Swift.String?
        /// The version of the current document shared with the account.
        public var sharedDocumentVersion: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            sharedDocumentVersion: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.sharedDocumentVersion = sharedDocumentVersion
        }
    }

}

extension SsmClientTypes.Activation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationId = "ActivationId"
        case createdDate = "CreatedDate"
        case defaultInstanceName = "DefaultInstanceName"
        case description = "Description"
        case expirationDate = "ExpirationDate"
        case expired = "Expired"
        case iamRole = "IamRole"
        case registrationLimit = "RegistrationLimit"
        case registrationsCount = "RegistrationsCount"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationId = activationId {
            try encodeContainer.encode(activationId, forKey: .activationId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let defaultInstanceName = defaultInstanceName {
            try encodeContainer.encode(defaultInstanceName, forKey: .defaultInstanceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if expired != false {
            try encodeContainer.encode(expired, forKey: .expired)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if registrationLimit != 0 {
            try encodeContainer.encode(registrationLimit, forKey: .registrationLimit)
        }
        if registrationsCount != 0 {
            try encodeContainer.encode(registrationsCount, forKey: .registrationsCount)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationId)
        activationId = activationIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceName)
        defaultInstanceName = defaultInstanceNameDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let registrationLimitDecoded = try containerValues.decode(Swift.Int.self, forKey: .registrationLimit)
        registrationLimit = registrationLimitDecoded
        let registrationsCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .registrationsCount)
        registrationsCount = registrationsCountDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let expiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .expired)
        expired = expiredDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SsmClientTypes.Activation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Activation(activationId: \(Swift.String(describing: activationId)), createdDate: \(Swift.String(describing: createdDate)), defaultInstanceName: \(Swift.String(describing: defaultInstanceName)), description: \(Swift.String(describing: description)), expirationDate: \(Swift.String(describing: expirationDate)), expired: \(Swift.String(describing: expired)), iamRole: \(Swift.String(describing: iamRole)), registrationLimit: \(Swift.String(describing: registrationLimit)), registrationsCount: \(Swift.String(describing: registrationsCount)), tags: \(Swift.String(describing: tags)))"}
}

extension SsmClientTypes {
    /// An activation registers one or more on-premises servers or virtual machines (VMs) with Amazon Web Services so that you can configure those servers or VMs using Run Command. A server or VM that has been registered with Amazon Web Services Systems Manager is called a managed node.
    public struct Activation: Swift.Equatable {
        /// The ID created by Systems Manager when you submitted the activation.
        public var activationId: Swift.String?
        /// The date the activation was created.
        public var createdDate: ClientRuntime.Date?
        /// A name for the managed node when it is created.
        public var defaultInstanceName: Swift.String?
        /// A user defined description of the activation.
        public var description: Swift.String?
        /// The date when this activation can no longer be used to register managed nodes.
        public var expirationDate: ClientRuntime.Date?
        /// Whether or not the activation is expired.
        public var expired: Swift.Bool
        /// The Identity and Access Management (IAM) role to assign to the managed node.
        public var iamRole: Swift.String?
        /// The maximum number of managed nodes that can be registered using this activation.
        public var registrationLimit: Swift.Int
        /// The number of managed nodes already registered with this activation.
        public var registrationsCount: Swift.Int
        /// Tags assigned to the activation.
        public var tags: [SsmClientTypes.Tag]?

        public init (
            activationId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            defaultInstanceName: Swift.String? = nil,
            description: Swift.String? = nil,
            expirationDate: ClientRuntime.Date? = nil,
            expired: Swift.Bool = false,
            iamRole: Swift.String? = nil,
            registrationLimit: Swift.Int = 0,
            registrationsCount: Swift.Int = 0,
            tags: [SsmClientTypes.Tag]? = nil
        )
        {
            self.activationId = activationId
            self.createdDate = createdDate
            self.defaultInstanceName = defaultInstanceName
            self.description = description
            self.expirationDate = expirationDate
            self.expired = expired
            self.iamRole = iamRole
            self.registrationLimit = registrationLimit
            self.registrationsCount = registrationsCount
            self.tags = tags
        }
    }

}

public struct AddTagsToResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceInput(resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), tags: \(Swift.String(describing: tags)))"}
}

extension AddTagsToResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AddTagsToResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddTagsToResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AddTagsToResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddTagsToResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInput: Swift.Equatable {
    /// The resource ID you want to tag. Use the ID of the resource. Here are some examples: MaintenanceWindow: mw-012345abcdePatchBaseline: pb-012345abcdeOpsMetadata object: ResourceID for tagging is created from the Amazon Resource Name (ARN) for the object. Specifically, ResourceID is created from the strings that come after the word opsmetadata in the ARN. For example, an OpsMetadata object with an ARN of arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager has a ResourceID of either aws/ssm/MyGroup/appmanager or /aws/ssm/MyGroup/appmanager. For the Document and Parameter values, use the name of the resource. ManagedInstance: mi-012345abcde The ManagedInstance type for this API operation is only for on-premises managed nodes. You must specify the name of the managed node in the following format: mi-ID_number . For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specifies the type of resource you are tagging. The ManagedInstance type for this API operation is for on-premises managed nodes. You must specify the name of the managed node in the following format: mi-ID_number . For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceType: SsmClientTypes.ResourceTypeForTagging?
    /// One or more tags. The value parameter is required. Don't enter personally identifiable information in this field.
    /// This member is required.
    public var tags: [SsmClientTypes.Tag]?

    public init (
        resourceId: Swift.String? = nil,
        resourceType: SsmClientTypes.ResourceTypeForTagging? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    public let resourceType: SsmClientTypes.ResourceTypeForTagging?
    public let resourceId: Swift.String?
    public let tags: [SsmClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceTypeForTagging.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsError" : self = .tooManyTagsError(try TooManyTagsError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case tooManyTagsError(TooManyTagsError)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceOutputResponse()"}
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddTagsToResourceOutputResponseBody: Swift.Equatable {
}

extension AddTagsToResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension AlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Error returned if an attempt is made to register a patch group with a patch baseline that is already registered with a different patch baseline.
public struct AlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateOpsItemRelatedItemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateOpsItemRelatedItemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateOpsItemRelatedItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateOpsItemRelatedItemOutputError>
}

extension AssociateOpsItemRelatedItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateOpsItemRelatedItemInput(associationType: \(Swift.String(describing: associationType)), opsItemId: \(Swift.String(describing: opsItemId)), resourceType: \(Swift.String(describing: resourceType)), resourceUri: \(Swift.String(describing: resourceUri)))"}
}

extension AssociateOpsItemRelatedItemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationType = "AssociationType"
        case opsItemId = "OpsItemId"
        case resourceType = "ResourceType"
        case resourceUri = "ResourceUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationType = associationType {
            try encodeContainer.encode(associationType, forKey: .associationType)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceUri = resourceUri {
            try encodeContainer.encode(resourceUri, forKey: .resourceUri)
        }
    }
}

public struct AssociateOpsItemRelatedItemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateOpsItemRelatedItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateOpsItemRelatedItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateOpsItemRelatedItemOutputError>
}

public struct AssociateOpsItemRelatedItemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateOpsItemRelatedItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateOpsItemRelatedItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateOpsItemRelatedItemOutputError>
}

public struct AssociateOpsItemRelatedItemInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateOpsItemRelatedItemInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateOpsItemRelatedItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateOpsItemRelatedItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateOpsItemRelatedItemOutputError>
}

public struct AssociateOpsItemRelatedItemInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateOpsItemRelatedItemInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateOpsItemRelatedItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateOpsItemRelatedItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateOpsItemRelatedItemOutputError>
}

public struct AssociateOpsItemRelatedItemInput: Swift.Equatable {
    /// The type of association that you want to create between an OpsItem and a resource. OpsCenter supports IsParentOf and RelatesTo association types.
    /// This member is required.
    public var associationType: Swift.String?
    /// The ID of the OpsItem to which you want to associate a resource as a related item.
    /// This member is required.
    public var opsItemId: Swift.String?
    /// The type of resource that you want to associate with an OpsItem. OpsCenter supports the following types: AWS::SSMIncidents::IncidentRecord: an Incident Manager incident. AWS::SSM::Document: a Systems Manager (SSM) document.
    /// This member is required.
    public var resourceType: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Web Services resource that you want to associate with the OpsItem.
    /// This member is required.
    public var resourceUri: Swift.String?

    public init (
        associationType: Swift.String? = nil,
        opsItemId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        resourceUri: Swift.String? = nil
    )
    {
        self.associationType = associationType
        self.opsItemId = opsItemId
        self.resourceType = resourceType
        self.resourceUri = resourceUri
    }
}

struct AssociateOpsItemRelatedItemInputBody: Swift.Equatable {
    public let opsItemId: Swift.String?
    public let associationType: Swift.String?
    public let resourceType: Swift.String?
    public let resourceUri: Swift.String?
}

extension AssociateOpsItemRelatedItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationType = "AssociationType"
        case opsItemId = "OpsItemId"
        case resourceType = "ResourceType"
        case resourceUri = "ResourceUri"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceUri)
        resourceUri = resourceUriDecoded
    }
}

extension AssociateOpsItemRelatedItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateOpsItemRelatedItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemRelatedItemAlreadyExistsException" : self = .opsItemRelatedItemAlreadyExistsException(try OpsItemRelatedItemAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateOpsItemRelatedItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case opsItemRelatedItemAlreadyExistsException(OpsItemRelatedItemAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateOpsItemRelatedItemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateOpsItemRelatedItemOutputResponse(associationId: \(Swift.String(describing: associationId)))"}
}

extension AssociateOpsItemRelatedItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateOpsItemRelatedItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationId = output.associationId
        } else {
            self.associationId = nil
        }
    }
}

public struct AssociateOpsItemRelatedItemOutputResponse: Swift.Equatable {
    /// The association ID.
    public var associationId: Swift.String?

    public init (
        associationId: Swift.String? = nil
    )
    {
        self.associationId = associationId
    }
}

struct AssociateOpsItemRelatedItemOutputResponseBody: Swift.Equatable {
    public let associationId: Swift.String?
}

extension AssociateOpsItemRelatedItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension AssociatedInstances: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatedInstances()"}
}

extension AssociatedInstances {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You must disassociate a document from all managed nodes before you can delete it.
public struct AssociatedInstances: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension SsmClientTypes.Association: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case lastExecutionDate = "LastExecutionDate"
        case name = "Name"
        case overview = "Overview"
        case scheduleExpression = "ScheduleExpression"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overview = overview {
            try encodeContainer.encode(overview, forKey: .overview)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let overviewDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationOverview.self, forKey: .overview)
        overview = overviewDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
    }
}

extension SsmClientTypes.Association: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Association(associationId: \(Swift.String(describing: associationId)), associationName: \(Swift.String(describing: associationName)), associationVersion: \(Swift.String(describing: associationVersion)), documentVersion: \(Swift.String(describing: documentVersion)), instanceId: \(Swift.String(describing: instanceId)), lastExecutionDate: \(Swift.String(describing: lastExecutionDate)), name: \(Swift.String(describing: name)), overview: \(Swift.String(describing: overview)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), targets: \(Swift.String(describing: targets)))"}
}

extension SsmClientTypes {
    /// Describes an association of a Amazon Web Services Systems Manager document (SSM document) and a managed node.
    public struct Association: Swift.Equatable {
        /// The ID created by the system when you create an association. An association is a binding between a document and a set of targets with a schedule.
        public var associationId: Swift.String?
        /// The association name.
        public var associationName: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// The version of the document used in the association.
        public var documentVersion: Swift.String?
        /// The managed node ID.
        public var instanceId: Swift.String?
        /// The date on which the association was last run.
        public var lastExecutionDate: ClientRuntime.Date?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// Information about the association.
        public var overview: SsmClientTypes.AssociationOverview?
        /// A cron expression that specifies a schedule when the association runs. The schedule runs in Coordinated Universal Time (UTC).
        public var scheduleExpression: Swift.String?
        /// The managed nodes targeted by the request to create an association. You can target all managed nodes in an Amazon Web Services account by specifying the InstanceIds key with a value of *.
        public var targets: [SsmClientTypes.Target]?

        public init (
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            overview: SsmClientTypes.AssociationOverview? = nil,
            scheduleExpression: Swift.String? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.documentVersion = documentVersion
            self.instanceId = instanceId
            self.lastExecutionDate = lastExecutionDate
            self.name = name
            self.overview = overview
            self.scheduleExpression = scheduleExpression
            self.targets = targets
        }
    }

}

extension AssociationAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationAlreadyExists()"}
}

extension AssociationAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified association already exists.
public struct AssociationAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension SsmClientTypes {
    public enum AssociationComplianceSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case low
        case medium
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationComplianceSeverity] {
            return [
                .critical,
                .high,
                .low,
                .medium,
                .unspecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationComplianceSeverity(rawValue: rawValue) ?? AssociationComplianceSeverity.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.AssociationDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case date = "Date"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case lastExecutionDate = "LastExecutionDate"
        case lastSuccessfulExecutionDate = "LastSuccessfulExecutionDate"
        case lastUpdateAssociationDate = "LastUpdateAssociationDate"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case overview = "Overview"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case status = "Status"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let lastSuccessfulExecutionDate = lastSuccessfulExecutionDate {
            try encodeContainer.encode(lastSuccessfulExecutionDate.timeIntervalSince1970, forKey: .lastSuccessfulExecutionDate)
        }
        if let lastUpdateAssociationDate = lastUpdateAssociationDate {
            try encodeContainer.encode(lastUpdateAssociationDate.timeIntervalSince1970, forKey: .lastUpdateAssociationDate)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let overview = overview {
            try encodeContainer.encode(overview, forKey: .overview)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let dateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .date)
        date = dateDecoded
        let lastUpdateAssociationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateAssociationDate)
        lastUpdateAssociationDate = lastUpdateAssociationDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationStatus.self, forKey: .status)
        status = statusDecoded
        let overviewDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationOverview.self, forKey: .overview)
        overview = overviewDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let lastSuccessfulExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSuccessfulExecutionDate)
        lastSuccessfulExecutionDate = lastSuccessfulExecutionDateDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension SsmClientTypes.AssociationDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationDescription(applyOnlyAtCronInterval: \(Swift.String(describing: applyOnlyAtCronInterval)), associationId: \(Swift.String(describing: associationId)), associationName: \(Swift.String(describing: associationName)), associationVersion: \(Swift.String(describing: associationVersion)), automationTargetParameterName: \(Swift.String(describing: automationTargetParameterName)), calendarNames: \(Swift.String(describing: calendarNames)), complianceSeverity: \(Swift.String(describing: complianceSeverity)), date: \(Swift.String(describing: date)), documentVersion: \(Swift.String(describing: documentVersion)), instanceId: \(Swift.String(describing: instanceId)), lastExecutionDate: \(Swift.String(describing: lastExecutionDate)), lastSuccessfulExecutionDate: \(Swift.String(describing: lastSuccessfulExecutionDate)), lastUpdateAssociationDate: \(Swift.String(describing: lastUpdateAssociationDate)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), outputLocation: \(Swift.String(describing: outputLocation)), overview: \(Swift.String(describing: overview)), parameters: \(Swift.String(describing: parameters)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), status: \(Swift.String(describing: status)), syncCompliance: \(Swift.String(describing: syncCompliance)), targetLocations: \(Swift.String(describing: targetLocations)), targets: \(Swift.String(describing: targets)))"}
}

extension SsmClientTypes {
    /// Describes the parameters for a document.
    public struct AssociationDescription: Swift.Equatable {
        /// By default, when you create a new associations, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
        public var applyOnlyAtCronInterval: Swift.Bool
        /// The association ID.
        public var associationId: Swift.String?
        /// The association name.
        public var associationName: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
        public var automationTargetParameterName: Swift.String?
        /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations only run when that change calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
        public var calendarNames: [Swift.String]?
        /// The severity level that is assigned to the association.
        public var complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
        /// The date when the association was made.
        public var date: ClientRuntime.Date?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The managed node ID.
        public var instanceId: Swift.String?
        /// The date on which the association was last run.
        public var lastExecutionDate: ClientRuntime.Date?
        /// The last date on which the association was successfully run.
        public var lastSuccessfulExecutionDate: ClientRuntime.Date?
        /// The date when the association was last updated.
        public var lastUpdateAssociationDate: ClientRuntime.Date?
        /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
        public var maxConcurrency: Swift.String?
        /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
        public var maxErrors: Swift.String?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// An S3 bucket where you want to store the output details of the request.
        public var outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
        /// Information about the association.
        public var overview: SsmClientTypes.AssociationOverview?
        /// A description of the parameters for a document.
        public var parameters: [Swift.String:[Swift.String]]?
        /// A cron expression that specifies a schedule when the association runs.
        public var scheduleExpression: Swift.String?
        /// The association status.
        public var status: SsmClientTypes.AssociationStatus?
        /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
        public var syncCompliance: SsmClientTypes.AssociationSyncCompliance?
        /// The combination of Amazon Web Services Regions and Amazon Web Services accounts where you want to run the association.
        public var targetLocations: [SsmClientTypes.TargetLocation]?
        /// The managed nodes targeted by the request.
        public var targets: [SsmClientTypes.Target]?

        public init (
            applyOnlyAtCronInterval: Swift.Bool = false,
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            automationTargetParameterName: Swift.String? = nil,
            calendarNames: [Swift.String]? = nil,
            complianceSeverity: SsmClientTypes.AssociationComplianceSeverity? = nil,
            date: ClientRuntime.Date? = nil,
            documentVersion: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            lastSuccessfulExecutionDate: ClientRuntime.Date? = nil,
            lastUpdateAssociationDate: ClientRuntime.Date? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: SsmClientTypes.InstanceAssociationOutputLocation? = nil,
            overview: SsmClientTypes.AssociationOverview? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            scheduleExpression: Swift.String? = nil,
            status: SsmClientTypes.AssociationStatus? = nil,
            syncCompliance: SsmClientTypes.AssociationSyncCompliance? = nil,
            targetLocations: [SsmClientTypes.TargetLocation]? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.automationTargetParameterName = automationTargetParameterName
            self.calendarNames = calendarNames
            self.complianceSeverity = complianceSeverity
            self.date = date
            self.documentVersion = documentVersion
            self.instanceId = instanceId
            self.lastExecutionDate = lastExecutionDate
            self.lastSuccessfulExecutionDate = lastSuccessfulExecutionDate
            self.lastUpdateAssociationDate = lastUpdateAssociationDate
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.outputLocation = outputLocation
            self.overview = overview
            self.parameters = parameters
            self.scheduleExpression = scheduleExpression
            self.status = status
            self.syncCompliance = syncCompliance
            self.targetLocations = targetLocations
            self.targets = targets
        }
    }

}

extension AssociationDoesNotExist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationDoesNotExist(message: \(Swift.String(describing: message)))"}
}

extension AssociationDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociationDoesNotExistBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified association doesn't exist.
public struct AssociationDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AssociationDoesNotExistBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AssociationDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.AssociationExecution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case createdTime = "CreatedTime"
        case detailedStatus = "DetailedStatus"
        case executionId = "ExecutionId"
        case lastExecutionDate = "LastExecutionDate"
        case resourceCountByStatus = "ResourceCountByStatus"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let resourceCountByStatus = resourceCountByStatus {
            try encodeContainer.encode(resourceCountByStatus, forKey: .resourceCountByStatus)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let resourceCountByStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceCountByStatus)
        resourceCountByStatus = resourceCountByStatusDecoded
    }
}

extension SsmClientTypes.AssociationExecution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationExecution(associationId: \(Swift.String(describing: associationId)), associationVersion: \(Swift.String(describing: associationVersion)), createdTime: \(Swift.String(describing: createdTime)), detailedStatus: \(Swift.String(describing: detailedStatus)), executionId: \(Swift.String(describing: executionId)), lastExecutionDate: \(Swift.String(describing: lastExecutionDate)), resourceCountByStatus: \(Swift.String(describing: resourceCountByStatus)), status: \(Swift.String(describing: status)))"}
}

extension SsmClientTypes {
    /// Includes information about the specified association.
    public struct AssociationExecution: Swift.Equatable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// The time the execution started.
        public var createdTime: ClientRuntime.Date?
        /// Detailed status information about the execution.
        public var detailedStatus: Swift.String?
        /// The execution ID for the association.
        public var executionId: Swift.String?
        /// The date of the last execution.
        public var lastExecutionDate: ClientRuntime.Date?
        /// An aggregate status of the resources in the execution based on the status type.
        public var resourceCountByStatus: Swift.String?
        /// The status of the association execution.
        public var status: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            detailedStatus: Swift.String? = nil,
            executionId: Swift.String? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            resourceCountByStatus: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationVersion = associationVersion
            self.createdTime = createdTime
            self.detailedStatus = detailedStatus
            self.executionId = executionId
            self.lastExecutionDate = lastExecutionDate
            self.resourceCountByStatus = resourceCountByStatus
            self.status = status
        }
    }

}

extension AssociationExecutionDoesNotExist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationExecutionDoesNotExist(message: \(Swift.String(describing: message)))"}
}

extension AssociationExecutionDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociationExecutionDoesNotExistBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified execution ID doesn't exist. Verify the ID number and try again.
public struct AssociationExecutionDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AssociationExecutionDoesNotExistBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AssociationExecutionDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.AssociationExecutionFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationExecutionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationFilterOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes.AssociationExecutionFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationExecutionFilter(key: \(Swift.String(describing: key)), type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension SsmClientTypes {
    /// Filters used in the request.
    public struct AssociationExecutionFilter: Swift.Equatable {
        /// The key value used in the request.
        /// This member is required.
        public var key: SsmClientTypes.AssociationExecutionFilterKey?
        /// The filter type specified in the request.
        /// This member is required.
        public var type: SsmClientTypes.AssociationFilterOperatorType?
        /// The value specified for the key.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.AssociationExecutionFilterKey? = nil,
            type: SsmClientTypes.AssociationFilterOperatorType? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.type = type
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum AssociationExecutionFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdtime
        case executionid
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationExecutionFilterKey] {
            return [
                .createdtime,
                .executionid,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdtime: return "CreatedTime"
            case .executionid: return "ExecutionId"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationExecutionFilterKey(rawValue: rawValue) ?? AssociationExecutionFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.AssociationExecutionTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case detailedStatus = "DetailedStatus"
        case executionId = "ExecutionId"
        case lastExecutionDate = "LastExecutionDate"
        case outputSource = "OutputSource"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let outputSource = outputSource {
            try encodeContainer.encode(outputSource, forKey: .outputSource)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let outputSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OutputSource.self, forKey: .outputSource)
        outputSource = outputSourceDecoded
    }
}

extension SsmClientTypes.AssociationExecutionTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationExecutionTarget(associationId: \(Swift.String(describing: associationId)), associationVersion: \(Swift.String(describing: associationVersion)), detailedStatus: \(Swift.String(describing: detailedStatus)), executionId: \(Swift.String(describing: executionId)), lastExecutionDate: \(Swift.String(describing: lastExecutionDate)), outputSource: \(Swift.String(describing: outputSource)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), status: \(Swift.String(describing: status)))"}
}

extension SsmClientTypes {
    /// Includes information about the specified association execution.
    public struct AssociationExecutionTarget: Swift.Equatable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// Detailed information about the execution status.
        public var detailedStatus: Swift.String?
        /// The execution ID.
        public var executionId: Swift.String?
        /// The date of the last execution.
        public var lastExecutionDate: ClientRuntime.Date?
        /// The location where the association details are saved.
        public var outputSource: SsmClientTypes.OutputSource?
        /// The resource ID, for example, the managed node ID where the association ran.
        public var resourceId: Swift.String?
        /// The resource type, for example, EC2.
        public var resourceType: Swift.String?
        /// The association execution status.
        public var status: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            detailedStatus: Swift.String? = nil,
            executionId: Swift.String? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            outputSource: SsmClientTypes.OutputSource? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationVersion = associationVersion
            self.detailedStatus = detailedStatus
            self.executionId = executionId
            self.lastExecutionDate = lastExecutionDate
            self.outputSource = outputSource
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
        }
    }

}

extension SsmClientTypes.AssociationExecutionTargetsFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationExecutionTargetsFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes.AssociationExecutionTargetsFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationExecutionTargetsFilter(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SsmClientTypes {
    /// Filters for the association execution.
    public struct AssociationExecutionTargetsFilter: Swift.Equatable {
        /// The key value used in the request.
        /// This member is required.
        public var key: SsmClientTypes.AssociationExecutionTargetsFilterKey?
        /// The value specified for the key.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.AssociationExecutionTargetsFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum AssociationExecutionTargetsFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resourceid
        case resourcetype
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationExecutionTargetsFilterKey] {
            return [
                .resourceid,
                .resourcetype,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resourceid: return "ResourceId"
            case .resourcetype: return "ResourceType"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationExecutionTargetsFilterKey(rawValue: rawValue) ?? AssociationExecutionTargetsFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.AssociationFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes.AssociationFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationFilter(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SsmClientTypes {
    /// Describes a filter.
    public struct AssociationFilter: Swift.Equatable {
        /// The name of the filter. InstanceId has been deprecated.
        /// This member is required.
        public var key: SsmClientTypes.AssociationFilterKey?
        /// The filter value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.AssociationFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum AssociationFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associationid
        case associationname
        case instanceid
        case lastexecutedafter
        case lastexecutedbefore
        case name
        case resourcegroupname
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationFilterKey] {
            return [
                .associationid,
                .associationname,
                .instanceid,
                .lastexecutedafter,
                .lastexecutedbefore,
                .name,
                .resourcegroupname,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associationid: return "AssociationId"
            case .associationname: return "AssociationName"
            case .instanceid: return "InstanceId"
            case .lastexecutedafter: return "LastExecutedAfter"
            case .lastexecutedbefore: return "LastExecutedBefore"
            case .name: return "Name"
            case .resourcegroupname: return "ResourceGroupName"
            case .status: return "AssociationStatusName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationFilterKey(rawValue: rawValue) ?? AssociationFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum AssociationFilterOperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case greaterthan
        case lessthan
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationFilterOperatorType] {
            return [
                .equal,
                .greaterthan,
                .lessthan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greaterthan: return "GREATER_THAN"
            case .lessthan: return "LESS_THAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationFilterOperatorType(rawValue: rawValue) ?? AssociationFilterOperatorType.sdkUnknown(rawValue)
        }
    }
}

extension AssociationLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationLimitExceeded()"}
}

extension AssociationLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can have at most 2,000 active associations.
public struct AssociationLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension SsmClientTypes.AssociationOverview: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatusAggregatedCount = "AssociationStatusAggregatedCount"
        case detailedStatus = "DetailedStatus"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatusAggregatedCount = associationStatusAggregatedCount {
            var associationStatusAggregatedCountContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .associationStatusAggregatedCount)
            for (dictKey0, associationstatusaggregatedcount0) in associationStatusAggregatedCount {
                try associationStatusAggregatedCountContainer.encode(associationstatusaggregatedcount0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let associationStatusAggregatedCountContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .associationStatusAggregatedCount)
        var associationStatusAggregatedCountDecoded0: [Swift.String:Swift.Int]? = nil
        if let associationStatusAggregatedCountContainer = associationStatusAggregatedCountContainer {
            associationStatusAggregatedCountDecoded0 = [Swift.String:Swift.Int]()
            for (key0, instancecount0) in associationStatusAggregatedCountContainer {
                if let instancecount0 = instancecount0 {
                    associationStatusAggregatedCountDecoded0?[key0] = instancecount0
                }
            }
        }
        associationStatusAggregatedCount = associationStatusAggregatedCountDecoded0
    }
}

extension SsmClientTypes.AssociationOverview: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationOverview(associationStatusAggregatedCount: \(Swift.String(describing: associationStatusAggregatedCount)), detailedStatus: \(Swift.String(describing: detailedStatus)), status: \(Swift.String(describing: status)))"}
}

extension SsmClientTypes {
    /// Information about the association.
    public struct AssociationOverview: Swift.Equatable {
        /// Returns the number of targets for the association status. For example, if you created an association with two managed nodes, and one of them was successful, this would return the count of managed nodes by status.
        public var associationStatusAggregatedCount: [Swift.String:Swift.Int]?
        /// A detailed status of the association.
        public var detailedStatus: Swift.String?
        /// The status of the association. Status can be: Pending, Success, or Failed.
        public var status: Swift.String?

        public init (
            associationStatusAggregatedCount: [Swift.String:Swift.Int]? = nil,
            detailedStatus: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationStatusAggregatedCount = associationStatusAggregatedCount
            self.detailedStatus = detailedStatus
            self.status = status
        }
    }

}

extension SsmClientTypes.AssociationStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo = "AdditionalInfo"
        case date = "Date"
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            try encodeContainer.encode(additionalInfo, forKey: .additionalInfo)
        }
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .date)
        date = dateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationStatusName.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let additionalInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalInfo)
        additionalInfo = additionalInfoDecoded
    }
}

extension SsmClientTypes.AssociationStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationStatus(additionalInfo: \(Swift.String(describing: additionalInfo)), date: \(Swift.String(describing: date)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension SsmClientTypes {
    /// Describes an association status.
    public struct AssociationStatus: Swift.Equatable {
        /// A user-defined string.
        public var additionalInfo: Swift.String?
        /// The date when the status changed.
        /// This member is required.
        public var date: ClientRuntime.Date?
        /// The reason for the status.
        /// This member is required.
        public var message: Swift.String?
        /// The status.
        /// This member is required.
        public var name: SsmClientTypes.AssociationStatusName?

        public init (
            additionalInfo: Swift.String? = nil,
            date: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            name: SsmClientTypes.AssociationStatusName? = nil
        )
        {
            self.additionalInfo = additionalInfo
            self.date = date
            self.message = message
            self.name = name
        }
    }

}

extension SsmClientTypes {
    public enum AssociationStatusName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatusName] {
            return [
                .failed,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationStatusName(rawValue: rawValue) ?? AssociationStatusName.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum AssociationSyncCompliance: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationSyncCompliance] {
            return [
                .auto,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationSyncCompliance(rawValue: rawValue) ?? AssociationSyncCompliance.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.AssociationVersionInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case createdDate = "CreatedDate"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension SsmClientTypes.AssociationVersionInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationVersionInfo(applyOnlyAtCronInterval: \(Swift.String(describing: applyOnlyAtCronInterval)), associationId: \(Swift.String(describing: associationId)), associationName: \(Swift.String(describing: associationName)), associationVersion: \(Swift.String(describing: associationVersion)), calendarNames: \(Swift.String(describing: calendarNames)), complianceSeverity: \(Swift.String(describing: complianceSeverity)), createdDate: \(Swift.String(describing: createdDate)), documentVersion: \(Swift.String(describing: documentVersion)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), outputLocation: \(Swift.String(describing: outputLocation)), parameters: \(Swift.String(describing: parameters)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), syncCompliance: \(Swift.String(describing: syncCompliance)), targetLocations: \(Swift.String(describing: targetLocations)), targets: \(Swift.String(describing: targets)))"}
}

extension SsmClientTypes {
    /// Information about the association version.
    public struct AssociationVersionInfo: Swift.Equatable {
        /// By default, when you create a new associations, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
        public var applyOnlyAtCronInterval: Swift.Bool
        /// The ID created by the system when the association was created.
        public var associationId: Swift.String?
        /// The name specified for the association version when the association version was created.
        public var associationName: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations for this version only run when that Change Calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
        public var calendarNames: [Swift.String]?
        /// The severity level that is assigned to the association.
        public var complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
        /// The date the association version was created.
        public var createdDate: ClientRuntime.Date?
        /// The version of an Amazon Web Services Systems Manager document (SSM document) used when the association version was created.
        public var documentVersion: Swift.String?
        /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
        public var maxConcurrency: Swift.String?
        /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
        public var maxErrors: Swift.String?
        /// The name specified when the association was created.
        public var name: Swift.String?
        /// The location in Amazon S3 specified for the association when the association version was created.
        public var outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
        /// Parameters specified when the association version was created.
        public var parameters: [Swift.String:[Swift.String]]?
        /// The cron or rate schedule specified for the association when the association version was created.
        public var scheduleExpression: Swift.String?
        /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
        public var syncCompliance: SsmClientTypes.AssociationSyncCompliance?
        /// The combination of Amazon Web Services Regions and Amazon Web Services accounts where you wanted to run the association when this association version was created.
        public var targetLocations: [SsmClientTypes.TargetLocation]?
        /// The targets specified for the association when the association version was created.
        public var targets: [SsmClientTypes.Target]?

        public init (
            applyOnlyAtCronInterval: Swift.Bool = false,
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            calendarNames: [Swift.String]? = nil,
            complianceSeverity: SsmClientTypes.AssociationComplianceSeverity? = nil,
            createdDate: ClientRuntime.Date? = nil,
            documentVersion: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: SsmClientTypes.InstanceAssociationOutputLocation? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            scheduleExpression: Swift.String? = nil,
            syncCompliance: SsmClientTypes.AssociationSyncCompliance? = nil,
            targetLocations: [SsmClientTypes.TargetLocation]? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.calendarNames = calendarNames
            self.complianceSeverity = complianceSeverity
            self.createdDate = createdDate
            self.documentVersion = documentVersion
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.outputLocation = outputLocation
            self.parameters = parameters
            self.scheduleExpression = scheduleExpression
            self.syncCompliance = syncCompliance
            self.targetLocations = targetLocations
            self.targets = targets
        }
    }

}

extension AssociationVersionLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationVersionLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension AssociationVersionLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociationVersionLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number versions allowed for an association. Each association has a limit of 1,000 versions.
public struct AssociationVersionLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AssociationVersionLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AssociationVersionLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.AttachmentContent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hash = "Hash"
        case hashType = "HashType"
        case name = "Name"
        case size = "Size"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hash = hash {
            try encodeContainer.encode(hash, forKey: .hash)
        }
        if let hashType = hashType {
            try encodeContainer.encode(hashType.rawValue, forKey: .hashType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let hashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hash)
        hash = hashDecoded
        let hashTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AttachmentHashType.self, forKey: .hashType)
        hashType = hashTypeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension SsmClientTypes.AttachmentContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentContent(hash: \(Swift.String(describing: hash)), hashType: \(Swift.String(describing: hashType)), name: \(Swift.String(describing: name)), size: \(Swift.String(describing: size)), url: \(Swift.String(describing: url)))"}
}

extension SsmClientTypes {
    /// A structure that includes attributes that describe a document attachment.
    public struct AttachmentContent: Swift.Equatable {
        /// The cryptographic hash value of the document content.
        public var hash: Swift.String?
        /// The hash algorithm used to calculate the hash value.
        public var hashType: SsmClientTypes.AttachmentHashType?
        /// The name of an attachment.
        public var name: Swift.String?
        /// The size of an attachment in bytes.
        public var size: Swift.Int
        /// The URL location of the attachment content.
        public var url: Swift.String?

        public init (
            hash: Swift.String? = nil,
            hashType: SsmClientTypes.AttachmentHashType? = nil,
            name: Swift.String? = nil,
            size: Swift.Int = 0,
            url: Swift.String? = nil
        )
        {
            self.hash = hash
            self.hashType = hashType
            self.name = name
            self.size = size
            self.url = url
        }
    }

}

extension SsmClientTypes {
    public enum AttachmentHashType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentHashType] {
            return [
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sha256: return "Sha256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentHashType(rawValue: rawValue) ?? AttachmentHashType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.AttachmentInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SsmClientTypes.AttachmentInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentInformation(name: \(Swift.String(describing: name)))"}
}

extension SsmClientTypes {
    /// An attribute of an attachment, such as the attachment name.
    public struct AttachmentInformation: Swift.Equatable {
        /// The name of the attachment.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension SsmClientTypes.AttachmentsSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for attachmentssourcevalues0 in values {
                try valuesContainer.encode(attachmentssourcevalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AttachmentsSourceKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SsmClientTypes.AttachmentsSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentsSource(key: \(Swift.String(describing: key)), name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// Identifying information about a document attachment, including the file name and a key-value pair that identifies the location of an attachment to a document.
    public struct AttachmentsSource: Swift.Equatable {
        /// The key of a key-value pair that identifies the location of an attachment to a document.
        public var key: SsmClientTypes.AttachmentsSourceKey?
        /// The name of the document attachment file.
        public var name: Swift.String?
        /// The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
        ///
        /// * For the key SourceUrl, the value is an S3 bucket location. For example: "Values": [ "s3://doc-example-bucket/my-folder" ]
        ///
        /// * For the key S3FileUrl, the value is a file in an S3 bucket. For example: "Values": [ "s3://doc-example-bucket/my-folder/my-file.py" ]
        ///
        /// * For the key AttachmentReference, the value is constructed from the name of another SSM document in your account, a version number of that document, and a file attached to that document version that you want to reuse. For example: "Values": [ "MyOtherDocument/3/my-other-file.py" ] However, if the SSM document is shared with you from another account, the full SSM document ARN must be specified instead of the document name only. For example: "Values": [ "arn:aws:ssm:us-east-2:111122223333:document/OtherAccountDocument/3/their-file.py" ]
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.AttachmentsSourceKey? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.name = name
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum AttachmentsSourceKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachmentreference
        case s3fileurl
        case sourceurl
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentsSourceKey] {
            return [
                .attachmentreference,
                .s3fileurl,
                .sourceurl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachmentreference: return "AttachmentReference"
            case .s3fileurl: return "S3FileUrl"
            case .sourceurl: return "SourceUrl"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentsSourceKey(rawValue: rawValue) ?? AttachmentsSourceKey.sdkUnknown(rawValue)
        }
    }
}

extension AutomationDefinitionNotApprovedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomationDefinitionNotApprovedException(message: \(Swift.String(describing: message)))"}
}

extension AutomationDefinitionNotApprovedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationDefinitionNotApprovedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the Change Manager change template used in the change request was rejected or is still in a pending state.
public struct AutomationDefinitionNotApprovedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationDefinitionNotApprovedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AutomationDefinitionNotApprovedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationDefinitionNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomationDefinitionNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension AutomationDefinitionNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationDefinitionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An Automation runbook with the specified name couldn't be found.
public struct AutomationDefinitionNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationDefinitionNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AutomationDefinitionNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationDefinitionVersionNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomationDefinitionVersionNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension AutomationDefinitionVersionNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationDefinitionVersionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An Automation runbook with the specified name and version couldn't be found.
public struct AutomationDefinitionVersionNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationDefinitionVersionNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AutomationDefinitionVersionNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.AutomationExecution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case automationExecutionId = "AutomationExecutionId"
        case automationExecutionStatus = "AutomationExecutionStatus"
        case automationSubtype = "AutomationSubtype"
        case changeRequestName = "ChangeRequestName"
        case currentAction = "CurrentAction"
        case currentStepName = "CurrentStepName"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case executedBy = "ExecutedBy"
        case executionEndTime = "ExecutionEndTime"
        case executionStartTime = "ExecutionStartTime"
        case failureMessage = "FailureMessage"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case opsItemId = "OpsItemId"
        case outputs = "Outputs"
        case parameters = "Parameters"
        case parentAutomationExecutionId = "ParentAutomationExecutionId"
        case progressCounters = "ProgressCounters"
        case resolvedTargets = "ResolvedTargets"
        case runbooks = "Runbooks"
        case scheduledTime = "ScheduledTime"
        case stepExecutions = "StepExecutions"
        case stepExecutionsTruncated = "StepExecutionsTruncated"
        case target = "Target"
        case targetLocations = "TargetLocations"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let automationExecutionStatus = automationExecutionStatus {
            try encodeContainer.encode(automationExecutionStatus.rawValue, forKey: .automationExecutionStatus)
        }
        if let automationSubtype = automationSubtype {
            try encodeContainer.encode(automationSubtype.rawValue, forKey: .automationSubtype)
        }
        if let changeRequestName = changeRequestName {
            try encodeContainer.encode(changeRequestName, forKey: .changeRequestName)
        }
        if let currentAction = currentAction {
            try encodeContainer.encode(currentAction, forKey: .currentAction)
        }
        if let currentStepName = currentStepName {
            try encodeContainer.encode(currentStepName, forKey: .currentStepName)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let executedBy = executedBy {
            try encodeContainer.encode(executedBy, forKey: .executedBy)
        }
        if let executionEndTime = executionEndTime {
            try encodeContainer.encode(executionEndTime.timeIntervalSince1970, forKey: .executionEndTime)
        }
        if let executionStartTime = executionStartTime {
            try encodeContainer.encode(executionStartTime.timeIntervalSince1970, forKey: .executionStartTime)
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputs)
            for (dictKey0, automationparametermap0) in outputs {
                try outputsContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let parentAutomationExecutionId = parentAutomationExecutionId {
            try encodeContainer.encode(parentAutomationExecutionId, forKey: .parentAutomationExecutionId)
        }
        if let progressCounters = progressCounters {
            try encodeContainer.encode(progressCounters, forKey: .progressCounters)
        }
        if let resolvedTargets = resolvedTargets {
            try encodeContainer.encode(resolvedTargets, forKey: .resolvedTargets)
        }
        if let runbooks = runbooks {
            var runbooksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runbooks)
            for runbooks0 in runbooks {
                try runbooksContainer.encode(runbooks0)
            }
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
        if let stepExecutions = stepExecutions {
            var stepExecutionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepExecutions)
            for stepexecutionlist0 in stepExecutions {
                try stepExecutionsContainer.encode(stepexecutionlist0)
            }
        }
        if stepExecutionsTruncated != false {
            try encodeContainer.encode(stepExecutionsTruncated, forKey: .stepExecutionsTruncated)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targetMaps = targetMaps {
            var targetMapsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetMaps)
            for targetmaps0 in targetMaps {
                var targetmaps0Container = targetMapsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, targetmap1) in targetmaps0 {
                    var targetmap1Container = targetmaps0Container.nestedUnkeyedContainer(forKey: ClientRuntime.Key(dictKey1))
                    for targetmapvaluelist2 in targetmap1 {
                        try targetmap1Container.encode(targetmapvaluelist2)
                    }
                }
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let executionStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionStartTime)
        executionStartTime = executionStartTimeDecoded
        let executionEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionEndTime)
        executionEndTime = executionEndTimeDecoded
        let automationExecutionStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecutionStatus.self, forKey: .automationExecutionStatus)
        automationExecutionStatus = automationExecutionStatusDecoded
        let stepExecutionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.StepExecution?].self, forKey: .stepExecutions)
        var stepExecutionsDecoded0:[SsmClientTypes.StepExecution]? = nil
        if let stepExecutionsContainer = stepExecutionsContainer {
            stepExecutionsDecoded0 = [SsmClientTypes.StepExecution]()
            for structure0 in stepExecutionsContainer {
                if let structure0 = structure0 {
                    stepExecutionsDecoded0?.append(structure0)
                }
            }
        }
        stepExecutions = stepExecutionsDecoded0
        let stepExecutionsTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .stepExecutionsTruncated)
        stepExecutionsTruncated = stepExecutionsTruncatedDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .outputs)
        var outputsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in outputsContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                outputsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        outputs = outputsDecoded0
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let modeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ExecutionMode.self, forKey: .mode)
        mode = modeDecoded
        let parentAutomationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentAutomationExecutionId)
        parentAutomationExecutionId = parentAutomationExecutionIdDecoded
        let executedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executedBy)
        executedBy = executedByDecoded
        let currentStepNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentStepName)
        currentStepName = currentStepNameDecoded
        let currentActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentAction)
        currentAction = currentActionDecoded
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetMapsContainer = try containerValues.decodeIfPresent([[Swift.String: [Swift.String?]?]?].self, forKey: .targetMaps)
        var targetMapsDecoded0:[[Swift.String:[Swift.String]]]? = nil
        if let targetMapsContainer = targetMapsContainer {
            targetMapsDecoded0 = [[Swift.String:[Swift.String]]]()
            for map0 in targetMapsContainer {
                var targetMapsContainerDecoded0: [Swift.String: [Swift.String]]? = nil
                if let map0 = map0 {
                    targetMapsContainerDecoded0 = [Swift.String: [Swift.String]]()
                    for (key1, targetmapvaluelist1) in map0 {
                        var targetmapvaluelist1Decoded1: [Swift.String]? = nil
                        if let targetmapvaluelist1 = targetmapvaluelist1 {
                            targetmapvaluelist1Decoded1 = [Swift.String]()
                            for string2 in targetmapvaluelist1 {
                                if let string2 = string2 {
                                    targetmapvaluelist1Decoded1?.append(string2)
                                }
                            }
                        }
                        targetMapsContainerDecoded0?[key1] = targetmapvaluelist1Decoded1
                    }
                }
                if let targetMapsContainerDecoded0 = targetMapsContainerDecoded0 {
                    targetMapsDecoded0?.append(targetMapsContainerDecoded0)
                }
            }
        }
        targetMaps = targetMapsDecoded0
        let resolvedTargetsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResolvedTargets.self, forKey: .resolvedTargets)
        resolvedTargets = resolvedTargetsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
        let progressCountersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ProgressCounters.self, forKey: .progressCounters)
        progressCounters = progressCountersDecoded
        let automationSubtypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationSubtype.self, forKey: .automationSubtype)
        automationSubtype = automationSubtypeDecoded
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
        let runbooksContainer = try containerValues.decodeIfPresent([SsmClientTypes.Runbook?].self, forKey: .runbooks)
        var runbooksDecoded0:[SsmClientTypes.Runbook]? = nil
        if let runbooksContainer = runbooksContainer {
            runbooksDecoded0 = [SsmClientTypes.Runbook]()
            for structure0 in runbooksContainer {
                if let structure0 = structure0 {
                    runbooksDecoded0?.append(structure0)
                }
            }
        }
        runbooks = runbooksDecoded0
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let changeRequestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeRequestName)
        changeRequestName = changeRequestNameDecoded
    }
}

extension SsmClientTypes.AutomationExecution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomationExecution(associationId: \(Swift.String(describing: associationId)), automationExecutionId: \(Swift.String(describing: automationExecutionId)), automationExecutionStatus: \(Swift.String(describing: automationExecutionStatus)), automationSubtype: \(Swift.String(describing: automationSubtype)), changeRequestName: \(Swift.String(describing: changeRequestName)), currentAction: \(Swift.String(describing: currentAction)), currentStepName: \(Swift.String(describing: currentStepName)), documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), executedBy: \(Swift.String(describing: executedBy)), executionEndTime: \(Swift.String(describing: executionEndTime)), executionStartTime: \(Swift.String(describing: executionStartTime)), failureMessage: \(Swift.String(describing: failureMessage)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), mode: \(Swift.String(describing: mode)), opsItemId: \(Swift.String(describing: opsItemId)), outputs: \(Swift.String(describing: outputs)), parameters: \(Swift.String(describing: parameters)), parentAutomationExecutionId: \(Swift.String(describing: parentAutomationExecutionId)), progressCounters: \(Swift.String(describing: progressCounters)), resolvedTargets: \(Swift.String(describing: resolvedTargets)), runbooks: \(Swift.String(describing: runbooks)), scheduledTime: \(Swift.String(describing: scheduledTime)), stepExecutions: \(Swift.String(describing: stepExecutions)), stepExecutionsTruncated: \(Swift.String(describing: stepExecutionsTruncated)), target: \(Swift.String(describing: target)), targetLocations: \(Swift.String(describing: targetLocations)), targetMaps: \(Swift.String(describing: targetMaps)), targetParameterName: \(Swift.String(describing: targetParameterName)), targets: \(Swift.String(describing: targets)))"}
}

extension SsmClientTypes {
    /// Detailed information about the current state of an individual Automation execution.
    public struct AutomationExecution: Swift.Equatable {
        /// The ID of a State Manager association used in the Automation operation.
        public var associationId: Swift.String?
        /// The execution ID.
        public var automationExecutionId: Swift.String?
        /// The execution status of the Automation.
        public var automationExecutionStatus: SsmClientTypes.AutomationExecutionStatus?
        /// The subtype of the Automation operation. Currently, the only supported value is ChangeRequest.
        public var automationSubtype: SsmClientTypes.AutomationSubtype?
        /// The name of the Change Manager change request.
        public var changeRequestName: Swift.String?
        /// The action of the step that is currently running.
        public var currentAction: Swift.String?
        /// The name of the step that is currently running.
        public var currentStepName: Swift.String?
        /// The name of the Automation runbook used during the execution.
        public var documentName: Swift.String?
        /// The version of the document to use during execution.
        public var documentVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who ran the automation.
        public var executedBy: Swift.String?
        /// The time the execution finished.
        public var executionEndTime: ClientRuntime.Date?
        /// The time the execution started.
        public var executionStartTime: ClientRuntime.Date?
        /// A message describing why an execution has failed, if the status is set to Failed.
        public var failureMessage: Swift.String?
        /// The MaxConcurrency value specified by the user when the execution started.
        public var maxConcurrency: Swift.String?
        /// The MaxErrors value specified by the user when the execution started.
        public var maxErrors: Swift.String?
        /// The automation execution mode.
        public var mode: SsmClientTypes.ExecutionMode?
        /// The ID of an OpsItem that is created to represent a Change Manager change request.
        public var opsItemId: Swift.String?
        /// The list of execution outputs as defined in the Automation runbook.
        public var outputs: [Swift.String:[Swift.String]]?
        /// The key-value map of execution parameters, which were supplied when calling [StartAutomationExecution].
        public var parameters: [Swift.String:[Swift.String]]?
        /// The AutomationExecutionId of the parent automation.
        public var parentAutomationExecutionId: Swift.String?
        /// An aggregate of step execution statuses displayed in the Amazon Web Services Systems Manager console for a multi-Region and multi-account Automation execution.
        public var progressCounters: SsmClientTypes.ProgressCounters?
        /// A list of resolved targets in the rate control execution.
        public var resolvedTargets: SsmClientTypes.ResolvedTargets?
        /// Information about the Automation runbooks that are run as part of a runbook workflow. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
        public var runbooks: [SsmClientTypes.Runbook]?
        /// The date and time the Automation operation is scheduled to start.
        public var scheduledTime: ClientRuntime.Date?
        /// A list of details about the current state of all steps that comprise an execution. An Automation runbook contains a list of steps that are run in order.
        public var stepExecutions: [SsmClientTypes.StepExecution]?
        /// A boolean value that indicates if the response contains the full list of the Automation step executions. If true, use the DescribeAutomationStepExecutions API operation to get the full list of step executions.
        public var stepExecutionsTruncated: Swift.Bool
        /// The target of the execution.
        public var target: Swift.String?
        /// The combination of Amazon Web Services Regions and/or Amazon Web Services accounts where you want to run the Automation.
        public var targetLocations: [SsmClientTypes.TargetLocation]?
        /// The specified key-value mapping of document parameters to target resources.
        public var targetMaps: [[Swift.String:[Swift.String]]]?
        /// The parameter name.
        public var targetParameterName: Swift.String?
        /// The specified targets.
        public var targets: [SsmClientTypes.Target]?

        public init (
            associationId: Swift.String? = nil,
            automationExecutionId: Swift.String? = nil,
            automationExecutionStatus: SsmClientTypes.AutomationExecutionStatus? = nil,
            automationSubtype: SsmClientTypes.AutomationSubtype? = nil,
            changeRequestName: Swift.String? = nil,
            currentAction: Swift.String? = nil,
            currentStepName: Swift.String? = nil,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            executedBy: Swift.String? = nil,
            executionEndTime: ClientRuntime.Date? = nil,
            executionStartTime: ClientRuntime.Date? = nil,
            failureMessage: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            mode: SsmClientTypes.ExecutionMode? = nil,
            opsItemId: Swift.String? = nil,
            outputs: [Swift.String:[Swift.String]]? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            parentAutomationExecutionId: Swift.String? = nil,
            progressCounters: SsmClientTypes.ProgressCounters? = nil,
            resolvedTargets: SsmClientTypes.ResolvedTargets? = nil,
            runbooks: [SsmClientTypes.Runbook]? = nil,
            scheduledTime: ClientRuntime.Date? = nil,
            stepExecutions: [SsmClientTypes.StepExecution]? = nil,
            stepExecutionsTruncated: Swift.Bool = false,
            target: Swift.String? = nil,
            targetLocations: [SsmClientTypes.TargetLocation]? = nil,
            targetMaps: [[Swift.String:[Swift.String]]]? = nil,
            targetParameterName: Swift.String? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.associationId = associationId
            self.automationExecutionId = automationExecutionId
            self.automationExecutionStatus = automationExecutionStatus
            self.automationSubtype = automationSubtype
            self.changeRequestName = changeRequestName
            self.currentAction = currentAction
            self.currentStepName = currentStepName
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.executedBy = executedBy
            self.executionEndTime = executionEndTime
            self.executionStartTime = executionStartTime
            self.failureMessage = failureMessage
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.mode = mode
            self.opsItemId = opsItemId
            self.outputs = outputs
            self.parameters = parameters
            self.parentAutomationExecutionId = parentAutomationExecutionId
            self.progressCounters = progressCounters
            self.resolvedTargets = resolvedTargets
            self.runbooks = runbooks
            self.scheduledTime = scheduledTime
            self.stepExecutions = stepExecutions
            self.stepExecutionsTruncated = stepExecutionsTruncated
            self.target = target
            self.targetLocations = targetLocations
            self.targetMaps = targetMaps
            self.targetParameterName = targetParameterName
            self.targets = targets
        }
    }

}

extension SsmClientTypes.AutomationExecutionFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for automationexecutionfiltervaluelist0 in values {
                try valuesContainer.encode(automationexecutionfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecutionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.AutomationExecutionFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomationExecutionFilter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// A filter used to match specific automation executions. This is used to limit the scope of Automation execution information returned.
    public struct AutomationExecutionFilter: Swift.Equatable {
        /// One or more keys to limit the results.
        /// This member is required.
        public var key: SsmClientTypes.AutomationExecutionFilterKey?
        /// The values used to limit the execution information associated with the filter's key.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.AutomationExecutionFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum AutomationExecutionFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automationSubtype
        case automationType
        case currentAction
        case documentNamePrefix
        case executionId
        case executionStatus
        case opsItemId
        case parentExecutionId
        case startTimeAfter
        case startTimeBefore
        case tagKey
        case targetResourceGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationExecutionFilterKey] {
            return [
                .automationSubtype,
                .automationType,
                .currentAction,
                .documentNamePrefix,
                .executionId,
                .executionStatus,
                .opsItemId,
                .parentExecutionId,
                .startTimeAfter,
                .startTimeBefore,
                .tagKey,
                .targetResourceGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automationSubtype: return "AutomationSubtype"
            case .automationType: return "AutomationType"
            case .currentAction: return "CurrentAction"
            case .documentNamePrefix: return "DocumentNamePrefix"
            case .executionId: return "ExecutionId"
            case .executionStatus: return "ExecutionStatus"
            case .opsItemId: return "OpsItemId"
            case .parentExecutionId: return "ParentExecutionId"
            case .startTimeAfter: return "StartTimeAfter"
            case .startTimeBefore: return "StartTimeBefore"
            case .tagKey: return "TagKey"
            case .targetResourceGroup: return "TargetResourceGroup"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomationExecutionFilterKey(rawValue: rawValue) ?? AutomationExecutionFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension AutomationExecutionLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomationExecutionLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension AutomationExecutionLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationExecutionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of simultaneously running Automation executions exceeded the allowable limit.
public struct AutomationExecutionLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationExecutionLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AutomationExecutionLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.AutomationExecutionMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case automationExecutionId = "AutomationExecutionId"
        case automationExecutionStatus = "AutomationExecutionStatus"
        case automationSubtype = "AutomationSubtype"
        case automationType = "AutomationType"
        case changeRequestName = "ChangeRequestName"
        case currentAction = "CurrentAction"
        case currentStepName = "CurrentStepName"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case executedBy = "ExecutedBy"
        case executionEndTime = "ExecutionEndTime"
        case executionStartTime = "ExecutionStartTime"
        case failureMessage = "FailureMessage"
        case logFile = "LogFile"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case opsItemId = "OpsItemId"
        case outputs = "Outputs"
        case parentAutomationExecutionId = "ParentAutomationExecutionId"
        case resolvedTargets = "ResolvedTargets"
        case runbooks = "Runbooks"
        case scheduledTime = "ScheduledTime"
        case target = "Target"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let automationExecutionStatus = automationExecutionStatus {
            try encodeContainer.encode(automationExecutionStatus.rawValue, forKey: .automationExecutionStatus)
        }
        if let automationSubtype = automationSubtype {
            try encodeContainer.encode(automationSubtype.rawValue, forKey: .automationSubtype)
        }
        if let automationType = automationType {
            try encodeContainer.encode(automationType.rawValue, forKey: .automationType)
        }
        if let changeRequestName = changeRequestName {
            try encodeContainer.encode(changeRequestName, forKey: .changeRequestName)
        }
        if let currentAction = currentAction {
            try encodeContainer.encode(currentAction, forKey: .currentAction)
        }
        if let currentStepName = currentStepName {
            try encodeContainer.encode(currentStepName, forKey: .currentStepName)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let executedBy = executedBy {
            try encodeContainer.encode(executedBy, forKey: .executedBy)
        }
        if let executionEndTime = executionEndTime {
            try encodeContainer.encode(executionEndTime.timeIntervalSince1970, forKey: .executionEndTime)
        }
        if let executionStartTime = executionStartTime {
            try encodeContainer.encode(executionStartTime.timeIntervalSince1970, forKey: .executionStartTime)
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let logFile = logFile {
            try encodeContainer.encode(logFile, forKey: .logFile)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputs)
            for (dictKey0, automationparametermap0) in outputs {
                try outputsContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let parentAutomationExecutionId = parentAutomationExecutionId {
            try encodeContainer.encode(parentAutomationExecutionId, forKey: .parentAutomationExecutionId)
        }
        if let resolvedTargets = resolvedTargets {
            try encodeContainer.encode(resolvedTargets, forKey: .resolvedTargets)
        }
        if let runbooks = runbooks {
            var runbooksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runbooks)
            for runbooks0 in runbooks {
                try runbooksContainer.encode(runbooks0)
            }
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetMaps = targetMaps {
            var targetMapsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetMaps)
            for targetmaps0 in targetMaps {
                var targetmaps0Container = targetMapsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, targetmap1) in targetmaps0 {
                    var targetmap1Container = targetmaps0Container.nestedUnkeyedContainer(forKey: ClientRuntime.Key(dictKey1))
                    for targetmapvaluelist2 in targetmap1 {
                        try targetmap1Container.encode(targetmapvaluelist2)
                    }
                }
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let automationExecutionStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecutionStatus.self, forKey: .automationExecutionStatus)
        automationExecutionStatus = automationExecutionStatusDecoded
        let executionStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionStartTime)
        executionStartTime = executionStartTimeDecoded
        let executionEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionEndTime)
        executionEndTime = executionEndTimeDecoded
        let executedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executedBy)
        executedBy = executedByDecoded
        let logFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logFile)
        logFile = logFileDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .outputs)
        var outputsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in outputsContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                outputsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        outputs = outputsDecoded0
        let modeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ExecutionMode.self, forKey: .mode)
        mode = modeDecoded
        let parentAutomationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentAutomationExecutionId)
        parentAutomationExecutionId = parentAutomationExecutionIdDecoded
        let currentStepNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentStepName)
        currentStepName = currentStepNameDecoded
        let currentActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentAction)
        currentAction = currentActionDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetMapsContainer = try containerValues.decodeIfPresent([[Swift.String: [Swift.String?]?]?].self, forKey: .targetMaps)
        var targetMapsDecoded0:[[Swift.String:[Swift.String]]]? = nil
        if let targetMapsContainer = targetMapsContainer {
            targetMapsDecoded0 = [[Swift.String:[Swift.String]]]()
            for map0 in targetMapsContainer {
                var targetMapsContainerDecoded0: [Swift.String: [Swift.String]]? = nil
                if let map0 = map0 {
                    targetMapsContainerDecoded0 = [Swift.String: [Swift.String]]()
                    for (key1, targetmapvaluelist1) in map0 {
                        var targetmapvaluelist1Decoded1: [Swift.String]? = nil
                        if let targetmapvaluelist1 = targetmapvaluelist1 {
                            targetmapvaluelist1Decoded1 = [Swift.String]()
                            for string2 in targetmapvaluelist1 {
                                if let string2 = string2 {
                                    targetmapvaluelist1Decoded1?.append(string2)
                                }
                            }
                        }
                        targetMapsContainerDecoded0?[key1] = targetmapvaluelist1Decoded1
                    }
                }
                if let targetMapsContainerDecoded0 = targetMapsContainerDecoded0 {
                    targetMapsDecoded0?.append(targetMapsContainerDecoded0)
                }
            }
        }
        targetMaps = targetMapsDecoded0
        let resolvedTargetsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResolvedTargets.self, forKey: .resolvedTargets)
        resolvedTargets = resolvedTargetsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let automationTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationType.self, forKey: .automationType)
        automationType = automationTypeDecoded
        let automationSubtypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationSubtype.self, forKey: .automationSubtype)
        automationSubtype = automationSubtypeDecoded
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
        let runbooksContainer = try containerValues.decodeIfPresent([SsmClientTypes.Runbook?].self, forKey: .runbooks)
        var runbooksDecoded0:[SsmClientTypes.Runbook]? = nil
        if let runbooksContainer = runbooksContainer {
            runbooksDecoded0 = [SsmClientTypes.Runbook]()
            for structure0 in runbooksContainer {
                if let structure0 = structure0 {
                    runbooksDecoded0?.append(structure0)
                }
            }
        }
        runbooks = runbooksDecoded0
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let changeRequestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeRequestName)
        changeRequestName = changeRequestNameDecoded
    }
}

extension SsmClientTypes.AutomationExecutionMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomationExecutionMetadata(associationId: \(Swift.String(describing: associationId)), automationExecutionId: \(Swift.String(describing: automationExecutionId)), automationExecutionStatus: \(Swift.String(describing: automationExecutionStatus)), automationSubtype: \(Swift.String(describing: automationSubtype)), automationType: \(Swift.String(describing: automationType)), changeRequestName: \(Swift.String(describing: changeRequestName)), currentAction: \(Swift.String(describing: currentAction)), currentStepName: \(Swift.String(describing: currentStepName)), documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), executedBy: \(Swift.String(describing: executedBy)), executionEndTime: \(Swift.String(describing: executionEndTime)), executionStartTime: \(Swift.String(describing: executionStartTime)), failureMessage: \(Swift.String(describing: failureMessage)), logFile: \(Swift.String(describing: logFile)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), mode: \(Swift.String(describing: mode)), opsItemId: \(Swift.String(describing: opsItemId)), outputs: \(Swift.String(describing: outputs)), parentAutomationExecutionId: \(Swift.String(describing: parentAutomationExecutionId)), resolvedTargets: \(Swift.String(describing: resolvedTargets)), runbooks: \(Swift.String(describing: runbooks)), scheduledTime: \(Swift.String(describing: scheduledTime)), target: \(Swift.String(describing: target)), targetMaps: \(Swift.String(describing: targetMaps)), targetParameterName: \(Swift.String(describing: targetParameterName)), targets: \(Swift.String(describing: targets)))"}
}

extension SsmClientTypes {
    /// Details about a specific Automation execution.
    public struct AutomationExecutionMetadata: Swift.Equatable {
        /// The ID of a State Manager association used in the Automation operation.
        public var associationId: Swift.String?
        /// The execution ID.
        public var automationExecutionId: Swift.String?
        /// The status of the execution.
        public var automationExecutionStatus: SsmClientTypes.AutomationExecutionStatus?
        /// The subtype of the Automation operation. Currently, the only supported value is ChangeRequest.
        public var automationSubtype: SsmClientTypes.AutomationSubtype?
        /// Use this filter with [DescribeAutomationExecutions]. Specify either Local or CrossAccount. CrossAccount is an Automation that runs in multiple Amazon Web Services Regions and Amazon Web Services accounts. For more information, see [Running Automation workflows in multiple Amazon Web Services Regions and accounts](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html) in the Amazon Web Services Systems Manager User Guide.
        public var automationType: SsmClientTypes.AutomationType?
        /// The name of the Change Manager change request.
        public var changeRequestName: Swift.String?
        /// The action of the step that is currently running.
        public var currentAction: Swift.String?
        /// The name of the step that is currently running.
        public var currentStepName: Swift.String?
        /// The name of the Automation runbook used during execution.
        public var documentName: Swift.String?
        /// The document version used during the execution.
        public var documentVersion: Swift.String?
        /// The IAM role ARN of the user who ran the automation.
        public var executedBy: Swift.String?
        /// The time the execution finished. This isn't populated if the execution is still in progress.
        public var executionEndTime: ClientRuntime.Date?
        /// The time the execution started.
        public var executionStartTime: ClientRuntime.Date?
        /// The list of execution outputs as defined in the Automation runbook.
        public var failureMessage: Swift.String?
        /// An S3 bucket where execution information is stored.
        public var logFile: Swift.String?
        /// The MaxConcurrency value specified by the user when starting the automation.
        public var maxConcurrency: Swift.String?
        /// The MaxErrors value specified by the user when starting the automation.
        public var maxErrors: Swift.String?
        /// The Automation execution mode.
        public var mode: SsmClientTypes.ExecutionMode?
        /// The ID of an OpsItem that is created to represent a Change Manager change request.
        public var opsItemId: Swift.String?
        /// The list of execution outputs as defined in the Automation runbook.
        public var outputs: [Swift.String:[Swift.String]]?
        /// The execution ID of the parent automation.
        public var parentAutomationExecutionId: Swift.String?
        /// A list of targets that resolved during the execution.
        public var resolvedTargets: SsmClientTypes.ResolvedTargets?
        /// Information about the Automation runbooks that are run during a runbook workflow in Change Manager. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
        public var runbooks: [SsmClientTypes.Runbook]?
        /// The date and time the Automation operation is scheduled to start.
        public var scheduledTime: ClientRuntime.Date?
        /// The list of execution outputs as defined in the Automation runbook.
        public var target: Swift.String?
        /// The specified key-value mapping of document parameters to target resources.
        public var targetMaps: [[Swift.String:[Swift.String]]]?
        /// The list of execution outputs as defined in the Automation runbook.
        public var targetParameterName: Swift.String?
        /// The targets defined by the user when starting the automation.
        public var targets: [SsmClientTypes.Target]?

        public init (
            associationId: Swift.String? = nil,
            automationExecutionId: Swift.String? = nil,
            automationExecutionStatus: SsmClientTypes.AutomationExecutionStatus? = nil,
            automationSubtype: SsmClientTypes.AutomationSubtype? = nil,
            automationType: SsmClientTypes.AutomationType? = nil,
            changeRequestName: Swift.String? = nil,
            currentAction: Swift.String? = nil,
            currentStepName: Swift.String? = nil,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            executedBy: Swift.String? = nil,
            executionEndTime: ClientRuntime.Date? = nil,
            executionStartTime: ClientRuntime.Date? = nil,
            failureMessage: Swift.String? = nil,
            logFile: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            mode: SsmClientTypes.ExecutionMode? = nil,
            opsItemId: Swift.String? = nil,
            outputs: [Swift.String:[Swift.String]]? = nil,
            parentAutomationExecutionId: Swift.String? = nil,
            resolvedTargets: SsmClientTypes.ResolvedTargets? = nil,
            runbooks: [SsmClientTypes.Runbook]? = nil,
            scheduledTime: ClientRuntime.Date? = nil,
            target: Swift.String? = nil,
            targetMaps: [[Swift.String:[Swift.String]]]? = nil,
            targetParameterName: Swift.String? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.associationId = associationId
            self.automationExecutionId = automationExecutionId
            self.automationExecutionStatus = automationExecutionStatus
            self.automationSubtype = automationSubtype
            self.automationType = automationType
            self.changeRequestName = changeRequestName
            self.currentAction = currentAction
            self.currentStepName = currentStepName
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.executedBy = executedBy
            self.executionEndTime = executionEndTime
            self.executionStartTime = executionStartTime
            self.failureMessage = failureMessage
            self.logFile = logFile
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.mode = mode
            self.opsItemId = opsItemId
            self.outputs = outputs
            self.parentAutomationExecutionId = parentAutomationExecutionId
            self.resolvedTargets = resolvedTargets
            self.runbooks = runbooks
            self.scheduledTime = scheduledTime
            self.target = target
            self.targetMaps = targetMaps
            self.targetParameterName = targetParameterName
            self.targets = targets
        }
    }

}

extension AutomationExecutionNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomationExecutionNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension AutomationExecutionNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationExecutionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is no automation execution information for the requested automation execution ID.
public struct AutomationExecutionNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationExecutionNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AutomationExecutionNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum AutomationExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case cancelled
        case cancelling
        case changeCalendarOverrideApproved
        case changeCalendarOverrideRejected
        case completedWithFailure
        case completedWithSuccess
        case failed
        case inprogress
        case pending
        case pendingApproval
        case pendingChangeCalendarOverride
        case rejected
        case runbookInprogress
        case scheduled
        case success
        case timedout
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationExecutionStatus] {
            return [
                .approved,
                .cancelled,
                .cancelling,
                .changeCalendarOverrideApproved,
                .changeCalendarOverrideRejected,
                .completedWithFailure,
                .completedWithSuccess,
                .failed,
                .inprogress,
                .pending,
                .pendingApproval,
                .pendingChangeCalendarOverride,
                .rejected,
                .runbookInprogress,
                .scheduled,
                .success,
                .timedout,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "Approved"
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .changeCalendarOverrideApproved: return "ChangeCalendarOverrideApproved"
            case .changeCalendarOverrideRejected: return "ChangeCalendarOverrideRejected"
            case .completedWithFailure: return "CompletedWithFailure"
            case .completedWithSuccess: return "CompletedWithSuccess"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .pendingApproval: return "PendingApproval"
            case .pendingChangeCalendarOverride: return "PendingChangeCalendarOverride"
            case .rejected: return "Rejected"
            case .runbookInprogress: return "RunbookInProgress"
            case .scheduled: return "Scheduled"
            case .success: return "Success"
            case .timedout: return "TimedOut"
            case .waiting: return "Waiting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomationExecutionStatus(rawValue: rawValue) ?? AutomationExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AutomationStepNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomationStepNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension AutomationStepNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationStepNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified step name and execution ID don't exist. Verify the information and try again.
public struct AutomationStepNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationStepNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AutomationStepNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum AutomationSubtype: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case changerequest
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationSubtype] {
            return [
                .changerequest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .changerequest: return "ChangeRequest"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomationSubtype(rawValue: rawValue) ?? AutomationSubtype.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum AutomationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case crossaccount
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationType] {
            return [
                .crossaccount,
                .local,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .crossaccount: return "CrossAccount"
            case .local: return "Local"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomationType(rawValue: rawValue) ?? AutomationType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.BaselineOverride: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case globalFilters = "GlobalFilters"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let globalFilters = globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension SsmClientTypes.BaselineOverride: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BaselineOverride(approvalRules: \(Swift.String(describing: approvalRules)), approvedPatches: \(Swift.String(describing: approvedPatches)), approvedPatchesComplianceLevel: \(Swift.String(describing: approvedPatchesComplianceLevel)), approvedPatchesEnableNonSecurity: \(Swift.String(describing: approvedPatchesEnableNonSecurity)), globalFilters: \(Swift.String(describing: globalFilters)), operatingSystem: \(Swift.String(describing: operatingSystem)), rejectedPatches: \(Swift.String(describing: rejectedPatches)), rejectedPatchesAction: \(Swift.String(describing: rejectedPatchesAction)), sources: \(Swift.String(describing: sources)))"}
}

extension SsmClientTypes {
    /// Defines the basic information about a patch baseline override.
    public struct BaselineOverride: Swift.Equatable {
        /// A set of rules defining the approval rules for a patch baseline.
        public var approvalRules: SsmClientTypes.PatchRuleGroup?
        /// A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
        public var approvedPatches: [Swift.String]?
        /// Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation.
        public var approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
        /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
        public var approvedPatchesEnableNonSecurity: Swift.Bool
        /// A set of patch filters, typically used for approval rules.
        public var globalFilters: SsmClientTypes.PatchFilterGroup?
        /// The operating system rule used by the patch baseline override.
        public var operatingSystem: SsmClientTypes.OperatingSystem?
        /// A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
        public var rejectedPatches: [Swift.String]?
        /// The action for Patch Manager to take on patches included in the RejectedPackages list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.
        public var rejectedPatchesAction: SsmClientTypes.PatchAction?
        /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
        public var sources: [SsmClientTypes.PatchSource]?

        public init (
            approvalRules: SsmClientTypes.PatchRuleGroup? = nil,
            approvedPatches: [Swift.String]? = nil,
            approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
            approvedPatchesEnableNonSecurity: Swift.Bool = false,
            globalFilters: SsmClientTypes.PatchFilterGroup? = nil,
            operatingSystem: SsmClientTypes.OperatingSystem? = nil,
            rejectedPatches: [Swift.String]? = nil,
            rejectedPatchesAction: SsmClientTypes.PatchAction? = nil,
            sources: [SsmClientTypes.PatchSource]? = nil
        )
        {
            self.approvalRules = approvalRules
            self.approvedPatches = approvedPatches
            self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
            self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
            self.globalFilters = globalFilters
            self.operatingSystem = operatingSystem
            self.rejectedPatches = rejectedPatches
            self.rejectedPatchesAction = rejectedPatchesAction
            self.sources = sources
        }
    }

}

extension SsmClientTypes {
    public enum CalendarState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [CalendarState] {
            return [
                .closed,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .open: return "OPEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CalendarState(rawValue: rawValue) ?? CalendarState.sdkUnknown(rawValue)
        }
    }
}

public struct CancelCommandInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelCommandInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelCommandInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelCommandInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelCommandOutputError>
}

extension CancelCommandInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelCommandInput(commandId: \(Swift.String(describing: commandId)), instanceIds: \(Swift.String(describing: instanceIds)))"}
}

extension CancelCommandInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case instanceIds = "InstanceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
    }
}

public struct CancelCommandInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelCommandInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelCommandInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelCommandInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelCommandOutputError>
}

public struct CancelCommandInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelCommandInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelCommandInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelCommandInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelCommandOutputError>
}

public struct CancelCommandInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelCommandInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CancelCommandInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelCommandInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelCommandOutputError>
}

public struct CancelCommandInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelCommandInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CancelCommandInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelCommandInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelCommandOutputError>
}

///
public struct CancelCommandInput: Swift.Equatable {
    /// The ID of the command you want to cancel.
    /// This member is required.
    public var commandId: Swift.String?
    /// (Optional) A list of managed node IDs on which you want to cancel the command. If not provided, the command is canceled on every node on which it was requested.
    public var instanceIds: [Swift.String]?

    public init (
        commandId: Swift.String? = nil,
        instanceIds: [Swift.String]? = nil
    )
    {
        self.commandId = commandId
        self.instanceIds = instanceIds
    }
}

struct CancelCommandInputBody: Swift.Equatable {
    public let commandId: Swift.String?
    public let instanceIds: [Swift.String]?
}

extension CancelCommandInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case instanceIds = "InstanceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension CancelCommandOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelCommandOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateInstanceId" : self = .duplicateInstanceId(try DuplicateInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelCommandOutputError: Swift.Error, Swift.Equatable {
    case duplicateInstanceId(DuplicateInstanceId)
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelCommandOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelCommandOutputResponse()"}
}

extension CancelCommandOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Whether or not the command was successfully canceled. There is no guarantee that a request can be canceled.
public struct CancelCommandOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelCommandOutputResponseBody: Swift.Equatable {
}

extension CancelCommandOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CancelMaintenanceWindowExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelMaintenanceWindowExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelMaintenanceWindowExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelMaintenanceWindowExecutionOutputError>
}

extension CancelMaintenanceWindowExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelMaintenanceWindowExecutionInput(windowExecutionId: \(Swift.String(describing: windowExecutionId)))"}
}

extension CancelMaintenanceWindowExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct CancelMaintenanceWindowExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelMaintenanceWindowExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelMaintenanceWindowExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelMaintenanceWindowExecutionOutputError>
}

public struct CancelMaintenanceWindowExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelMaintenanceWindowExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelMaintenanceWindowExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelMaintenanceWindowExecutionOutputError>
}

public struct CancelMaintenanceWindowExecutionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelMaintenanceWindowExecutionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CancelMaintenanceWindowExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelMaintenanceWindowExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelMaintenanceWindowExecutionOutputError>
}

public struct CancelMaintenanceWindowExecutionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelMaintenanceWindowExecutionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CancelMaintenanceWindowExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelMaintenanceWindowExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelMaintenanceWindowExecutionOutputError>
}

public struct CancelMaintenanceWindowExecutionInput: Swift.Equatable {
    /// The ID of the maintenance window execution to stop.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        windowExecutionId: Swift.String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

struct CancelMaintenanceWindowExecutionInputBody: Swift.Equatable {
    public let windowExecutionId: Swift.String?
}

extension CancelMaintenanceWindowExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
    }
}

extension CancelMaintenanceWindowExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelMaintenanceWindowExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelMaintenanceWindowExecutionOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelMaintenanceWindowExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelMaintenanceWindowExecutionOutputResponse(windowExecutionId: \(Swift.String(describing: windowExecutionId)))"}
}

extension CancelMaintenanceWindowExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelMaintenanceWindowExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowExecutionId = output.windowExecutionId
        } else {
            self.windowExecutionId = nil
        }
    }
}

public struct CancelMaintenanceWindowExecutionOutputResponse: Swift.Equatable {
    /// The ID of the maintenance window execution that has been stopped.
    public var windowExecutionId: Swift.String?

    public init (
        windowExecutionId: Swift.String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

struct CancelMaintenanceWindowExecutionOutputResponseBody: Swift.Equatable {
    public let windowExecutionId: Swift.String?
}

extension CancelMaintenanceWindowExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
    }
}

extension SsmClientTypes.CloudWatchOutputConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupName = "CloudWatchLogGroupName"
        case cloudWatchOutputEnabled = "CloudWatchOutputEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupName = cloudWatchLogGroupName {
            try encodeContainer.encode(cloudWatchLogGroupName, forKey: .cloudWatchLogGroupName)
        }
        if cloudWatchOutputEnabled != false {
            try encodeContainer.encode(cloudWatchOutputEnabled, forKey: .cloudWatchOutputEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupName)
        cloudWatchLogGroupName = cloudWatchLogGroupNameDecoded
        let cloudWatchOutputEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .cloudWatchOutputEnabled)
        cloudWatchOutputEnabled = cloudWatchOutputEnabledDecoded
    }
}

extension SsmClientTypes.CloudWatchOutputConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudWatchOutputConfig(cloudWatchLogGroupName: \(Swift.String(describing: cloudWatchLogGroupName)), cloudWatchOutputEnabled: \(Swift.String(describing: cloudWatchOutputEnabled)))"}
}

extension SsmClientTypes {
    /// Configuration options for sending command output to Amazon CloudWatch Logs.
    public struct CloudWatchOutputConfig: Swift.Equatable {
        /// The name of the CloudWatch Logs log group where you want to send command output. If you don't specify a group name, Amazon Web Services Systems Manager automatically creates a log group for you. The log group uses the following naming format: aws/ssm/SystemsManagerDocumentName
        public var cloudWatchLogGroupName: Swift.String?
        /// Enables Systems Manager to send command output to CloudWatch Logs.
        public var cloudWatchOutputEnabled: Swift.Bool

        public init (
            cloudWatchLogGroupName: Swift.String? = nil,
            cloudWatchOutputEnabled: Swift.Bool = false
        )
        {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.cloudWatchOutputEnabled = cloudWatchOutputEnabled
        }
    }

}

extension SsmClientTypes.Command: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case commandId = "CommandId"
        case comment = "Comment"
        case completedCount = "CompletedCount"
        case deliveryTimedOutCount = "DeliveryTimedOutCount"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case errorCount = "ErrorCount"
        case expiresAfter = "ExpiresAfter"
        case instanceIds = "InstanceIds"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case parameters = "Parameters"
        case requestedDateTime = "RequestedDateTime"
        case serviceRole = "ServiceRole"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case targetCount = "TargetCount"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if completedCount != 0 {
            try encodeContainer.encode(completedCount, forKey: .completedCount)
        }
        if deliveryTimedOutCount != 0 {
            try encodeContainer.encode(deliveryTimedOutCount, forKey: .deliveryTimedOutCount)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if errorCount != 0 {
            try encodeContainer.encode(errorCount, forKey: .errorCount)
        }
        if let expiresAfter = expiresAfter {
            try encodeContainer.encode(expiresAfter.timeIntervalSince1970, forKey: .expiresAfter)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestedDateTime = requestedDateTime {
            try encodeContainer.encode(requestedDateTime.timeIntervalSince1970, forKey: .requestedDateTime)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if targetCount != 0 {
            try encodeContainer.encode(targetCount, forKey: .targetCount)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let expiresAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiresAfter)
        expiresAfter = expiresAfterDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let requestedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .requestedDateTime)
        requestedDateTime = requestedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CommandStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .targetCount)
        targetCount = targetCountDecoded
        let completedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .completedCount)
        completedCount = completedCountDecoded
        let errorCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .errorCount)
        errorCount = errorCountDecoded
        let deliveryTimedOutCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .deliveryTimedOutCount)
        deliveryTimedOutCount = deliveryTimedOutCountDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
    }
}

extension SsmClientTypes.Command: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Command(cloudWatchOutputConfig: \(Swift.String(describing: cloudWatchOutputConfig)), commandId: \(Swift.String(describing: commandId)), comment: \(Swift.String(describing: comment)), completedCount: \(Swift.String(describing: completedCount)), deliveryTimedOutCount: \(Swift.String(describing: deliveryTimedOutCount)), documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), errorCount: \(Swift.String(describing: errorCount)), expiresAfter: \(Swift.String(describing: expiresAfter)), instanceIds: \(Swift.String(describing: instanceIds)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), notificationConfig: \(Swift.String(describing: notificationConfig)), outputS3BucketName: \(Swift.String(describing: outputS3BucketName)), outputS3KeyPrefix: \(Swift.String(describing: outputS3KeyPrefix)), outputS3Region: \(Swift.String(describing: outputS3Region)), parameters: \(Swift.String(describing: parameters)), requestedDateTime: \(Swift.String(describing: requestedDateTime)), serviceRole: \(Swift.String(describing: serviceRole)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), targetCount: \(Swift.String(describing: targetCount)), targets: \(Swift.String(describing: targets)), timeoutSeconds: \(Swift.String(describing: timeoutSeconds)))"}
}

extension SsmClientTypes {
    /// Describes a command request.
    public struct Command: Swift.Equatable {
        /// Amazon CloudWatch Logs information where you want Amazon Web Services Systems Manager to send the command output.
        public var cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
        /// A unique identifier for this command.
        public var commandId: Swift.String?
        /// User-specified information about the command, such as a brief description of what the command should do.
        public var comment: Swift.String?
        /// The number of targets for which the command invocation reached a terminal state. Terminal states include the following: Success, Failed, Execution Timed Out, Delivery Timed Out, Canceled, Terminated, or Undeliverable.
        public var completedCount: Swift.Int
        /// The number of targets for which the status is Delivery Timed Out.
        public var deliveryTimedOutCount: Swift.Int
        /// The name of the document requested for execution.
        public var documentName: Swift.String?
        /// The Systems Manager document (SSM document) version.
        public var documentVersion: Swift.String?
        /// The number of targets for which the status is Failed or Execution Timed Out.
        public var errorCount: Swift.Int
        /// If this time is reached and the command hasn't already started running, it won't run. Calculated based on the ExpiresAfter user input provided as part of the SendCommand API operation.
        public var expiresAfter: ClientRuntime.Date?
        /// The managed node IDs against which this command was requested.
        public var instanceIds: [Swift.String]?
        /// The maximum number of managed nodes that are allowed to run the command at the same time. You can specify a number of managed nodes, such as 10, or a percentage of nodes, such as 10%. The default value is 50. For more information about how to use MaxConcurrency, see [Running commands using Systems Manager Run Command](https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html) in the Amazon Web Services Systems Manager User Guide.
        public var maxConcurrency: Swift.String?
        /// The maximum number of errors allowed before the system stops sending the command to additional targets. You can specify a number of errors, such as 10, or a percentage or errors, such as 10%. The default value is 0. For more information about how to use MaxErrors, see [Running commands using Systems Manager Run Command](https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html) in the Amazon Web Services Systems Manager User Guide.
        public var maxErrors: Swift.String?
        /// Configurations for sending notifications about command status changes.
        public var notificationConfig: SsmClientTypes.NotificationConfig?
        /// The S3 bucket where the responses to the command executions should be stored. This was requested when issuing the command.
        public var outputS3BucketName: Swift.String?
        /// The S3 directory path inside the bucket where the responses to the command executions should be stored. This was requested when issuing the command.
        public var outputS3KeyPrefix: Swift.String?
        /// (Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager automatically determines the Amazon Web Services Region of the S3 bucket.
        public var outputS3Region: Swift.String?
        /// The parameter values to be inserted in the document when running the command.
        public var parameters: [Swift.String:[Swift.String]]?
        /// The date and time the command was requested.
        public var requestedDateTime: ClientRuntime.Date?
        /// The Identity and Access Management (IAM) service role that Run Command, a capability of Amazon Web Services Systems Manager, uses to act on your behalf when sending notifications about command status changes.
        public var serviceRole: Swift.String?
        /// The status of the command.
        public var status: SsmClientTypes.CommandStatus?
        /// A detailed status of the command execution. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
        ///
        /// * Pending: The command hasn't been sent to any managed nodes.
        ///
        /// * In Progress: The command has been sent to at least one managed node but hasn't reached a final state on all managed nodes.
        ///
        /// * Success: The command successfully ran on all invocations. This is a terminal state.
        ///
        /// * Delivery Timed Out: The value of MaxErrors or more command invocations shows a status of Delivery Timed Out. This is a terminal state.
        ///
        /// * Execution Timed Out: The value of MaxErrors or more command invocations shows a status of Execution Timed Out. This is a terminal state.
        ///
        /// * Failed: The value of MaxErrors or more command invocations shows a status of Failed. This is a terminal state.
        ///
        /// * Incomplete: The command was attempted on all managed nodes and one or more invocations doesn't have a value of Success but not enough invocations failed for the status to be Failed. This is a terminal state.
        ///
        /// * Canceled: The command was terminated before it was completed. This is a terminal state.
        ///
        /// * Rate Exceeded: The number of managed nodes targeted by the command exceeded the account limit for pending invocations. The system has canceled the command before running it on any managed node. This is a terminal state.
        public var statusDetails: Swift.String?
        /// The number of targets for the command.
        public var targetCount: Swift.Int
        /// An array of search criteria that targets managed nodes using a Key,Value combination that you specify. Targets is required if you don't provide one or more managed node IDs in the call.
        public var targets: [SsmClientTypes.Target]?
        /// The TimeoutSeconds value specified for a command.
        public var timeoutSeconds: Swift.Int

        public init (
            cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig? = nil,
            commandId: Swift.String? = nil,
            comment: Swift.String? = nil,
            completedCount: Swift.Int = 0,
            deliveryTimedOutCount: Swift.Int = 0,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            errorCount: Swift.Int = 0,
            expiresAfter: ClientRuntime.Date? = nil,
            instanceIds: [Swift.String]? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            notificationConfig: SsmClientTypes.NotificationConfig? = nil,
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            outputS3Region: Swift.String? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            requestedDateTime: ClientRuntime.Date? = nil,
            serviceRole: Swift.String? = nil,
            status: SsmClientTypes.CommandStatus? = nil,
            statusDetails: Swift.String? = nil,
            targetCount: Swift.Int = 0,
            targets: [SsmClientTypes.Target]? = nil,
            timeoutSeconds: Swift.Int = 0
        )
        {
            self.cloudWatchOutputConfig = cloudWatchOutputConfig
            self.commandId = commandId
            self.comment = comment
            self.completedCount = completedCount
            self.deliveryTimedOutCount = deliveryTimedOutCount
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.errorCount = errorCount
            self.expiresAfter = expiresAfter
            self.instanceIds = instanceIds
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.notificationConfig = notificationConfig
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.outputS3Region = outputS3Region
            self.parameters = parameters
            self.requestedDateTime = requestedDateTime
            self.serviceRole = serviceRole
            self.status = status
            self.statusDetails = statusDetails
            self.targetCount = targetCount
            self.targets = targets
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension SsmClientTypes.CommandFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CommandFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes.CommandFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CommandFilter(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SsmClientTypes {
    /// Describes a command filter. A managed node ID can't be specified when a command status is Pending because the command hasn't run on the node yet.
    public struct CommandFilter: Swift.Equatable {
        /// The name of the filter. The ExecutionStage filter can't be used with the ListCommandInvocations operation, only with ListCommands.
        /// This member is required.
        public var key: SsmClientTypes.CommandFilterKey?
        /// The filter value. Valid values for each filter key are as follows:
        ///
        /// * InvokedAfter: Specify a timestamp to limit your results. For example, specify 2021-07-07T00:00:00Z to see a list of command executions occurring July 7, 2021, and later.
        ///
        /// * InvokedBefore: Specify a timestamp to limit your results. For example, specify 2021-07-07T00:00:00Z to see a list of command executions from before July 7, 2021.
        ///
        /// * Status: Specify a valid command status to see a list of all command executions with that status. The status choices depend on the API you call. The status values you can specify for ListCommands are:
        ///
        /// * Pending
        ///
        /// * InProgress
        ///
        /// * Success
        ///
        /// * Cancelled
        ///
        /// * Failed
        ///
        /// * TimedOut (this includes both Delivery and Execution time outs)
        ///
        /// * AccessDenied
        ///
        /// * DeliveryTimedOut
        ///
        /// * ExecutionTimedOut
        ///
        /// * Incomplete
        ///
        /// * NoInstancesInTag
        ///
        /// * LimitExceeded
        ///
        ///
        /// The status values you can specify for ListCommandInvocations are:
        ///
        /// * Pending
        ///
        /// * InProgress
        ///
        /// * Delayed
        ///
        /// * Success
        ///
        /// * Cancelled
        ///
        /// * Failed
        ///
        /// * TimedOut (this includes both Delivery and Execution time outs)
        ///
        /// * AccessDenied
        ///
        /// * DeliveryTimedOut
        ///
        /// * ExecutionTimedOut
        ///
        /// * Undeliverable
        ///
        /// * InvalidPlatform
        ///
        /// * Terminated
        ///
        ///
        ///
        ///
        /// * DocumentName: Specify name of the Amazon Web Services Systems Manager document (SSM document) for which you want to see command execution results. For example, specify AWS-RunPatchBaseline to see command executions that used this SSM document to perform security patching operations on managed nodes.
        ///
        /// * ExecutionStage: Specify one of the following values (ListCommands operations only):
        ///
        /// * Executing: Returns a list of command executions that are currently still running.
        ///
        /// * Complete: Returns a list of command executions that have already completed.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.CommandFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum CommandFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case documentName
        case executionStage
        case invokedAfter
        case invokedBefore
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandFilterKey] {
            return [
                .documentName,
                .executionStage,
                .invokedAfter,
                .invokedBefore,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .documentName: return "DocumentName"
            case .executionStage: return "ExecutionStage"
            case .invokedAfter: return "InvokedAfter"
            case .invokedBefore: return "InvokedBefore"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommandFilterKey(rawValue: rawValue) ?? CommandFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.CommandInvocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case commandId = "CommandId"
        case commandPlugins = "CommandPlugins"
        case comment = "Comment"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case instanceName = "InstanceName"
        case notificationConfig = "NotificationConfig"
        case requestedDateTime = "RequestedDateTime"
        case serviceRole = "ServiceRole"
        case standardErrorUrl = "StandardErrorUrl"
        case standardOutputUrl = "StandardOutputUrl"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case traceOutput = "TraceOutput"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let commandPlugins = commandPlugins {
            var commandPluginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commandPlugins)
            for commandpluginlist0 in commandPlugins {
                try commandPluginsContainer.encode(commandpluginlist0)
            }
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceName = instanceName {
            try encodeContainer.encode(instanceName, forKey: .instanceName)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let requestedDateTime = requestedDateTime {
            try encodeContainer.encode(requestedDateTime.timeIntervalSince1970, forKey: .requestedDateTime)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let standardErrorUrl = standardErrorUrl {
            try encodeContainer.encode(standardErrorUrl, forKey: .standardErrorUrl)
        }
        if let standardOutputUrl = standardOutputUrl {
            try encodeContainer.encode(standardOutputUrl, forKey: .standardOutputUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let traceOutput = traceOutput {
            try encodeContainer.encode(traceOutput, forKey: .traceOutput)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceName)
        instanceName = instanceNameDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let requestedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .requestedDateTime)
        requestedDateTime = requestedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CommandInvocationStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let traceOutputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceOutput)
        traceOutput = traceOutputDecoded
        let standardOutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardOutputUrl)
        standardOutputUrl = standardOutputUrlDecoded
        let standardErrorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardErrorUrl)
        standardErrorUrl = standardErrorUrlDecoded
        let commandPluginsContainer = try containerValues.decodeIfPresent([SsmClientTypes.CommandPlugin?].self, forKey: .commandPlugins)
        var commandPluginsDecoded0:[SsmClientTypes.CommandPlugin]? = nil
        if let commandPluginsContainer = commandPluginsContainer {
            commandPluginsDecoded0 = [SsmClientTypes.CommandPlugin]()
            for structure0 in commandPluginsContainer {
                if let structure0 = structure0 {
                    commandPluginsDecoded0?.append(structure0)
                }
            }
        }
        commandPlugins = commandPluginsDecoded0
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
    }
}

extension SsmClientTypes.CommandInvocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CommandInvocation(cloudWatchOutputConfig: \(Swift.String(describing: cloudWatchOutputConfig)), commandId: \(Swift.String(describing: commandId)), commandPlugins: \(Swift.String(describing: commandPlugins)), comment: \(Swift.String(describing: comment)), documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), instanceId: \(Swift.String(describing: instanceId)), instanceName: \(Swift.String(describing: instanceName)), notificationConfig: \(Swift.String(describing: notificationConfig)), requestedDateTime: \(Swift.String(describing: requestedDateTime)), serviceRole: \(Swift.String(describing: serviceRole)), standardErrorUrl: \(Swift.String(describing: standardErrorUrl)), standardOutputUrl: \(Swift.String(describing: standardOutputUrl)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), traceOutput: \(Swift.String(describing: traceOutput)))"}
}

extension SsmClientTypes {
    /// An invocation is a copy of a command sent to a specific managed node. A command can apply to one or more managed nodes. A command invocation applies to one managed node. For example, if a user runs SendCommand against three managed nodes, then a command invocation is created for each requested managed node ID. A command invocation returns status and detail information about a command you ran.
    public struct CommandInvocation: Swift.Equatable {
        /// Amazon CloudWatch Logs information where you want Amazon Web Services Systems Manager to send the command output.
        public var cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
        /// The command against which this invocation was requested.
        public var commandId: Swift.String?
        /// Plugins processed by the command.
        public var commandPlugins: [SsmClientTypes.CommandPlugin]?
        /// User-specified information about the command, such as a brief description of what the command should do.
        public var comment: Swift.String?
        /// The document name that was requested for execution.
        public var documentName: Swift.String?
        /// The Systems Manager document (SSM document) version.
        public var documentVersion: Swift.String?
        /// The managed node ID in which this invocation was requested.
        public var instanceId: Swift.String?
        /// The fully qualified host name of the managed node.
        public var instanceName: Swift.String?
        /// Configurations for sending notifications about command status changes on a per managed node basis.
        public var notificationConfig: SsmClientTypes.NotificationConfig?
        /// The time and date the request was sent to this managed node.
        public var requestedDateTime: ClientRuntime.Date?
        /// The Identity and Access Management (IAM) service role that Run Command, a capability of Amazon Web Services Systems Manager, uses to act on your behalf when sending notifications about command status changes on a per managed node basis.
        public var serviceRole: Swift.String?
        /// The URL to the plugin's StdErr file in Amazon Simple Storage Service (Amazon S3), if the S3 bucket was defined for the parent command. For an invocation, StandardErrorUrl is populated if there is just one plugin defined for the command, and the S3 bucket was defined for the command.
        public var standardErrorUrl: Swift.String?
        /// The URL to the plugin's StdOut file in Amazon Simple Storage Service (Amazon S3), if the S3 bucket was defined for the parent command. For an invocation, StandardOutputUrl is populated if there is just one plugin defined for the command, and the S3 bucket was defined for the command.
        public var standardOutputUrl: Swift.String?
        /// Whether or not the invocation succeeded, failed, or is pending.
        public var status: SsmClientTypes.CommandInvocationStatus?
        /// A detailed status of the command execution for each invocation (each managed node targeted by the command). StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
        ///
        /// * Pending: The command hasn't been sent to the managed node.
        ///
        /// * In Progress: The command has been sent to the managed node but hasn't reached a terminal state.
        ///
        /// * Success: The execution of the command or plugin was successfully completed. This is a terminal state.
        ///
        /// * Delivery Timed Out: The command wasn't delivered to the managed node before the delivery timeout expired. Delivery timeouts don't count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Execution Timed Out: Command execution started on the managed node, but the execution wasn't complete before the execution timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Failed: The command wasn't successful on the managed node. For a plugin, this indicates that the result code wasn't zero. For a command invocation, this indicates that the result code for one or more plugins wasn't zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Canceled: The command was terminated before it was completed. This is a terminal state.
        ///
        /// * Undeliverable: The command can't be delivered to the managed node. The managed node might not exist or might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit and don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.
        public var statusDetails: Swift.String?
        /// Gets the trace output sent by the agent.
        public var traceOutput: Swift.String?

        public init (
            cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig? = nil,
            commandId: Swift.String? = nil,
            commandPlugins: [SsmClientTypes.CommandPlugin]? = nil,
            comment: Swift.String? = nil,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceName: Swift.String? = nil,
            notificationConfig: SsmClientTypes.NotificationConfig? = nil,
            requestedDateTime: ClientRuntime.Date? = nil,
            serviceRole: Swift.String? = nil,
            standardErrorUrl: Swift.String? = nil,
            standardOutputUrl: Swift.String? = nil,
            status: SsmClientTypes.CommandInvocationStatus? = nil,
            statusDetails: Swift.String? = nil,
            traceOutput: Swift.String? = nil
        )
        {
            self.cloudWatchOutputConfig = cloudWatchOutputConfig
            self.commandId = commandId
            self.commandPlugins = commandPlugins
            self.comment = comment
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.instanceId = instanceId
            self.instanceName = instanceName
            self.notificationConfig = notificationConfig
            self.requestedDateTime = requestedDateTime
            self.serviceRole = serviceRole
            self.standardErrorUrl = standardErrorUrl
            self.standardOutputUrl = standardOutputUrl
            self.status = status
            self.statusDetails = statusDetails
            self.traceOutput = traceOutput
        }
    }

}

extension SsmClientTypes {
    public enum CommandInvocationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case delayed
        case failed
        case inProgress
        case pending
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandInvocationStatus] {
            return [
                .cancelled,
                .cancelling,
                .delayed,
                .failed,
                .inProgress,
                .pending,
                .success,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .delayed: return "Delayed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommandInvocationStatus(rawValue: rawValue) ?? CommandInvocationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.CommandPlugin: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case output = "Output"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case responseCode = "ResponseCode"
        case responseFinishDateTime = "ResponseFinishDateTime"
        case responseStartDateTime = "ResponseStartDateTime"
        case standardErrorUrl = "StandardErrorUrl"
        case standardOutputUrl = "StandardOutputUrl"
        case status = "Status"
        case statusDetails = "StatusDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
        if responseCode != 0 {
            try encodeContainer.encode(responseCode, forKey: .responseCode)
        }
        if let responseFinishDateTime = responseFinishDateTime {
            try encodeContainer.encode(responseFinishDateTime.timeIntervalSince1970, forKey: .responseFinishDateTime)
        }
        if let responseStartDateTime = responseStartDateTime {
            try encodeContainer.encode(responseStartDateTime.timeIntervalSince1970, forKey: .responseStartDateTime)
        }
        if let standardErrorUrl = standardErrorUrl {
            try encodeContainer.encode(standardErrorUrl, forKey: .standardErrorUrl)
        }
        if let standardOutputUrl = standardOutputUrl {
            try encodeContainer.encode(standardOutputUrl, forKey: .standardOutputUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CommandPluginStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let responseCodeDecoded = try containerValues.decode(Swift.Int.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let responseStartDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .responseStartDateTime)
        responseStartDateTime = responseStartDateTimeDecoded
        let responseFinishDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .responseFinishDateTime)
        responseFinishDateTime = responseFinishDateTimeDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
        let standardOutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardOutputUrl)
        standardOutputUrl = standardOutputUrlDecoded
        let standardErrorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardErrorUrl)
        standardErrorUrl = standardErrorUrlDecoded
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
    }
}

extension SsmClientTypes.CommandPlugin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CommandPlugin(name: \(Swift.String(describing: name)), output: \(Swift.String(describing: output)), outputS3BucketName: \(Swift.String(describing: outputS3BucketName)), outputS3KeyPrefix: \(Swift.String(describing: outputS3KeyPrefix)), outputS3Region: \(Swift.String(describing: outputS3Region)), responseCode: \(Swift.String(describing: responseCode)), responseFinishDateTime: \(Swift.String(describing: responseFinishDateTime)), responseStartDateTime: \(Swift.String(describing: responseStartDateTime)), standardErrorUrl: \(Swift.String(describing: standardErrorUrl)), standardOutputUrl: \(Swift.String(describing: standardOutputUrl)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)))"}
}

extension SsmClientTypes {
    /// Describes plugin details.
    public struct CommandPlugin: Swift.Equatable {
        /// The name of the plugin. Must be one of the following: aws:updateAgent, aws:domainjoin, aws:applications, aws:runPowerShellScript, aws:psmodule, aws:cloudWatch, aws:runShellScript, or aws:updateSSMAgent.
        public var name: Swift.String?
        /// Output of the plugin execution.
        public var output: Swift.String?
        /// The S3 bucket where the responses to the command executions should be stored. This was requested when issuing the command. For example, in the following response: doc-example-bucket/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-02573cafcfEXAMPLE/awsrunShellScriptdoc-example-bucket is the name of the S3 bucket; ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix; i-02573cafcfEXAMPLE is the managed node ID; awsrunShellScript is the name of the plugin.
        public var outputS3BucketName: Swift.String?
        /// The S3 directory path inside the bucket where the responses to the command executions should be stored. This was requested when issuing the command. For example, in the following response: doc-example-bucket/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-02573cafcfEXAMPLE/awsrunShellScriptdoc-example-bucket is the name of the S3 bucket; ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix; i-02573cafcfEXAMPLE is the managed node ID; awsrunShellScript is the name of the plugin.
        public var outputS3KeyPrefix: Swift.String?
        /// (Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Amazon Web Services Systems Manager automatically determines the S3 bucket region.
        public var outputS3Region: Swift.String?
        /// A numeric response code generated after running the plugin.
        public var responseCode: Swift.Int
        /// The time the plugin stopped running. Could stop prematurely if, for example, a cancel command was sent.
        public var responseFinishDateTime: ClientRuntime.Date?
        /// The time the plugin started running.
        public var responseStartDateTime: ClientRuntime.Date?
        /// The URL for the complete text written by the plugin to stderr. If execution isn't yet complete, then this string is empty.
        public var standardErrorUrl: Swift.String?
        /// The URL for the complete text written by the plugin to stdout in Amazon S3. If the S3 bucket for the command wasn't specified, then this string is empty.
        public var standardOutputUrl: Swift.String?
        /// The status of this plugin. You can run a document with multiple plugins.
        public var status: SsmClientTypes.CommandPluginStatus?
        /// A detailed status of the plugin execution. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
        ///
        /// * Pending: The command hasn't been sent to the managed node.
        ///
        /// * In Progress: The command has been sent to the managed node but hasn't reached a terminal state.
        ///
        /// * Success: The execution of the command or plugin was successfully completed. This is a terminal state.
        ///
        /// * Delivery Timed Out: The command wasn't delivered to the managed node before the delivery timeout expired. Delivery timeouts don't count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Execution Timed Out: Command execution started on the managed node, but the execution wasn't complete before the execution timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Failed: The command wasn't successful on the managed node. For a plugin, this indicates that the result code wasn't zero. For a command invocation, this indicates that the result code for one or more plugins wasn't zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Canceled: The command was terminated before it was completed. This is a terminal state.
        ///
        /// * Undeliverable: The command can't be delivered to the managed node. The managed node might not exist, or it might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit, and they don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.
        public var statusDetails: Swift.String?

        public init (
            name: Swift.String? = nil,
            output: Swift.String? = nil,
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            outputS3Region: Swift.String? = nil,
            responseCode: Swift.Int = 0,
            responseFinishDateTime: ClientRuntime.Date? = nil,
            responseStartDateTime: ClientRuntime.Date? = nil,
            standardErrorUrl: Swift.String? = nil,
            standardOutputUrl: Swift.String? = nil,
            status: SsmClientTypes.CommandPluginStatus? = nil,
            statusDetails: Swift.String? = nil
        )
        {
            self.name = name
            self.output = output
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.outputS3Region = outputS3Region
            self.responseCode = responseCode
            self.responseFinishDateTime = responseFinishDateTime
            self.responseStartDateTime = responseStartDateTime
            self.standardErrorUrl = standardErrorUrl
            self.standardOutputUrl = standardOutputUrl
            self.status = status
            self.statusDetails = statusDetails
        }
    }

}

extension SsmClientTypes {
    public enum CommandPluginStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case inProgress
        case pending
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandPluginStatus] {
            return [
                .cancelled,
                .failed,
                .inProgress,
                .pending,
                .success,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommandPluginStatus(rawValue: rawValue) ?? CommandPluginStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum CommandStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case inProgress
        case pending
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .inProgress,
                .pending,
                .success,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommandStatus(rawValue: rawValue) ?? CommandStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.ComplianceExecutionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case executionTime = "ExecutionTime"
        case executionType = "ExecutionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionTime = executionTime {
            try encodeContainer.encode(executionTime.timeIntervalSince1970, forKey: .executionTime)
        }
        if let executionType = executionType {
            try encodeContainer.encode(executionType, forKey: .executionType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

extension SsmClientTypes.ComplianceExecutionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComplianceExecutionSummary(executionId: \(Swift.String(describing: executionId)), executionTime: \(Swift.String(describing: executionTime)), executionType: \(Swift.String(describing: executionType)))"}
}

extension SsmClientTypes {
    /// A summary of the call execution that includes an execution ID, the type of execution (for example, Command), and the date/time of the execution using a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.
    public struct ComplianceExecutionSummary: Swift.Equatable {
        /// An ID created by the system when PutComplianceItems was called. For example, CommandID is a valid execution ID. You can use this ID in subsequent calls.
        public var executionId: Swift.String?
        /// The time the execution ran as a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.
        /// This member is required.
        public var executionTime: ClientRuntime.Date?
        /// The type of execution. For example, Command is a valid execution type.
        public var executionType: Swift.String?

        public init (
            executionId: Swift.String? = nil,
            executionTime: ClientRuntime.Date? = nil,
            executionType: Swift.String? = nil
        )
        {
            self.executionId = executionId
            self.executionTime = executionTime
            self.executionType = executionType
        }
    }

}

extension SsmClientTypes.ComplianceItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case details = "Details"
        case executionSummary = "ExecutionSummary"
        case id = "Id"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let details = details {
            var detailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .details)
            for (dictKey0, complianceitemdetails0) in details {
                try detailsContainer.encode(complianceitemdetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let severityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceSeverity.self, forKey: .severity)
        severity = severityDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceExecutionSummary.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let detailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .details)
        var detailsDecoded0: [Swift.String:Swift.String]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in detailsContainer {
                if let attributevalue0 = attributevalue0 {
                    detailsDecoded0?[key0] = attributevalue0
                }
            }
        }
        details = detailsDecoded0
    }
}

extension SsmClientTypes.ComplianceItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComplianceItem(complianceType: \(Swift.String(describing: complianceType)), details: \(Swift.String(describing: details)), executionSummary: \(Swift.String(describing: executionSummary)), id: \(Swift.String(describing: id)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), severity: \(Swift.String(describing: severity)), status: \(Swift.String(describing: status)), title: \(Swift.String(describing: title)))"}
}

extension SsmClientTypes {
    /// Information about the compliance as defined by the resource type. For example, for a patch resource type, Items includes information about the PatchSeverity, Classification, and so on.
    public struct ComplianceItem: Swift.Equatable {
        /// The compliance type. For example, Association (for a State Manager association), Patch, or Custom:string are all valid compliance types.
        public var complianceType: Swift.String?
        /// A "Key": "Value" tag combination for the compliance item.
        public var details: [Swift.String:Swift.String]?
        /// A summary for the compliance item. The summary includes an execution ID, the execution type (for example, command), and the execution time.
        public var executionSummary: SsmClientTypes.ComplianceExecutionSummary?
        /// An ID for the compliance item. For example, if the compliance item is a Windows patch, the ID could be the number of the KB article; for example: KB4010320.
        public var id: Swift.String?
        /// An ID for the resource. For a managed node, this is the node ID.
        public var resourceId: Swift.String?
        /// The type of resource. ManagedInstance is currently the only supported resource type.
        public var resourceType: Swift.String?
        /// The severity of the compliance status. Severity can be one of the following: Critical, High, Medium, Low, Informational, Unspecified.
        public var severity: SsmClientTypes.ComplianceSeverity?
        /// The status of the compliance item. An item is either COMPLIANT, NON_COMPLIANT, or an empty string (for Windows patches that aren't applicable).
        public var status: SsmClientTypes.ComplianceStatus?
        /// A title for the compliance item. For example, if the compliance item is a Windows patch, the title could be the title of the KB article for the patch; for example: Security Update for Active Directory Federation Services.
        public var title: Swift.String?

        public init (
            complianceType: Swift.String? = nil,
            details: [Swift.String:Swift.String]? = nil,
            executionSummary: SsmClientTypes.ComplianceExecutionSummary? = nil,
            id: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            severity: SsmClientTypes.ComplianceSeverity? = nil,
            status: SsmClientTypes.ComplianceStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.complianceType = complianceType
            self.details = details
            self.executionSummary = executionSummary
            self.id = id
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.severity = severity
            self.status = status
            self.title = title
        }
    }

}

extension SsmClientTypes.ComplianceItemEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case id = "Id"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            var detailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .details)
            for (dictKey0, complianceitemdetails0) in details {
                try detailsContainer.encode(complianceitemdetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let severityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let detailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .details)
        var detailsDecoded0: [Swift.String:Swift.String]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in detailsContainer {
                if let attributevalue0 = attributevalue0 {
                    detailsDecoded0?[key0] = attributevalue0
                }
            }
        }
        details = detailsDecoded0
    }
}

extension SsmClientTypes.ComplianceItemEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComplianceItemEntry(details: \(Swift.String(describing: details)), id: \(Swift.String(describing: id)), severity: \(Swift.String(describing: severity)), status: \(Swift.String(describing: status)), title: \(Swift.String(describing: title)))"}
}

extension SsmClientTypes {
    /// Information about a compliance item.
    public struct ComplianceItemEntry: Swift.Equatable {
        /// A "Key": "Value" tag combination for the compliance item.
        public var details: [Swift.String:Swift.String]?
        /// The compliance item ID. For example, if the compliance item is a Windows patch, the ID could be the number of the KB article.
        public var id: Swift.String?
        /// The severity of the compliance status. Severity can be one of the following: Critical, High, Medium, Low, Informational, Unspecified.
        /// This member is required.
        public var severity: SsmClientTypes.ComplianceSeverity?
        /// The status of the compliance item. An item is either COMPLIANT or NON_COMPLIANT.
        /// This member is required.
        public var status: SsmClientTypes.ComplianceStatus?
        /// The title of the compliance item. For example, if the compliance item is a Windows patch, the title could be the title of the KB article for the patch; for example: Security Update for Active Directory Federation Services.
        public var title: Swift.String?

        public init (
            details: [Swift.String:Swift.String]? = nil,
            id: Swift.String? = nil,
            severity: SsmClientTypes.ComplianceSeverity? = nil,
            status: SsmClientTypes.ComplianceStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.details = details
            self.id = id
            self.severity = severity
            self.status = status
            self.title = title
        }
    }

}

extension SsmClientTypes {
    public enum ComplianceQueryOperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginwith
        case equal
        case greaterthan
        case lessthan
        case notequal
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceQueryOperatorType] {
            return [
                .beginwith,
                .equal,
                .greaterthan,
                .lessthan,
                .notequal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginwith: return "BEGIN_WITH"
            case .equal: return "EQUAL"
            case .greaterthan: return "GREATER_THAN"
            case .lessthan: return "LESS_THAN"
            case .notequal: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceQueryOperatorType(rawValue: rawValue) ?? ComplianceQueryOperatorType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum ComplianceSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceSeverity] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .unspecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceSeverity(rawValue: rawValue) ?? ComplianceSeverity.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum ComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliant
        case noncompliant
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceStatus] {
            return [
                .compliant,
                .noncompliant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .noncompliant: return "NON_COMPLIANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceStatus(rawValue: rawValue) ?? ComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.ComplianceStringFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for compliancestringfiltervaluelist0 in values {
                try valuesContainer.encode(compliancestringfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceQueryOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes.ComplianceStringFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComplianceStringFilter(key: \(Swift.String(describing: key)), type: \(Swift.String(describing: type)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// One or more filters. Use a filter to return a more specific list of results.
    public struct ComplianceStringFilter: Swift.Equatable {
        /// The name of the filter.
        public var key: Swift.String?
        /// The type of comparison that should be performed for the value: Equal, NotEqual, BeginWith, LessThan, or GreaterThan.
        public var type: SsmClientTypes.ComplianceQueryOperatorType?
        /// The value for which to search.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            type: SsmClientTypes.ComplianceQueryOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }

}

extension SsmClientTypes.ComplianceSummaryItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case compliantSummary = "CompliantSummary"
        case nonCompliantSummary = "NonCompliantSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let compliantSummary = compliantSummary {
            try encodeContainer.encode(compliantSummary, forKey: .compliantSummary)
        }
        if let nonCompliantSummary = nonCompliantSummary {
            try encodeContainer.encode(nonCompliantSummary, forKey: .nonCompliantSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let compliantSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CompliantSummary.self, forKey: .compliantSummary)
        compliantSummary = compliantSummaryDecoded
        let nonCompliantSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NonCompliantSummary.self, forKey: .nonCompliantSummary)
        nonCompliantSummary = nonCompliantSummaryDecoded
    }
}

extension SsmClientTypes.ComplianceSummaryItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComplianceSummaryItem(complianceType: \(Swift.String(describing: complianceType)), compliantSummary: \(Swift.String(describing: compliantSummary)), nonCompliantSummary: \(Swift.String(describing: nonCompliantSummary)))"}
}

extension SsmClientTypes {
    /// A summary of compliance information by compliance type.
    public struct ComplianceSummaryItem: Swift.Equatable {
        /// The type of compliance item. For example, the compliance type can be Association, Patch, or Custom:string.
        public var complianceType: Swift.String?
        /// A list of COMPLIANT items for the specified compliance type.
        public var compliantSummary: SsmClientTypes.CompliantSummary?
        /// A list of NON_COMPLIANT items for the specified compliance type.
        public var nonCompliantSummary: SsmClientTypes.NonCompliantSummary?

        public init (
            complianceType: Swift.String? = nil,
            compliantSummary: SsmClientTypes.CompliantSummary? = nil,
            nonCompliantSummary: SsmClientTypes.NonCompliantSummary? = nil
        )
        {
            self.complianceType = complianceType
            self.compliantSummary = compliantSummary
            self.nonCompliantSummary = nonCompliantSummary
        }
    }

}

extension ComplianceTypeCountLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComplianceTypeCountLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ComplianceTypeCountLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ComplianceTypeCountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You specified too many custom compliance types. You can specify a maximum of 10 different types.
public struct ComplianceTypeCountLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ComplianceTypeCountLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ComplianceTypeCountLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum ComplianceUploadType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case partial
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceUploadType] {
            return [
                .complete,
                .partial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .partial: return "PARTIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceUploadType(rawValue: rawValue) ?? ComplianceUploadType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.CompliantSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compliantCount = "CompliantCount"
        case severitySummary = "SeveritySummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if compliantCount != 0 {
            try encodeContainer.encode(compliantCount, forKey: .compliantCount)
        }
        if let severitySummary = severitySummary {
            try encodeContainer.encode(severitySummary, forKey: .severitySummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compliantCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .compliantCount)
        compliantCount = compliantCountDecoded
        let severitySummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SeveritySummary.self, forKey: .severitySummary)
        severitySummary = severitySummaryDecoded
    }
}

extension SsmClientTypes.CompliantSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompliantSummary(compliantCount: \(Swift.String(describing: compliantCount)), severitySummary: \(Swift.String(describing: severitySummary)))"}
}

extension SsmClientTypes {
    /// A summary of resources that are compliant. The summary is organized according to the resource count for each compliance type.
    public struct CompliantSummary: Swift.Equatable {
        /// The total number of resources that are compliant.
        public var compliantCount: Swift.Int
        /// A summary of the compliance severity by compliance type.
        public var severitySummary: SsmClientTypes.SeveritySummary?

        public init (
            compliantCount: Swift.Int = 0,
            severitySummary: SsmClientTypes.SeveritySummary? = nil
        )
        {
            self.compliantCount = compliantCount
            self.severitySummary = severitySummary
        }
    }

}

extension SsmClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .notConnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .notConnected: return "NotConnected"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

public struct CreateActivationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateActivationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateActivationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateActivationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateActivationOutputError>
}

extension CreateActivationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateActivationInput(defaultInstanceName: \(Swift.String(describing: defaultInstanceName)), description: \(Swift.String(describing: description)), expirationDate: \(Swift.String(describing: expirationDate)), iamRole: \(Swift.String(describing: iamRole)), registrationLimit: \(Swift.String(describing: registrationLimit)), registrationMetadata: \(Swift.String(describing: registrationMetadata)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateActivationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultInstanceName = "DefaultInstanceName"
        case description = "Description"
        case expirationDate = "ExpirationDate"
        case iamRole = "IamRole"
        case registrationLimit = "RegistrationLimit"
        case registrationMetadata = "RegistrationMetadata"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultInstanceName = defaultInstanceName {
            try encodeContainer.encode(defaultInstanceName, forKey: .defaultInstanceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if registrationLimit != 0 {
            try encodeContainer.encode(registrationLimit, forKey: .registrationLimit)
        }
        if let registrationMetadata = registrationMetadata {
            var registrationMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .registrationMetadata)
            for registrationmetadatalist0 in registrationMetadata {
                try registrationMetadataContainer.encode(registrationmetadatalist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateActivationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateActivationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateActivationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateActivationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateActivationOutputError>
}

public struct CreateActivationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateActivationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateActivationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateActivationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateActivationOutputError>
}

public struct CreateActivationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateActivationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateActivationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateActivationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateActivationOutputError>
}

public struct CreateActivationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateActivationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateActivationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateActivationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateActivationOutputError>
}

public struct CreateActivationInput: Swift.Equatable {
    /// The name of the registered, managed node as it will appear in the Amazon Web Services Systems Manager console or when you use the Amazon Web Services command line tools to list Systems Manager resources. Don't enter personally identifiable information in this field.
    public var defaultInstanceName: Swift.String?
    /// A user-defined description of the resource that you want to register with Systems Manager. Don't enter personally identifiable information in this field.
    public var description: Swift.String?
    /// The date by which this activation request should expire, in timestamp format, such as "2021-07-07T00:00:00". You can specify a date up to 30 days in advance. If you don't provide an expiration date, the activation code expires in 24 hours.
    public var expirationDate: ClientRuntime.Date?
    /// The name of the Identity and Access Management (IAM) role that you want to assign to the managed node. This IAM role must provide AssumeRole permissions for the Amazon Web Services Systems Manager service principal ssm.amazonaws.com. For more information, see [Create an IAM service role for a hybrid environment](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-service-role.html) in the Amazon Web Services Systems Manager User Guide.
    /// This member is required.
    public var iamRole: Swift.String?
    /// Specify the maximum number of managed nodes you want to register. The default value is 1.
    public var registrationLimit: Swift.Int
    /// Reserved for internal use.
    public var registrationMetadata: [SsmClientTypes.RegistrationMetadataItem]?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an activation to identify which servers or virtual machines (VMs) in your on-premises environment you intend to activate. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=Environment,Value=Production
    ///
    ///
    /// When you install SSM Agent on your on-premises servers and VMs, you specify an activation ID and code. When you specify the activation ID and code, tags assigned to the activation are automatically applied to the on-premises servers or VMs. You can't add tags to or delete tags from an existing activation. You can tag your on-premises servers, edge devices, and VMs after they connect to Systems Manager for the first time and are assigned a managed node ID. This means they are listed in the Amazon Web Services Systems Manager console with an ID that is prefixed with "mi-". For information about how to add tags to your managed nodes, see [AddTagsToResource]. For information about how to remove tags from your managed nodes, see [RemoveTagsFromResource].
    public var tags: [SsmClientTypes.Tag]?

    public init (
        defaultInstanceName: Swift.String? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        iamRole: Swift.String? = nil,
        registrationLimit: Swift.Int = 0,
        registrationMetadata: [SsmClientTypes.RegistrationMetadataItem]? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.defaultInstanceName = defaultInstanceName
        self.description = description
        self.expirationDate = expirationDate
        self.iamRole = iamRole
        self.registrationLimit = registrationLimit
        self.registrationMetadata = registrationMetadata
        self.tags = tags
    }
}

struct CreateActivationInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let defaultInstanceName: Swift.String?
    public let iamRole: Swift.String?
    public let registrationLimit: Swift.Int
    public let expirationDate: ClientRuntime.Date?
    public let tags: [SsmClientTypes.Tag]?
    public let registrationMetadata: [SsmClientTypes.RegistrationMetadataItem]?
}

extension CreateActivationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultInstanceName = "DefaultInstanceName"
        case description = "Description"
        case expirationDate = "ExpirationDate"
        case iamRole = "IamRole"
        case registrationLimit = "RegistrationLimit"
        case registrationMetadata = "RegistrationMetadata"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceName)
        defaultInstanceName = defaultInstanceNameDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let registrationLimitDecoded = try containerValues.decode(Swift.Int.self, forKey: .registrationLimit)
        registrationLimit = registrationLimitDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let registrationMetadataContainer = try containerValues.decodeIfPresent([SsmClientTypes.RegistrationMetadataItem?].self, forKey: .registrationMetadata)
        var registrationMetadataDecoded0:[SsmClientTypes.RegistrationMetadataItem]? = nil
        if let registrationMetadataContainer = registrationMetadataContainer {
            registrationMetadataDecoded0 = [SsmClientTypes.RegistrationMetadataItem]()
            for structure0 in registrationMetadataContainer {
                if let structure0 = structure0 {
                    registrationMetadataDecoded0?.append(structure0)
                }
            }
        }
        registrationMetadata = registrationMetadataDecoded0
    }
}

extension CreateActivationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateActivationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateActivationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidParameters(InvalidParameters)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateActivationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateActivationOutputResponse(activationCode: \(Swift.String(describing: activationCode)), activationId: \(Swift.String(describing: activationId)))"}
}

extension CreateActivationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateActivationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activationCode = output.activationCode
            self.activationId = output.activationId
        } else {
            self.activationCode = nil
            self.activationId = nil
        }
    }
}

public struct CreateActivationOutputResponse: Swift.Equatable {
    /// The code the system generates when it processes the activation. The activation code functions like a password to validate the activation ID.
    public var activationCode: Swift.String?
    /// The ID number generated by the system when it processed the activation. The activation ID functions like a user name.
    public var activationId: Swift.String?

    public init (
        activationCode: Swift.String? = nil,
        activationId: Swift.String? = nil
    )
    {
        self.activationCode = activationCode
        self.activationId = activationId
    }
}

struct CreateActivationOutputResponseBody: Swift.Equatable {
    public let activationId: Swift.String?
    public let activationCode: Swift.String?
}

extension CreateActivationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationCode = "ActivationCode"
        case activationId = "ActivationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationId)
        activationId = activationIdDecoded
        let activationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationCode)
        activationCode = activationCodeDecoded
    }
}

public struct CreateAssociationBatchInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssociationBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssociationBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssociationBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssociationBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssociationBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssociationBatchOutputError>
}

extension CreateAssociationBatchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssociationBatchInput(entries: \(Swift.String(describing: entries)))"}
}

extension CreateAssociationBatchInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for createassociationbatchrequestentries0 in entries {
                try entriesContainer.encode(createassociationbatchrequestentries0)
            }
        }
    }
}

public struct CreateAssociationBatchInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssociationBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssociationBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssociationBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssociationBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssociationBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssociationBatchOutputError>
}

public struct CreateAssociationBatchInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssociationBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssociationBatchInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssociationBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssociationBatchInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssociationBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssociationBatchOutputError>
}

public struct CreateAssociationBatchInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssociationBatchInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAssociationBatchInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssociationBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAssociationBatchInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssociationBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssociationBatchOutputError>
}

public struct CreateAssociationBatchInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssociationBatchInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAssociationBatchInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssociationBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAssociationBatchInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssociationBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssociationBatchOutputError>
}

public struct CreateAssociationBatchInput: Swift.Equatable {
    /// One or more associations.
    /// This member is required.
    public var entries: [SsmClientTypes.CreateAssociationBatchRequestEntry]?

    public init (
        entries: [SsmClientTypes.CreateAssociationBatchRequestEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct CreateAssociationBatchInputBody: Swift.Equatable {
    public let entries: [SsmClientTypes.CreateAssociationBatchRequestEntry]?
}

extension CreateAssociationBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([SsmClientTypes.CreateAssociationBatchRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[SsmClientTypes.CreateAssociationBatchRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [SsmClientTypes.CreateAssociationBatchRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension CreateAssociationBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssociationBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationLimitExceeded" : self = .associationLimitExceeded(try AssociationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateInstanceId" : self = .duplicateInstanceId(try DuplicateInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputLocation" : self = .invalidOutputLocation(try InvalidOutputLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchedule" : self = .invalidSchedule(try InvalidSchedule(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlatformType" : self = .unsupportedPlatformType(try UnsupportedPlatformType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssociationBatchOutputError: Swift.Error, Swift.Equatable {
    case associationLimitExceeded(AssociationLimitExceeded)
    case duplicateInstanceId(DuplicateInstanceId)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidInstanceId(InvalidInstanceId)
    case invalidOutputLocation(InvalidOutputLocation)
    case invalidParameters(InvalidParameters)
    case invalidSchedule(InvalidSchedule)
    case invalidTarget(InvalidTarget)
    case unsupportedPlatformType(UnsupportedPlatformType)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssociationBatchOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssociationBatchOutputResponse(failed: \(Swift.String(describing: failed)), successful: \(Swift.String(describing: successful)))"}
}

extension CreateAssociationBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAssociationBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failed = output.failed
            self.successful = output.successful
        } else {
            self.failed = nil
            self.successful = nil
        }
    }
}

public struct CreateAssociationBatchOutputResponse: Swift.Equatable {
    /// Information about the associations that failed.
    public var failed: [SsmClientTypes.FailedCreateAssociation]?
    /// Information about the associations that succeeded.
    public var successful: [SsmClientTypes.AssociationDescription]?

    public init (
        failed: [SsmClientTypes.FailedCreateAssociation]? = nil,
        successful: [SsmClientTypes.AssociationDescription]? = nil
    )
    {
        self.failed = failed
        self.successful = successful
    }
}

struct CreateAssociationBatchOutputResponseBody: Swift.Equatable {
    public let successful: [SsmClientTypes.AssociationDescription]?
    public let failed: [SsmClientTypes.FailedCreateAssociation]?
}

extension CreateAssociationBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failed = "Failed"
        case successful = "Successful"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationDescription?].self, forKey: .successful)
        var successfulDecoded0:[SsmClientTypes.AssociationDescription]? = nil
        if let successfulContainer = successfulContainer {
            successfulDecoded0 = [SsmClientTypes.AssociationDescription]()
            for structure0 in successfulContainer {
                if let structure0 = structure0 {
                    successfulDecoded0?.append(structure0)
                }
            }
        }
        successful = successfulDecoded0
        let failedContainer = try containerValues.decodeIfPresent([SsmClientTypes.FailedCreateAssociation?].self, forKey: .failed)
        var failedDecoded0:[SsmClientTypes.FailedCreateAssociation]? = nil
        if let failedContainer = failedContainer {
            failedDecoded0 = [SsmClientTypes.FailedCreateAssociation]()
            for structure0 in failedContainer {
                if let structure0 = structure0 {
                    failedDecoded0?.append(structure0)
                }
            }
        }
        failed = failedDecoded0
    }
}

extension SsmClientTypes.CreateAssociationBatchRequestEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationName = "AssociationName"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension SsmClientTypes.CreateAssociationBatchRequestEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssociationBatchRequestEntry(applyOnlyAtCronInterval: \(Swift.String(describing: applyOnlyAtCronInterval)), associationName: \(Swift.String(describing: associationName)), automationTargetParameterName: \(Swift.String(describing: automationTargetParameterName)), calendarNames: \(Swift.String(describing: calendarNames)), complianceSeverity: \(Swift.String(describing: complianceSeverity)), documentVersion: \(Swift.String(describing: documentVersion)), instanceId: \(Swift.String(describing: instanceId)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), outputLocation: \(Swift.String(describing: outputLocation)), parameters: \(Swift.String(describing: parameters)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), syncCompliance: \(Swift.String(describing: syncCompliance)), targetLocations: \(Swift.String(describing: targetLocations)), targets: \(Swift.String(describing: targets)))"}
}

extension SsmClientTypes {
    /// Describes the association of a Amazon Web Services Systems Manager document (SSM document) and a managed node.
    public struct CreateAssociationBatchRequestEntry: Swift.Equatable {
        /// By default, when you create a new associations, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
        public var applyOnlyAtCronInterval: Swift.Bool
        /// Specify a descriptive name for the association.
        public var associationName: Swift.String?
        /// Specify the target for the association. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
        public var automationTargetParameterName: Swift.String?
        /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations only run when that Change Calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
        public var calendarNames: [Swift.String]?
        /// The severity level to assign to the association.
        public var complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The managed node ID. InstanceId has been deprecated. To specify a managed node ID for an association, use the Targets parameter. Requests that include the parameter InstanceID with Systems Manager documents (SSM documents) that use schema version 2.0 or later will fail. In addition, if you use the parameter InstanceId, you can't use the parameters AssociationName, DocumentVersion, MaxErrors, MaxConcurrency, OutputLocation, or ScheduleExpression. To use these parameters, you must use the Targets parameter.
        public var instanceId: Swift.String?
        /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
        public var maxConcurrency: Swift.String?
        /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
        public var maxErrors: Swift.String?
        /// The name of the SSM document that contains the configuration information for the managed node. You can specify Command or Automation runbooks. You can specify Amazon Web Services-predefined documents, documents you created, or a document that is shared with you from another account. For SSM documents that are shared with you from other Amazon Web Services accounts, you must specify the complete SSM document ARN, in the following format: arn:aws:ssm:region:account-id:document/document-name  For example: arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document For Amazon Web Services-predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, AWS-ApplyPatchBaseline or My-Document.
        /// This member is required.
        public var name: Swift.String?
        /// An S3 bucket where you want to store the results of this request.
        public var outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
        /// A description of the parameters for a document.
        public var parameters: [Swift.String:[Swift.String]]?
        /// A cron expression that specifies a schedule when the association runs.
        public var scheduleExpression: Swift.String?
        /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
        public var syncCompliance: SsmClientTypes.AssociationSyncCompliance?
        /// Use this action to create an association in multiple Regions and multiple accounts.
        public var targetLocations: [SsmClientTypes.TargetLocation]?
        /// The managed nodes targeted by the request.
        public var targets: [SsmClientTypes.Target]?

        public init (
            applyOnlyAtCronInterval: Swift.Bool = false,
            associationName: Swift.String? = nil,
            automationTargetParameterName: Swift.String? = nil,
            calendarNames: [Swift.String]? = nil,
            complianceSeverity: SsmClientTypes.AssociationComplianceSeverity? = nil,
            documentVersion: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: SsmClientTypes.InstanceAssociationOutputLocation? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            scheduleExpression: Swift.String? = nil,
            syncCompliance: SsmClientTypes.AssociationSyncCompliance? = nil,
            targetLocations: [SsmClientTypes.TargetLocation]? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
            self.associationName = associationName
            self.automationTargetParameterName = automationTargetParameterName
            self.calendarNames = calendarNames
            self.complianceSeverity = complianceSeverity
            self.documentVersion = documentVersion
            self.instanceId = instanceId
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.outputLocation = outputLocation
            self.parameters = parameters
            self.scheduleExpression = scheduleExpression
            self.syncCompliance = syncCompliance
            self.targetLocations = targetLocations
            self.targets = targets
        }
    }

}

public struct CreateAssociationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssociationOutputError>
}

extension CreateAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssociationInput(applyOnlyAtCronInterval: \(Swift.String(describing: applyOnlyAtCronInterval)), associationName: \(Swift.String(describing: associationName)), automationTargetParameterName: \(Swift.String(describing: automationTargetParameterName)), calendarNames: \(Swift.String(describing: calendarNames)), complianceSeverity: \(Swift.String(describing: complianceSeverity)), documentVersion: \(Swift.String(describing: documentVersion)), instanceId: \(Swift.String(describing: instanceId)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), outputLocation: \(Swift.String(describing: outputLocation)), parameters: \(Swift.String(describing: parameters)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), syncCompliance: \(Swift.String(describing: syncCompliance)), targetLocations: \(Swift.String(describing: targetLocations)), targets: \(Swift.String(describing: targets)))"}
}

extension CreateAssociationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationName = "AssociationName"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct CreateAssociationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssociationOutputError>
}

public struct CreateAssociationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssociationOutputError>
}

public struct CreateAssociationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssociationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssociationOutputError>
}

public struct CreateAssociationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssociationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssociationOutputError>
}

public struct CreateAssociationInput: Swift.Equatable {
    /// By default, when you create a new association, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
    public var applyOnlyAtCronInterval: Swift.Bool
    /// Specify a descriptive name for the association.
    public var associationName: Swift.String?
    /// Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
    public var automationTargetParameterName: Swift.String?
    /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents you want to gate your associations under. The associations only run when that change calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
    public var calendarNames: [Swift.String]?
    /// The severity level to assign to the association.
    public var complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
    /// The document version you want to associate with the target(s). Can be a specific version or the default version.
    public var documentVersion: Swift.String?
    /// The managed node ID. InstanceId has been deprecated. To specify a managed node ID for an association, use the Targets parameter. Requests that include the parameter InstanceID with Systems Manager documents (SSM documents) that use schema version 2.0 or later will fail. In addition, if you use the parameter InstanceId, you can't use the parameters AssociationName, DocumentVersion, MaxErrors, MaxConcurrency, OutputLocation, or ScheduleExpression. To use these parameters, you must use the Targets parameter.
    public var instanceId: Swift.String?
    /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
    public var maxConcurrency: Swift.String?
    /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
    public var maxErrors: Swift.String?
    /// The name of the SSM Command document or Automation runbook that contains the configuration information for the managed node. You can specify Amazon Web Services-predefined documents, documents you created, or a document that is shared with you from another account. For Systems Manager documents (SSM documents) that are shared with you from other Amazon Web Services accounts, you must specify the complete SSM document ARN, in the following format: arn:partition:ssm:region:account-id:document/document-name  For example: arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document For Amazon Web Services-predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, AWS-ApplyPatchBaseline or My-Document.
    /// This member is required.
    public var name: Swift.String?
    /// An Amazon Simple Storage Service (Amazon S3) bucket where you want to store the output details of the request.
    public var outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
    /// The parameters for the runtime configuration of the document.
    public var parameters: [Swift.String:[Swift.String]]?
    /// A cron expression when the association will be applied to the target(s).
    public var scheduleExpression: Swift.String?
    /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
    public var syncCompliance: SsmClientTypes.AssociationSyncCompliance?
    /// A location is a combination of Amazon Web Services Regions and Amazon Web Services accounts where you want to run the association. Use this action to create an association in multiple Regions and multiple accounts.
    public var targetLocations: [SsmClientTypes.TargetLocation]?
    /// The targets for the association. You can target managed nodes by using tags, Amazon Web Services resource groups, all managed nodes in an Amazon Web Services account, or individual managed node IDs. You can target all managed nodes in an Amazon Web Services account by specifying the InstanceIds key with a value of *. For more information about choosing targets for an association, see [Using targets and rate controls with State Manager associations](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-state-manager-targets-and-rate-controls.html) in the Amazon Web Services Systems Manager User Guide.
    public var targets: [SsmClientTypes.Target]?

    public init (
        applyOnlyAtCronInterval: Swift.Bool = false,
        associationName: Swift.String? = nil,
        automationTargetParameterName: Swift.String? = nil,
        calendarNames: [Swift.String]? = nil,
        complianceSeverity: SsmClientTypes.AssociationComplianceSeverity? = nil,
        documentVersion: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        outputLocation: SsmClientTypes.InstanceAssociationOutputLocation? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        scheduleExpression: Swift.String? = nil,
        syncCompliance: SsmClientTypes.AssociationSyncCompliance? = nil,
        targetLocations: [SsmClientTypes.TargetLocation]? = nil,
        targets: [SsmClientTypes.Target]? = nil
    )
    {
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationName = associationName
        self.automationTargetParameterName = automationTargetParameterName
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.documentVersion = documentVersion
        self.instanceId = instanceId
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.syncCompliance = syncCompliance
        self.targetLocations = targetLocations
        self.targets = targets
    }
}

struct CreateAssociationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let documentVersion: Swift.String?
    public let instanceId: Swift.String?
    public let parameters: [Swift.String:[Swift.String]]?
    public let targets: [SsmClientTypes.Target]?
    public let scheduleExpression: Swift.String?
    public let outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
    public let associationName: Swift.String?
    public let automationTargetParameterName: Swift.String?
    public let maxErrors: Swift.String?
    public let maxConcurrency: Swift.String?
    public let complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
    public let syncCompliance: SsmClientTypes.AssociationSyncCompliance?
    public let applyOnlyAtCronInterval: Swift.Bool
    public let calendarNames: [Swift.String]?
    public let targetLocations: [SsmClientTypes.TargetLocation]?
}

extension CreateAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationName = "AssociationName"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension CreateAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationAlreadyExists" : self = .associationAlreadyExists(try AssociationAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociationLimitExceeded" : self = .associationLimitExceeded(try AssociationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputLocation" : self = .invalidOutputLocation(try InvalidOutputLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchedule" : self = .invalidSchedule(try InvalidSchedule(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlatformType" : self = .unsupportedPlatformType(try UnsupportedPlatformType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssociationOutputError: Swift.Error, Swift.Equatable {
    case associationAlreadyExists(AssociationAlreadyExists)
    case associationLimitExceeded(AssociationLimitExceeded)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidInstanceId(InvalidInstanceId)
    case invalidOutputLocation(InvalidOutputLocation)
    case invalidParameters(InvalidParameters)
    case invalidSchedule(InvalidSchedule)
    case invalidTarget(InvalidTarget)
    case unsupportedPlatformType(UnsupportedPlatformType)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssociationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssociationOutputResponse(associationDescription: \(Swift.String(describing: associationDescription)))"}
}

extension CreateAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct CreateAssociationOutputResponse: Swift.Equatable {
    /// Information about the association.
    public var associationDescription: SsmClientTypes.AssociationDescription?

    public init (
        associationDescription: SsmClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct CreateAssociationOutputResponseBody: Swift.Equatable {
    public let associationDescription: SsmClientTypes.AssociationDescription?
}

extension CreateAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

public struct CreateDocumentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDocumentOutputError>
}

extension CreateDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDocumentInput(attachments: \(Swift.String(describing: attachments)), content: \(Swift.String(describing: content)), displayName: \(Swift.String(describing: displayName)), documentFormat: \(Swift.String(describing: documentFormat)), documentType: \(Swift.String(describing: documentType)), name: \(Swift.String(describing: name)), requires: \(Swift.String(describing: requires)), tags: \(Swift.String(describing: tags)), targetType: \(Swift.String(describing: targetType)), versionName: \(Swift.String(describing: versionName)))"}
}

extension CreateDocumentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case name = "Name"
        case requires = "Requires"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachmentssourcelist0 in attachments {
                try attachmentsContainer.encode(attachmentssourcelist0)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentType = documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requires = requires {
            var requiresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requires)
            for documentrequireslist0 in requires {
                try requiresContainer.encode(documentrequireslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

public struct CreateDocumentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDocumentOutputError>
}

public struct CreateDocumentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDocumentOutputError>
}

public struct CreateDocumentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDocumentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDocumentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDocumentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDocumentOutputError>
}

public struct CreateDocumentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDocumentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDocumentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDocumentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDocumentOutputError>
}

public struct CreateDocumentInput: Swift.Equatable {
    /// A list of key-value pairs that describe attachments to a version of a document.
    public var attachments: [SsmClientTypes.AttachmentsSource]?
    /// The content for the new SSM document in JSON or YAML format. We recommend storing the contents for your new document in an external JSON or YAML file and referencing the file in a command. For examples, see the following topics in the Amazon Web Services Systems Manager User Guide.
    ///
    /// * [Create an SSM document (Amazon Web Services API)](https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-api.html)
    ///
    /// * [Create an SSM document (Amazon Web Services CLI)](https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-cli.html)
    ///
    /// * [Create an SSM document (API)](https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-api.html)
    /// This member is required.
    public var content: Swift.String?
    /// An optional field where you can specify a friendly name for the SSM document. This value can differ for each version of the document. You can update this value at a later time using the [UpdateDocument] operation.
    public var displayName: Swift.String?
    /// Specify the document format for the request. The document format can be JSON, YAML, or TEXT. JSON is the default format.
    public var documentFormat: SsmClientTypes.DocumentFormat?
    /// The type of document to create.
    public var documentType: SsmClientTypes.DocumentType?
    /// A name for the SSM document. You can't use the following strings as document name prefixes. These are reserved by Amazon Web Services for use as document name prefixes:
    ///
    /// * aws-
    ///
    /// * amazon
    ///
    /// * amzn
    /// This member is required.
    public var name: Swift.String?
    /// A list of SSM documents required by a document. This parameter is used exclusively by AppConfig. When a user creates an AppConfig configuration in an SSM document, the user must also specify a required document for validation purposes. In this case, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document for validation purposes. For more information, see [What is AppConfig?](https://docs.aws.amazon.com/appconfig/latest/userguide/what-is-appconfig.html) in the AppConfig User Guide.
    public var requires: [SsmClientTypes.DocumentRequires]?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an SSM document to identify the types of targets or the environment where it will run. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=Environment,Value=Production
    ///
    ///
    /// To add tags to an existing SSM document, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?
    /// Specify a target type to define the kinds of resources the document can run on. For example, to run a document on EC2 instances, specify the following value: /AWS::EC2::Instance. If you specify a value of '/' the document can run on all types of resources. If you don't specify a value, the document can't run on any resources. For a list of valid resource types, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide.
    public var targetType: Swift.String?
    /// An optional field specifying the version of the artifact you are creating with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init (
        attachments: [SsmClientTypes.AttachmentsSource]? = nil,
        content: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentFormat: SsmClientTypes.DocumentFormat? = nil,
        documentType: SsmClientTypes.DocumentType? = nil,
        name: Swift.String? = nil,
        requires: [SsmClientTypes.DocumentRequires]? = nil,
        tags: [SsmClientTypes.Tag]? = nil,
        targetType: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.content = content
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentType = documentType
        self.name = name
        self.requires = requires
        self.tags = tags
        self.targetType = targetType
        self.versionName = versionName
    }
}

struct CreateDocumentInputBody: Swift.Equatable {
    public let content: Swift.String?
    public let requires: [SsmClientTypes.DocumentRequires]?
    public let attachments: [SsmClientTypes.AttachmentsSource]?
    public let name: Swift.String?
    public let displayName: Swift.String?
    public let versionName: Swift.String?
    public let documentType: SsmClientTypes.DocumentType?
    public let documentFormat: SsmClientTypes.DocumentFormat?
    public let targetType: Swift.String?
    public let tags: [SsmClientTypes.Tag]?
}

extension CreateDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case name = "Name"
        case requires = "Requires"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let requiresContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[SsmClientTypes.DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [SsmClientTypes.DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let attachmentsContainer = try containerValues.decodeIfPresent([SsmClientTypes.AttachmentsSource?].self, forKey: .attachments)
        var attachmentsDecoded0:[SsmClientTypes.AttachmentsSource]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [SsmClientTypes.AttachmentsSource]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DocumentAlreadyExists" : self = .documentAlreadyExists(try DocumentAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentLimitExceeded" : self = .documentLimitExceeded(try DocumentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentContent" : self = .invalidDocumentContent(try InvalidDocumentContent(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentSchemaVersion" : self = .invalidDocumentSchemaVersion(try InvalidDocumentSchemaVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxDocumentSizeExceeded" : self = .maxDocumentSizeExceeded(try MaxDocumentSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDocumentOutputError: Swift.Error, Swift.Equatable {
    case documentAlreadyExists(DocumentAlreadyExists)
    case documentLimitExceeded(DocumentLimitExceeded)
    case internalServerError(InternalServerError)
    case invalidDocumentContent(InvalidDocumentContent)
    case invalidDocumentSchemaVersion(InvalidDocumentSchemaVersion)
    case maxDocumentSizeExceeded(MaxDocumentSizeExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDocumentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDocumentOutputResponse(documentDescription: \(Swift.String(describing: documentDescription)))"}
}

extension CreateDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documentDescription = output.documentDescription
        } else {
            self.documentDescription = nil
        }
    }
}

public struct CreateDocumentOutputResponse: Swift.Equatable {
    /// Information about the SSM document.
    public var documentDescription: SsmClientTypes.DocumentDescription?

    public init (
        documentDescription: SsmClientTypes.DocumentDescription? = nil
    )
    {
        self.documentDescription = documentDescription
    }
}

struct CreateDocumentOutputResponseBody: Swift.Equatable {
    public let documentDescription: SsmClientTypes.DocumentDescription?
}

extension CreateDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentDescription = "DocumentDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentDescription.self, forKey: .documentDescription)
        documentDescription = documentDescriptionDecoded
    }
}

public struct CreateMaintenanceWindowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMaintenanceWindowOutputError>
}

extension CreateMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMaintenanceWindowInput(allowUnassociatedTargets: \(Swift.String(describing: allowUnassociatedTargets)), clientToken: \(Swift.String(describing: clientToken)), cutoff: \(Swift.String(describing: cutoff)), description: \(Swift.String(describing: description)), duration: \(Swift.String(describing: duration)), endDate: \(Swift.String(describing: endDate)), name: \(Swift.String(describing: name)), schedule: \(Swift.String(describing: schedule)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleTimezone: \(Swift.String(describing: scheduleTimezone)), startDate: \(Swift.String(describing: startDate)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateMaintenanceWindowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case clientToken = "ClientToken"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case endDate = "EndDate"
        case name = "Name"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowUnassociatedTargets != false {
            try encodeContainer.encode(allowUnassociatedTargets, forKey: .allowUnassociatedTargets)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if cutoff != 0 {
            try encodeContainer.encode(cutoff, forKey: .cutoff)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleTimezone = scheduleTimezone {
            try encodeContainer.encode(scheduleTimezone, forKey: .scheduleTimezone)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateMaintenanceWindowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMaintenanceWindowOutputError>
}

public struct CreateMaintenanceWindowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMaintenanceWindowOutputError>
}

public struct CreateMaintenanceWindowInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMaintenanceWindowInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMaintenanceWindowOutputError>
}

public struct CreateMaintenanceWindowInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMaintenanceWindowInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMaintenanceWindowOutputError>
}

public struct CreateMaintenanceWindowInput: Swift.Equatable {
    /// Enables a maintenance window task to run on managed nodes, even if you haven't registered those nodes as targets. If enabled, then you must specify the unregistered managed nodes (by node ID) when you register a task with the maintenance window. If you don't enable this option, then you must specify previously-registered targets when you register a task with the maintenance window.
    /// This member is required.
    public var allowUnassociatedTargets: Swift.Bool
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    /// This member is required.
    public var cutoff: Swift.Int
    /// An optional description for the maintenance window. We recommend specifying a description to help you organize your maintenance windows.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    /// This member is required.
    public var duration: Swift.Int
    /// The date and time, in ISO-8601 Extended format, for when you want the maintenance window to become inactive. EndDate allows you to set a date and time in the future when the maintenance window will no longer run.
    public var endDate: Swift.String?
    /// The name of the maintenance window.
    /// This member is required.
    public var name: Swift.String?
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    /// This member is required.
    public var schedule: Swift.String?
    /// The number of days to wait after the date and time specified by a cron expression before running the maintenance window. For example, the following cron expression schedules a maintenance window to run on the third Tuesday of every month at 11:30 PM. cron(30 23 ? * TUE#3 *) If the schedule offset is 2, the maintenance window won't run until two days later.
    public var scheduleOffset: Swift.Int
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The date and time, in ISO-8601 Extended format, for when you want the maintenance window to become active. StartDate allows you to delay activation of the maintenance window until the specified future date.
    public var startDate: Swift.String?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a maintenance window to identify the type of tasks it will run, the types of targets, and the environment it will run in. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=TaskType,Value=AgentUpdate
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=Environment,Value=Production
    ///
    ///
    /// To add tags to an existing maintenance window, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?

    public init (
        allowUnassociatedTargets: Swift.Bool = false,
        clientToken: Swift.String? = nil,
        cutoff: Swift.Int = 0,
        description: Swift.String? = nil,
        duration: Swift.Int = 0,
        endDate: Swift.String? = nil,
        name: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int = 0,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.clientToken = clientToken
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.endDate = endDate
        self.name = name
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.tags = tags
    }
}

struct CreateMaintenanceWindowInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let startDate: Swift.String?
    public let endDate: Swift.String?
    public let schedule: Swift.String?
    public let scheduleTimezone: Swift.String?
    public let scheduleOffset: Swift.Int
    public let duration: Swift.Int
    public let cutoff: Swift.Int
    public let allowUnassociatedTargets: Swift.Bool
    public let clientToken: Swift.String?
    public let tags: [SsmClientTypes.Tag]?
}

extension CreateMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case clientToken = "ClientToken"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case endDate = "EndDate"
        case name = "Name"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Swift.Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMaintenanceWindowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMaintenanceWindowOutputResponse(windowId: \(Swift.String(describing: windowId)))"}
}

extension CreateMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowId = output.windowId
        } else {
            self.windowId = nil
        }
    }
}

public struct CreateMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the created maintenance window.
    public var windowId: Swift.String?

    public init (
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct CreateMaintenanceWindowOutputResponseBody: Swift.Equatable {
    public let windowId: Swift.String?
}

extension CreateMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

public struct CreateOpsItemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOpsItemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOpsItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOpsItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOpsItemOutputError>
}

extension CreateOpsItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOpsItemInput(actualEndTime: \(Swift.String(describing: actualEndTime)), actualStartTime: \(Swift.String(describing: actualStartTime)), category: \(Swift.String(describing: category)), description: \(Swift.String(describing: description)), notifications: \(Swift.String(describing: notifications)), operationalData: \(Swift.String(describing: operationalData)), opsItemType: \(Swift.String(describing: opsItemType)), plannedEndTime: \(Swift.String(describing: plannedEndTime)), plannedStartTime: \(Swift.String(describing: plannedStartTime)), priority: \(Swift.String(describing: priority)), relatedOpsItems: \(Swift.String(describing: relatedOpsItems)), severity: \(Swift.String(describing: severity)), source: \(Swift.String(describing: source)), tags: \(Swift.String(describing: tags)), title: \(Swift.String(describing: title)))"}
}

extension CreateOpsItemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case source = "Source"
        case tags = "Tags"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for opsitemnotifications0 in notifications {
                try notificationsContainer.encode(opsitemnotifications0)
            }
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let opsItemType = opsItemType {
            try encodeContainer.encode(opsItemType, forKey: .opsItemType)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let relatedOpsItems = relatedOpsItems {
            var relatedOpsItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedOpsItems)
            for relatedopsitems0 in relatedOpsItems {
                try relatedOpsItemsContainer.encode(relatedopsitems0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

public struct CreateOpsItemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOpsItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOpsItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOpsItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOpsItemOutputError>
}

public struct CreateOpsItemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOpsItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOpsItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOpsItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOpsItemOutputError>
}

public struct CreateOpsItemInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOpsItemInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateOpsItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOpsItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOpsItemOutputError>
}

public struct CreateOpsItemInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOpsItemInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateOpsItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOpsItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOpsItemOutputError>
}

public struct CreateOpsItemInput: Swift.Equatable {
    /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualEndTime: ClientRuntime.Date?
    /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualStartTime: ClientRuntime.Date?
    /// Specify a category to assign to an OpsItem.
    public var category: Swift.String?
    /// Information about the OpsItem.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this OpsItem is edited or changed.
    public var notifications: [SsmClientTypes.OpsItemNotification]?
    /// Operational data is custom data that provides useful reference details about the OpsItem. For example, you can specify log files, error strings, license keys, troubleshooting tips, or other relevant data. You enter operational data as key-value pairs. The key has a maximum length of 128 characters. The value has a maximum size of 20 KB. Operational data keys can't begin with the following: amazon, aws, amzn, ssm, /amazon, /aws, /amzn, /ssm. You can choose to make the data searchable by other users in the account or you can restrict search access. Searchable data means that all users with access to the OpsItem Overview page (as provided by the [DescribeOpsItems] API operation) can view and search on the specified data. Operational data that isn't searchable is only viewable by users who have access to the OpsItem (as provided by the [GetOpsItem] API operation). Use the /aws/resources key in OperationalData to specify a related resource in the request. Use the /aws/automations key in OperationalData to associate an Automation runbook with the OpsItem. To view Amazon Web Services CLI example commands that use these keys, see [Creating OpsItems manually](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems) in the Amazon Web Services Systems Manager User Guide.
    public var operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
    /// The type of OpsItem to create. Currently, the only valid values are /aws/changerequest and /aws/issue.
    public var opsItemType: Swift.String?
    /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedEndTime: ClientRuntime.Date?
    /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedStartTime: ClientRuntime.Date?
    /// The importance of this OpsItem in relation to other OpsItems in the system.
    public var priority: Swift.Int?
    /// One or more OpsItems that share something in common with the current OpsItems. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
    public var relatedOpsItems: [SsmClientTypes.RelatedOpsItem]?
    /// Specify a severity to assign to an OpsItem.
    public var severity: Swift.String?
    /// The origin of the OpsItem, such as Amazon EC2 or Systems Manager. The source name can't contain the following strings: aws, amazon, and amzn.
    /// This member is required.
    public var source: Swift.String?
    /// Optional metadata that you assign to a resource. You can restrict access to OpsItems by using an inline IAM policy that specifies tags. For more information, see [Getting started with OpsCenter](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-getting-started.html#OpsCenter-getting-started-user-permissions) in the Amazon Web Services Systems Manager User Guide. Tags use a key-value pair. For example: Key=Department,Value=Finance To add tags to a new OpsItem, a user must have IAM permissions for both the ssm:CreateOpsItems operation and the ssm:AddTagsToResource operation. To add tags to an existing OpsItem, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?
    /// A short heading that describes the nature of the OpsItem and the impacted resource.
    /// This member is required.
    public var title: Swift.String?

    public init (
        actualEndTime: ClientRuntime.Date? = nil,
        actualStartTime: ClientRuntime.Date? = nil,
        category: Swift.String? = nil,
        description: Swift.String? = nil,
        notifications: [SsmClientTypes.OpsItemNotification]? = nil,
        operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil,
        opsItemType: Swift.String? = nil,
        plannedEndTime: ClientRuntime.Date? = nil,
        plannedStartTime: ClientRuntime.Date? = nil,
        priority: Swift.Int? = nil,
        relatedOpsItems: [SsmClientTypes.RelatedOpsItem]? = nil,
        severity: Swift.String? = nil,
        source: Swift.String? = nil,
        tags: [SsmClientTypes.Tag]? = nil,
        title: Swift.String? = nil
    )
    {
        self.actualEndTime = actualEndTime
        self.actualStartTime = actualStartTime
        self.category = category
        self.description = description
        self.notifications = notifications
        self.operationalData = operationalData
        self.opsItemType = opsItemType
        self.plannedEndTime = plannedEndTime
        self.plannedStartTime = plannedStartTime
        self.priority = priority
        self.relatedOpsItems = relatedOpsItems
        self.severity = severity
        self.source = source
        self.tags = tags
        self.title = title
    }
}

struct CreateOpsItemInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let opsItemType: Swift.String?
    public let operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
    public let notifications: [SsmClientTypes.OpsItemNotification]?
    public let priority: Swift.Int?
    public let relatedOpsItems: [SsmClientTypes.RelatedOpsItem]?
    public let source: Swift.String?
    public let title: Swift.String?
    public let tags: [SsmClientTypes.Tag]?
    public let category: Swift.String?
    public let severity: Swift.String?
    public let actualStartTime: ClientRuntime.Date?
    public let actualEndTime: ClientRuntime.Date?
    public let plannedStartTime: ClientRuntime.Date?
    public let plannedEndTime: ClientRuntime.Date?
}

extension CreateOpsItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case source = "Source"
        case tags = "Tags"
        case title = "Title"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let opsItemTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemType)
        opsItemType = opsItemTypeDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [Swift.String:SsmClientTypes.OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let notificationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[SsmClientTypes.OpsItemNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [SsmClientTypes.OpsItemNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let relatedOpsItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.RelatedOpsItem?].self, forKey: .relatedOpsItems)
        var relatedOpsItemsDecoded0:[SsmClientTypes.RelatedOpsItem]? = nil
        if let relatedOpsItemsContainer = relatedOpsItemsContainer {
            relatedOpsItemsDecoded0 = [SsmClientTypes.RelatedOpsItem]()
            for structure0 in relatedOpsItemsContainer {
                if let structure0 = structure0 {
                    relatedOpsItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedOpsItems = relatedOpsItemsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension CreateOpsItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOpsItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemAlreadyExistsException" : self = .opsItemAlreadyExistsException(try OpsItemAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOpsItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemAlreadyExistsException(OpsItemAlreadyExistsException)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOpsItemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOpsItemOutputResponse(opsItemId: \(Swift.String(describing: opsItemId)))"}
}

extension CreateOpsItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOpsItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.opsItemId = output.opsItemId
        } else {
            self.opsItemId = nil
        }
    }
}

public struct CreateOpsItemOutputResponse: Swift.Equatable {
    /// The ID of the OpsItem.
    public var opsItemId: Swift.String?

    public init (
        opsItemId: Swift.String? = nil
    )
    {
        self.opsItemId = opsItemId
    }
}

struct CreateOpsItemOutputResponseBody: Swift.Equatable {
    public let opsItemId: Swift.String?
}

extension CreateOpsItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

public struct CreateOpsMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOpsMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOpsMetadataOutputError>
}

extension CreateOpsMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOpsMetadataInput(metadata: \(Swift.String(describing: metadata)), resourceId: \(Swift.String(describing: resourceId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateOpsMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadatamap0) in metadata {
                try metadataContainer.encode(metadatamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateOpsMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOpsMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOpsMetadataOutputError>
}

public struct CreateOpsMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOpsMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOpsMetadataOutputError>
}

public struct CreateOpsMetadataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOpsMetadataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateOpsMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOpsMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOpsMetadataOutputError>
}

public struct CreateOpsMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOpsMetadataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateOpsMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOpsMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOpsMetadataOutputError>
}

public struct CreateOpsMetadataInput: Swift.Equatable {
    /// Metadata for a new Application Manager application.
    public var metadata: [Swift.String:SsmClientTypes.MetadataValue]?
    /// A resource ID for a new Application Manager application.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Optional metadata that you assign to a resource. You can specify a maximum of five tags for an OpsMetadata object. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an OpsMetadata object to identify an environment or target Amazon Web Services Region. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=Environment,Value=Production
    ///
    /// * Key=Region,Value=us-east-2
    public var tags: [SsmClientTypes.Tag]?

    public init (
        metadata: [Swift.String:SsmClientTypes.MetadataValue]? = nil,
        resourceId: Swift.String? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.metadata = metadata
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct CreateOpsMetadataInputBody: Swift.Equatable {
    public let resourceId: Swift.String?
    public let metadata: [Swift.String:SsmClientTypes.MetadataValue]?
    public let tags: [SsmClientTypes.Tag]?
}

extension CreateOpsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MetadataValue?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:SsmClientTypes.MetadataValue]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:SsmClientTypes.MetadataValue]()
            for (key0, metadatavalue0) in metadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateOpsMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOpsMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataAlreadyExistsException" : self = .opsMetadataAlreadyExistsException(try OpsMetadataAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataLimitExceededException" : self = .opsMetadataLimitExceededException(try OpsMetadataLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataTooManyUpdatesException" : self = .opsMetadataTooManyUpdatesException(try OpsMetadataTooManyUpdatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOpsMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataAlreadyExistsException(OpsMetadataAlreadyExistsException)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataLimitExceededException(OpsMetadataLimitExceededException)
    case opsMetadataTooManyUpdatesException(OpsMetadataTooManyUpdatesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOpsMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOpsMetadataOutputResponse(opsMetadataArn: \(Swift.String(describing: opsMetadataArn)))"}
}

extension CreateOpsMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.opsMetadataArn = output.opsMetadataArn
        } else {
            self.opsMetadataArn = nil
        }
    }
}

public struct CreateOpsMetadataOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the OpsMetadata Object or blob created by the call.
    public var opsMetadataArn: Swift.String?

    public init (
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

struct CreateOpsMetadataOutputResponseBody: Swift.Equatable {
    public let opsMetadataArn: Swift.String?
}

extension CreateOpsMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
    }
}

public struct CreatePatchBaselineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePatchBaselineOutputError>
}

extension CreatePatchBaselineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePatchBaselineInput(approvalRules: \(Swift.String(describing: approvalRules)), approvedPatches: \(Swift.String(describing: approvedPatches)), approvedPatchesComplianceLevel: \(Swift.String(describing: approvedPatchesComplianceLevel)), approvedPatchesEnableNonSecurity: \(Swift.String(describing: approvedPatchesEnableNonSecurity)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), globalFilters: \(Swift.String(describing: globalFilters)), name: \(Swift.String(describing: name)), operatingSystem: \(Swift.String(describing: operatingSystem)), rejectedPatches: \(Swift.String(describing: rejectedPatches)), rejectedPatchesAction: \(Swift.String(describing: rejectedPatchesAction)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePatchBaselineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case clientToken = "ClientToken"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalFilters = globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePatchBaselineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePatchBaselineOutputError>
}

public struct CreatePatchBaselineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePatchBaselineOutputError>
}

public struct CreatePatchBaselineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePatchBaselineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreatePatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePatchBaselineOutputError>
}

public struct CreatePatchBaselineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePatchBaselineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreatePatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePatchBaselineOutputError>
}

public struct CreatePatchBaselineInput: Swift.Equatable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SsmClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var approvedPatches: [Swift.String]?
    /// Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation. The default value is UNSPECIFIED.
    public var approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to include patches in the baseline.
    public var globalFilters: SsmClientTypes.PatchFilterGroup?
    /// The name of the patch baseline.
    /// This member is required.
    public var name: Swift.String?
    /// Defines the operating system the patch baseline applies to. The default value is WINDOWS.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var rejectedPatches: [Swift.String]?
    /// The action for Patch Manager to take on patches included in the RejectedPackages list.
    ///
    /// * ALLOW_AS_DEPENDENCY : A package in the Rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as InstalledOther. This is the default action if no option is specified.
    ///
    /// * BLOCK : Packages in the RejectedPatches list, and packages that include them as dependencies, aren't installed under any circumstances. If a package was installed before it was added to the Rejected patches list, it is considered non-compliant with the patch baseline, and its status is reported as InstalledRejected.
    public var rejectedPatchesAction: SsmClientTypes.PatchAction?
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SsmClientTypes.PatchSource]?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a patch baseline to identify the severity level of patches it specifies and the operating system family it applies to. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=PatchSeverity,Value=Critical
    ///
    /// * Key=OS,Value=Windows
    ///
    ///
    /// To add tags to an existing patch baseline, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?

    public init (
        approvalRules: SsmClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool = false,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        globalFilters: SsmClientTypes.PatchFilterGroup? = nil,
        name: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SsmClientTypes.PatchAction? = nil,
        sources: [SsmClientTypes.PatchSource]? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.clientToken = clientToken
        self.description = description
        self.globalFilters = globalFilters
        self.name = name
        self.operatingSystem = operatingSystem
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
        self.tags = tags
    }
}

struct CreatePatchBaselineInputBody: Swift.Equatable {
    public let operatingSystem: SsmClientTypes.OperatingSystem?
    public let name: Swift.String?
    public let globalFilters: SsmClientTypes.PatchFilterGroup?
    public let approvalRules: SsmClientTypes.PatchRuleGroup?
    public let approvedPatches: [Swift.String]?
    public let approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    public let approvedPatchesEnableNonSecurity: Swift.Bool
    public let rejectedPatches: [Swift.String]?
    public let rejectedPatchesAction: SsmClientTypes.PatchAction?
    public let description: Swift.String?
    public let sources: [SsmClientTypes.PatchSource]?
    public let clientToken: Swift.String?
    public let tags: [SsmClientTypes.Tag]?
}

extension CreatePatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case clientToken = "ClientToken"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePatchBaselineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePatchBaselineOutputResponse(baselineId: \(Swift.String(describing: baselineId)))"}
}

extension CreatePatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
        } else {
            self.baselineId = nil
        }
    }
}

public struct CreatePatchBaselineOutputResponse: Swift.Equatable {
    /// The ID of the created patch baseline.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct CreatePatchBaselineOutputResponseBody: Swift.Equatable {
    public let baselineId: Swift.String?
}

extension CreatePatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

public struct CreateResourceDataSyncInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceDataSyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceDataSyncOutputError>
}

extension CreateResourceDataSyncInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceDataSyncInput(s3Destination: \(Swift.String(describing: s3Destination)), syncName: \(Swift.String(describing: syncName)), syncSource: \(Swift.String(describing: syncSource)), syncType: \(Swift.String(describing: syncType)))"}
}

extension CreateResourceDataSyncInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Destination = "S3Destination"
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncSource = syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

public struct CreateResourceDataSyncInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceDataSyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceDataSyncOutputError>
}

public struct CreateResourceDataSyncInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceDataSyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceDataSyncOutputError>
}

public struct CreateResourceDataSyncInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceDataSyncInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateResourceDataSyncInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateResourceDataSyncInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceDataSyncOutputError>
}

public struct CreateResourceDataSyncInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceDataSyncInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateResourceDataSyncInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateResourceDataSyncInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceDataSyncOutputError>
}

public struct CreateResourceDataSyncInput: Swift.Equatable {
    /// Amazon S3 configuration details for the sync. This parameter is required if the SyncType value is SyncToDestination.
    public var s3Destination: SsmClientTypes.ResourceDataSyncS3Destination?
    /// A name for the configuration.
    /// This member is required.
    public var syncName: Swift.String?
    /// Specify information about the data sources to synchronize. This parameter is required if the SyncType value is SyncFromSource.
    public var syncSource: SsmClientTypes.ResourceDataSyncSource?
    /// Specify SyncToDestination to create a resource data sync that synchronizes data to an S3 bucket for Inventory. If you specify SyncToDestination, you must provide a value for S3Destination. Specify SyncFromSource to synchronize data from a single account and multiple Regions, or multiple Amazon Web Services accounts and Amazon Web Services Regions, as listed in Organizations for Explorer. If you specify SyncFromSource, you must provide a value for SyncSource. The default value is SyncToDestination.
    public var syncType: Swift.String?

    public init (
        s3Destination: SsmClientTypes.ResourceDataSyncS3Destination? = nil,
        syncName: Swift.String? = nil,
        syncSource: SsmClientTypes.ResourceDataSyncSource? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.s3Destination = s3Destination
        self.syncName = syncName
        self.syncSource = syncSource
        self.syncType = syncType
    }
}

struct CreateResourceDataSyncInputBody: Swift.Equatable {
    public let syncName: Swift.String?
    public let s3Destination: SsmClientTypes.ResourceDataSyncS3Destination?
    public let syncType: Swift.String?
    public let syncSource: SsmClientTypes.ResourceDataSyncSource?
}

extension CreateResourceDataSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Destination = "S3Destination"
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncS3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncSource.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
    }
}

extension CreateResourceDataSyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceDataSyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncAlreadyExists" : self = .resourceDataSyncAlreadyExistsException(try ResourceDataSyncAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncCountExceeded" : self = .resourceDataSyncCountExceededException(try ResourceDataSyncCountExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfiguration" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceDataSyncOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceDataSyncAlreadyExistsException(ResourceDataSyncAlreadyExistsException)
    case resourceDataSyncCountExceededException(ResourceDataSyncCountExceededException)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceDataSyncOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceDataSyncOutputResponse()"}
}

extension CreateResourceDataSyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateResourceDataSyncOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateResourceDataSyncOutputResponseBody: Swift.Equatable {
}

extension CreateResourceDataSyncOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CustomSchemaCountLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomSchemaCountLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension CustomSchemaCountLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CustomSchemaCountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the limit for custom schemas. Delete one or more custom schemas and try again.
public struct CustomSchemaCountLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomSchemaCountLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CustomSchemaCountLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteActivationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteActivationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteActivationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteActivationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteActivationOutputError>
}

extension DeleteActivationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteActivationInput(activationId: \(Swift.String(describing: activationId)))"}
}

extension DeleteActivationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationId = "ActivationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationId = activationId {
            try encodeContainer.encode(activationId, forKey: .activationId)
        }
    }
}

public struct DeleteActivationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteActivationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteActivationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteActivationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteActivationOutputError>
}

public struct DeleteActivationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteActivationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteActivationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteActivationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteActivationOutputError>
}

public struct DeleteActivationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteActivationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteActivationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteActivationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteActivationOutputError>
}

public struct DeleteActivationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteActivationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteActivationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteActivationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteActivationOutputError>
}

public struct DeleteActivationInput: Swift.Equatable {
    /// The ID of the activation that you want to delete.
    /// This member is required.
    public var activationId: Swift.String?

    public init (
        activationId: Swift.String? = nil
    )
    {
        self.activationId = activationId
    }
}

struct DeleteActivationInputBody: Swift.Equatable {
    public let activationId: Swift.String?
}

extension DeleteActivationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationId = "ActivationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationId)
        activationId = activationIdDecoded
    }
}

extension DeleteActivationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteActivationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidActivation" : self = .invalidActivation(try InvalidActivation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidActivationId" : self = .invalidActivationId(try InvalidActivationId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteActivationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidActivation(InvalidActivation)
    case invalidActivationId(InvalidActivationId)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteActivationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteActivationOutputResponse()"}
}

extension DeleteActivationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteActivationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteActivationOutputResponseBody: Swift.Equatable {
}

extension DeleteActivationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteAssociationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssociationOutputError>
}

extension DeleteAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssociationInput(associationId: \(Swift.String(describing: associationId)), instanceId: \(Swift.String(describing: instanceId)), name: \(Swift.String(describing: name)))"}
}

extension DeleteAssociationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteAssociationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssociationOutputError>
}

public struct DeleteAssociationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssociationOutputError>
}

public struct DeleteAssociationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssociationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssociationOutputError>
}

public struct DeleteAssociationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssociationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssociationOutputError>
}

public struct DeleteAssociationInput: Swift.Equatable {
    /// The association ID that you want to delete.
    public var associationId: Swift.String?
    /// The managed node ID. InstanceId has been deprecated. To specify a managed node ID for an association, use the Targets parameter. Requests that include the parameter InstanceID with Systems Manager documents (SSM documents) that use schema version 2.0 or later will fail. In addition, if you use the parameter InstanceId, you can't use the parameters AssociationName, DocumentVersion, MaxErrors, MaxConcurrency, OutputLocation, or ScheduleExpression. To use these parameters, you must use the Targets parameter.
    public var instanceId: Swift.String?
    /// The name of the SSM document.
    public var name: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.name = name
    }
}

struct DeleteAssociationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let instanceId: Swift.String?
    public let associationId: Swift.String?
}

extension DeleteAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension DeleteAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssociationOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidInstanceId(InvalidInstanceId)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssociationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssociationOutputResponse()"}
}

extension DeleteAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssociationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAssociationOutputResponseBody: Swift.Equatable {
}

extension DeleteAssociationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDocumentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDocumentOutputError>
}

extension DeleteDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDocumentInput(documentVersion: \(Swift.String(describing: documentVersion)), force: \(Swift.String(describing: force)), name: \(Swift.String(describing: name)), versionName: \(Swift.String(describing: versionName)))"}
}

extension DeleteDocumentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case force = "Force"
        case name = "Name"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

public struct DeleteDocumentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDocumentOutputError>
}

public struct DeleteDocumentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDocumentOutputError>
}

public struct DeleteDocumentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDocumentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDocumentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDocumentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDocumentOutputError>
}

public struct DeleteDocumentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDocumentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDocumentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDocumentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDocumentOutputError>
}

public struct DeleteDocumentInput: Swift.Equatable {
    /// The version of the document that you want to delete. If not provided, all versions of the document are deleted.
    public var documentVersion: Swift.String?
    /// Some SSM document types require that you specify a Force flag before you can delete the document. For example, you must specify a Force flag to delete a document of type ApplicationConfigurationSchema. You can restrict access to the Force flag in an Identity and Access Management (IAM) policy.
    public var force: Swift.Bool
    /// The name of the document.
    /// This member is required.
    public var name: Swift.String?
    /// The version name of the document that you want to delete. If not provided, all versions of the document are deleted.
    public var versionName: Swift.String?

    public init (
        documentVersion: Swift.String? = nil,
        force: Swift.Bool = false,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.force = force
        self.name = name
        self.versionName = versionName
    }
}

struct DeleteDocumentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let documentVersion: Swift.String?
    public let versionName: Swift.String?
    public let force: Swift.Bool
}

extension DeleteDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case force = "Force"
        case name = "Name"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let forceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeleteDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociatedInstances" : self = .associatedInstances(try AssociatedInstances(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDocumentOutputError: Swift.Error, Swift.Equatable {
    case associatedInstances(AssociatedInstances)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDocumentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDocumentOutputResponse()"}
}

extension DeleteDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDocumentOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDocumentOutputResponseBody: Swift.Equatable {
}

extension DeleteDocumentOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteInventoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInventoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInventoryOutputError>
}

extension DeleteInventoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInventoryInput(clientToken: \(Swift.String(describing: clientToken)), dryRun: \(Swift.String(describing: dryRun)), schemaDeleteOption: \(Swift.String(describing: schemaDeleteOption)), typeName: \(Swift.String(describing: typeName)))"}
}

extension DeleteInventoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case schemaDeleteOption = "SchemaDeleteOption"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let schemaDeleteOption = schemaDeleteOption {
            try encodeContainer.encode(schemaDeleteOption.rawValue, forKey: .schemaDeleteOption)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }
}

public struct DeleteInventoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInventoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInventoryOutputError>
}

public struct DeleteInventoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInventoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInventoryOutputError>
}

public struct DeleteInventoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInventoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteInventoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteInventoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInventoryOutputError>
}

public struct DeleteInventoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInventoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteInventoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteInventoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInventoryOutputError>
}

public struct DeleteInventoryInput: Swift.Equatable {
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// Use this option to view a summary of the deletion request without deleting any data or the data type. This option is useful when you only want to understand what will be deleted. Once you validate that the data to be deleted is what you intend to delete, you can run the same command without specifying the DryRun option.
    public var dryRun: Swift.Bool
    /// Use the SchemaDeleteOption to delete a custom inventory type (schema). If you don't choose this option, the system only deletes existing inventory data associated with the custom inventory type. Choose one of the following options: DisableSchema: If you choose this option, the system ignores all inventory data for the specified version, and any earlier versions. To enable this schema again, you must call the PutInventory operation for a version greater than the disabled version. DeleteSchema: This option deletes the specified custom type from the Inventory service. You can recreate the schema later, if you want.
    public var schemaDeleteOption: SsmClientTypes.InventorySchemaDeleteOption?
    /// The name of the custom inventory type for which you want to delete either all previously collected data or the inventory type itself.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        schemaDeleteOption: SsmClientTypes.InventorySchemaDeleteOption? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.schemaDeleteOption = schemaDeleteOption
        self.typeName = typeName
    }
}

struct DeleteInventoryInputBody: Swift.Equatable {
    public let typeName: Swift.String?
    public let schemaDeleteOption: SsmClientTypes.InventorySchemaDeleteOption?
    public let dryRun: Swift.Bool
    public let clientToken: Swift.String?
}

extension DeleteInventoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case schemaDeleteOption = "SchemaDeleteOption"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let schemaDeleteOptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventorySchemaDeleteOption.self, forKey: .schemaDeleteOption)
        schemaDeleteOption = schemaDeleteOptionDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteInventoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInventoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeleteInventoryParameters" : self = .invalidDeleteInventoryParametersException(try InvalidDeleteInventoryParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInventoryRequest" : self = .invalidInventoryRequestException(try InvalidInventoryRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOption" : self = .invalidOptionException(try InvalidOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInventoryOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDeleteInventoryParametersException(InvalidDeleteInventoryParametersException)
    case invalidInventoryRequestException(InvalidInventoryRequestException)
    case invalidOptionException(InvalidOptionException)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInventoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInventoryOutputResponse(deletionId: \(Swift.String(describing: deletionId)), deletionSummary: \(Swift.String(describing: deletionSummary)), typeName: \(Swift.String(describing: typeName)))"}
}

extension DeleteInventoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteInventoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletionId = output.deletionId
            self.deletionSummary = output.deletionSummary
            self.typeName = output.typeName
        } else {
            self.deletionId = nil
            self.deletionSummary = nil
            self.typeName = nil
        }
    }
}

public struct DeleteInventoryOutputResponse: Swift.Equatable {
    /// Every DeleteInventory operation is assigned a unique ID. This option returns a unique ID. You can use this ID to query the status of a delete operation. This option is useful for ensuring that a delete operation has completed before you begin other operations.
    public var deletionId: Swift.String?
    /// A summary of the delete operation. For more information about this summary, see [Deleting custom inventory](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-custom.html#sysman-inventory-delete-summary) in the Amazon Web Services Systems Manager User Guide.
    public var deletionSummary: SsmClientTypes.InventoryDeletionSummary?
    /// The name of the inventory data type specified in the request.
    public var typeName: Swift.String?

    public init (
        deletionId: Swift.String? = nil,
        deletionSummary: SsmClientTypes.InventoryDeletionSummary? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.deletionId = deletionId
        self.deletionSummary = deletionSummary
        self.typeName = typeName
    }
}

struct DeleteInventoryOutputResponseBody: Swift.Equatable {
    public let deletionId: Swift.String?
    public let typeName: Swift.String?
    public let deletionSummary: SsmClientTypes.InventoryDeletionSummary?
}

extension DeleteInventoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionId = "DeletionId"
        case deletionSummary = "DeletionSummary"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionId)
        deletionId = deletionIdDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let deletionSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventoryDeletionSummary.self, forKey: .deletionSummary)
        deletionSummary = deletionSummaryDecoded
    }
}

public struct DeleteMaintenanceWindowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMaintenanceWindowOutputError>
}

extension DeleteMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMaintenanceWindowInput(windowId: \(Swift.String(describing: windowId)))"}
}

extension DeleteMaintenanceWindowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct DeleteMaintenanceWindowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMaintenanceWindowOutputError>
}

public struct DeleteMaintenanceWindowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMaintenanceWindowOutputError>
}

public struct DeleteMaintenanceWindowInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMaintenanceWindowInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMaintenanceWindowOutputError>
}

public struct DeleteMaintenanceWindowInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMaintenanceWindowInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMaintenanceWindowOutputError>
}

public struct DeleteMaintenanceWindowInput: Swift.Equatable {
    /// The ID of the maintenance window to delete.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct DeleteMaintenanceWindowInputBody: Swift.Equatable {
    public let windowId: Swift.String?
}

extension DeleteMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

extension DeleteMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMaintenanceWindowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMaintenanceWindowOutputResponse(windowId: \(Swift.String(describing: windowId)))"}
}

extension DeleteMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowId = output.windowId
        } else {
            self.windowId = nil
        }
    }
}

public struct DeleteMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the deleted maintenance window.
    public var windowId: Swift.String?

    public init (
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct DeleteMaintenanceWindowOutputResponseBody: Swift.Equatable {
    public let windowId: Swift.String?
}

extension DeleteMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

public struct DeleteOpsMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOpsMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOpsMetadataOutputError>
}

extension DeleteOpsMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOpsMetadataInput(opsMetadataArn: \(Swift.String(describing: opsMetadataArn)))"}
}

extension DeleteOpsMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
    }
}

public struct DeleteOpsMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOpsMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOpsMetadataOutputError>
}

public struct DeleteOpsMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOpsMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOpsMetadataOutputError>
}

public struct DeleteOpsMetadataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOpsMetadataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteOpsMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOpsMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOpsMetadataOutputError>
}

public struct DeleteOpsMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOpsMetadataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteOpsMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOpsMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOpsMetadataOutputError>
}

public struct DeleteOpsMetadataInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an OpsMetadata Object to delete.
    /// This member is required.
    public var opsMetadataArn: Swift.String?

    public init (
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

struct DeleteOpsMetadataInputBody: Swift.Equatable {
    public let opsMetadataArn: Swift.String?
}

extension DeleteOpsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
    }
}

extension DeleteOpsMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOpsMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataNotFoundException" : self = .opsMetadataNotFoundException(try OpsMetadataNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOpsMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataNotFoundException(OpsMetadataNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOpsMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOpsMetadataOutputResponse()"}
}

extension DeleteOpsMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOpsMetadataOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteOpsMetadataOutputResponseBody: Swift.Equatable {
}

extension DeleteOpsMetadataOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteParameterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParameterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParameterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterOutputError>
}

extension DeleteParameterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteParameterInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteParameterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteParameterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParameterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParameterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterOutputError>
}

public struct DeleteParameterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParameterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParameterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterOutputError>
}

public struct DeleteParameterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteParameterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteParameterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterOutputError>
}

public struct DeleteParameterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteParameterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteParameterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterOutputError>
}

public struct DeleteParameterInput: Swift.Equatable {
    /// The name of the parameter to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteParameterInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteParameterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParameterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParameterOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case parameterNotFound(ParameterNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParameterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteParameterOutputResponse()"}
}

extension DeleteParameterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteParameterOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteParameterOutputResponseBody: Swift.Equatable {
}

extension DeleteParameterOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParametersOutputError>
}

extension DeleteParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteParametersInput(names: \(Swift.String(describing: names)))"}
}

extension DeleteParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for parameternamelist0 in names {
                try namesContainer.encode(parameternamelist0)
            }
        }
    }
}

public struct DeleteParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParametersOutputError>
}

public struct DeleteParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParametersOutputError>
}

public struct DeleteParametersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParametersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParametersOutputError>
}

public struct DeleteParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParametersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParametersOutputError>
}

public struct DeleteParametersInput: Swift.Equatable {
    /// The names of the parameters to delete. After deleting a parameter, wait for at least 30 seconds to create a parameter with the same name.
    /// This member is required.
    public var names: [Swift.String]?

    public init (
        names: [Swift.String]? = nil
    )
    {
        self.names = names
    }
}

struct DeleteParametersInputBody: Swift.Equatable {
    public let names: [Swift.String]?
}

extension DeleteParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension DeleteParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParametersOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteParametersOutputResponse(deletedParameters: \(Swift.String(describing: deletedParameters)), invalidParameters: \(Swift.String(describing: invalidParameters)))"}
}

extension DeleteParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletedParameters = output.deletedParameters
            self.invalidParameters = output.invalidParameters
        } else {
            self.deletedParameters = nil
            self.invalidParameters = nil
        }
    }
}

public struct DeleteParametersOutputResponse: Swift.Equatable {
    /// The names of the deleted parameters.
    public var deletedParameters: [Swift.String]?
    /// The names of parameters that weren't deleted because the parameters aren't valid.
    public var invalidParameters: [Swift.String]?

    public init (
        deletedParameters: [Swift.String]? = nil,
        invalidParameters: [Swift.String]? = nil
    )
    {
        self.deletedParameters = deletedParameters
        self.invalidParameters = invalidParameters
    }
}

struct DeleteParametersOutputResponseBody: Swift.Equatable {
    public let deletedParameters: [Swift.String]?
    public let invalidParameters: [Swift.String]?
}

extension DeleteParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletedParameters = "DeletedParameters"
        case invalidParameters = "InvalidParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deletedParameters)
        var deletedParametersDecoded0:[Swift.String]? = nil
        if let deletedParametersContainer = deletedParametersContainer {
            deletedParametersDecoded0 = [Swift.String]()
            for string0 in deletedParametersContainer {
                if let string0 = string0 {
                    deletedParametersDecoded0?.append(string0)
                }
            }
        }
        deletedParameters = deletedParametersDecoded0
        let invalidParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidParameters)
        var invalidParametersDecoded0:[Swift.String]? = nil
        if let invalidParametersContainer = invalidParametersContainer {
            invalidParametersDecoded0 = [Swift.String]()
            for string0 in invalidParametersContainer {
                if let string0 = string0 {
                    invalidParametersDecoded0?.append(string0)
                }
            }
        }
        invalidParameters = invalidParametersDecoded0
    }
}

public struct DeletePatchBaselineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePatchBaselineOutputError>
}

extension DeletePatchBaselineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePatchBaselineInput(baselineId: \(Swift.String(describing: baselineId)))"}
}

extension DeletePatchBaselineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
    }
}

public struct DeletePatchBaselineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePatchBaselineOutputError>
}

public struct DeletePatchBaselineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePatchBaselineOutputError>
}

public struct DeletePatchBaselineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePatchBaselineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeletePatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePatchBaselineOutputError>
}

public struct DeletePatchBaselineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePatchBaselineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeletePatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePatchBaselineOutputError>
}

public struct DeletePatchBaselineInput: Swift.Equatable {
    /// The ID of the patch baseline to delete.
    /// This member is required.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct DeletePatchBaselineInputBody: Swift.Equatable {
    public let baselineId: Swift.String?
}

extension DeletePatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension DeletePatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePatchBaselineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePatchBaselineOutputResponse(baselineId: \(Swift.String(describing: baselineId)))"}
}

extension DeletePatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeletePatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
        } else {
            self.baselineId = nil
        }
    }
}

public struct DeletePatchBaselineOutputResponse: Swift.Equatable {
    /// The ID of the deleted patch baseline.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct DeletePatchBaselineOutputResponseBody: Swift.Equatable {
    public let baselineId: Swift.String?
}

extension DeletePatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

public struct DeleteResourceDataSyncInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceDataSyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceDataSyncOutputError>
}

extension DeleteResourceDataSyncInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceDataSyncInput(syncName: \(Swift.String(describing: syncName)), syncType: \(Swift.String(describing: syncType)))"}
}

extension DeleteResourceDataSyncInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncName = "SyncName"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

public struct DeleteResourceDataSyncInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceDataSyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceDataSyncOutputError>
}

public struct DeleteResourceDataSyncInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceDataSyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceDataSyncOutputError>
}

public struct DeleteResourceDataSyncInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceDataSyncInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteResourceDataSyncInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResourceDataSyncInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceDataSyncOutputError>
}

public struct DeleteResourceDataSyncInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceDataSyncInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteResourceDataSyncInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResourceDataSyncInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceDataSyncOutputError>
}

public struct DeleteResourceDataSyncInput: Swift.Equatable {
    /// The name of the configuration to delete.
    /// This member is required.
    public var syncName: Swift.String?
    /// Specify the type of resource data sync to delete.
    public var syncType: Swift.String?

    public init (
        syncName: Swift.String? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.syncName = syncName
        self.syncType = syncType
    }
}

struct DeleteResourceDataSyncInputBody: Swift.Equatable {
    public let syncName: Swift.String?
    public let syncType: Swift.String?
}

extension DeleteResourceDataSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncName = "SyncName"
        case syncType = "SyncType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
    }
}

extension DeleteResourceDataSyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceDataSyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfiguration" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncNotFound" : self = .resourceDataSyncNotFoundException(try ResourceDataSyncNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceDataSyncOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case resourceDataSyncNotFoundException(ResourceDataSyncNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceDataSyncOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceDataSyncOutputResponse()"}
}

extension DeleteResourceDataSyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceDataSyncOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteResourceDataSyncOutputResponseBody: Swift.Equatable {
}

extension DeleteResourceDataSyncOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterManagedInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterManagedInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterManagedInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterManagedInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterManagedInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterManagedInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterManagedInstanceOutputError>
}

extension DeregisterManagedInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterManagedInstanceInput(instanceId: \(Swift.String(describing: instanceId)))"}
}

extension DeregisterManagedInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct DeregisterManagedInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterManagedInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterManagedInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterManagedInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterManagedInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterManagedInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterManagedInstanceOutputError>
}

public struct DeregisterManagedInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterManagedInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterManagedInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterManagedInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterManagedInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterManagedInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterManagedInstanceOutputError>
}

public struct DeregisterManagedInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterManagedInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeregisterManagedInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterManagedInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterManagedInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterManagedInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterManagedInstanceOutputError>
}

public struct DeregisterManagedInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterManagedInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeregisterManagedInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterManagedInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterManagedInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterManagedInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterManagedInstanceOutputError>
}

public struct DeregisterManagedInstanceInput: Swift.Equatable {
    /// The ID assigned to the managed node when you registered it using the activation process.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DeregisterManagedInstanceInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
}

extension DeregisterManagedInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension DeregisterManagedInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterManagedInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterManagedInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterManagedInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterManagedInstanceOutputResponse()"}
}

extension DeregisterManagedInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterManagedInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterManagedInstanceOutputResponseBody: Swift.Equatable {
}

extension DeregisterManagedInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterPatchBaselineForPatchGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterPatchBaselineForPatchGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterPatchBaselineForPatchGroupOutputError>
}

extension DeregisterPatchBaselineForPatchGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterPatchBaselineForPatchGroupInput(baselineId: \(Swift.String(describing: baselineId)), patchGroup: \(Swift.String(describing: patchGroup)))"}
}

extension DeregisterPatchBaselineForPatchGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

public struct DeregisterPatchBaselineForPatchGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterPatchBaselineForPatchGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterPatchBaselineForPatchGroupOutputError>
}

public struct DeregisterPatchBaselineForPatchGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterPatchBaselineForPatchGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterPatchBaselineForPatchGroupOutputError>
}

public struct DeregisterPatchBaselineForPatchGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterPatchBaselineForPatchGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeregisterPatchBaselineForPatchGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterPatchBaselineForPatchGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterPatchBaselineForPatchGroupOutputError>
}

public struct DeregisterPatchBaselineForPatchGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterPatchBaselineForPatchGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeregisterPatchBaselineForPatchGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterPatchBaselineForPatchGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterPatchBaselineForPatchGroupOutputError>
}

public struct DeregisterPatchBaselineForPatchGroupInput: Swift.Equatable {
    /// The ID of the patch baseline to deregister the patch group from.
    /// This member is required.
    public var baselineId: Swift.String?
    /// The name of the patch group that should be deregistered from the patch baseline.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct DeregisterPatchBaselineForPatchGroupInputBody: Swift.Equatable {
    public let baselineId: Swift.String?
    public let patchGroup: Swift.String?
}

extension DeregisterPatchBaselineForPatchGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension DeregisterPatchBaselineForPatchGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterPatchBaselineForPatchGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterPatchBaselineForPatchGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterPatchBaselineForPatchGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterPatchBaselineForPatchGroupOutputResponse(baselineId: \(Swift.String(describing: baselineId)), patchGroup: \(Swift.String(describing: patchGroup)))"}
}

extension DeregisterPatchBaselineForPatchGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterPatchBaselineForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
            self.patchGroup = output.patchGroup
        } else {
            self.baselineId = nil
            self.patchGroup = nil
        }
    }
}

public struct DeregisterPatchBaselineForPatchGroupOutputResponse: Swift.Equatable {
    /// The ID of the patch baseline the patch group was deregistered from.
    public var baselineId: Swift.String?
    /// The name of the patch group deregistered from the patch baseline.
    public var patchGroup: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct DeregisterPatchBaselineForPatchGroupOutputResponseBody: Swift.Equatable {
    public let baselineId: Swift.String?
    public let patchGroup: Swift.String?
}

extension DeregisterPatchBaselineForPatchGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

public struct DeregisterTargetFromMaintenanceWindowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTargetFromMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTargetFromMaintenanceWindowOutputError>
}

extension DeregisterTargetFromMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterTargetFromMaintenanceWindowInput(safe: \(Swift.String(describing: safe)), windowId: \(Swift.String(describing: windowId)), windowTargetId: \(Swift.String(describing: windowTargetId)))"}
}

extension DeregisterTargetFromMaintenanceWindowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case safe = "Safe"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if safe != false {
            try encodeContainer.encode(safe, forKey: .safe)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }
}

public struct DeregisterTargetFromMaintenanceWindowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTargetFromMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTargetFromMaintenanceWindowOutputError>
}

public struct DeregisterTargetFromMaintenanceWindowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTargetFromMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTargetFromMaintenanceWindowOutputError>
}

public struct DeregisterTargetFromMaintenanceWindowInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTargetFromMaintenanceWindowInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeregisterTargetFromMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterTargetFromMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTargetFromMaintenanceWindowOutputError>
}

public struct DeregisterTargetFromMaintenanceWindowInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTargetFromMaintenanceWindowInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeregisterTargetFromMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterTargetFromMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTargetFromMaintenanceWindowOutputError>
}

public struct DeregisterTargetFromMaintenanceWindowInput: Swift.Equatable {
    /// The system checks if the target is being referenced by a task. If the target is being referenced, the system returns an error and doesn't deregister the target from the maintenance window.
    public var safe: Swift.Bool
    /// The ID of the maintenance window the target should be removed from.
    /// This member is required.
    public var windowId: Swift.String?
    /// The ID of the target definition to remove.
    /// This member is required.
    public var windowTargetId: Swift.String?

    public init (
        safe: Swift.Bool = false,
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.safe = safe
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct DeregisterTargetFromMaintenanceWindowInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let windowTargetId: Swift.String?
    public let safe: Swift.Bool
}

extension DeregisterTargetFromMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case safe = "Safe"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let safeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .safe)
        safe = safeDecoded
    }
}

extension DeregisterTargetFromMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTargetFromMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetInUseException" : self = .targetInUseException(try TargetInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTargetFromMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case targetInUseException(TargetInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTargetFromMaintenanceWindowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterTargetFromMaintenanceWindowOutputResponse(windowId: \(Swift.String(describing: windowId)), windowTargetId: \(Swift.String(describing: windowTargetId)))"}
}

extension DeregisterTargetFromMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterTargetFromMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowId = output.windowId
            self.windowTargetId = output.windowTargetId
        } else {
            self.windowId = nil
            self.windowTargetId = nil
        }
    }
}

public struct DeregisterTargetFromMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the maintenance window the target was removed from.
    public var windowId: Swift.String?
    /// The ID of the removed target definition.
    public var windowTargetId: Swift.String?

    public init (
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct DeregisterTargetFromMaintenanceWindowOutputResponseBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let windowTargetId: Swift.String?
}

extension DeregisterTargetFromMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

public struct DeregisterTaskFromMaintenanceWindowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTaskFromMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTaskFromMaintenanceWindowOutputError>
}

extension DeregisterTaskFromMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterTaskFromMaintenanceWindowInput(windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)))"}
}

extension DeregisterTaskFromMaintenanceWindowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }
}

public struct DeregisterTaskFromMaintenanceWindowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTaskFromMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTaskFromMaintenanceWindowOutputError>
}

public struct DeregisterTaskFromMaintenanceWindowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTaskFromMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTaskFromMaintenanceWindowOutputError>
}

public struct DeregisterTaskFromMaintenanceWindowInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTaskFromMaintenanceWindowInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeregisterTaskFromMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterTaskFromMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTaskFromMaintenanceWindowOutputError>
}

public struct DeregisterTaskFromMaintenanceWindowInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTaskFromMaintenanceWindowInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeregisterTaskFromMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterTaskFromMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTaskFromMaintenanceWindowOutputError>
}

public struct DeregisterTaskFromMaintenanceWindowInput: Swift.Equatable {
    /// The ID of the maintenance window the task should be removed from.
    /// This member is required.
    public var windowId: Swift.String?
    /// The ID of the task to remove from the maintenance window.
    /// This member is required.
    public var windowTaskId: Swift.String?

    public init (
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct DeregisterTaskFromMaintenanceWindowInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let windowTaskId: Swift.String?
}

extension DeregisterTaskFromMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension DeregisterTaskFromMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTaskFromMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTaskFromMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTaskFromMaintenanceWindowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterTaskFromMaintenanceWindowOutputResponse(windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)))"}
}

extension DeregisterTaskFromMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterTaskFromMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowId = output.windowId
            self.windowTaskId = output.windowTaskId
        } else {
            self.windowId = nil
            self.windowTaskId = nil
        }
    }
}

public struct DeregisterTaskFromMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the maintenance window the task was removed from.
    public var windowId: Swift.String?
    /// The ID of the task removed from the maintenance window.
    public var windowTaskId: Swift.String?

    public init (
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct DeregisterTaskFromMaintenanceWindowOutputResponseBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let windowTaskId: Swift.String?
}

extension DeregisterTaskFromMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension SsmClientTypes.DescribeActivationsFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterKey = "FilterKey"
        case filterValues = "FilterValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterKey = filterKey {
            try encodeContainer.encode(filterKey.rawValue, forKey: .filterKey)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterValues)
            for stringlist0 in filterValues {
                try filterValuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterKeyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DescribeActivationsFilterKeys.self, forKey: .filterKey)
        filterKey = filterKeyDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterValues)
        var filterValuesDecoded0:[Swift.String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [Swift.String]()
            for string0 in filterValuesContainer {
                if let string0 = string0 {
                    filterValuesDecoded0?.append(string0)
                }
            }
        }
        filterValues = filterValuesDecoded0
    }
}

extension SsmClientTypes.DescribeActivationsFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeActivationsFilter(filterKey: \(Swift.String(describing: filterKey)), filterValues: \(Swift.String(describing: filterValues)))"}
}

extension SsmClientTypes {
    /// Filter for the DescribeActivation API.
    public struct DescribeActivationsFilter: Swift.Equatable {
        /// The name of the filter.
        public var filterKey: SsmClientTypes.DescribeActivationsFilterKeys?
        /// The filter values.
        public var filterValues: [Swift.String]?

        public init (
            filterKey: SsmClientTypes.DescribeActivationsFilterKeys? = nil,
            filterValues: [Swift.String]? = nil
        )
        {
            self.filterKey = filterKey
            self.filterValues = filterValues
        }
    }

}

extension SsmClientTypes {
    public enum DescribeActivationsFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activationIds
        case defaultInstanceName
        case iamRole
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribeActivationsFilterKeys] {
            return [
                .activationIds,
                .defaultInstanceName,
                .iamRole,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activationIds: return "ActivationIds"
            case .defaultInstanceName: return "DefaultInstanceName"
            case .iamRole: return "IamRole"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DescribeActivationsFilterKeys(rawValue: rawValue) ?? DescribeActivationsFilterKeys.sdkUnknown(rawValue)
        }
    }
}

public struct DescribeActivationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeActivationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeActivationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeActivationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeActivationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeActivationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeActivationsOutputError>
}

extension DescribeActivationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeActivationsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeActivationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for describeactivationsfilterlist0 in filters {
                try filtersContainer.encode(describeactivationsfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeActivationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeActivationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeActivationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeActivationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeActivationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeActivationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeActivationsOutputError>
}

public struct DescribeActivationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeActivationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeActivationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeActivationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeActivationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeActivationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeActivationsOutputError>
}

public struct DescribeActivationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeActivationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeActivationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeActivationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeActivationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeActivationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeActivationsOutputError>
}

public struct DescribeActivationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeActivationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeActivationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeActivationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeActivationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeActivationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeActivationsOutputError>
}

public struct DescribeActivationsInput: Swift.Equatable {
    /// A filter to view information about your activations.
    public var filters: [SsmClientTypes.DescribeActivationsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.DescribeActivationsFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeActivationsInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.DescribeActivationsFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeActivationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.DescribeActivationsFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.DescribeActivationsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.DescribeActivationsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeActivationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeActivationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeActivationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeActivationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeActivationsOutputResponse(activationList: \(Swift.String(describing: activationList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeActivationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeActivationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activationList = output.activationList
            self.nextToken = output.nextToken
        } else {
            self.activationList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeActivationsOutputResponse: Swift.Equatable {
    /// A list of activations for your Amazon Web Services account.
    public var activationList: [SsmClientTypes.Activation]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        activationList: [SsmClientTypes.Activation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.activationList = activationList
        self.nextToken = nextToken
    }
}

struct DescribeActivationsOutputResponseBody: Swift.Equatable {
    public let activationList: [SsmClientTypes.Activation]?
    public let nextToken: Swift.String?
}

extension DescribeActivationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationList = "ActivationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationListContainer = try containerValues.decodeIfPresent([SsmClientTypes.Activation?].self, forKey: .activationList)
        var activationListDecoded0:[SsmClientTypes.Activation]? = nil
        if let activationListContainer = activationListContainer {
            activationListDecoded0 = [SsmClientTypes.Activation]()
            for structure0 in activationListContainer {
                if let structure0 = structure0 {
                    activationListDecoded0?.append(structure0)
                }
            }
        }
        activationList = activationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAssociationExecutionTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationExecutionTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssociationExecutionTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssociationExecutionTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationExecutionTargetsOutputError>
}

extension DescribeAssociationExecutionTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssociationExecutionTargetsInput(associationId: \(Swift.String(describing: associationId)), executionId: \(Swift.String(describing: executionId)), filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAssociationExecutionTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case executionId = "ExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for associationexecutiontargetsfilterlist0 in filters {
                try filtersContainer.encode(associationexecutiontargetsfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAssociationExecutionTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationExecutionTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssociationExecutionTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssociationExecutionTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationExecutionTargetsOutputError>
}

public struct DescribeAssociationExecutionTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationExecutionTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssociationExecutionTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssociationExecutionTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationExecutionTargetsOutputError>
}

public struct DescribeAssociationExecutionTargetsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationExecutionTargetsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAssociationExecutionTargetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssociationExecutionTargetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationExecutionTargetsOutputError>
}

public struct DescribeAssociationExecutionTargetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationExecutionTargetsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAssociationExecutionTargetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssociationExecutionTargetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationExecutionTargetsOutputError>
}

public struct DescribeAssociationExecutionTargetsInput: Swift.Equatable {
    /// The association ID that includes the execution for which you want to view details.
    /// This member is required.
    public var associationId: Swift.String?
    /// The execution ID for which you want to view details.
    /// This member is required.
    public var executionId: Swift.String?
    /// Filters for the request. You can specify the following filters and values. Status (EQUAL) ResourceId (EQUAL) ResourceType (EQUAL)
    public var filters: [SsmClientTypes.AssociationExecutionTargetsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        executionId: Swift.String? = nil,
        filters: [SsmClientTypes.AssociationExecutionTargetsFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.executionId = executionId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionTargetsInputBody: Swift.Equatable {
    public let associationId: Swift.String?
    public let executionId: Swift.String?
    public let filters: [SsmClientTypes.AssociationExecutionTargetsFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeAssociationExecutionTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case executionId = "ExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationExecutionTargetsFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.AssociationExecutionTargetsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.AssociationExecutionTargetsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAssociationExecutionTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssociationExecutionTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociationExecutionDoesNotExist" : self = .associationExecutionDoesNotExist(try AssociationExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssociationExecutionTargetsOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case associationExecutionDoesNotExist(AssociationExecutionDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssociationExecutionTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssociationExecutionTargetsOutputResponse(associationExecutionTargets: \(Swift.String(describing: associationExecutionTargets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAssociationExecutionTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssociationExecutionTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationExecutionTargets = output.associationExecutionTargets
            self.nextToken = output.nextToken
        } else {
            self.associationExecutionTargets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAssociationExecutionTargetsOutputResponse: Swift.Equatable {
    /// Information about the execution.
    public var associationExecutionTargets: [SsmClientTypes.AssociationExecutionTarget]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationExecutionTargets: [SsmClientTypes.AssociationExecutionTarget]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationExecutionTargets = associationExecutionTargets
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionTargetsOutputResponseBody: Swift.Equatable {
    public let associationExecutionTargets: [SsmClientTypes.AssociationExecutionTarget]?
    public let nextToken: Swift.String?
}

extension DescribeAssociationExecutionTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationExecutionTargets = "AssociationExecutionTargets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationExecutionTargetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationExecutionTarget?].self, forKey: .associationExecutionTargets)
        var associationExecutionTargetsDecoded0:[SsmClientTypes.AssociationExecutionTarget]? = nil
        if let associationExecutionTargetsContainer = associationExecutionTargetsContainer {
            associationExecutionTargetsDecoded0 = [SsmClientTypes.AssociationExecutionTarget]()
            for structure0 in associationExecutionTargetsContainer {
                if let structure0 = structure0 {
                    associationExecutionTargetsDecoded0?.append(structure0)
                }
            }
        }
        associationExecutionTargets = associationExecutionTargetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAssociationExecutionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssociationExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssociationExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationExecutionsOutputError>
}

extension DescribeAssociationExecutionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssociationExecutionsInput(associationId: \(Swift.String(describing: associationId)), filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAssociationExecutionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for associationexecutionfilterlist0 in filters {
                try filtersContainer.encode(associationexecutionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAssociationExecutionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssociationExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssociationExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationExecutionsOutputError>
}

public struct DescribeAssociationExecutionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssociationExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssociationExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationExecutionsOutputError>
}

public struct DescribeAssociationExecutionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationExecutionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAssociationExecutionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssociationExecutionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationExecutionsOutputError>
}

public struct DescribeAssociationExecutionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationExecutionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAssociationExecutionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssociationExecutionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationExecutionsOutputError>
}

public struct DescribeAssociationExecutionsInput: Swift.Equatable {
    /// The association ID for which you want to view execution history details.
    /// This member is required.
    public var associationId: Swift.String?
    /// Filters for the request. You can specify the following filters and values. ExecutionId (EQUAL) Status (EQUAL) CreatedTime (EQUAL, GREATER_THAN, LESS_THAN)
    public var filters: [SsmClientTypes.AssociationExecutionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        filters: [SsmClientTypes.AssociationExecutionFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionsInputBody: Swift.Equatable {
    public let associationId: Swift.String?
    public let filters: [SsmClientTypes.AssociationExecutionFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeAssociationExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationExecutionFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.AssociationExecutionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.AssociationExecutionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAssociationExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssociationExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssociationExecutionsOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssociationExecutionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssociationExecutionsOutputResponse(associationExecutions: \(Swift.String(describing: associationExecutions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAssociationExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssociationExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationExecutions = output.associationExecutions
            self.nextToken = output.nextToken
        } else {
            self.associationExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAssociationExecutionsOutputResponse: Swift.Equatable {
    /// A list of the executions for the specified association ID.
    public var associationExecutions: [SsmClientTypes.AssociationExecution]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationExecutions: [SsmClientTypes.AssociationExecution]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationExecutions = associationExecutions
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionsOutputResponseBody: Swift.Equatable {
    public let associationExecutions: [SsmClientTypes.AssociationExecution]?
    public let nextToken: Swift.String?
}

extension DescribeAssociationExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationExecutions = "AssociationExecutions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationExecutionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationExecution?].self, forKey: .associationExecutions)
        var associationExecutionsDecoded0:[SsmClientTypes.AssociationExecution]? = nil
        if let associationExecutionsContainer = associationExecutionsContainer {
            associationExecutionsDecoded0 = [SsmClientTypes.AssociationExecution]()
            for structure0 in associationExecutionsContainer {
                if let structure0 = structure0 {
                    associationExecutionsDecoded0?.append(structure0)
                }
            }
        }
        associationExecutions = associationExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAssociationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationOutputError>
}

extension DescribeAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssociationInput(associationId: \(Swift.String(describing: associationId)), associationVersion: \(Swift.String(describing: associationVersion)), instanceId: \(Swift.String(describing: instanceId)), name: \(Swift.String(describing: name)))"}
}

extension DescribeAssociationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeAssociationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationOutputError>
}

public struct DescribeAssociationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationOutputError>
}

public struct DescribeAssociationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationOutputError>
}

public struct DescribeAssociationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssociationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssociationOutputError>
}

public struct DescribeAssociationInput: Swift.Equatable {
    /// The association ID for which you want information.
    public var associationId: Swift.String?
    /// Specify the association version to retrieve. To view the latest version, either specify $LATEST for this parameter, or omit this parameter. To view a list of all associations for a managed node, use [ListAssociations]. To get a list of versions for a specific association, use [ListAssociationVersions].
    public var associationVersion: Swift.String?
    /// The managed node ID.
    public var instanceId: Swift.String?
    /// The name of the SSM document.
    public var name: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        associationVersion: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.associationVersion = associationVersion
        self.instanceId = instanceId
        self.name = name
    }
}

struct DescribeAssociationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let instanceId: Swift.String?
    public let associationId: Swift.String?
    public let associationVersion: Swift.String?
}

extension DescribeAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
    }
}

extension DescribeAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAssociationVersion" : self = .invalidAssociationVersion(try InvalidAssociationVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssociationOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidAssociationVersion(InvalidAssociationVersion)
    case invalidDocument(InvalidDocument)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssociationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssociationOutputResponse(associationDescription: \(Swift.String(describing: associationDescription)))"}
}

extension DescribeAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct DescribeAssociationOutputResponse: Swift.Equatable {
    /// Information about the association.
    public var associationDescription: SsmClientTypes.AssociationDescription?

    public init (
        associationDescription: SsmClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct DescribeAssociationOutputResponseBody: Swift.Equatable {
    public let associationDescription: SsmClientTypes.AssociationDescription?
}

extension DescribeAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

public struct DescribeAutomationExecutionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutomationExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutomationExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutomationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutomationExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutomationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutomationExecutionsOutputError>
}

extension DescribeAutomationExecutionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAutomationExecutionsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAutomationExecutionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for automationexecutionfilterlist0 in filters {
                try filtersContainer.encode(automationexecutionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAutomationExecutionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutomationExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutomationExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutomationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutomationExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutomationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutomationExecutionsOutputError>
}

public struct DescribeAutomationExecutionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutomationExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutomationExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutomationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutomationExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutomationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutomationExecutionsOutputError>
}

public struct DescribeAutomationExecutionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutomationExecutionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAutomationExecutionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutomationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAutomationExecutionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutomationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutomationExecutionsOutputError>
}

public struct DescribeAutomationExecutionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutomationExecutionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAutomationExecutionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutomationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAutomationExecutionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutomationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutomationExecutionsOutputError>
}

public struct DescribeAutomationExecutionsInput: Swift.Equatable {
    /// Filters used to limit the scope of executions that are requested.
    public var filters: [SsmClientTypes.AutomationExecutionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.AutomationExecutionFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAutomationExecutionsInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.AutomationExecutionFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeAutomationExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.AutomationExecutionFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.AutomationExecutionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.AutomationExecutionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAutomationExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutomationExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAutomationExecutionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterValue(InvalidFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutomationExecutionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAutomationExecutionsOutputResponse(automationExecutionMetadataList: \(Swift.String(describing: automationExecutionMetadataList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAutomationExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAutomationExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automationExecutionMetadataList = output.automationExecutionMetadataList
            self.nextToken = output.nextToken
        } else {
            self.automationExecutionMetadataList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAutomationExecutionsOutputResponse: Swift.Equatable {
    /// The list of details about each automation execution which has occurred which matches the filter specification, if any.
    public var automationExecutionMetadataList: [SsmClientTypes.AutomationExecutionMetadata]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        automationExecutionMetadataList: [SsmClientTypes.AutomationExecutionMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.automationExecutionMetadataList = automationExecutionMetadataList
        self.nextToken = nextToken
    }
}

struct DescribeAutomationExecutionsOutputResponseBody: Swift.Equatable {
    public let automationExecutionMetadataList: [SsmClientTypes.AutomationExecutionMetadata]?
    public let nextToken: Swift.String?
}

extension DescribeAutomationExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionMetadataList = "AutomationExecutionMetadataList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionMetadataListContainer = try containerValues.decodeIfPresent([SsmClientTypes.AutomationExecutionMetadata?].self, forKey: .automationExecutionMetadataList)
        var automationExecutionMetadataListDecoded0:[SsmClientTypes.AutomationExecutionMetadata]? = nil
        if let automationExecutionMetadataListContainer = automationExecutionMetadataListContainer {
            automationExecutionMetadataListDecoded0 = [SsmClientTypes.AutomationExecutionMetadata]()
            for structure0 in automationExecutionMetadataListContainer {
                if let structure0 = structure0 {
                    automationExecutionMetadataListDecoded0?.append(structure0)
                }
            }
        }
        automationExecutionMetadataList = automationExecutionMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAutomationStepExecutionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutomationStepExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutomationStepExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutomationStepExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutomationStepExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutomationStepExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutomationStepExecutionsOutputError>
}

extension DescribeAutomationStepExecutionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAutomationStepExecutionsInput(automationExecutionId: \(Swift.String(describing: automationExecutionId)), filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), reverseOrder: \(Swift.String(describing: reverseOrder)))"}
}

extension DescribeAutomationStepExecutionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case reverseOrder = "ReverseOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for stepexecutionfilterlist0 in filters {
                try filtersContainer.encode(stepexecutionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if reverseOrder != false {
            try encodeContainer.encode(reverseOrder, forKey: .reverseOrder)
        }
    }
}

public struct DescribeAutomationStepExecutionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutomationStepExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutomationStepExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutomationStepExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutomationStepExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutomationStepExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutomationStepExecutionsOutputError>
}

public struct DescribeAutomationStepExecutionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutomationStepExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutomationStepExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutomationStepExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutomationStepExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutomationStepExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutomationStepExecutionsOutputError>
}

public struct DescribeAutomationStepExecutionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutomationStepExecutionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAutomationStepExecutionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutomationStepExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAutomationStepExecutionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutomationStepExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutomationStepExecutionsOutputError>
}

public struct DescribeAutomationStepExecutionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutomationStepExecutionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAutomationStepExecutionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutomationStepExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAutomationStepExecutionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutomationStepExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutomationStepExecutionsOutputError>
}

public struct DescribeAutomationStepExecutionsInput: Swift.Equatable {
    /// The Automation execution ID for which you want step execution descriptions.
    /// This member is required.
    public var automationExecutionId: Swift.String?
    /// One or more filters to limit the number of step executions returned by the request.
    public var filters: [SsmClientTypes.StepExecutionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Indicates whether to list step executions in reverse order by start time. The default value is 'false'.
    public var reverseOrder: Swift.Bool

    public init (
        automationExecutionId: Swift.String? = nil,
        filters: [SsmClientTypes.StepExecutionFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        reverseOrder: Swift.Bool = false
    )
    {
        self.automationExecutionId = automationExecutionId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reverseOrder = reverseOrder
    }
}

struct DescribeAutomationStepExecutionsInputBody: Swift.Equatable {
    public let automationExecutionId: Swift.String?
    public let filters: [SsmClientTypes.StepExecutionFilter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
    public let reverseOrder: Swift.Bool
}

extension DescribeAutomationStepExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case reverseOrder = "ReverseOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.StepExecutionFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.StepExecutionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.StepExecutionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let reverseOrderDecoded = try containerValues.decode(Swift.Bool.self, forKey: .reverseOrder)
        reverseOrder = reverseOrderDecoded
    }
}

extension DescribeAutomationStepExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutomationStepExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFound" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAutomationStepExecutionsOutputError: Swift.Error, Swift.Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterValue(InvalidFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutomationStepExecutionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAutomationStepExecutionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), stepExecutions: \(Swift.String(describing: stepExecutions)))"}
}

extension DescribeAutomationStepExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAutomationStepExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stepExecutions = output.stepExecutions
        } else {
            self.nextToken = nil
            self.stepExecutions = nil
        }
    }
}

public struct DescribeAutomationStepExecutionsOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// A list of details about the current state of all steps that make up an execution.
    public var stepExecutions: [SsmClientTypes.StepExecution]?

    public init (
        nextToken: Swift.String? = nil,
        stepExecutions: [SsmClientTypes.StepExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.stepExecutions = stepExecutions
    }
}

struct DescribeAutomationStepExecutionsOutputResponseBody: Swift.Equatable {
    public let stepExecutions: [SsmClientTypes.StepExecution]?
    public let nextToken: Swift.String?
}

extension DescribeAutomationStepExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stepExecutions = "StepExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepExecutionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.StepExecution?].self, forKey: .stepExecutions)
        var stepExecutionsDecoded0:[SsmClientTypes.StepExecution]? = nil
        if let stepExecutionsContainer = stepExecutionsContainer {
            stepExecutionsDecoded0 = [SsmClientTypes.StepExecution]()
            for structure0 in stepExecutionsContainer {
                if let structure0 = structure0 {
                    stepExecutionsDecoded0?.append(structure0)
                }
            }
        }
        stepExecutions = stepExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAvailablePatchesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailablePatchesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAvailablePatchesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailablePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAvailablePatchesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailablePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailablePatchesOutputError>
}

extension DescribeAvailablePatchesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAvailablePatchesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAvailablePatchesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAvailablePatchesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailablePatchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAvailablePatchesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailablePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAvailablePatchesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailablePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailablePatchesOutputError>
}

public struct DescribeAvailablePatchesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailablePatchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAvailablePatchesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailablePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAvailablePatchesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailablePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailablePatchesOutputError>
}

public struct DescribeAvailablePatchesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailablePatchesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAvailablePatchesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailablePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAvailablePatchesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailablePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailablePatchesOutputError>
}

public struct DescribeAvailablePatchesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailablePatchesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAvailablePatchesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailablePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAvailablePatchesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailablePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailablePatchesOutputError>
}

public struct DescribeAvailablePatchesInput: Swift.Equatable {
    /// Each element in the array is a structure containing a key-value pair. Windows Server Supported keys for Windows Server managed node patches include the following:
    ///
    /// * PATCH_SET Sample values: OS | APPLICATION
    ///
    /// * PRODUCT Sample values: WindowsServer2012 | Office 2010 | MicrosoftDefenderAntivirus
    ///
    /// * PRODUCT_FAMILY Sample values: Windows | Office
    ///
    /// * MSRC_SEVERITY Sample values: ServicePacks | Important | Moderate
    ///
    /// * CLASSIFICATION Sample values: ServicePacks | SecurityUpdates | DefinitionUpdates
    ///
    /// * PATCH_ID Sample values: KB123456 | KB4516046
    ///
    ///
    /// Linux When specifying filters for Linux patches, you must specify a key-pair for PRODUCT. For example, using the Command Line Interface (CLI), the following command fails: aws ssm describe-available-patches --filters Key=CVE_ID,Values=CVE-2018-3615 However, the following command succeeds: aws ssm describe-available-patches --filters Key=PRODUCT,Values=AmazonLinux2018.03 Key=CVE_ID,Values=CVE-2018-3615 Supported keys for Linux managed node patches include the following:
    ///
    /// * PRODUCT Sample values: AmazonLinux2018.03 | AmazonLinux2.0
    ///
    /// * NAME Sample values: kernel-headers | samba-python | php
    ///
    /// * SEVERITY Sample values: Critical | Important | Medium | Low
    ///
    /// * EPOCH Sample values: 0 | 1
    ///
    /// * VERSION Sample values: 78.6.1 | 4.10.16
    ///
    /// * RELEASE Sample values: 9.56.amzn1 | 1.amzn2
    ///
    /// * ARCH Sample values: i686 | x86_64
    ///
    /// * REPOSITORY Sample values: Core | Updates
    ///
    /// * ADVISORY_ID Sample values: ALAS-2018-1058 | ALAS2-2021-1594
    ///
    /// * CVE_ID Sample values: CVE-2018-3615 | CVE-2020-1472
    ///
    /// * BUGZILLA_ID Sample values: 1463241
    public var filters: [SsmClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAvailablePatchesInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.PatchOrchestratorFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeAvailablePatchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAvailablePatchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAvailablePatchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAvailablePatchesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAvailablePatchesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAvailablePatchesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), patches: \(Swift.String(describing: patches)))"}
}

extension DescribeAvailablePatchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAvailablePatchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.patches = output.patches
        } else {
            self.nextToken = nil
            self.patches = nil
        }
    }
}

public struct DescribeAvailablePatchesOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// An array of patches. Each entry in the array is a patch structure.
    public var patches: [SsmClientTypes.Patch]?

    public init (
        nextToken: Swift.String? = nil,
        patches: [SsmClientTypes.Patch]? = nil
    )
    {
        self.nextToken = nextToken
        self.patches = patches
    }
}

struct DescribeAvailablePatchesOutputResponseBody: Swift.Equatable {
    public let patches: [SsmClientTypes.Patch]?
    public let nextToken: Swift.String?
}

extension DescribeAvailablePatchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case patches = "Patches"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchesContainer = try containerValues.decodeIfPresent([SsmClientTypes.Patch?].self, forKey: .patches)
        var patchesDecoded0:[SsmClientTypes.Patch]? = nil
        if let patchesContainer = patchesContainer {
            patchesDecoded0 = [SsmClientTypes.Patch]()
            for structure0 in patchesContainer {
                if let structure0 = structure0 {
                    patchesDecoded0?.append(structure0)
                }
            }
        }
        patches = patchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeDocumentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDocumentOutputError>
}

extension DescribeDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDocumentInput(documentVersion: \(Swift.String(describing: documentVersion)), name: \(Swift.String(describing: name)), versionName: \(Swift.String(describing: versionName)))"}
}

extension DescribeDocumentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

public struct DescribeDocumentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDocumentOutputError>
}

public struct DescribeDocumentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDocumentOutputError>
}

public struct DescribeDocumentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDocumentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeDocumentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDocumentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDocumentOutputError>
}

public struct DescribeDocumentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDocumentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeDocumentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDocumentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDocumentOutputError>
}

public struct DescribeDocumentInput: Swift.Equatable {
    /// The document version for which you want information. Can be a specific version or the default version.
    public var documentVersion: Swift.String?
    /// The name of the SSM document.
    /// This member is required.
    public var name: Swift.String?
    /// An optional field specifying the version of the artifact associated with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init (
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.name = name
        self.versionName = versionName
    }
}

struct DescribeDocumentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let documentVersion: Swift.String?
    public let versionName: Swift.String?
}

extension DescribeDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
    }
}

extension DescribeDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDocumentOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDocumentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDocumentOutputResponse(document: \(Swift.String(describing: document)))"}
}

extension DescribeDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.document = output.document
        } else {
            self.document = nil
        }
    }
}

public struct DescribeDocumentOutputResponse: Swift.Equatable {
    /// Information about the SSM document.
    public var document: SsmClientTypes.DocumentDescription?

    public init (
        document: SsmClientTypes.DocumentDescription? = nil
    )
    {
        self.document = document
    }
}

struct DescribeDocumentOutputResponseBody: Swift.Equatable {
    public let document: SsmClientTypes.DocumentDescription?
}

extension DescribeDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentDescription.self, forKey: .document)
        document = documentDecoded
    }
}

public struct DescribeDocumentPermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDocumentPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDocumentPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDocumentPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDocumentPermissionOutputError>
}

extension DescribeDocumentPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDocumentPermissionInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), permissionType: \(Swift.String(describing: permissionType)))"}
}

extension DescribeDocumentPermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case permissionType = "PermissionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
    }
}

public struct DescribeDocumentPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDocumentPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDocumentPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDocumentPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDocumentPermissionOutputError>
}

public struct DescribeDocumentPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDocumentPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDocumentPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDocumentPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDocumentPermissionOutputError>
}

public struct DescribeDocumentPermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDocumentPermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeDocumentPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDocumentPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDocumentPermissionOutputError>
}

public struct DescribeDocumentPermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDocumentPermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeDocumentPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDocumentPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDocumentPermissionOutputError>
}

public struct DescribeDocumentPermissionInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The name of the document for which you are the owner.
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The permission type for the document. The permission type can be Share.
    /// This member is required.
    public var permissionType: SsmClientTypes.DocumentPermissionType?

    public init (
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        permissionType: SsmClientTypes.DocumentPermissionType? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.permissionType = permissionType
    }
}

struct DescribeDocumentPermissionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let permissionType: SsmClientTypes.DocumentPermissionType?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeDocumentPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case permissionType = "PermissionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentPermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDocumentPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDocumentPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPermissionType" : self = .invalidPermissionType(try InvalidPermissionType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDocumentPermissionOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case invalidNextToken(InvalidNextToken)
    case invalidPermissionType(InvalidPermissionType)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDocumentPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDocumentPermissionOutputResponse(accountIds: \(Swift.String(describing: accountIds)), accountSharingInfoList: \(Swift.String(describing: accountSharingInfoList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeDocumentPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDocumentPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.accountSharingInfoList = output.accountSharingInfoList
            self.nextToken = output.nextToken
        } else {
            self.accountIds = nil
            self.accountSharingInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDocumentPermissionOutputResponse: Swift.Equatable {
    /// The account IDs that have permission to use this document. The ID can be either an Amazon Web Services account or All.
    public var accountIds: [Swift.String]?
    /// A list of Amazon Web Services accounts where the current document is shared and the version shared with each account.
    public var accountSharingInfoList: [SsmClientTypes.AccountSharingInfo]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        accountSharingInfoList: [SsmClientTypes.AccountSharingInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.accountSharingInfoList = accountSharingInfoList
        self.nextToken = nextToken
    }
}

struct DescribeDocumentPermissionOutputResponseBody: Swift.Equatable {
    public let accountIds: [Swift.String]?
    public let accountSharingInfoList: [SsmClientTypes.AccountSharingInfo]?
    public let nextToken: Swift.String?
}

extension DescribeDocumentPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case accountSharingInfoList = "AccountSharingInfoList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let accountSharingInfoListContainer = try containerValues.decodeIfPresent([SsmClientTypes.AccountSharingInfo?].self, forKey: .accountSharingInfoList)
        var accountSharingInfoListDecoded0:[SsmClientTypes.AccountSharingInfo]? = nil
        if let accountSharingInfoListContainer = accountSharingInfoListContainer {
            accountSharingInfoListDecoded0 = [SsmClientTypes.AccountSharingInfo]()
            for structure0 in accountSharingInfoListContainer {
                if let structure0 = structure0 {
                    accountSharingInfoListDecoded0?.append(structure0)
                }
            }
        }
        accountSharingInfoList = accountSharingInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEffectiveInstanceAssociationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEffectiveInstanceAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEffectiveInstanceAssociationsOutputError>
}

extension DescribeEffectiveInstanceAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEffectiveInstanceAssociationsInput(instanceId: \(Swift.String(describing: instanceId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeEffectiveInstanceAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeEffectiveInstanceAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEffectiveInstanceAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEffectiveInstanceAssociationsOutputError>
}

public struct DescribeEffectiveInstanceAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEffectiveInstanceAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEffectiveInstanceAssociationsOutputError>
}

public struct DescribeEffectiveInstanceAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEffectiveInstanceAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeEffectiveInstanceAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEffectiveInstanceAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEffectiveInstanceAssociationsOutputError>
}

public struct DescribeEffectiveInstanceAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEffectiveInstanceAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeEffectiveInstanceAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEffectiveInstanceAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEffectiveInstanceAssociationsOutputError>
}

public struct DescribeEffectiveInstanceAssociationsInput: Swift.Equatable {
    /// The managed node ID for which you want to view all associations.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEffectiveInstanceAssociationsInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeEffectiveInstanceAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEffectiveInstanceAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEffectiveInstanceAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEffectiveInstanceAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEffectiveInstanceAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEffectiveInstanceAssociationsOutputResponse(associations: \(Swift.String(describing: associations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeEffectiveInstanceAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEffectiveInstanceAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associations = output.associations
            self.nextToken = output.nextToken
        } else {
            self.associations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEffectiveInstanceAssociationsOutputResponse: Swift.Equatable {
    /// The associations for the requested managed node.
    public var associations: [SsmClientTypes.InstanceAssociation]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        associations: [SsmClientTypes.InstanceAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

struct DescribeEffectiveInstanceAssociationsOutputResponseBody: Swift.Equatable {
    public let associations: [SsmClientTypes.InstanceAssociation]?
    public let nextToken: Swift.String?
}

extension DescribeEffectiveInstanceAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstanceAssociation?].self, forKey: .associations)
        var associationsDecoded0:[SsmClientTypes.InstanceAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [SsmClientTypes.InstanceAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEffectivePatchesForPatchBaselineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEffectivePatchesForPatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEffectivePatchesForPatchBaselineOutputError>
}

extension DescribeEffectivePatchesForPatchBaselineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEffectivePatchesForPatchBaselineInput(baselineId: \(Swift.String(describing: baselineId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeEffectivePatchesForPatchBaselineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeEffectivePatchesForPatchBaselineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEffectivePatchesForPatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEffectivePatchesForPatchBaselineOutputError>
}

public struct DescribeEffectivePatchesForPatchBaselineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEffectivePatchesForPatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEffectivePatchesForPatchBaselineOutputError>
}

public struct DescribeEffectivePatchesForPatchBaselineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEffectivePatchesForPatchBaselineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeEffectivePatchesForPatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEffectivePatchesForPatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEffectivePatchesForPatchBaselineOutputError>
}

public struct DescribeEffectivePatchesForPatchBaselineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEffectivePatchesForPatchBaselineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeEffectivePatchesForPatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEffectivePatchesForPatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEffectivePatchesForPatchBaselineOutputError>
}

public struct DescribeEffectivePatchesForPatchBaselineInput: Swift.Equatable {
    /// The ID of the patch baseline to retrieve the effective patches for.
    /// This member is required.
    public var baselineId: Swift.String?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEffectivePatchesForPatchBaselineInputBody: Swift.Equatable {
    public let baselineId: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeEffectivePatchesForPatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEffectivePatchesForPatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEffectivePatchesForPatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperatingSystem" : self = .unsupportedOperatingSystem(try UnsupportedOperatingSystem(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEffectivePatchesForPatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unsupportedOperatingSystem(UnsupportedOperatingSystem)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEffectivePatchesForPatchBaselineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEffectivePatchesForPatchBaselineOutputResponse(effectivePatches: \(Swift.String(describing: effectivePatches)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeEffectivePatchesForPatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEffectivePatchesForPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.effectivePatches = output.effectivePatches
            self.nextToken = output.nextToken
        } else {
            self.effectivePatches = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEffectivePatchesForPatchBaselineOutputResponse: Swift.Equatable {
    /// An array of patches and patch status.
    public var effectivePatches: [SsmClientTypes.EffectivePatch]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        effectivePatches: [SsmClientTypes.EffectivePatch]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.effectivePatches = effectivePatches
        self.nextToken = nextToken
    }
}

struct DescribeEffectivePatchesForPatchBaselineOutputResponseBody: Swift.Equatable {
    public let effectivePatches: [SsmClientTypes.EffectivePatch]?
    public let nextToken: Swift.String?
}

extension DescribeEffectivePatchesForPatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectivePatches = "EffectivePatches"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectivePatchesContainer = try containerValues.decodeIfPresent([SsmClientTypes.EffectivePatch?].self, forKey: .effectivePatches)
        var effectivePatchesDecoded0:[SsmClientTypes.EffectivePatch]? = nil
        if let effectivePatchesContainer = effectivePatchesContainer {
            effectivePatchesDecoded0 = [SsmClientTypes.EffectivePatch]()
            for structure0 in effectivePatchesContainer {
                if let structure0 = structure0 {
                    effectivePatchesDecoded0?.append(structure0)
                }
            }
        }
        effectivePatches = effectivePatchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstanceAssociationsStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstanceAssociationsStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstanceAssociationsStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstanceAssociationsStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstanceAssociationsStatusOutputError>
}

extension DescribeInstanceAssociationsStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstanceAssociationsStatusInput(instanceId: \(Swift.String(describing: instanceId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeInstanceAssociationsStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeInstanceAssociationsStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstanceAssociationsStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstanceAssociationsStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstanceAssociationsStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstanceAssociationsStatusOutputError>
}

public struct DescribeInstanceAssociationsStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstanceAssociationsStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstanceAssociationsStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstanceAssociationsStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstanceAssociationsStatusOutputError>
}

public struct DescribeInstanceAssociationsStatusInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstanceAssociationsStatusInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeInstanceAssociationsStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstanceAssociationsStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstanceAssociationsStatusOutputError>
}

public struct DescribeInstanceAssociationsStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstanceAssociationsStatusInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeInstanceAssociationsStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstanceAssociationsStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstanceAssociationsStatusOutputError>
}

public struct DescribeInstanceAssociationsStatusInput: Swift.Equatable {
    /// The managed node IDs for which you want association status information.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstanceAssociationsStatusInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeInstanceAssociationsStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstanceAssociationsStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceAssociationsStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceAssociationsStatusOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceAssociationsStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstanceAssociationsStatusOutputResponse(instanceAssociationStatusInfos: \(Swift.String(describing: instanceAssociationStatusInfos)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeInstanceAssociationsStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstanceAssociationsStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceAssociationStatusInfos = output.instanceAssociationStatusInfos
            self.nextToken = output.nextToken
        } else {
            self.instanceAssociationStatusInfos = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstanceAssociationsStatusOutputResponse: Swift.Equatable {
    /// Status information about the association.
    public var instanceAssociationStatusInfos: [SsmClientTypes.InstanceAssociationStatusInfo]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        instanceAssociationStatusInfos: [SsmClientTypes.InstanceAssociationStatusInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceAssociationStatusInfos = instanceAssociationStatusInfos
        self.nextToken = nextToken
    }
}

struct DescribeInstanceAssociationsStatusOutputResponseBody: Swift.Equatable {
    public let instanceAssociationStatusInfos: [SsmClientTypes.InstanceAssociationStatusInfo]?
    public let nextToken: Swift.String?
}

extension DescribeInstanceAssociationsStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAssociationStatusInfos = "InstanceAssociationStatusInfos"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceAssociationStatusInfosContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstanceAssociationStatusInfo?].self, forKey: .instanceAssociationStatusInfos)
        var instanceAssociationStatusInfosDecoded0:[SsmClientTypes.InstanceAssociationStatusInfo]? = nil
        if let instanceAssociationStatusInfosContainer = instanceAssociationStatusInfosContainer {
            instanceAssociationStatusInfosDecoded0 = [SsmClientTypes.InstanceAssociationStatusInfo]()
            for structure0 in instanceAssociationStatusInfosContainer {
                if let structure0 = structure0 {
                    instanceAssociationStatusInfosDecoded0?.append(structure0)
                }
            }
        }
        instanceAssociationStatusInfos = instanceAssociationStatusInfosDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstanceInformationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstanceInformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstanceInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstanceInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstanceInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstanceInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstanceInformationOutputError>
}

extension DescribeInstanceInformationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstanceInformationInput(filters: \(Swift.String(describing: filters)), instanceInformationFilterList: \(Swift.String(describing: instanceInformationFilterList)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeInstanceInformationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceInformationFilterList = "InstanceInformationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for instanceinformationstringfilterlist0 in filters {
                try filtersContainer.encode(instanceinformationstringfilterlist0)
            }
        }
        if let instanceInformationFilterList = instanceInformationFilterList {
            var instanceInformationFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceInformationFilterList)
            for instanceinformationfilterlist0 in instanceInformationFilterList {
                try instanceInformationFilterListContainer.encode(instanceinformationfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeInstanceInformationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstanceInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstanceInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstanceInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstanceInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstanceInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstanceInformationOutputError>
}

public struct DescribeInstanceInformationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstanceInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstanceInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstanceInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstanceInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstanceInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstanceInformationOutputError>
}

public struct DescribeInstanceInformationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstanceInformationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeInstanceInformationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstanceInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstanceInformationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstanceInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstanceInformationOutputError>
}

public struct DescribeInstanceInformationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstanceInformationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeInstanceInformationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstanceInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstanceInformationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstanceInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstanceInformationOutputError>
}

public struct DescribeInstanceInformationInput: Swift.Equatable {
    /// One or more filters. Use a filter to return a more specific list of managed nodes. You can filter based on tags applied to EC2 instances. Use this Filters data type instead of InstanceInformationFilterList, which is deprecated.
    public var filters: [SsmClientTypes.InstanceInformationStringFilter]?
    /// This is a legacy method. We recommend that you don't use this method. Instead, use the Filters data type. Filters enables you to return node information by filtering based on tags applied to managed nodes. Attempting to use InstanceInformationFilterList and Filters leads to an exception error.
    public var instanceInformationFilterList: [SsmClientTypes.InstanceInformationFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.InstanceInformationStringFilter]? = nil,
        instanceInformationFilterList: [SsmClientTypes.InstanceInformationFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceInformationFilterList = instanceInformationFilterList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstanceInformationInputBody: Swift.Equatable {
    public let instanceInformationFilterList: [SsmClientTypes.InstanceInformationFilter]?
    public let filters: [SsmClientTypes.InstanceInformationStringFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeInstanceInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceInformationFilterList = "InstanceInformationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceInformationFilterListContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstanceInformationFilter?].self, forKey: .instanceInformationFilterList)
        var instanceInformationFilterListDecoded0:[SsmClientTypes.InstanceInformationFilter]? = nil
        if let instanceInformationFilterListContainer = instanceInformationFilterListContainer {
            instanceInformationFilterListDecoded0 = [SsmClientTypes.InstanceInformationFilter]()
            for structure0 in instanceInformationFilterListContainer {
                if let structure0 = structure0 {
                    instanceInformationFilterListDecoded0?.append(structure0)
                }
            }
        }
        instanceInformationFilterList = instanceInformationFilterListDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstanceInformationStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.InstanceInformationStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.InstanceInformationStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstanceInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceInformationFilterValue" : self = .invalidInstanceInformationFilterValue(try InvalidInstanceInformationFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceInformationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidInstanceId(InvalidInstanceId)
    case invalidInstanceInformationFilterValue(InvalidInstanceInformationFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceInformationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstanceInformationOutputResponse(instanceInformationList: \(Swift.String(describing: instanceInformationList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeInstanceInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstanceInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceInformationList = output.instanceInformationList
            self.nextToken = output.nextToken
        } else {
            self.instanceInformationList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstanceInformationOutputResponse: Swift.Equatable {
    /// The managed node information list.
    public var instanceInformationList: [SsmClientTypes.InstanceInformation]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        instanceInformationList: [SsmClientTypes.InstanceInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceInformationList = instanceInformationList
        self.nextToken = nextToken
    }
}

struct DescribeInstanceInformationOutputResponseBody: Swift.Equatable {
    public let instanceInformationList: [SsmClientTypes.InstanceInformation]?
    public let nextToken: Swift.String?
}

extension DescribeInstanceInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceInformationList = "InstanceInformationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceInformationListContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstanceInformation?].self, forKey: .instanceInformationList)
        var instanceInformationListDecoded0:[SsmClientTypes.InstanceInformation]? = nil
        if let instanceInformationListContainer = instanceInformationListContainer {
            instanceInformationListDecoded0 = [SsmClientTypes.InstanceInformation]()
            for structure0 in instanceInformationListContainer {
                if let structure0 = structure0 {
                    instanceInformationListDecoded0?.append(structure0)
                }
            }
        }
        instanceInformationList = instanceInformationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstancePatchStatesForPatchGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchStatesForPatchGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchStatesForPatchGroupOutputError>
}

extension DescribeInstancePatchStatesForPatchGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstancePatchStatesForPatchGroupInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), patchGroup: \(Swift.String(describing: patchGroup)))"}
}

extension DescribeInstancePatchStatesForPatchGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for instancepatchstatefilterlist0 in filters {
                try filtersContainer.encode(instancepatchstatefilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

public struct DescribeInstancePatchStatesForPatchGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchStatesForPatchGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchStatesForPatchGroupOutputError>
}

public struct DescribeInstancePatchStatesForPatchGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchStatesForPatchGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchStatesForPatchGroupOutputError>
}

public struct DescribeInstancePatchStatesForPatchGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchStatesForPatchGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeInstancePatchStatesForPatchGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstancePatchStatesForPatchGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchStatesForPatchGroupOutputError>
}

public struct DescribeInstancePatchStatesForPatchGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchStatesForPatchGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeInstancePatchStatesForPatchGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstancePatchStatesForPatchGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchStatesForPatchGroupOutputError>
}

public struct DescribeInstancePatchStatesForPatchGroupInput: Swift.Equatable {
    /// Each entry in the array is a structure containing:
    ///
    /// * Key (string between 1 and 200 characters)
    ///
    /// * Values (array containing a single string)
    ///
    /// * Type (string "Equal", "NotEqual", "LessThan", "GreaterThan")
    public var filters: [SsmClientTypes.InstancePatchStateFilter]?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The name of the patch group for which the patch state information should be retrieved.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init (
        filters: [SsmClientTypes.InstancePatchStateFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.patchGroup = patchGroup
    }
}

struct DescribeInstancePatchStatesForPatchGroupInputBody: Swift.Equatable {
    public let patchGroup: Swift.String?
    public let filters: [SsmClientTypes.InstancePatchStateFilter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension DescribeInstancePatchStatesForPatchGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstancePatchStateFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.InstancePatchStateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.InstancePatchStateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInstancePatchStatesForPatchGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancePatchStatesForPatchGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancePatchStatesForPatchGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancePatchStatesForPatchGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstancePatchStatesForPatchGroupOutputResponse(instancePatchStates: \(Swift.String(describing: instancePatchStates)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeInstancePatchStatesForPatchGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstancePatchStatesForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instancePatchStates = output.instancePatchStates
            self.nextToken = output.nextToken
        } else {
            self.instancePatchStates = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstancePatchStatesForPatchGroupOutputResponse: Swift.Equatable {
    /// The high-level patch state for the requested managed nodes.
    public var instancePatchStates: [SsmClientTypes.InstancePatchState]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        instancePatchStates: [SsmClientTypes.InstancePatchState]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instancePatchStates = instancePatchStates
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchStatesForPatchGroupOutputResponseBody: Swift.Equatable {
    public let instancePatchStates: [SsmClientTypes.InstancePatchState]?
    public let nextToken: Swift.String?
}

extension DescribeInstancePatchStatesForPatchGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePatchStates = "InstancePatchStates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePatchStatesContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstancePatchState?].self, forKey: .instancePatchStates)
        var instancePatchStatesDecoded0:[SsmClientTypes.InstancePatchState]? = nil
        if let instancePatchStatesContainer = instancePatchStatesContainer {
            instancePatchStatesDecoded0 = [SsmClientTypes.InstancePatchState]()
            for structure0 in instancePatchStatesContainer {
                if let structure0 = structure0 {
                    instancePatchStatesDecoded0?.append(structure0)
                }
            }
        }
        instancePatchStates = instancePatchStatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstancePatchStatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchStatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchStatesOutputError>
}

extension DescribeInstancePatchStatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstancePatchStatesInput(instanceIds: \(Swift.String(describing: instanceIds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeInstancePatchStatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeInstancePatchStatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchStatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchStatesOutputError>
}

public struct DescribeInstancePatchStatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchStatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancePatchStatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchStatesOutputError>
}

public struct DescribeInstancePatchStatesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchStatesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeInstancePatchStatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstancePatchStatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchStatesOutputError>
}

public struct DescribeInstancePatchStatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchStatesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeInstancePatchStatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstancePatchStatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchStatesOutputError>
}

public struct DescribeInstancePatchStatesInput: Swift.Equatable {
    /// The ID of the managed node for which patch state information should be retrieved.
    /// This member is required.
    public var instanceIds: [Swift.String]?
    /// The maximum number of managed nodes to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        instanceIds: [Swift.String]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchStatesInputBody: Swift.Equatable {
    public let instanceIds: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension DescribeInstancePatchStatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInstancePatchStatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancePatchStatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancePatchStatesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancePatchStatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstancePatchStatesOutputResponse(instancePatchStates: \(Swift.String(describing: instancePatchStates)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeInstancePatchStatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstancePatchStatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instancePatchStates = output.instancePatchStates
            self.nextToken = output.nextToken
        } else {
            self.instancePatchStates = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstancePatchStatesOutputResponse: Swift.Equatable {
    /// The high-level patch state for the requested managed nodes.
    public var instancePatchStates: [SsmClientTypes.InstancePatchState]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        instancePatchStates: [SsmClientTypes.InstancePatchState]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instancePatchStates = instancePatchStates
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchStatesOutputResponseBody: Swift.Equatable {
    public let instancePatchStates: [SsmClientTypes.InstancePatchState]?
    public let nextToken: Swift.String?
}

extension DescribeInstancePatchStatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePatchStates = "InstancePatchStates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePatchStatesContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstancePatchState?].self, forKey: .instancePatchStates)
        var instancePatchStatesDecoded0:[SsmClientTypes.InstancePatchState]? = nil
        if let instancePatchStatesContainer = instancePatchStatesContainer {
            instancePatchStatesDecoded0 = [SsmClientTypes.InstancePatchState]()
            for structure0 in instancePatchStatesContainer {
                if let structure0 = structure0 {
                    instancePatchStatesDecoded0?.append(structure0)
                }
            }
        }
        instancePatchStates = instancePatchStatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstancePatchesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancePatchesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancePatchesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchesOutputError>
}

extension DescribeInstancePatchesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstancePatchesInput(filters: \(Swift.String(describing: filters)), instanceId: \(Swift.String(describing: instanceId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeInstancePatchesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeInstancePatchesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancePatchesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancePatchesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchesOutputError>
}

public struct DescribeInstancePatchesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancePatchesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancePatchesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchesOutputError>
}

public struct DescribeInstancePatchesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeInstancePatchesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstancePatchesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchesOutputError>
}

public struct DescribeInstancePatchesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancePatchesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeInstancePatchesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstancePatchesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancePatchesOutputError>
}

public struct DescribeInstancePatchesInput: Swift.Equatable {
    /// Each element in the array is a structure containing a key-value pair. Supported keys for DescribeInstancePatchesinclude the following:
    ///
    /// * Classification Sample values: Security | SecurityUpdates
    ///
    /// * KBId Sample values: KB4480056 | java-1.7.0-openjdk.x86_64
    ///
    /// * Severity Sample values: Important | Medium | Low
    ///
    /// * State Sample values: Installed | InstalledOther | InstalledPendingReboot
    public var filters: [SsmClientTypes.PatchOrchestratorFilter]?
    /// The ID of the managed node whose patch state information should be retrieved.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.PatchOrchestratorFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchesInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let filters: [SsmClientTypes.PatchOrchestratorFilter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension DescribeInstancePatchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInstancePatchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancePatchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancePatchesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancePatchesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstancePatchesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), patches: \(Swift.String(describing: patches)))"}
}

extension DescribeInstancePatchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstancePatchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.patches = output.patches
        } else {
            self.nextToken = nil
            self.patches = nil
        }
    }
}

public struct DescribeInstancePatchesOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Each entry in the array is a structure containing:
    ///
    /// * Title (string)
    ///
    /// * KBId (string)
    ///
    /// * Classification (string)
    ///
    /// * Severity (string)
    ///
    /// * State (string, such as "INSTALLED" or "FAILED")
    ///
    /// * InstalledTime (DateTime)
    ///
    /// * InstalledBy (string)
    public var patches: [SsmClientTypes.PatchComplianceData]?

    public init (
        nextToken: Swift.String? = nil,
        patches: [SsmClientTypes.PatchComplianceData]? = nil
    )
    {
        self.nextToken = nextToken
        self.patches = patches
    }
}

struct DescribeInstancePatchesOutputResponseBody: Swift.Equatable {
    public let patches: [SsmClientTypes.PatchComplianceData]?
    public let nextToken: Swift.String?
}

extension DescribeInstancePatchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case patches = "Patches"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchComplianceData?].self, forKey: .patches)
        var patchesDecoded0:[SsmClientTypes.PatchComplianceData]? = nil
        if let patchesContainer = patchesContainer {
            patchesDecoded0 = [SsmClientTypes.PatchComplianceData]()
            for structure0 in patchesContainer {
                if let structure0 = structure0 {
                    patchesDecoded0?.append(structure0)
                }
            }
        }
        patches = patchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInventoryDeletionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInventoryDeletionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInventoryDeletionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInventoryDeletionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInventoryDeletionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInventoryDeletionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInventoryDeletionsOutputError>
}

extension DescribeInventoryDeletionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInventoryDeletionsInput(deletionId: \(Swift.String(describing: deletionId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeInventoryDeletionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionId = "DeletionId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionId = deletionId {
            try encodeContainer.encode(deletionId, forKey: .deletionId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeInventoryDeletionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInventoryDeletionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInventoryDeletionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInventoryDeletionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInventoryDeletionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInventoryDeletionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInventoryDeletionsOutputError>
}

public struct DescribeInventoryDeletionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInventoryDeletionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInventoryDeletionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInventoryDeletionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInventoryDeletionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInventoryDeletionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInventoryDeletionsOutputError>
}

public struct DescribeInventoryDeletionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInventoryDeletionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeInventoryDeletionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInventoryDeletionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInventoryDeletionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInventoryDeletionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInventoryDeletionsOutputError>
}

public struct DescribeInventoryDeletionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInventoryDeletionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeInventoryDeletionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInventoryDeletionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInventoryDeletionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInventoryDeletionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInventoryDeletionsOutputError>
}

public struct DescribeInventoryDeletionsInput: Swift.Equatable {
    /// Specify the delete inventory ID for which you want information. This ID was returned by the DeleteInventory operation.
    public var deletionId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        deletionId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.deletionId = deletionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInventoryDeletionsInputBody: Swift.Equatable {
    public let deletionId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension DescribeInventoryDeletionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionId = "DeletionId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionId)
        deletionId = deletionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInventoryDeletionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInventoryDeletionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeletionId" : self = .invalidDeletionIdException(try InvalidDeletionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInventoryDeletionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDeletionIdException(InvalidDeletionIdException)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInventoryDeletionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInventoryDeletionsOutputResponse(inventoryDeletions: \(Swift.String(describing: inventoryDeletions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeInventoryDeletionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInventoryDeletionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inventoryDeletions = output.inventoryDeletions
            self.nextToken = output.nextToken
        } else {
            self.inventoryDeletions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInventoryDeletionsOutputResponse: Swift.Equatable {
    /// A list of status items for deleted inventory.
    public var inventoryDeletions: [SsmClientTypes.InventoryDeletionStatusItem]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        inventoryDeletions: [SsmClientTypes.InventoryDeletionStatusItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inventoryDeletions = inventoryDeletions
        self.nextToken = nextToken
    }
}

struct DescribeInventoryDeletionsOutputResponseBody: Swift.Equatable {
    public let inventoryDeletions: [SsmClientTypes.InventoryDeletionStatusItem]?
    public let nextToken: Swift.String?
}

extension DescribeInventoryDeletionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inventoryDeletions = "InventoryDeletions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inventoryDeletionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryDeletionStatusItem?].self, forKey: .inventoryDeletions)
        var inventoryDeletionsDecoded0:[SsmClientTypes.InventoryDeletionStatusItem]? = nil
        if let inventoryDeletionsContainer = inventoryDeletionsContainer {
            inventoryDeletionsDecoded0 = [SsmClientTypes.InventoryDeletionStatusItem]()
            for structure0 in inventoryDeletionsContainer {
                if let structure0 = structure0 {
                    inventoryDeletionsDecoded0?.append(structure0)
                }
            }
        }
        inventoryDeletions = inventoryDeletionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionTaskInvocationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionTaskInvocationsOutputError>
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowExecutionTaskInvocationsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), taskId: \(Swift.String(describing: taskId)), windowExecutionId: \(Swift.String(describing: windowExecutionId)))"}
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionTaskInvocationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionTaskInvocationsOutputError>
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionTaskInvocationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionTaskInvocationsOutputError>
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionTaskInvocationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowExecutionTaskInvocationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowExecutionTaskInvocationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionTaskInvocationsOutputError>
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionTaskInvocationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowExecutionTaskInvocationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowExecutionTaskInvocationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionTaskInvocationsOutputError>
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInput: Swift.Equatable {
    /// Optional filters used to scope down the returned task invocations. The supported filter key is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and CANCELLED.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the specific task in the maintenance window task that should be retrieved.
    /// This member is required.
    public var taskId: Swift.String?
    /// The ID of the maintenance window execution the task is part of.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        taskId: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

struct DescribeMaintenanceWindowExecutionTaskInvocationsInputBody: Swift.Equatable {
    public let windowExecutionId: Swift.String?
    public let taskId: Swift.String?
    public let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowExecutionTaskInvocationsOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), windowExecutionTaskInvocationIdentities: \(Swift.String(describing: windowExecutionTaskInvocationIdentities)))"}
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.windowExecutionTaskInvocationIdentities = output.windowExecutionTaskInvocationIdentities
        } else {
            self.nextToken = nil
            self.windowExecutionTaskInvocationIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the task invocation results per invocation.
    public var windowExecutionTaskInvocationIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]?

    public init (
        nextToken: Swift.String? = nil,
        windowExecutionTaskInvocationIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutionTaskInvocationIdentities = windowExecutionTaskInvocationIdentities
    }
}

struct DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponseBody: Swift.Equatable {
    public let windowExecutionTaskInvocationIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]?
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case windowExecutionTaskInvocationIdentities = "WindowExecutionTaskInvocationIdentities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionTaskInvocationIdentitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity?].self, forKey: .windowExecutionTaskInvocationIdentities)
        var windowExecutionTaskInvocationIdentitiesDecoded0:[SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]? = nil
        if let windowExecutionTaskInvocationIdentitiesContainer = windowExecutionTaskInvocationIdentitiesContainer {
            windowExecutionTaskInvocationIdentitiesDecoded0 = [SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]()
            for structure0 in windowExecutionTaskInvocationIdentitiesContainer {
                if let structure0 = structure0 {
                    windowExecutionTaskInvocationIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowExecutionTaskInvocationIdentities = windowExecutionTaskInvocationIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowExecutionTasksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionTasksOutputError>
}

extension DescribeMaintenanceWindowExecutionTasksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowExecutionTasksInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), windowExecutionId: \(Swift.String(describing: windowExecutionId)))"}
}

extension DescribeMaintenanceWindowExecutionTasksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTasksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionTasksOutputError>
}

public struct DescribeMaintenanceWindowExecutionTasksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionTasksOutputError>
}

public struct DescribeMaintenanceWindowExecutionTasksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionTasksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowExecutionTasksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowExecutionTasksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionTasksOutputError>
}

public struct DescribeMaintenanceWindowExecutionTasksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionTasksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowExecutionTasksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowExecutionTasksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionTasksOutputError>
}

public struct DescribeMaintenanceWindowExecutionTasksInput: Swift.Equatable {
    /// Optional filters used to scope down the returned tasks. The supported filter key is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and CANCELLED.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window execution whose task executions should be retrieved.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowExecutionId = windowExecutionId
    }
}

struct DescribeMaintenanceWindowExecutionTasksInputBody: Swift.Equatable {
    public let windowExecutionId: Swift.String?
    public let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowExecutionTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowExecutionTasksOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowExecutionTasksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowExecutionTasksOutputResponse(nextToken: \(Swift.String(describing: nextToken)), windowExecutionTaskIdentities: \(Swift.String(describing: windowExecutionTaskIdentities)))"}
}

extension DescribeMaintenanceWindowExecutionTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowExecutionTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.windowExecutionTaskIdentities = output.windowExecutionTaskIdentities
        } else {
            self.nextToken = nil
            self.windowExecutionTaskIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTasksOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the task executions.
    public var windowExecutionTaskIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]?

    public init (
        nextToken: Swift.String? = nil,
        windowExecutionTaskIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutionTaskIdentities = windowExecutionTaskIdentities
    }
}

struct DescribeMaintenanceWindowExecutionTasksOutputResponseBody: Swift.Equatable {
    public let windowExecutionTaskIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]?
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case windowExecutionTaskIdentities = "WindowExecutionTaskIdentities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionTaskIdentitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowExecutionTaskIdentity?].self, forKey: .windowExecutionTaskIdentities)
        var windowExecutionTaskIdentitiesDecoded0:[SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]? = nil
        if let windowExecutionTaskIdentitiesContainer = windowExecutionTaskIdentitiesContainer {
            windowExecutionTaskIdentitiesDecoded0 = [SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]()
            for structure0 in windowExecutionTaskIdentitiesContainer {
                if let structure0 = structure0 {
                    windowExecutionTaskIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowExecutionTaskIdentities = windowExecutionTaskIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowExecutionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionsOutputError>
}

extension DescribeMaintenanceWindowExecutionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowExecutionsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), windowId: \(Swift.String(describing: windowId)))"}
}

extension DescribeMaintenanceWindowExecutionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct DescribeMaintenanceWindowExecutionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionsOutputError>
}

public struct DescribeMaintenanceWindowExecutionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionsOutputError>
}

public struct DescribeMaintenanceWindowExecutionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowExecutionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowExecutionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionsOutputError>
}

public struct DescribeMaintenanceWindowExecutionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowExecutionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowExecutionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowExecutionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowExecutionsOutputError>
}

public struct DescribeMaintenanceWindowExecutionsInput: Swift.Equatable {
    /// Each entry in the array is a structure containing:
    ///
    /// * Key. A string between 1 and 128 characters. Supported keys include ExecutedBefore and ExecutedAfter.
    ///
    /// * Values. An array of strings, each between 1 and 256 characters. Supported values are date/time strings in a valid ISO 8601 date/time format, such as 2021-11-04T05:00:00Z.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window whose executions should be retrieved.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowExecutionsInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowExecutionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowExecutionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowExecutionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), windowExecutions: \(Swift.String(describing: windowExecutions)))"}
}

extension DescribeMaintenanceWindowExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.windowExecutions = output.windowExecutions
        } else {
            self.nextToken = nil
            self.windowExecutions = nil
        }
    }
}

public struct DescribeMaintenanceWindowExecutionsOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the maintenance window executions.
    public var windowExecutions: [SsmClientTypes.MaintenanceWindowExecution]?

    public init (
        nextToken: Swift.String? = nil,
        windowExecutions: [SsmClientTypes.MaintenanceWindowExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutions = windowExecutions
    }
}

struct DescribeMaintenanceWindowExecutionsOutputResponseBody: Swift.Equatable {
    public let windowExecutions: [SsmClientTypes.MaintenanceWindowExecution]?
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case windowExecutions = "WindowExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowExecution?].self, forKey: .windowExecutions)
        var windowExecutionsDecoded0:[SsmClientTypes.MaintenanceWindowExecution]? = nil
        if let windowExecutionsContainer = windowExecutionsContainer {
            windowExecutionsDecoded0 = [SsmClientTypes.MaintenanceWindowExecution]()
            for structure0 in windowExecutionsContainer {
                if let structure0 = structure0 {
                    windowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        windowExecutions = windowExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowScheduleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowScheduleOutputError>
}

extension DescribeMaintenanceWindowScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowScheduleInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceType: \(Swift.String(describing: resourceType)), targets: \(Swift.String(describing: targets)), windowId: \(Swift.String(describing: windowId)))"}
}

extension DescribeMaintenanceWindowScheduleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct DescribeMaintenanceWindowScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowScheduleOutputError>
}

public struct DescribeMaintenanceWindowScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowScheduleOutputError>
}

public struct DescribeMaintenanceWindowScheduleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowScheduleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowScheduleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowScheduleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowScheduleOutputError>
}

public struct DescribeMaintenanceWindowScheduleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowScheduleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowScheduleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowScheduleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowScheduleOutputError>
}

public struct DescribeMaintenanceWindowScheduleInput: Swift.Equatable {
    /// Filters used to limit the range of results. For example, you can limit maintenance window executions to only those scheduled before or after a certain date and time.
    public var filters: [SsmClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The type of resource you want to retrieve information about. For example, INSTANCE.
    public var resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    /// The managed node ID or key-value pair to retrieve information about.
    public var targets: [SsmClientTypes.Target]?
    /// The ID of the maintenance window to retrieve information about.
    public var windowId: Swift.String?

    public init (
        filters: [SsmClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceType: SsmClientTypes.MaintenanceWindowResourceType? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.targets = targets
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowScheduleInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let targets: [SsmClientTypes.Target]?
    public let resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    public let filters: [SsmClientTypes.PatchOrchestratorFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowScheduleOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowScheduleOutputResponse(nextToken: \(Swift.String(describing: nextToken)), scheduledWindowExecutions: \(Swift.String(describing: scheduledWindowExecutions)))"}
}

extension DescribeMaintenanceWindowScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scheduledWindowExecutions = output.scheduledWindowExecutions
        } else {
            self.nextToken = nil
            self.scheduledWindowExecutions = nil
        }
    }
}

public struct DescribeMaintenanceWindowScheduleOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. (You use this token in the next call.)
    public var nextToken: Swift.String?
    /// Information about maintenance window executions scheduled for the specified time range.
    public var scheduledWindowExecutions: [SsmClientTypes.ScheduledWindowExecution]?

    public init (
        nextToken: Swift.String? = nil,
        scheduledWindowExecutions: [SsmClientTypes.ScheduledWindowExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledWindowExecutions = scheduledWindowExecutions
    }
}

struct DescribeMaintenanceWindowScheduleOutputResponseBody: Swift.Equatable {
    public let scheduledWindowExecutions: [SsmClientTypes.ScheduledWindowExecution]?
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case scheduledWindowExecutions = "ScheduledWindowExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledWindowExecutionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ScheduledWindowExecution?].self, forKey: .scheduledWindowExecutions)
        var scheduledWindowExecutionsDecoded0:[SsmClientTypes.ScheduledWindowExecution]? = nil
        if let scheduledWindowExecutionsContainer = scheduledWindowExecutionsContainer {
            scheduledWindowExecutionsDecoded0 = [SsmClientTypes.ScheduledWindowExecution]()
            for structure0 in scheduledWindowExecutionsContainer {
                if let structure0 = structure0 {
                    scheduledWindowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        scheduledWindowExecutions = scheduledWindowExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowTargetsOutputError>
}

extension DescribeMaintenanceWindowTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowTargetsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), windowId: \(Swift.String(describing: windowId)))"}
}

extension DescribeMaintenanceWindowTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct DescribeMaintenanceWindowTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowTargetsOutputError>
}

public struct DescribeMaintenanceWindowTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowTargetsOutputError>
}

public struct DescribeMaintenanceWindowTargetsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowTargetsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowTargetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowTargetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowTargetsOutputError>
}

public struct DescribeMaintenanceWindowTargetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowTargetsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowTargetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowTargetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowTargetsOutputError>
}

public struct DescribeMaintenanceWindowTargetsInput: Swift.Equatable {
    /// Optional filters that can be used to narrow down the scope of the returned window targets. The supported filter keys are Type, WindowTargetId, and OwnerInformation.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window whose targets should be retrieved.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowTargetsInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowTargetsOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowTargetsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), targets: \(Swift.String(describing: targets)))"}
}

extension DescribeMaintenanceWindowTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.targets = output.targets
        } else {
            self.nextToken = nil
            self.targets = nil
        }
    }
}

public struct DescribeMaintenanceWindowTargetsOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the targets in the maintenance window.
    public var targets: [SsmClientTypes.MaintenanceWindowTarget]?

    public init (
        nextToken: Swift.String? = nil,
        targets: [SsmClientTypes.MaintenanceWindowTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.targets = targets
    }
}

struct DescribeMaintenanceWindowTargetsOutputResponseBody: Swift.Equatable {
    public let targets: [SsmClientTypes.MaintenanceWindowTarget]?
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowTarget?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.MaintenanceWindowTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.MaintenanceWindowTarget]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowTasksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowTasksOutputError>
}

extension DescribeMaintenanceWindowTasksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowTasksInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), windowId: \(Swift.String(describing: windowId)))"}
}

extension DescribeMaintenanceWindowTasksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct DescribeMaintenanceWindowTasksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowTasksOutputError>
}

public struct DescribeMaintenanceWindowTasksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowTasksOutputError>
}

public struct DescribeMaintenanceWindowTasksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowTasksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowTasksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowTasksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowTasksOutputError>
}

public struct DescribeMaintenanceWindowTasksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowTasksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowTasksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowTasksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowTasksOutputError>
}

public struct DescribeMaintenanceWindowTasksInput: Swift.Equatable {
    /// Optional filters used to narrow down the scope of the returned tasks. The supported filter keys are WindowTaskId, TaskArn, Priority, and TaskType.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window whose tasks should be retrieved.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowTasksInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowTasksOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowTasksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowTasksOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tasks: \(Swift.String(describing: tasks)))"}
}

extension DescribeMaintenanceWindowTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct DescribeMaintenanceWindowTasksOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the tasks in the maintenance window.
    public var tasks: [SsmClientTypes.MaintenanceWindowTask]?

    public init (
        nextToken: Swift.String? = nil,
        tasks: [SsmClientTypes.MaintenanceWindowTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct DescribeMaintenanceWindowTasksOutputResponseBody: Swift.Equatable {
    public let tasks: [SsmClientTypes.MaintenanceWindowTask]?
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tasks = "Tasks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowTask?].self, forKey: .tasks)
        var tasksDecoded0:[SsmClientTypes.MaintenanceWindowTask]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [SsmClientTypes.MaintenanceWindowTask]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowsForTargetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowsForTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowsForTargetOutputError>
}

extension DescribeMaintenanceWindowsForTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowsForTargetInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceType: \(Swift.String(describing: resourceType)), targets: \(Swift.String(describing: targets)))"}
}

extension DescribeMaintenanceWindowsForTargetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct DescribeMaintenanceWindowsForTargetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowsForTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowsForTargetOutputError>
}

public struct DescribeMaintenanceWindowsForTargetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowsForTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowsForTargetOutputError>
}

public struct DescribeMaintenanceWindowsForTargetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowsForTargetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowsForTargetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowsForTargetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowsForTargetOutputError>
}

public struct DescribeMaintenanceWindowsForTargetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowsForTargetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowsForTargetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowsForTargetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowsForTargetOutputError>
}

public struct DescribeMaintenanceWindowsForTargetInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The type of resource you want to retrieve information about. For example, INSTANCE.
    /// This member is required.
    public var resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    /// The managed node ID or key-value pair to retrieve information about.
    /// This member is required.
    public var targets: [SsmClientTypes.Target]?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceType: SsmClientTypes.MaintenanceWindowResourceType? = nil,
        targets: [SsmClientTypes.Target]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.targets = targets
    }
}

struct DescribeMaintenanceWindowsForTargetInputBody: Swift.Equatable {
    public let targets: [SsmClientTypes.Target]?
    public let resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowsForTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowsForTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowsForTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowsForTargetOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowsForTargetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowsForTargetOutputResponse(nextToken: \(Swift.String(describing: nextToken)), windowIdentities: \(Swift.String(describing: windowIdentities)))"}
}

extension DescribeMaintenanceWindowsForTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowsForTargetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.windowIdentities = output.windowIdentities
        } else {
            self.nextToken = nil
            self.windowIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowsForTargetOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. (You use this token in the next call.)
    public var nextToken: Swift.String?
    /// Information about the maintenance window targets and tasks a managed node is associated with.
    public var windowIdentities: [SsmClientTypes.MaintenanceWindowIdentityForTarget]?

    public init (
        nextToken: Swift.String? = nil,
        windowIdentities: [SsmClientTypes.MaintenanceWindowIdentityForTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowIdentities = windowIdentities
    }
}

struct DescribeMaintenanceWindowsForTargetOutputResponseBody: Swift.Equatable {
    public let windowIdentities: [SsmClientTypes.MaintenanceWindowIdentityForTarget]?
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowsForTargetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case windowIdentities = "WindowIdentities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdentitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowIdentityForTarget?].self, forKey: .windowIdentities)
        var windowIdentitiesDecoded0:[SsmClientTypes.MaintenanceWindowIdentityForTarget]? = nil
        if let windowIdentitiesContainer = windowIdentitiesContainer {
            windowIdentitiesDecoded0 = [SsmClientTypes.MaintenanceWindowIdentityForTarget]()
            for structure0 in windowIdentitiesContainer {
                if let structure0 = structure0 {
                    windowIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowIdentities = windowIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowsOutputError>
}

extension DescribeMaintenanceWindowsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeMaintenanceWindowsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeMaintenanceWindowsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowsOutputError>
}

public struct DescribeMaintenanceWindowsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceWindowsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowsOutputError>
}

public struct DescribeMaintenanceWindowsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowsOutputError>
}

public struct DescribeMaintenanceWindowsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceWindowsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceWindowsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceWindowsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceWindowsOutputError>
}

public struct DescribeMaintenanceWindowsInput: Swift.Equatable {
    /// Optional filters used to narrow down the scope of the returned maintenance windows. Supported filter keys are Name and Enabled. For example, Name=MyMaintenanceWindow and Enabled=True.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeMaintenanceWindowsInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceWindowsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), windowIdentities: \(Swift.String(describing: windowIdentities)))"}
}

extension DescribeMaintenanceWindowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.windowIdentities = output.windowIdentities
        } else {
            self.nextToken = nil
            self.windowIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowsOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the maintenance windows.
    public var windowIdentities: [SsmClientTypes.MaintenanceWindowIdentity]?

    public init (
        nextToken: Swift.String? = nil,
        windowIdentities: [SsmClientTypes.MaintenanceWindowIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowIdentities = windowIdentities
    }
}

struct DescribeMaintenanceWindowsOutputResponseBody: Swift.Equatable {
    public let windowIdentities: [SsmClientTypes.MaintenanceWindowIdentity]?
    public let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case windowIdentities = "WindowIdentities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdentitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowIdentity?].self, forKey: .windowIdentities)
        var windowIdentitiesDecoded0:[SsmClientTypes.MaintenanceWindowIdentity]? = nil
        if let windowIdentitiesContainer = windowIdentitiesContainer {
            windowIdentitiesDecoded0 = [SsmClientTypes.MaintenanceWindowIdentity]()
            for structure0 in windowIdentitiesContainer {
                if let structure0 = structure0 {
                    windowIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowIdentities = windowIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeOpsItemsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOpsItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOpsItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOpsItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOpsItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOpsItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOpsItemsOutputError>
}

extension DescribeOpsItemsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOpsItemsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), opsItemFilters: \(Swift.String(describing: opsItemFilters)))"}
}

extension DescribeOpsItemsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemFilters = "OpsItemFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let opsItemFilters = opsItemFilters {
            var opsItemFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .opsItemFilters)
            for opsitemfilters0 in opsItemFilters {
                try opsItemFiltersContainer.encode(opsitemfilters0)
            }
        }
    }
}

public struct DescribeOpsItemsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOpsItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOpsItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOpsItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOpsItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOpsItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOpsItemsOutputError>
}

public struct DescribeOpsItemsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOpsItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOpsItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOpsItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOpsItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOpsItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOpsItemsOutputError>
}

public struct DescribeOpsItemsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOpsItemsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeOpsItemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOpsItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeOpsItemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOpsItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOpsItemsOutputError>
}

public struct DescribeOpsItemsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOpsItemsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeOpsItemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOpsItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeOpsItemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOpsItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOpsItemsOutputError>
}

public struct DescribeOpsItemsInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// One or more filters to limit the response.
    ///
    /// * Key: CreatedTime Operations: GreaterThan, LessThan
    ///
    /// * Key: LastModifiedBy Operations: Contains, Equals
    ///
    /// * Key: LastModifiedTime Operations: GreaterThan, LessThan
    ///
    /// * Key: Priority Operations: Equals
    ///
    /// * Key: Source Operations: Contains, Equals
    ///
    /// * Key: Status Operations: Equals
    ///
    /// * Key: Title* Operations: Equals,Contains
    ///
    /// * Key: OperationalData** Operations: Equals
    ///
    /// * Key: OperationalDataKey Operations: Equals
    ///
    /// * Key: OperationalDataValue Operations: Equals, Contains
    ///
    /// * Key: OpsItemId Operations: Equals
    ///
    /// * Key: ResourceId Operations: Contains
    ///
    /// * Key: AutomationId Operations: Equals
    ///
    ///
    /// *The Equals operator for Title matches the first 100 characters. If you specify more than 100 characters, they system returns an error that the filter value exceeds the length limit. **If you filter the response by using the OperationalData operator, specify a key-value pair by using the following JSON format: {"key":"key_name","value":"a_value"}
    public var opsItemFilters: [SsmClientTypes.OpsItemFilter]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        opsItemFilters: [SsmClientTypes.OpsItemFilter]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsItemFilters = opsItemFilters
    }
}

struct DescribeOpsItemsInputBody: Swift.Equatable {
    public let opsItemFilters: [SsmClientTypes.OpsItemFilter]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeOpsItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemFilters = "OpsItemFilters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemFiltersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemFilter?].self, forKey: .opsItemFilters)
        var opsItemFiltersDecoded0:[SsmClientTypes.OpsItemFilter]? = nil
        if let opsItemFiltersContainer = opsItemFiltersContainer {
            opsItemFiltersDecoded0 = [SsmClientTypes.OpsItemFilter]()
            for structure0 in opsItemFiltersContainer {
                if let structure0 = structure0 {
                    opsItemFiltersDecoded0?.append(structure0)
                }
            }
        }
        opsItemFilters = opsItemFiltersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOpsItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOpsItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOpsItemsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOpsItemsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOpsItemsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), opsItemSummaries: \(Swift.String(describing: opsItemSummaries)))"}
}

extension DescribeOpsItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOpsItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.opsItemSummaries = output.opsItemSummaries
        } else {
            self.nextToken = nil
            self.opsItemSummaries = nil
        }
    }
}

public struct DescribeOpsItemsOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of OpsItems.
    public var opsItemSummaries: [SsmClientTypes.OpsItemSummary]?

    public init (
        nextToken: Swift.String? = nil,
        opsItemSummaries: [SsmClientTypes.OpsItemSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.opsItemSummaries = opsItemSummaries
    }
}

struct DescribeOpsItemsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let opsItemSummaries: [SsmClientTypes.OpsItemSummary]?
}

extension DescribeOpsItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case opsItemSummaries = "OpsItemSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let opsItemSummariesContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemSummary?].self, forKey: .opsItemSummaries)
        var opsItemSummariesDecoded0:[SsmClientTypes.OpsItemSummary]? = nil
        if let opsItemSummariesContainer = opsItemSummariesContainer {
            opsItemSummariesDecoded0 = [SsmClientTypes.OpsItemSummary]()
            for structure0 in opsItemSummariesContainer {
                if let structure0 = structure0 {
                    opsItemSummariesDecoded0?.append(structure0)
                }
            }
        }
        opsItemSummaries = opsItemSummariesDecoded0
    }
}

public struct DescribeParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

extension DescribeParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeParametersInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), parameterFilters: \(Swift.String(describing: parameterFilters)))"}
}

extension DescribeParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for parametersfilterlist0 in filters {
                try filtersContainer.encode(parametersfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterFilters = parameterFilters {
            var parameterFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterFilters)
            for parameterstringfilterlist0 in parameterFilters {
                try parameterFiltersContainer.encode(parameterstringfilterlist0)
            }
        }
    }
}

public struct DescribeParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInput: Swift.Equatable {
    /// This data type is deprecated. Instead, use ParameterFilters.
    public var filters: [SsmClientTypes.ParametersFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Filters to limit the request results.
    public var parameterFilters: [SsmClientTypes.ParameterStringFilter]?

    public init (
        filters: [SsmClientTypes.ParametersFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        parameterFilters: [SsmClientTypes.ParameterStringFilter]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterFilters = parameterFilters
    }
}

struct DescribeParametersInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.ParametersFilter]?
    public let parameterFilters: [SsmClientTypes.ParameterStringFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribeParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParametersFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.ParametersFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.ParametersFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let parameterFiltersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterStringFilter?].self, forKey: .parameterFilters)
        var parameterFiltersDecoded0:[SsmClientTypes.ParameterStringFilter]? = nil
        if let parameterFiltersContainer = parameterFiltersContainer {
            parameterFiltersDecoded0 = [SsmClientTypes.ParameterStringFilter]()
            for structure0 in parameterFiltersContainer {
                if let structure0 = structure0 {
                    parameterFiltersDecoded0?.append(structure0)
                }
            }
        }
        parameterFilters = parameterFiltersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterOption" : self = .invalidFilterOption(try InvalidFilterOption(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeParametersOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterOption(InvalidFilterOption)
    case invalidFilterValue(InvalidFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeParametersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeParametersOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items.
    public var nextToken: Swift.String?
    /// Parameters returned by the request.
    public var parameters: [SsmClientTypes.ParameterMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [SsmClientTypes.ParameterMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeParametersOutputResponseBody: Swift.Equatable {
    public let parameters: [SsmClientTypes.ParameterMetadata]?
    public let nextToken: Swift.String?
}

extension DescribeParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterMetadata?].self, forKey: .parameters)
        var parametersDecoded0:[SsmClientTypes.ParameterMetadata]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SsmClientTypes.ParameterMetadata]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribePatchBaselinesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchBaselinesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchBaselinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchBaselinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchBaselinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchBaselinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchBaselinesOutputError>
}

extension DescribePatchBaselinesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePatchBaselinesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribePatchBaselinesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribePatchBaselinesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchBaselinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchBaselinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchBaselinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchBaselinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchBaselinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchBaselinesOutputError>
}

public struct DescribePatchBaselinesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchBaselinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchBaselinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchBaselinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchBaselinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchBaselinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchBaselinesOutputError>
}

public struct DescribePatchBaselinesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchBaselinesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribePatchBaselinesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchBaselinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePatchBaselinesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchBaselinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchBaselinesOutputError>
}

public struct DescribePatchBaselinesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchBaselinesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribePatchBaselinesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchBaselinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePatchBaselinesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchBaselinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchBaselinesOutputError>
}

public struct DescribePatchBaselinesInput: Swift.Equatable {
    /// Each element in the array is a structure containing a key-value pair. Supported keys for DescribePatchBaselines include the following:
    ///
    /// * NAME_PREFIX Sample values: AWS- | My-
    ///
    /// * OWNER Sample values: AWS | Self
    ///
    /// * OPERATING_SYSTEM Sample values: AMAZON_LINUX | SUSE | WINDOWS
    public var filters: [SsmClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of patch baselines to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribePatchBaselinesInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.PatchOrchestratorFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribePatchBaselinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchBaselinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchBaselinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchBaselinesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchBaselinesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePatchBaselinesOutputResponse(baselineIdentities: \(Swift.String(describing: baselineIdentities)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribePatchBaselinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePatchBaselinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineIdentities = output.baselineIdentities
            self.nextToken = output.nextToken
        } else {
            self.baselineIdentities = nil
            self.nextToken = nil
        }
    }
}

public struct DescribePatchBaselinesOutputResponse: Swift.Equatable {
    /// An array of PatchBaselineIdentity elements.
    public var baselineIdentities: [SsmClientTypes.PatchBaselineIdentity]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        baselineIdentities: [SsmClientTypes.PatchBaselineIdentity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.baselineIdentities = baselineIdentities
        self.nextToken = nextToken
    }
}

struct DescribePatchBaselinesOutputResponseBody: Swift.Equatable {
    public let baselineIdentities: [SsmClientTypes.PatchBaselineIdentity]?
    public let nextToken: Swift.String?
}

extension DescribePatchBaselinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineIdentities = "BaselineIdentities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdentitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchBaselineIdentity?].self, forKey: .baselineIdentities)
        var baselineIdentitiesDecoded0:[SsmClientTypes.PatchBaselineIdentity]? = nil
        if let baselineIdentitiesContainer = baselineIdentitiesContainer {
            baselineIdentitiesDecoded0 = [SsmClientTypes.PatchBaselineIdentity]()
            for structure0 in baselineIdentitiesContainer {
                if let structure0 = structure0 {
                    baselineIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        baselineIdentities = baselineIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribePatchGroupStateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchGroupStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchGroupStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchGroupStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchGroupStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchGroupStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchGroupStateOutputError>
}

extension DescribePatchGroupStateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePatchGroupStateInput(patchGroup: \(Swift.String(describing: patchGroup)))"}
}

extension DescribePatchGroupStateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

public struct DescribePatchGroupStateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchGroupStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchGroupStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchGroupStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchGroupStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchGroupStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchGroupStateOutputError>
}

public struct DescribePatchGroupStateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchGroupStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchGroupStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchGroupStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchGroupStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchGroupStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchGroupStateOutputError>
}

public struct DescribePatchGroupStateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchGroupStateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribePatchGroupStateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchGroupStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePatchGroupStateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchGroupStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchGroupStateOutputError>
}

public struct DescribePatchGroupStateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchGroupStateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribePatchGroupStateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchGroupStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePatchGroupStateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchGroupStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchGroupStateOutputError>
}

public struct DescribePatchGroupStateInput: Swift.Equatable {
    /// The name of the patch group whose patch snapshot should be retrieved.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init (
        patchGroup: Swift.String? = nil
    )
    {
        self.patchGroup = patchGroup
    }
}

struct DescribePatchGroupStateInputBody: Swift.Equatable {
    public let patchGroup: Swift.String?
}

extension DescribePatchGroupStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension DescribePatchGroupStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchGroupStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchGroupStateOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchGroupStateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePatchGroupStateOutputResponse(instances: \(Swift.String(describing: instances)), instancesWithCriticalNonCompliantPatches: \(Swift.String(describing: instancesWithCriticalNonCompliantPatches)), instancesWithFailedPatches: \(Swift.String(describing: instancesWithFailedPatches)), instancesWithInstalledOtherPatches: \(Swift.String(describing: instancesWithInstalledOtherPatches)), instancesWithInstalledPatches: \(Swift.String(describing: instancesWithInstalledPatches)), instancesWithInstalledPendingRebootPatches: \(Swift.String(describing: instancesWithInstalledPendingRebootPatches)), instancesWithInstalledRejectedPatches: \(Swift.String(describing: instancesWithInstalledRejectedPatches)), instancesWithMissingPatches: \(Swift.String(describing: instancesWithMissingPatches)), instancesWithNotApplicablePatches: \(Swift.String(describing: instancesWithNotApplicablePatches)), instancesWithOtherNonCompliantPatches: \(Swift.String(describing: instancesWithOtherNonCompliantPatches)), instancesWithSecurityNonCompliantPatches: \(Swift.String(describing: instancesWithSecurityNonCompliantPatches)), instancesWithUnreportedNotApplicablePatches: \(Swift.String(describing: instancesWithUnreportedNotApplicablePatches)))"}
}

extension DescribePatchGroupStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePatchGroupStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.instancesWithCriticalNonCompliantPatches = output.instancesWithCriticalNonCompliantPatches
            self.instancesWithFailedPatches = output.instancesWithFailedPatches
            self.instancesWithInstalledOtherPatches = output.instancesWithInstalledOtherPatches
            self.instancesWithInstalledPatches = output.instancesWithInstalledPatches
            self.instancesWithInstalledPendingRebootPatches = output.instancesWithInstalledPendingRebootPatches
            self.instancesWithInstalledRejectedPatches = output.instancesWithInstalledRejectedPatches
            self.instancesWithMissingPatches = output.instancesWithMissingPatches
            self.instancesWithNotApplicablePatches = output.instancesWithNotApplicablePatches
            self.instancesWithOtherNonCompliantPatches = output.instancesWithOtherNonCompliantPatches
            self.instancesWithSecurityNonCompliantPatches = output.instancesWithSecurityNonCompliantPatches
            self.instancesWithUnreportedNotApplicablePatches = output.instancesWithUnreportedNotApplicablePatches
        } else {
            self.instances = 0
            self.instancesWithCriticalNonCompliantPatches = 0
            self.instancesWithFailedPatches = 0
            self.instancesWithInstalledOtherPatches = 0
            self.instancesWithInstalledPatches = 0
            self.instancesWithInstalledPendingRebootPatches = 0
            self.instancesWithInstalledRejectedPatches = 0
            self.instancesWithMissingPatches = 0
            self.instancesWithNotApplicablePatches = 0
            self.instancesWithOtherNonCompliantPatches = 0
            self.instancesWithSecurityNonCompliantPatches = 0
            self.instancesWithUnreportedNotApplicablePatches = 0
        }
    }
}

public struct DescribePatchGroupStateOutputResponse: Swift.Equatable {
    /// The number of managed nodes in the patch group.
    public var instances: Swift.Int
    /// The number of managed nodes where patches that are specified as Critical for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithCriticalNonCompliantPatches: Swift.Int
    /// The number of managed nodes with patches from the patch baseline that failed to install.
    public var instancesWithFailedPatches: Swift.Int
    /// The number of managed nodes with patches installed that aren't defined in the patch baseline.
    public var instancesWithInstalledOtherPatches: Swift.Int
    /// The number of managed nodes with installed patches.
    public var instancesWithInstalledPatches: Swift.Int
    /// The number of managed nodes with patches installed by Patch Manager that haven't been rebooted after the patch installation. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithInstalledPendingRebootPatches: Swift.Int
    /// The number of managed nodes with patches installed that are specified in a RejectedPatches list. Patches with a status of INSTALLED_REJECTED were typically installed before they were added to a RejectedPatches list. If ALLOW_AS_DEPENDENCY is the specified option for RejectedPatchesAction, the value of InstancesWithInstalledRejectedPatches will always be 0 (zero).
    public var instancesWithInstalledRejectedPatches: Swift.Int
    /// The number of managed nodes with missing patches from the patch baseline.
    public var instancesWithMissingPatches: Swift.Int
    /// The number of managed nodes with patches that aren't applicable.
    public var instancesWithNotApplicablePatches: Swift.Int
    /// The number of managed nodes with patches installed that are specified as other than Critical or Security but aren't compliant with the patch baseline. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithOtherNonCompliantPatches: Swift.Int
    /// The number of managed nodes where patches that are specified as Security in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithSecurityNonCompliantPatches: Swift.Int
    /// The number of managed nodes with NotApplicable patches beyond the supported limit, which aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.
    public var instancesWithUnreportedNotApplicablePatches: Swift.Int

    public init (
        instances: Swift.Int = 0,
        instancesWithCriticalNonCompliantPatches: Swift.Int = 0,
        instancesWithFailedPatches: Swift.Int = 0,
        instancesWithInstalledOtherPatches: Swift.Int = 0,
        instancesWithInstalledPatches: Swift.Int = 0,
        instancesWithInstalledPendingRebootPatches: Swift.Int = 0,
        instancesWithInstalledRejectedPatches: Swift.Int = 0,
        instancesWithMissingPatches: Swift.Int = 0,
        instancesWithNotApplicablePatches: Swift.Int = 0,
        instancesWithOtherNonCompliantPatches: Swift.Int = 0,
        instancesWithSecurityNonCompliantPatches: Swift.Int = 0,
        instancesWithUnreportedNotApplicablePatches: Swift.Int = 0
    )
    {
        self.instances = instances
        self.instancesWithCriticalNonCompliantPatches = instancesWithCriticalNonCompliantPatches
        self.instancesWithFailedPatches = instancesWithFailedPatches
        self.instancesWithInstalledOtherPatches = instancesWithInstalledOtherPatches
        self.instancesWithInstalledPatches = instancesWithInstalledPatches
        self.instancesWithInstalledPendingRebootPatches = instancesWithInstalledPendingRebootPatches
        self.instancesWithInstalledRejectedPatches = instancesWithInstalledRejectedPatches
        self.instancesWithMissingPatches = instancesWithMissingPatches
        self.instancesWithNotApplicablePatches = instancesWithNotApplicablePatches
        self.instancesWithOtherNonCompliantPatches = instancesWithOtherNonCompliantPatches
        self.instancesWithSecurityNonCompliantPatches = instancesWithSecurityNonCompliantPatches
        self.instancesWithUnreportedNotApplicablePatches = instancesWithUnreportedNotApplicablePatches
    }
}

struct DescribePatchGroupStateOutputResponseBody: Swift.Equatable {
    public let instances: Swift.Int
    public let instancesWithInstalledPatches: Swift.Int
    public let instancesWithInstalledOtherPatches: Swift.Int
    public let instancesWithInstalledPendingRebootPatches: Swift.Int
    public let instancesWithInstalledRejectedPatches: Swift.Int
    public let instancesWithMissingPatches: Swift.Int
    public let instancesWithFailedPatches: Swift.Int
    public let instancesWithNotApplicablePatches: Swift.Int
    public let instancesWithUnreportedNotApplicablePatches: Swift.Int
    public let instancesWithCriticalNonCompliantPatches: Swift.Int
    public let instancesWithSecurityNonCompliantPatches: Swift.Int
    public let instancesWithOtherNonCompliantPatches: Swift.Int
}

extension DescribePatchGroupStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case instancesWithCriticalNonCompliantPatches = "InstancesWithCriticalNonCompliantPatches"
        case instancesWithFailedPatches = "InstancesWithFailedPatches"
        case instancesWithInstalledOtherPatches = "InstancesWithInstalledOtherPatches"
        case instancesWithInstalledPatches = "InstancesWithInstalledPatches"
        case instancesWithInstalledPendingRebootPatches = "InstancesWithInstalledPendingRebootPatches"
        case instancesWithInstalledRejectedPatches = "InstancesWithInstalledRejectedPatches"
        case instancesWithMissingPatches = "InstancesWithMissingPatches"
        case instancesWithNotApplicablePatches = "InstancesWithNotApplicablePatches"
        case instancesWithOtherNonCompliantPatches = "InstancesWithOtherNonCompliantPatches"
        case instancesWithSecurityNonCompliantPatches = "InstancesWithSecurityNonCompliantPatches"
        case instancesWithUnreportedNotApplicablePatches = "InstancesWithUnreportedNotApplicablePatches"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instances)
        instances = instancesDecoded
        let instancesWithInstalledPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithInstalledPatches)
        instancesWithInstalledPatches = instancesWithInstalledPatchesDecoded
        let instancesWithInstalledOtherPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithInstalledOtherPatches)
        instancesWithInstalledOtherPatches = instancesWithInstalledOtherPatchesDecoded
        let instancesWithInstalledPendingRebootPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithInstalledPendingRebootPatches)
        instancesWithInstalledPendingRebootPatches = instancesWithInstalledPendingRebootPatchesDecoded
        let instancesWithInstalledRejectedPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithInstalledRejectedPatches)
        instancesWithInstalledRejectedPatches = instancesWithInstalledRejectedPatchesDecoded
        let instancesWithMissingPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithMissingPatches)
        instancesWithMissingPatches = instancesWithMissingPatchesDecoded
        let instancesWithFailedPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithFailedPatches)
        instancesWithFailedPatches = instancesWithFailedPatchesDecoded
        let instancesWithNotApplicablePatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithNotApplicablePatches)
        instancesWithNotApplicablePatches = instancesWithNotApplicablePatchesDecoded
        let instancesWithUnreportedNotApplicablePatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithUnreportedNotApplicablePatches)
        instancesWithUnreportedNotApplicablePatches = instancesWithUnreportedNotApplicablePatchesDecoded
        let instancesWithCriticalNonCompliantPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithCriticalNonCompliantPatches)
        instancesWithCriticalNonCompliantPatches = instancesWithCriticalNonCompliantPatchesDecoded
        let instancesWithSecurityNonCompliantPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithSecurityNonCompliantPatches)
        instancesWithSecurityNonCompliantPatches = instancesWithSecurityNonCompliantPatchesDecoded
        let instancesWithOtherNonCompliantPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithOtherNonCompliantPatches)
        instancesWithOtherNonCompliantPatches = instancesWithOtherNonCompliantPatchesDecoded
    }
}

public struct DescribePatchGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchGroupsOutputError>
}

extension DescribePatchGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePatchGroupsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribePatchGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribePatchGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchGroupsOutputError>
}

public struct DescribePatchGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchGroupsOutputError>
}

public struct DescribePatchGroupsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchGroupsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribePatchGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePatchGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchGroupsOutputError>
}

public struct DescribePatchGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchGroupsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribePatchGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePatchGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchGroupsOutputError>
}

public struct DescribePatchGroupsInput: Swift.Equatable {
    /// Each element in the array is a structure containing a key-value pair. Supported keys for DescribePatchGroups include the following:
    ///
    /// * NAME_PREFIX Sample values: AWS- | My-.
    ///
    /// * OPERATING_SYSTEM Sample values: AMAZON_LINUX | SUSE | WINDOWS
    public var filters: [SsmClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of patch groups to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribePatchGroupsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int
    public let filters: [SsmClientTypes.PatchOrchestratorFilter]?
    public let nextToken: Swift.String?
}

extension DescribePatchGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePatchGroupsOutputResponse(mappings: \(Swift.String(describing: mappings)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribePatchGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePatchGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mappings = output.mappings
            self.nextToken = output.nextToken
        } else {
            self.mappings = nil
            self.nextToken = nil
        }
    }
}

public struct DescribePatchGroupsOutputResponse: Swift.Equatable {
    /// Each entry in the array contains:
    ///
    /// * PatchGroup: string (between 1 and 256 characters. Regex: ^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$)
    ///
    /// * PatchBaselineIdentity: A PatchBaselineIdentity element.
    public var mappings: [SsmClientTypes.PatchGroupPatchBaselineMapping]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        mappings: [SsmClientTypes.PatchGroupPatchBaselineMapping]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mappings = mappings
        self.nextToken = nextToken
    }
}

struct DescribePatchGroupsOutputResponseBody: Swift.Equatable {
    public let mappings: [SsmClientTypes.PatchGroupPatchBaselineMapping]?
    public let nextToken: Swift.String?
}

extension DescribePatchGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mappings = "Mappings"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mappingsContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchGroupPatchBaselineMapping?].self, forKey: .mappings)
        var mappingsDecoded0:[SsmClientTypes.PatchGroupPatchBaselineMapping]? = nil
        if let mappingsContainer = mappingsContainer {
            mappingsDecoded0 = [SsmClientTypes.PatchGroupPatchBaselineMapping]()
            for structure0 in mappingsContainer {
                if let structure0 = structure0 {
                    mappingsDecoded0?.append(structure0)
                }
            }
        }
        mappings = mappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribePatchPropertiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchPropertiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchPropertiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchPropertiesOutputError>
}

extension DescribePatchPropertiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePatchPropertiesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), operatingSystem: \(Swift.String(describing: operatingSystem)), patchSet: \(Swift.String(describing: patchSet)), property: \(Swift.String(describing: property)))"}
}

extension DescribePatchPropertiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case operatingSystem = "OperatingSystem"
        case patchSet = "PatchSet"
        case property = "Property"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let patchSet = patchSet {
            try encodeContainer.encode(patchSet.rawValue, forKey: .patchSet)
        }
        if let property = property {
            try encodeContainer.encode(property.rawValue, forKey: .property)
        }
    }
}

public struct DescribePatchPropertiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchPropertiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchPropertiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchPropertiesOutputError>
}

public struct DescribePatchPropertiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePatchPropertiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePatchPropertiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchPropertiesOutputError>
}

public struct DescribePatchPropertiesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchPropertiesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribePatchPropertiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePatchPropertiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchPropertiesOutputError>
}

public struct DescribePatchPropertiesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePatchPropertiesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribePatchPropertiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePatchPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePatchPropertiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePatchPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePatchPropertiesOutputError>
}

public struct DescribePatchPropertiesInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The operating system type for which to list patches.
    /// This member is required.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// Indicates whether to list patches for the Windows operating system or for applications released by Microsoft. Not applicable for the Linux or macOS operating systems.
    public var patchSet: SsmClientTypes.PatchSet?
    /// The patch property for which you want to view patch details.
    /// This member is required.
    public var property: SsmClientTypes.PatchProperty?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        patchSet: SsmClientTypes.PatchSet? = nil,
        property: SsmClientTypes.PatchProperty? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operatingSystem = operatingSystem
        self.patchSet = patchSet
        self.property = property
    }
}

struct DescribePatchPropertiesInputBody: Swift.Equatable {
    public let operatingSystem: SsmClientTypes.OperatingSystem?
    public let property: SsmClientTypes.PatchProperty?
    public let patchSet: SsmClientTypes.PatchSet?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension DescribePatchPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case operatingSystem = "OperatingSystem"
        case patchSet = "PatchSet"
        case property = "Property"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let propertyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchProperty.self, forKey: .property)
        property = propertyDecoded
        let patchSetDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchSet.self, forKey: .patchSet)
        patchSet = patchSetDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchPropertiesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchPropertiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePatchPropertiesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), properties: \(Swift.String(describing: properties)))"}
}

extension DescribePatchPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePatchPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.properties = output.properties
        } else {
            self.nextToken = nil
            self.properties = nil
        }
    }
}

public struct DescribePatchPropertiesOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. (You use this token in the next call.)
    public var nextToken: Swift.String?
    /// A list of the properties for patches matching the filter request parameters.
    public var properties: [[Swift.String:Swift.String]]?

    public init (
        nextToken: Swift.String? = nil,
        properties: [[Swift.String:Swift.String]]? = nil
    )
    {
        self.nextToken = nextToken
        self.properties = properties
    }
}

struct DescribePatchPropertiesOutputResponseBody: Swift.Equatable {
    public let properties: [[Swift.String:Swift.String]]?
    public let nextToken: Swift.String?
}

extension DescribePatchPropertiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case properties = "Properties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertiesContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .properties)
        var propertiesDecoded0:[[Swift.String:Swift.String]]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in propertiesContainer {
                var propertiesContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    propertiesContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            propertiesContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let propertiesContainerDecoded0 = propertiesContainerDecoded0 {
                    propertiesDecoded0?.append(propertiesContainerDecoded0)
                }
            }
        }
        properties = propertiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSessionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSessionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSessionsOutputError>
}

extension DescribeSessionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSessionsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), state: \(Swift.String(describing: state)))"}
}

extension DescribeSessionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for sessionfilterlist0 in filters {
                try filtersContainer.encode(sessionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

public struct DescribeSessionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSessionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeSessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSessionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeSessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInput: Swift.Equatable {
    /// One or more filters to limit the type of sessions returned by the request.
    public var filters: [SsmClientTypes.SessionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The session status to retrieve a list of sessions for. For example, "Active".
    /// This member is required.
    public var state: SsmClientTypes.SessionState?

    public init (
        filters: [SsmClientTypes.SessionFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        state: SsmClientTypes.SessionState? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

struct DescribeSessionsInputBody: Swift.Equatable {
    public let state: SsmClientTypes.SessionState?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
    public let filters: [SsmClientTypes.SessionFilter]?
}

extension DescribeSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.SessionFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.SessionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.SessionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSessionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSessionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSessionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sessions: \(Swift.String(describing: sessions)))"}
}

extension DescribeSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct DescribeSessionsOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// A list of sessions meeting the request parameters.
    public var sessions: [SsmClientTypes.Session]?

    public init (
        nextToken: Swift.String? = nil,
        sessions: [SsmClientTypes.Session]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct DescribeSessionsOutputResponseBody: Swift.Equatable {
    public let sessions: [SsmClientTypes.Session]?
    public let nextToken: Swift.String?
}

extension DescribeSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sessions = "Sessions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Session?].self, forKey: .sessions)
        var sessionsDecoded0:[SsmClientTypes.Session]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [SsmClientTypes.Session]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DisassociateOpsItemRelatedItemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateOpsItemRelatedItemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateOpsItemRelatedItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateOpsItemRelatedItemOutputError>
}

extension DisassociateOpsItemRelatedItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateOpsItemRelatedItemInput(associationId: \(Swift.String(describing: associationId)), opsItemId: \(Swift.String(describing: opsItemId)))"}
}

extension DisassociateOpsItemRelatedItemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }
}

public struct DisassociateOpsItemRelatedItemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateOpsItemRelatedItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateOpsItemRelatedItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateOpsItemRelatedItemOutputError>
}

public struct DisassociateOpsItemRelatedItemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateOpsItemRelatedItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateOpsItemRelatedItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateOpsItemRelatedItemOutputError>
}

public struct DisassociateOpsItemRelatedItemInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateOpsItemRelatedItemInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateOpsItemRelatedItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateOpsItemRelatedItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateOpsItemRelatedItemOutputError>
}

public struct DisassociateOpsItemRelatedItemInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateOpsItemRelatedItemInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateOpsItemRelatedItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateOpsItemRelatedItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateOpsItemRelatedItemOutputError>
}

public struct DisassociateOpsItemRelatedItemInput: Swift.Equatable {
    /// The ID of the association for which you want to delete an association between the OpsItem and a related item.
    /// This member is required.
    public var associationId: Swift.String?
    /// The ID of the OpsItem for which you want to delete an association between the OpsItem and a related item.
    /// This member is required.
    public var opsItemId: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.opsItemId = opsItemId
    }
}

struct DisassociateOpsItemRelatedItemInputBody: Swift.Equatable {
    public let opsItemId: Swift.String?
    public let associationId: Swift.String?
}

extension DisassociateOpsItemRelatedItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension DisassociateOpsItemRelatedItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateOpsItemRelatedItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemRelatedItemAssociationNotFoundException" : self = .opsItemRelatedItemAssociationNotFoundException(try OpsItemRelatedItemAssociationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateOpsItemRelatedItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case opsItemRelatedItemAssociationNotFoundException(OpsItemRelatedItemAssociationNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateOpsItemRelatedItemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateOpsItemRelatedItemOutputResponse()"}
}

extension DisassociateOpsItemRelatedItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateOpsItemRelatedItemOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateOpsItemRelatedItemOutputResponseBody: Swift.Equatable {
}

extension DisassociateOpsItemRelatedItemOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DocumentAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension DocumentAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DocumentAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified document already exists.
public struct DocumentAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DocumentAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.DocumentDefaultVersionDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVersion = "DefaultVersion"
        case defaultVersionName = "DefaultVersionName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let defaultVersionName = defaultVersionName {
            try encodeContainer.encode(defaultVersionName, forKey: .defaultVersionName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let defaultVersionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionName)
        defaultVersionName = defaultVersionNameDecoded
    }
}

extension SsmClientTypes.DocumentDefaultVersionDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentDefaultVersionDescription(defaultVersion: \(Swift.String(describing: defaultVersion)), defaultVersionName: \(Swift.String(describing: defaultVersionName)), name: \(Swift.String(describing: name)))"}
}

extension SsmClientTypes {
    /// A default version of a document.
    public struct DocumentDefaultVersionDescription: Swift.Equatable {
        /// The default version of the document.
        public var defaultVersion: Swift.String?
        /// The default version of the artifact associated with the document.
        public var defaultVersionName: Swift.String?
        /// The name of the document.
        public var name: Swift.String?

        public init (
            defaultVersion: Swift.String? = nil,
            defaultVersionName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.defaultVersion = defaultVersion
            self.defaultVersionName = defaultVersionName
            self.name = name
        }
    }

}

extension SsmClientTypes.DocumentDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvedVersion = "ApprovedVersion"
        case attachmentsInformation = "AttachmentsInformation"
        case author = "Author"
        case createdDate = "CreatedDate"
        case defaultVersion = "DefaultVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case documentVersion = "DocumentVersion"
        case hash = "Hash"
        case hashType = "HashType"
        case latestVersion = "LatestVersion"
        case name = "Name"
        case owner = "Owner"
        case parameters = "Parameters"
        case pendingReviewVersion = "PendingReviewVersion"
        case platformTypes = "PlatformTypes"
        case requires = "Requires"
        case reviewInformation = "ReviewInformation"
        case reviewStatus = "ReviewStatus"
        case schemaVersion = "SchemaVersion"
        case sha1 = "Sha1"
        case status = "Status"
        case statusInformation = "StatusInformation"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvedVersion = approvedVersion {
            try encodeContainer.encode(approvedVersion, forKey: .approvedVersion)
        }
        if let attachmentsInformation = attachmentsInformation {
            var attachmentsInformationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentsInformation)
            for attachmentinformationlist0 in attachmentsInformation {
                try attachmentsInformationContainer.encode(attachmentinformationlist0)
            }
        }
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentType = documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let hash = hash {
            try encodeContainer.encode(hash, forKey: .hash)
        }
        if let hashType = hashType {
            try encodeContainer.encode(hashType.rawValue, forKey: .hashType)
        }
        if let latestVersion = latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for documentparameterlist0 in parameters {
                try parametersContainer.encode(documentparameterlist0)
            }
        }
        if let pendingReviewVersion = pendingReviewVersion {
            try encodeContainer.encode(pendingReviewVersion, forKey: .pendingReviewVersion)
        }
        if let platformTypes = platformTypes {
            var platformTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformTypes)
            for platformtypelist0 in platformTypes {
                try platformTypesContainer.encode(platformtypelist0.rawValue)
            }
        }
        if let requires = requires {
            var requiresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requires)
            for documentrequireslist0 in requires {
                try requiresContainer.encode(documentrequireslist0)
            }
        }
        if let reviewInformation = reviewInformation {
            var reviewInformationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewInformation)
            for reviewinformationlist0 in reviewInformation {
                try reviewInformationContainer.encode(reviewinformationlist0)
            }
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sha1 = sha1 {
            try encodeContainer.encode(sha1, forKey: .sha1)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusInformation = statusInformation {
            try encodeContainer.encode(statusInformation, forKey: .statusInformation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sha1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sha1)
        sha1 = sha1Decoded
        let hashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hash)
        hash = hashDecoded
        let hashTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentHashType.self, forKey: .hashType)
        hashType = hashTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentStatus.self, forKey: .status)
        status = statusDecoded
        let statusInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusInformation)
        statusInformation = statusInformationDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentParameter?].self, forKey: .parameters)
        var parametersDecoded0:[SsmClientTypes.DocumentParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SsmClientTypes.DocumentParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let platformTypesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PlatformType?].self, forKey: .platformTypes)
        var platformTypesDecoded0:[SsmClientTypes.PlatformType]? = nil
        if let platformTypesContainer = platformTypesContainer {
            platformTypesDecoded0 = [SsmClientTypes.PlatformType]()
            for string0 in platformTypesContainer {
                if let string0 = string0 {
                    platformTypesDecoded0?.append(string0)
                }
            }
        }
        platformTypes = platformTypesDecoded0
        let documentTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let attachmentsInformationContainer = try containerValues.decodeIfPresent([SsmClientTypes.AttachmentInformation?].self, forKey: .attachmentsInformation)
        var attachmentsInformationDecoded0:[SsmClientTypes.AttachmentInformation]? = nil
        if let attachmentsInformationContainer = attachmentsInformationContainer {
            attachmentsInformationDecoded0 = [SsmClientTypes.AttachmentInformation]()
            for structure0 in attachmentsInformationContainer {
                if let structure0 = structure0 {
                    attachmentsInformationDecoded0?.append(structure0)
                }
            }
        }
        attachmentsInformation = attachmentsInformationDecoded0
        let requiresContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[SsmClientTypes.DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [SsmClientTypes.DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let reviewInformationContainer = try containerValues.decodeIfPresent([SsmClientTypes.ReviewInformation?].self, forKey: .reviewInformation)
        var reviewInformationDecoded0:[SsmClientTypes.ReviewInformation]? = nil
        if let reviewInformationContainer = reviewInformationContainer {
            reviewInformationDecoded0 = [SsmClientTypes.ReviewInformation]()
            for structure0 in reviewInformationContainer {
                if let structure0 = structure0 {
                    reviewInformationDecoded0?.append(structure0)
                }
            }
        }
        reviewInformation = reviewInformationDecoded0
        let approvedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvedVersion)
        approvedVersion = approvedVersionDecoded
        let pendingReviewVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingReviewVersion)
        pendingReviewVersion = pendingReviewVersionDecoded
        let reviewStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
    }
}

extension SsmClientTypes.DocumentDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentDescription(approvedVersion: \(Swift.String(describing: approvedVersion)), attachmentsInformation: \(Swift.String(describing: attachmentsInformation)), author: \(Swift.String(describing: author)), createdDate: \(Swift.String(describing: createdDate)), defaultVersion: \(Swift.String(describing: defaultVersion)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), documentFormat: \(Swift.String(describing: documentFormat)), documentType: \(Swift.String(describing: documentType)), documentVersion: \(Swift.String(describing: documentVersion)), hash: \(Swift.String(describing: hash)), hashType: \(Swift.String(describing: hashType)), latestVersion: \(Swift.String(describing: latestVersion)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), parameters: \(Swift.String(describing: parameters)), pendingReviewVersion: \(Swift.String(describing: pendingReviewVersion)), platformTypes: \(Swift.String(describing: platformTypes)), requires: \(Swift.String(describing: requires)), reviewInformation: \(Swift.String(describing: reviewInformation)), reviewStatus: \(Swift.String(describing: reviewStatus)), schemaVersion: \(Swift.String(describing: schemaVersion)), sha1: \(Swift.String(describing: sha1)), status: \(Swift.String(describing: status)), statusInformation: \(Swift.String(describing: statusInformation)), tags: \(Swift.String(describing: tags)), targetType: \(Swift.String(describing: targetType)), versionName: \(Swift.String(describing: versionName)))"}
}

extension SsmClientTypes {
    /// Describes a Amazon Web Services Systems Manager document (SSM document).
    public struct DocumentDescription: Swift.Equatable {
        /// The version of the document currently approved for use in the organization.
        public var approvedVersion: Swift.String?
        /// Details about the document attachments, including names, locations, sizes, and so on.
        public var attachmentsInformation: [SsmClientTypes.AttachmentInformation]?
        /// The user in your organization who created the document.
        public var author: Swift.String?
        /// The date when the document was created.
        public var createdDate: ClientRuntime.Date?
        /// The default version.
        public var defaultVersion: Swift.String?
        /// A description of the document.
        public var description: Swift.String?
        /// The friendly name of the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
        public var displayName: Swift.String?
        /// The document format, either JSON or YAML.
        public var documentFormat: SsmClientTypes.DocumentFormat?
        /// The type of document.
        public var documentType: SsmClientTypes.DocumentType?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The Sha256 or Sha1 hash created by the system when the document was created. Sha1 hashes have been deprecated.
        public var hash: Swift.String?
        /// The hash type of the document. Valid values include Sha256 or Sha1. Sha1 hashes have been deprecated.
        public var hashType: SsmClientTypes.DocumentHashType?
        /// The latest version of the document.
        public var latestVersion: Swift.String?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// The Amazon Web Services user account that created the document.
        public var owner: Swift.String?
        /// A description of the parameters for a document.
        public var parameters: [SsmClientTypes.DocumentParameter]?
        /// The version of the document that is currently under review.
        public var pendingReviewVersion: Swift.String?
        /// The list of OS platforms compatible with this SSM document.
        public var platformTypes: [SsmClientTypes.PlatformType]?
        /// A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.
        public var requires: [SsmClientTypes.DocumentRequires]?
        /// Details about the review of a document.
        public var reviewInformation: [SsmClientTypes.ReviewInformation]?
        /// The current status of the review.
        public var reviewStatus: SsmClientTypes.ReviewStatus?
        /// The schema version.
        public var schemaVersion: Swift.String?
        /// The SHA1 hash of the document, which you can use for verification.
        public var sha1: Swift.String?
        /// The status of the SSM document.
        public var status: SsmClientTypes.DocumentStatus?
        /// A message returned by Amazon Web Services Systems Manager that explains the Status value. For example, a Failed status might be explained by the StatusInformation message, "The specified S3 bucket doesn't exist. Verify that the URL of the S3 bucket is correct."
        public var statusInformation: Swift.String?
        /// The tags, or metadata, that have been applied to the document.
        public var tags: [SsmClientTypes.Tag]?
        /// The target type which defines the kinds of resources the document can run on. For example, /AWS::EC2::Instance. For a list of valid resource types, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide.
        public var targetType: Swift.String?
        /// The version of the artifact associated with the document.
        public var versionName: Swift.String?

        public init (
            approvedVersion: Swift.String? = nil,
            attachmentsInformation: [SsmClientTypes.AttachmentInformation]? = nil,
            author: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            defaultVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            documentFormat: SsmClientTypes.DocumentFormat? = nil,
            documentType: SsmClientTypes.DocumentType? = nil,
            documentVersion: Swift.String? = nil,
            hash: Swift.String? = nil,
            hashType: SsmClientTypes.DocumentHashType? = nil,
            latestVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parameters: [SsmClientTypes.DocumentParameter]? = nil,
            pendingReviewVersion: Swift.String? = nil,
            platformTypes: [SsmClientTypes.PlatformType]? = nil,
            requires: [SsmClientTypes.DocumentRequires]? = nil,
            reviewInformation: [SsmClientTypes.ReviewInformation]? = nil,
            reviewStatus: SsmClientTypes.ReviewStatus? = nil,
            schemaVersion: Swift.String? = nil,
            sha1: Swift.String? = nil,
            status: SsmClientTypes.DocumentStatus? = nil,
            statusInformation: Swift.String? = nil,
            tags: [SsmClientTypes.Tag]? = nil,
            targetType: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.approvedVersion = approvedVersion
            self.attachmentsInformation = attachmentsInformation
            self.author = author
            self.createdDate = createdDate
            self.defaultVersion = defaultVersion
            self.description = description
            self.displayName = displayName
            self.documentFormat = documentFormat
            self.documentType = documentType
            self.documentVersion = documentVersion
            self.hash = hash
            self.hashType = hashType
            self.latestVersion = latestVersion
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.pendingReviewVersion = pendingReviewVersion
            self.platformTypes = platformTypes
            self.requires = requires
            self.reviewInformation = reviewInformation
            self.reviewStatus = reviewStatus
            self.schemaVersion = schemaVersion
            self.sha1 = sha1
            self.status = status
            self.statusInformation = statusInformation
            self.tags = tags
            self.targetType = targetType
            self.versionName = versionName
        }
    }

}

extension SsmClientTypes.DocumentFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes.DocumentFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentFilter(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SsmClientTypes {
    /// This data type is deprecated. Instead, use [DocumentKeyValuesFilter].
    public struct DocumentFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: SsmClientTypes.DocumentFilterKey?
        /// The value of the filter.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.DocumentFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum DocumentFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case documenttype
        case name
        case owner
        case platformtypes
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentFilterKey] {
            return [
                .documenttype,
                .name,
                .owner,
                .platformtypes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .documenttype: return "DocumentType"
            case .name: return "Name"
            case .owner: return "Owner"
            case .platformtypes: return "PlatformTypes"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentFilterKey(rawValue: rawValue) ?? DocumentFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum DocumentFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case text
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentFormat] {
            return [
                .json,
                .text,
                .yaml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .text: return "TEXT"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentFormat(rawValue: rawValue) ?? DocumentFormat.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum DocumentHashType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sha1
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentHashType] {
            return [
                .sha1,
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sha1: return "Sha1"
            case .sha256: return "Sha256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentHashType(rawValue: rawValue) ?? DocumentHashType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "Author"
        case createdDate = "CreatedDate"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case owner = "Owner"
        case platformTypes = "PlatformTypes"
        case requires = "Requires"
        case reviewStatus = "ReviewStatus"
        case schemaVersion = "SchemaVersion"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentType = documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platformTypes = platformTypes {
            var platformTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformTypes)
            for platformtypelist0 in platformTypes {
                try platformTypesContainer.encode(platformtypelist0.rawValue)
            }
        }
        if let requires = requires {
            var requiresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requires)
            for documentrequireslist0 in requires {
                try requiresContainer.encode(documentrequireslist0)
            }
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let platformTypesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PlatformType?].self, forKey: .platformTypes)
        var platformTypesDecoded0:[SsmClientTypes.PlatformType]? = nil
        if let platformTypesContainer = platformTypesContainer {
            platformTypesDecoded0 = [SsmClientTypes.PlatformType]()
            for string0 in platformTypesContainer {
                if let string0 = string0 {
                    platformTypesDecoded0?.append(string0)
                }
            }
        }
        platformTypes = platformTypesDecoded0
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let requiresContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[SsmClientTypes.DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [SsmClientTypes.DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let reviewStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
    }
}

extension SsmClientTypes.DocumentIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentIdentifier(author: \(Swift.String(describing: author)), createdDate: \(Swift.String(describing: createdDate)), displayName: \(Swift.String(describing: displayName)), documentFormat: \(Swift.String(describing: documentFormat)), documentType: \(Swift.String(describing: documentType)), documentVersion: \(Swift.String(describing: documentVersion)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), platformTypes: \(Swift.String(describing: platformTypes)), requires: \(Swift.String(describing: requires)), reviewStatus: \(Swift.String(describing: reviewStatus)), schemaVersion: \(Swift.String(describing: schemaVersion)), tags: \(Swift.String(describing: tags)), targetType: \(Swift.String(describing: targetType)), versionName: \(Swift.String(describing: versionName)))"}
}

extension SsmClientTypes {
    /// Describes the name of a SSM document.
    public struct DocumentIdentifier: Swift.Equatable {
        /// The user in your organization who created the document.
        public var author: Swift.String?
        /// The date the SSM document was created.
        public var createdDate: ClientRuntime.Date?
        /// An optional field where you can specify a friendly name for the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
        public var displayName: Swift.String?
        /// The document format, either JSON or YAML.
        public var documentFormat: SsmClientTypes.DocumentFormat?
        /// The document type.
        public var documentType: SsmClientTypes.DocumentType?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// The Amazon Web Services user account that created the document.
        public var owner: Swift.String?
        /// The operating system platform.
        public var platformTypes: [SsmClientTypes.PlatformType]?
        /// A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.
        public var requires: [SsmClientTypes.DocumentRequires]?
        /// The current status of a document review.
        public var reviewStatus: SsmClientTypes.ReviewStatus?
        /// The schema version.
        public var schemaVersion: Swift.String?
        /// The tags, or metadata, that have been applied to the document.
        public var tags: [SsmClientTypes.Tag]?
        /// The target type which defines the kinds of resources the document can run on. For example, /AWS::EC2::Instance. For a list of valid resource types, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide.
        public var targetType: Swift.String?
        /// An optional field specifying the version of the artifact associated with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
        public var versionName: Swift.String?

        public init (
            author: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            documentFormat: SsmClientTypes.DocumentFormat? = nil,
            documentType: SsmClientTypes.DocumentType? = nil,
            documentVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platformTypes: [SsmClientTypes.PlatformType]? = nil,
            requires: [SsmClientTypes.DocumentRequires]? = nil,
            reviewStatus: SsmClientTypes.ReviewStatus? = nil,
            schemaVersion: Swift.String? = nil,
            tags: [SsmClientTypes.Tag]? = nil,
            targetType: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.author = author
            self.createdDate = createdDate
            self.displayName = displayName
            self.documentFormat = documentFormat
            self.documentType = documentType
            self.documentVersion = documentVersion
            self.name = name
            self.owner = owner
            self.platformTypes = platformTypes
            self.requires = requires
            self.reviewStatus = reviewStatus
            self.schemaVersion = schemaVersion
            self.tags = tags
            self.targetType = targetType
            self.versionName = versionName
        }
    }

}

extension SsmClientTypes.DocumentKeyValuesFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for documentkeyvaluesfiltervalues0 in values {
                try valuesContainer.encode(documentkeyvaluesfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.DocumentKeyValuesFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentKeyValuesFilter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// One or more filters. Use a filter to return a more specific list of documents. For keys, you can specify one or more tags that have been applied to a document. You can also use Amazon Web Services-provided keys, some of which have specific allowed values. These keys and their associated values are as follows: DocumentType
    ///
    /// * ApplicationConfiguration
    ///
    /// * ApplicationConfigurationSchema
    ///
    /// * Automation
    ///
    /// * ChangeCalendar
    ///
    /// * Command
    ///
    /// * DeploymentStrategy
    ///
    /// * Package
    ///
    /// * Policy
    ///
    /// * Session
    ///
    ///
    /// Owner Note that only one Owner can be specified in a request. For example: Key=Owner,Values=Self.
    ///
    /// * Amazon
    ///
    /// * Private
    ///
    /// * Public
    ///
    /// * Self
    ///
    /// * ThirdParty
    ///
    ///
    /// PlatformTypes
    ///
    /// * Linux
    ///
    /// * Windows
    ///
    ///
    /// Name is another Amazon Web Services-provided key. If you use Name as a key, you can use a name prefix to return a list of documents. For example, in the Amazon Web Services CLI, to return a list of all documents that begin with Te, run the following command: aws ssm list-documents --filters Key=Name,Values=Te You can also use the TargetType Amazon Web Services-provided key. For a list of valid resource type values that can be used with this key, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide. If you specify more than two keys, only documents that are identified by all the tags are returned in the results. If you specify more than two values for a key, documents that are identified by any of the values are returned in the results. To specify a custom key-value pair, use the format Key=tag:tagName,Values=valueName. For example, if you created a key called region and are using the Amazon Web Services CLI to call the list-documents command: aws ssm list-documents --filters Key=tag:region,Values=east,west Key=Owner,Values=Self
    public struct DocumentKeyValuesFilter: Swift.Equatable {
        /// The name of the filter key.
        public var key: Swift.String?
        /// The value for the filter key.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension DocumentLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension DocumentLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DocumentLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can have at most 500 active SSM documents.
public struct DocumentLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DocumentLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum DocumentMetadataEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case documentreviews
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentMetadataEnum] {
            return [
                .documentreviews,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .documentreviews: return "DocumentReviews"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentMetadataEnum(rawValue: rawValue) ?? DocumentMetadataEnum.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentMetadataResponseInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reviewerResponse = "ReviewerResponse"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reviewerResponse = reviewerResponse {
            var reviewerResponseContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewerResponse)
            for documentreviewerresponselist0 in reviewerResponse {
                try reviewerResponseContainer.encode(documentreviewerresponselist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewerResponseContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentReviewerResponseSource?].self, forKey: .reviewerResponse)
        var reviewerResponseDecoded0:[SsmClientTypes.DocumentReviewerResponseSource]? = nil
        if let reviewerResponseContainer = reviewerResponseContainer {
            reviewerResponseDecoded0 = [SsmClientTypes.DocumentReviewerResponseSource]()
            for structure0 in reviewerResponseContainer {
                if let structure0 = structure0 {
                    reviewerResponseDecoded0?.append(structure0)
                }
            }
        }
        reviewerResponse = reviewerResponseDecoded0
    }
}

extension SsmClientTypes.DocumentMetadataResponseInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentMetadataResponseInfo(reviewerResponse: \(Swift.String(describing: reviewerResponse)))"}
}

extension SsmClientTypes {
    /// Details about the response to a document review request.
    public struct DocumentMetadataResponseInfo: Swift.Equatable {
        /// Details about a reviewer's response to a document review request.
        public var reviewerResponse: [SsmClientTypes.DocumentReviewerResponseSource]?

        public init (
            reviewerResponse: [SsmClientTypes.DocumentReviewerResponseSource]? = nil
        )
        {
            self.reviewerResponse = reviewerResponse
        }
    }

}

extension SsmClientTypes.DocumentParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentParameterType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension SsmClientTypes.DocumentParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentParameter(defaultValue: \(Swift.String(describing: defaultValue)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension SsmClientTypes {
    /// Parameters specified in a System Manager document that run on the server when the command is run.
    public struct DocumentParameter: Swift.Equatable {
        /// If specified, the default values for the parameters. Parameters without a default value are required. Parameters with a default value are optional.
        public var defaultValue: Swift.String?
        /// A description of what the parameter does, how to use it, the default value, and whether or not the parameter is optional.
        public var description: Swift.String?
        /// The name of the parameter.
        public var name: Swift.String?
        /// The type of parameter. The type can be either String or StringList.
        public var type: SsmClientTypes.DocumentParameterType?

        public init (
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: SsmClientTypes.DocumentParameterType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension SsmClientTypes {
    public enum DocumentParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case string
        case stringlist
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentParameterType] {
            return [
                .string,
                .stringlist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .string: return "String"
            case .stringlist: return "StringList"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentParameterType(rawValue: rawValue) ?? DocumentParameterType.sdkUnknown(rawValue)
        }
    }
}

extension DocumentPermissionLimit: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentPermissionLimit(message: \(Swift.String(describing: message)))"}
}

extension DocumentPermissionLimit {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DocumentPermissionLimitBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The document can't be shared with more Amazon Web Services user accounts. You can share a document with a maximum of 20 accounts. You can publicly share up to five documents. If you need to increase this limit, contact Amazon Web Services Support.
public struct DocumentPermissionLimit: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentPermissionLimitBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DocumentPermissionLimitBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum DocumentPermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case share
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentPermissionType] {
            return [
                .share,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .share: return "Share"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentPermissionType(rawValue: rawValue) ?? DocumentPermissionType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentRequires: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SsmClientTypes.DocumentRequires: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentRequires(name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension SsmClientTypes {
    /// An SSM document required by the current document.
    public struct DocumentRequires: Swift.Equatable {
        /// The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
        /// This member is required.
        public var name: Swift.String?
        /// The document version required by the current document.
        public var version: Swift.String?

        public init (
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension SsmClientTypes {
    public enum DocumentReviewAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approve
        case reject
        case sendforreview
        case updatereview
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentReviewAction] {
            return [
                .approve,
                .reject,
                .sendforreview,
                .updatereview,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approve: return "Approve"
            case .reject: return "Reject"
            case .sendforreview: return "SendForReview"
            case .updatereview: return "UpdateReview"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentReviewAction(rawValue: rawValue) ?? DocumentReviewAction.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentReviewCommentSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentReviewCommentType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension SsmClientTypes.DocumentReviewCommentSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentReviewCommentSource(content: \(Swift.String(describing: content)), type: \(Swift.String(describing: type)))"}
}

extension SsmClientTypes {
    /// Information about comments added to a document review request.
    public struct DocumentReviewCommentSource: Swift.Equatable {
        /// The content of a comment entered by a user who requests a review of a new document version, or who reviews the new version.
        public var content: Swift.String?
        /// The type of information added to a review request. Currently, only the value Comment is supported.
        public var type: SsmClientTypes.DocumentReviewCommentType?

        public init (
            content: Swift.String? = nil,
            type: SsmClientTypes.DocumentReviewCommentType? = nil
        )
        {
            self.content = content
            self.type = type
        }
    }

}

extension SsmClientTypes {
    public enum DocumentReviewCommentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case comment
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentReviewCommentType] {
            return [
                .comment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .comment: return "Comment"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentReviewCommentType(rawValue: rawValue) ?? DocumentReviewCommentType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentReviewerResponseSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case createTime = "CreateTime"
        case reviewStatus = "ReviewStatus"
        case reviewer = "Reviewer"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            var commentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comment)
            for documentreviewcommentlist0 in comment {
                try commentContainer.encode(documentreviewcommentlist0)
            }
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let reviewer = reviewer {
            try encodeContainer.encode(reviewer, forKey: .reviewer)
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime.timeIntervalSince1970, forKey: .updatedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let reviewStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
        let commentContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentReviewCommentSource?].self, forKey: .comment)
        var commentDecoded0:[SsmClientTypes.DocumentReviewCommentSource]? = nil
        if let commentContainer = commentContainer {
            commentDecoded0 = [SsmClientTypes.DocumentReviewCommentSource]()
            for structure0 in commentContainer {
                if let structure0 = structure0 {
                    commentDecoded0?.append(structure0)
                }
            }
        }
        comment = commentDecoded0
        let reviewerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewer)
        reviewer = reviewerDecoded
    }
}

extension SsmClientTypes.DocumentReviewerResponseSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentReviewerResponseSource(comment: \(Swift.String(describing: comment)), createTime: \(Swift.String(describing: createTime)), reviewStatus: \(Swift.String(describing: reviewStatus)), reviewer: \(Swift.String(describing: reviewer)), updatedTime: \(Swift.String(describing: updatedTime)))"}
}

extension SsmClientTypes {
    /// Information about a reviewer's response to a document review request.
    public struct DocumentReviewerResponseSource: Swift.Equatable {
        /// The comment entered by a reviewer as part of their document review response.
        public var comment: [SsmClientTypes.DocumentReviewCommentSource]?
        /// The date and time that a reviewer entered a response to a document review request.
        public var createTime: ClientRuntime.Date?
        /// The current review status of a new custom SSM document created by a member of your organization, or of the latest version of an existing SSM document. Only one version of a document can be in the APPROVED state at a time. When a new version is approved, the status of the previous version changes to REJECTED. Only one version of a document can be in review, or PENDING, at a time.
        public var reviewStatus: SsmClientTypes.ReviewStatus?
        /// The user in your organization assigned to review a document request.
        public var reviewer: Swift.String?
        /// The date and time that a reviewer last updated a response to a document review request.
        public var updatedTime: ClientRuntime.Date?

        public init (
            comment: [SsmClientTypes.DocumentReviewCommentSource]? = nil,
            createTime: ClientRuntime.Date? = nil,
            reviewStatus: SsmClientTypes.ReviewStatus? = nil,
            reviewer: Swift.String? = nil,
            updatedTime: ClientRuntime.Date? = nil
        )
        {
            self.comment = comment
            self.createTime = createTime
            self.reviewStatus = reviewStatus
            self.reviewer = reviewer
            self.updatedTime = updatedTime
        }
    }

}

extension SsmClientTypes.DocumentReviews: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case comment = "Comment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let comment = comment {
            var commentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comment)
            for documentreviewcommentlist0 in comment {
                try commentContainer.encode(documentreviewcommentlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentReviewAction.self, forKey: .action)
        action = actionDecoded
        let commentContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentReviewCommentSource?].self, forKey: .comment)
        var commentDecoded0:[SsmClientTypes.DocumentReviewCommentSource]? = nil
        if let commentContainer = commentContainer {
            commentDecoded0 = [SsmClientTypes.DocumentReviewCommentSource]()
            for structure0 in commentContainer {
                if let structure0 = structure0 {
                    commentDecoded0?.append(structure0)
                }
            }
        }
        comment = commentDecoded0
    }
}

extension SsmClientTypes.DocumentReviews: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentReviews(action: \(Swift.String(describing: action)), comment: \(Swift.String(describing: comment)))"}
}

extension SsmClientTypes {
    /// Information about a document approval review.
    public struct DocumentReviews: Swift.Equatable {
        /// The action to take on a document approval review request.
        /// This member is required.
        public var action: SsmClientTypes.DocumentReviewAction?
        /// A comment entered by a user in your organization about the document review request.
        public var comment: [SsmClientTypes.DocumentReviewCommentSource]?

        public init (
            action: SsmClientTypes.DocumentReviewAction? = nil,
            comment: [SsmClientTypes.DocumentReviewCommentSource]? = nil
        )
        {
            self.action = action
            self.comment = comment
        }
    }

}

extension SsmClientTypes {
    /// The status of a document.
    public enum DocumentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentStatus(rawValue: rawValue) ?? DocumentStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum DocumentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applicationconfiguration
        case applicationconfigurationschema
        case automation
        case changecalendar
        case changetemplate
        case command
        case deploymentstrategy
        case package
        case policy
        case problemanalysis
        case problemanalysistemplate
        case session
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentType] {
            return [
                .applicationconfiguration,
                .applicationconfigurationschema,
                .automation,
                .changecalendar,
                .changetemplate,
                .command,
                .deploymentstrategy,
                .package,
                .policy,
                .problemanalysis,
                .problemanalysistemplate,
                .session,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applicationconfiguration: return "ApplicationConfiguration"
            case .applicationconfigurationschema: return "ApplicationConfigurationSchema"
            case .automation: return "Automation"
            case .changecalendar: return "ChangeCalendar"
            case .changetemplate: return "Automation.ChangeTemplate"
            case .command: return "Command"
            case .deploymentstrategy: return "DeploymentStrategy"
            case .package: return "Package"
            case .policy: return "Policy"
            case .problemanalysis: return "ProblemAnalysis"
            case .problemanalysistemplate: return "ProblemAnalysisTemplate"
            case .session: return "Session"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentType(rawValue: rawValue) ?? DocumentType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentVersionInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case isDefaultVersion = "IsDefaultVersion"
        case name = "Name"
        case reviewStatus = "ReviewStatus"
        case status = "Status"
        case statusInformation = "StatusInformation"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if isDefaultVersion != false {
            try encodeContainer.encode(isDefaultVersion, forKey: .isDefaultVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusInformation = statusInformation {
            try encodeContainer.encode(statusInformation, forKey: .statusInformation)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentStatus.self, forKey: .status)
        status = statusDecoded
        let statusInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusInformation)
        statusInformation = statusInformationDecoded
        let reviewStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
    }
}

extension SsmClientTypes.DocumentVersionInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentVersionInfo(createdDate: \(Swift.String(describing: createdDate)), displayName: \(Swift.String(describing: displayName)), documentFormat: \(Swift.String(describing: documentFormat)), documentVersion: \(Swift.String(describing: documentVersion)), isDefaultVersion: \(Swift.String(describing: isDefaultVersion)), name: \(Swift.String(describing: name)), reviewStatus: \(Swift.String(describing: reviewStatus)), status: \(Swift.String(describing: status)), statusInformation: \(Swift.String(describing: statusInformation)), versionName: \(Swift.String(describing: versionName)))"}
}

extension SsmClientTypes {
    /// Version information about the document.
    public struct DocumentVersionInfo: Swift.Equatable {
        /// The date the document was created.
        public var createdDate: ClientRuntime.Date?
        /// The friendly name of the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
        public var displayName: Swift.String?
        /// The document format, either JSON or YAML.
        public var documentFormat: SsmClientTypes.DocumentFormat?
        /// The document version.
        public var documentVersion: Swift.String?
        /// An identifier for the default version of the document.
        public var isDefaultVersion: Swift.Bool
        /// The document name.
        public var name: Swift.String?
        /// The current status of the approval review for the latest version of the document.
        public var reviewStatus: SsmClientTypes.ReviewStatus?
        /// The status of the SSM document, such as Creating, Active, Failed, and Deleting.
        public var status: SsmClientTypes.DocumentStatus?
        /// A message returned by Amazon Web Services Systems Manager that explains the Status value. For example, a Failed status might be explained by the StatusInformation message, "The specified S3 bucket doesn't exist. Verify that the URL of the S3 bucket is correct."
        public var statusInformation: Swift.String?
        /// The version of the artifact associated with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
        public var versionName: Swift.String?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            documentFormat: SsmClientTypes.DocumentFormat? = nil,
            documentVersion: Swift.String? = nil,
            isDefaultVersion: Swift.Bool = false,
            name: Swift.String? = nil,
            reviewStatus: SsmClientTypes.ReviewStatus? = nil,
            status: SsmClientTypes.DocumentStatus? = nil,
            statusInformation: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.displayName = displayName
            self.documentFormat = documentFormat
            self.documentVersion = documentVersion
            self.isDefaultVersion = isDefaultVersion
            self.name = name
            self.reviewStatus = reviewStatus
            self.status = status
            self.statusInformation = statusInformation
            self.versionName = versionName
        }
    }

}

extension DocumentVersionLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentVersionLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension DocumentVersionLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DocumentVersionLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The document has too many versions. Delete one or more document versions and try again.
public struct DocumentVersionLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentVersionLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DocumentVersionLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DoesNotExistException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DoesNotExistException(message: \(Swift.String(describing: message)))"}
}

extension DoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Error returned when the ID specified for a resource, such as a maintenance window or patch baseline, doesn't exist. For information about resource quotas in Amazon Web Services Systems Manager, see [Systems Manager service quotas](https://docs.aws.amazon.com/general/latest/gr/ssm.html#limits_ssm) in the Amazon Web Services General Reference.
public struct DoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DoesNotExistExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateDocumentContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateDocumentContent(message: \(Swift.String(describing: message)))"}
}

extension DuplicateDocumentContent {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateDocumentContentBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The content of the association document matches another document. Change the content of the document and try again.
public struct DuplicateDocumentContent: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateDocumentContentBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DuplicateDocumentContentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateDocumentVersionName: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateDocumentVersionName(message: \(Swift.String(describing: message)))"}
}

extension DuplicateDocumentVersionName {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateDocumentVersionNameBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The version name has already been used in this document. Specify a different version name, and then try again.
public struct DuplicateDocumentVersionName: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateDocumentVersionNameBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DuplicateDocumentVersionNameBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateInstanceId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateInstanceId()"}
}

extension DuplicateInstanceId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't specify a managed node ID in more than one association.
public struct DuplicateInstanceId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension SsmClientTypes.EffectivePatch: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patch = "Patch"
        case patchStatus = "PatchStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patch = patch {
            try encodeContainer.encode(patch, forKey: .patch)
        }
        if let patchStatus = patchStatus {
            try encodeContainer.encode(patchStatus, forKey: .patchStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchDecoded = try containerValues.decodeIfPresent(SsmClientTypes.Patch.self, forKey: .patch)
        patch = patchDecoded
        let patchStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchStatus.self, forKey: .patchStatus)
        patchStatus = patchStatusDecoded
    }
}

extension SsmClientTypes.EffectivePatch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EffectivePatch(patch: \(Swift.String(describing: patch)), patchStatus: \(Swift.String(describing: patchStatus)))"}
}

extension SsmClientTypes {
    /// The EffectivePatch structure defines metadata about a patch along with the approval state of the patch in a particular patch baseline. The approval state includes information about whether the patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly rejected and the date the patch was or will be approved.
    public struct EffectivePatch: Swift.Equatable {
        /// Provides metadata for a patch, including information such as the KB ID, severity, classification and a URL for where more information can be obtained about the patch.
        public var patch: SsmClientTypes.Patch?
        /// The status of the patch in a patch baseline. This includes information about whether the patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly rejected and the date the patch was or will be approved.
        public var patchStatus: SsmClientTypes.PatchStatus?

        public init (
            patch: SsmClientTypes.Patch? = nil,
            patchStatus: SsmClientTypes.PatchStatus? = nil
        )
        {
            self.patch = patch
            self.patchStatus = patchStatus
        }
    }

}

extension SsmClientTypes {
    public enum ExecutionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case interactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionMode] {
            return [
                .auto,
                .interactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .interactive: return "Interactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionMode(rawValue: rawValue) ?? ExecutionMode.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.FailedCreateAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entry = "Entry"
        case fault = "Fault"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let fault = fault {
            try encodeContainer.encode(fault.rawValue, forKey: .fault)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CreateAssociationBatchRequestEntry.self, forKey: .entry)
        entry = entryDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let faultDecoded = try containerValues.decodeIfPresent(SsmClientTypes.Fault.self, forKey: .fault)
        fault = faultDecoded
    }
}

extension SsmClientTypes.FailedCreateAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailedCreateAssociation(entry: \(Swift.String(describing: entry)), fault: \(Swift.String(describing: fault)), message: \(Swift.String(describing: message)))"}
}

extension SsmClientTypes {
    /// Describes a failed association.
    public struct FailedCreateAssociation: Swift.Equatable {
        /// The association.
        public var entry: SsmClientTypes.CreateAssociationBatchRequestEntry?
        /// The source of the failure.
        public var fault: SsmClientTypes.Fault?
        /// A description of the failure.
        public var message: Swift.String?

        public init (
            entry: SsmClientTypes.CreateAssociationBatchRequestEntry? = nil,
            fault: SsmClientTypes.Fault? = nil,
            message: Swift.String? = nil
        )
        {
            self.entry = entry
            self.fault = fault
            self.message = message
        }
    }

}

extension SsmClientTypes.FailureDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case failureStage = "FailureStage"
        case failureType = "FailureType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            var detailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .details)
            for (dictKey0, automationparametermap0) in details {
                try detailsContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let failureStage = failureStage {
            try encodeContainer.encode(failureStage, forKey: .failureStage)
        }
        if let failureType = failureType {
            try encodeContainer.encode(failureType, forKey: .failureType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureStageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureStage)
        failureStage = failureStageDecoded
        let failureTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let detailsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .details)
        var detailsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in detailsContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                detailsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        details = detailsDecoded0
    }
}

extension SsmClientTypes.FailureDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailureDetails(details: \(Swift.String(describing: details)), failureStage: \(Swift.String(describing: failureStage)), failureType: \(Swift.String(describing: failureType)))"}
}

extension SsmClientTypes {
    /// Information about an Automation failure.
    public struct FailureDetails: Swift.Equatable {
        /// Detailed information about the Automation step failure.
        public var details: [Swift.String:[Swift.String]]?
        /// The stage of the Automation execution when the failure occurred. The stages include the following: InputValidation, PreVerification, Invocation, PostVerification.
        public var failureStage: Swift.String?
        /// The type of Automation failure. Failure types include the following: Action, Permission, Throttling, Verification, Internal.
        public var failureType: Swift.String?

        public init (
            details: [Swift.String:[Swift.String]]? = nil,
            failureStage: Swift.String? = nil,
            failureType: Swift.String? = nil
        )
        {
            self.details = details
            self.failureStage = failureStage
            self.failureType = failureType
        }
    }

}

extension SsmClientTypes {
    public enum Fault: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case client
        case server
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [Fault] {
            return [
                .client,
                .server,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .client: return "Client"
            case .server: return "Server"
            case .unknown: return "Unknown"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Fault(rawValue: rawValue) ?? Fault.sdkUnknown(rawValue)
        }
    }
}

extension FeatureNotAvailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FeatureNotAvailableException(message: \(Swift.String(describing: message)))"}
}

extension FeatureNotAvailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FeatureNotAvailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You attempted to register a LAMBDA or STEP_FUNCTIONS task in a region where the corresponding service isn't available.
public struct FeatureNotAvailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FeatureNotAvailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FeatureNotAvailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetAutomationExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAutomationExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAutomationExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAutomationExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAutomationExecutionOutputError>
}

extension GetAutomationExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAutomationExecutionInput(automationExecutionId: \(Swift.String(describing: automationExecutionId)))"}
}

extension GetAutomationExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
    }
}

public struct GetAutomationExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAutomationExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAutomationExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAutomationExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAutomationExecutionOutputError>
}

public struct GetAutomationExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAutomationExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAutomationExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAutomationExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAutomationExecutionOutputError>
}

public struct GetAutomationExecutionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAutomationExecutionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAutomationExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAutomationExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAutomationExecutionOutputError>
}

public struct GetAutomationExecutionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAutomationExecutionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAutomationExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAutomationExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAutomationExecutionOutputError>
}

public struct GetAutomationExecutionInput: Swift.Equatable {
    /// The unique identifier for an existing automation execution to examine. The execution ID is returned by StartAutomationExecution when the execution of an Automation runbook is initiated.
    /// This member is required.
    public var automationExecutionId: Swift.String?

    public init (
        automationExecutionId: Swift.String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

struct GetAutomationExecutionInputBody: Swift.Equatable {
    public let automationExecutionId: Swift.String?
}

extension GetAutomationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
    }
}

extension GetAutomationExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAutomationExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFound" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAutomationExecutionOutputError: Swift.Error, Swift.Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAutomationExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAutomationExecutionOutputResponse(automationExecution: \(Swift.String(describing: automationExecution)))"}
}

extension GetAutomationExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAutomationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automationExecution = output.automationExecution
        } else {
            self.automationExecution = nil
        }
    }
}

public struct GetAutomationExecutionOutputResponse: Swift.Equatable {
    /// Detailed information about the current state of an automation execution.
    public var automationExecution: SsmClientTypes.AutomationExecution?

    public init (
        automationExecution: SsmClientTypes.AutomationExecution? = nil
    )
    {
        self.automationExecution = automationExecution
    }
}

struct GetAutomationExecutionOutputResponseBody: Swift.Equatable {
    public let automationExecution: SsmClientTypes.AutomationExecution?
}

extension GetAutomationExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecution = "AutomationExecution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecution.self, forKey: .automationExecution)
        automationExecution = automationExecutionDecoded
    }
}

public struct GetCalendarStateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCalendarStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCalendarStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCalendarStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCalendarStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCalendarStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCalendarStateOutputError>
}

extension GetCalendarStateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCalendarStateInput(atTime: \(Swift.String(describing: atTime)), calendarNames: \(Swift.String(describing: calendarNames)))"}
}

extension GetCalendarStateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atTime = "AtTime"
        case calendarNames = "CalendarNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let atTime = atTime {
            try encodeContainer.encode(atTime, forKey: .atTime)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
    }
}

public struct GetCalendarStateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCalendarStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCalendarStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCalendarStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCalendarStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCalendarStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCalendarStateOutputError>
}

public struct GetCalendarStateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCalendarStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCalendarStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCalendarStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCalendarStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCalendarStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCalendarStateOutputError>
}

public struct GetCalendarStateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCalendarStateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCalendarStateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCalendarStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCalendarStateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCalendarStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCalendarStateOutputError>
}

public struct GetCalendarStateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCalendarStateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCalendarStateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCalendarStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCalendarStateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCalendarStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCalendarStateOutputError>
}

public struct GetCalendarStateInput: Swift.Equatable {
    /// (Optional) The specific time for which you want to get calendar state information, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. If you don't specify a value or AtTime, the current time is used.
    public var atTime: Swift.String?
    /// The names or Amazon Resource Names (ARNs) of the Systems Manager documents (SSM documents) that represent the calendar entries for which you want to get the state.
    /// This member is required.
    public var calendarNames: [Swift.String]?

    public init (
        atTime: Swift.String? = nil,
        calendarNames: [Swift.String]? = nil
    )
    {
        self.atTime = atTime
        self.calendarNames = calendarNames
    }
}

struct GetCalendarStateInputBody: Swift.Equatable {
    public let calendarNames: [Swift.String]?
    public let atTime: Swift.String?
}

extension GetCalendarStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atTime = "AtTime"
        case calendarNames = "CalendarNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let atTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .atTime)
        atTime = atTimeDecoded
    }
}

extension GetCalendarStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCalendarStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentType" : self = .invalidDocumentType(try InvalidDocumentType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCalendarException" : self = .unsupportedCalendarException(try UnsupportedCalendarException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCalendarStateOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentType(InvalidDocumentType)
    case unsupportedCalendarException(UnsupportedCalendarException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCalendarStateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCalendarStateOutputResponse(atTime: \(Swift.String(describing: atTime)), nextTransitionTime: \(Swift.String(describing: nextTransitionTime)), state: \(Swift.String(describing: state)))"}
}

extension GetCalendarStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCalendarStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.atTime = output.atTime
            self.nextTransitionTime = output.nextTransitionTime
            self.state = output.state
        } else {
            self.atTime = nil
            self.nextTransitionTime = nil
            self.state = nil
        }
    }
}

public struct GetCalendarStateOutputResponse: Swift.Equatable {
    /// The time, as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string, that you specified in your command. If you don't specify a time, GetCalendarState uses the current time.
    public var atTime: Swift.String?
    /// The time, as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string, that the calendar state will change. If the current calendar state is OPEN, NextTransitionTime indicates when the calendar state changes to CLOSED, and vice-versa.
    public var nextTransitionTime: Swift.String?
    /// The state of the calendar. An OPEN calendar indicates that actions are allowed to proceed, and a CLOSED calendar indicates that actions aren't allowed to proceed.
    public var state: SsmClientTypes.CalendarState?

    public init (
        atTime: Swift.String? = nil,
        nextTransitionTime: Swift.String? = nil,
        state: SsmClientTypes.CalendarState? = nil
    )
    {
        self.atTime = atTime
        self.nextTransitionTime = nextTransitionTime
        self.state = state
    }
}

struct GetCalendarStateOutputResponseBody: Swift.Equatable {
    public let state: SsmClientTypes.CalendarState?
    public let atTime: Swift.String?
    public let nextTransitionTime: Swift.String?
}

extension GetCalendarStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atTime = "AtTime"
        case nextTransitionTime = "NextTransitionTime"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CalendarState.self, forKey: .state)
        state = stateDecoded
        let atTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .atTime)
        atTime = atTimeDecoded
        let nextTransitionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextTransitionTime)
        nextTransitionTime = nextTransitionTimeDecoded
    }
}

public struct GetCommandInvocationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCommandInvocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCommandInvocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCommandInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCommandInvocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCommandInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCommandInvocationOutputError>
}

extension GetCommandInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCommandInvocationInput(commandId: \(Swift.String(describing: commandId)), instanceId: \(Swift.String(describing: instanceId)), pluginName: \(Swift.String(describing: pluginName)))"}
}

extension GetCommandInvocationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case instanceId = "InstanceId"
        case pluginName = "PluginName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let pluginName = pluginName {
            try encodeContainer.encode(pluginName, forKey: .pluginName)
        }
    }
}

public struct GetCommandInvocationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCommandInvocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCommandInvocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCommandInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCommandInvocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCommandInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCommandInvocationOutputError>
}

public struct GetCommandInvocationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCommandInvocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCommandInvocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCommandInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCommandInvocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCommandInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCommandInvocationOutputError>
}

public struct GetCommandInvocationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCommandInvocationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCommandInvocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCommandInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCommandInvocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCommandInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCommandInvocationOutputError>
}

public struct GetCommandInvocationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCommandInvocationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCommandInvocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCommandInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCommandInvocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCommandInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCommandInvocationOutputError>
}

public struct GetCommandInvocationInput: Swift.Equatable {
    /// (Required) The parent command ID of the invocation plugin.
    /// This member is required.
    public var commandId: Swift.String?
    /// (Required) The ID of the managed node targeted by the command. A managed node can be an Amazon Elastic Compute Cloud (Amazon EC2) instance, edge device, and on-premises server or VM in your hybrid environment that is configured for Amazon Web Services Systems Manager.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the plugin for which you want detailed results. If the document contains only one plugin, you can omit the name and details for that plugin. If the document contains more than one plugin, you must specify the name of the plugin for which you want to view details. Plugin names are also referred to as step names in Systems Manager documents (SSM documents). For example, aws:RunShellScript is a plugin. To find the PluginName, check the document content and find the name of the plugin. Alternatively, use [ListCommandInvocations] with the CommandId and Details parameters. The PluginName is the Name attribute of the CommandPlugin object in the CommandPlugins list.
    public var pluginName: Swift.String?

    public init (
        commandId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        pluginName: Swift.String? = nil
    )
    {
        self.commandId = commandId
        self.instanceId = instanceId
        self.pluginName = pluginName
    }
}

struct GetCommandInvocationInputBody: Swift.Equatable {
    public let commandId: Swift.String?
    public let instanceId: Swift.String?
    public let pluginName: Swift.String?
}

extension GetCommandInvocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case instanceId = "InstanceId"
        case pluginName = "PluginName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let pluginNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginName)
        pluginName = pluginNameDecoded
    }
}

extension GetCommandInvocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommandInvocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPluginName" : self = .invalidPluginName(try InvalidPluginName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvocationDoesNotExist" : self = .invocationDoesNotExist(try InvocationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCommandInvocationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidInstanceId(InvalidInstanceId)
    case invalidPluginName(InvalidPluginName)
    case invocationDoesNotExist(InvocationDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommandInvocationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCommandInvocationOutputResponse(cloudWatchOutputConfig: \(Swift.String(describing: cloudWatchOutputConfig)), commandId: \(Swift.String(describing: commandId)), comment: \(Swift.String(describing: comment)), documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), executionElapsedTime: \(Swift.String(describing: executionElapsedTime)), executionEndDateTime: \(Swift.String(describing: executionEndDateTime)), executionStartDateTime: \(Swift.String(describing: executionStartDateTime)), instanceId: \(Swift.String(describing: instanceId)), pluginName: \(Swift.String(describing: pluginName)), responseCode: \(Swift.String(describing: responseCode)), standardErrorContent: \(Swift.String(describing: standardErrorContent)), standardErrorUrl: \(Swift.String(describing: standardErrorUrl)), standardOutputContent: \(Swift.String(describing: standardOutputContent)), standardOutputUrl: \(Swift.String(describing: standardOutputUrl)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)))"}
}

extension GetCommandInvocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCommandInvocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchOutputConfig = output.cloudWatchOutputConfig
            self.commandId = output.commandId
            self.comment = output.comment
            self.documentName = output.documentName
            self.documentVersion = output.documentVersion
            self.executionElapsedTime = output.executionElapsedTime
            self.executionEndDateTime = output.executionEndDateTime
            self.executionStartDateTime = output.executionStartDateTime
            self.instanceId = output.instanceId
            self.pluginName = output.pluginName
            self.responseCode = output.responseCode
            self.standardErrorContent = output.standardErrorContent
            self.standardErrorUrl = output.standardErrorUrl
            self.standardOutputContent = output.standardOutputContent
            self.standardOutputUrl = output.standardOutputUrl
            self.status = output.status
            self.statusDetails = output.statusDetails
        } else {
            self.cloudWatchOutputConfig = nil
            self.commandId = nil
            self.comment = nil
            self.documentName = nil
            self.documentVersion = nil
            self.executionElapsedTime = nil
            self.executionEndDateTime = nil
            self.executionStartDateTime = nil
            self.instanceId = nil
            self.pluginName = nil
            self.responseCode = 0
            self.standardErrorContent = nil
            self.standardErrorUrl = nil
            self.standardOutputContent = nil
            self.standardOutputUrl = nil
            self.status = nil
            self.statusDetails = nil
        }
    }
}

public struct GetCommandInvocationOutputResponse: Swift.Equatable {
    /// Amazon CloudWatch Logs information where Systems Manager sent the command output.
    public var cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
    /// The parent command ID of the invocation plugin.
    public var commandId: Swift.String?
    /// The comment text for the command.
    public var comment: Swift.String?
    /// The name of the document that was run. For example, AWS-RunShellScript.
    public var documentName: Swift.String?
    /// The Systems Manager document (SSM document) version used in the request.
    public var documentVersion: Swift.String?
    /// Duration since ExecutionStartDateTime.
    public var executionElapsedTime: Swift.String?
    /// The date and time the plugin finished running. Date and time are written in ISO 8601 format. For example, June 7, 2017 is represented as 2017-06-7. The following sample Amazon Web Services CLI command uses the InvokedAfter filter. aws ssm list-commands --filters key=InvokedAfter,value=2017-06-07T00:00:00Z If the plugin hasn't started to run, the string is empty.
    public var executionEndDateTime: Swift.String?
    /// The date and time the plugin started running. Date and time are written in ISO 8601 format. For example, June 7, 2017 is represented as 2017-06-7. The following sample Amazon Web Services CLI command uses the InvokedBefore filter. aws ssm list-commands --filters key=InvokedBefore,value=2017-06-07T00:00:00Z If the plugin hasn't started to run, the string is empty.
    public var executionStartDateTime: Swift.String?
    /// The ID of the managed node targeted by the command. A managed node can be an Amazon Elastic Compute Cloud (Amazon EC2) instance, edge device, or on-premises server or VM in your hybrid environment that is configured for Amazon Web Services Systems Manager.
    public var instanceId: Swift.String?
    /// The name of the plugin, or step name, for which details are reported. For example, aws:RunShellScript is a plugin.
    public var pluginName: Swift.String?
    /// The error level response code for the plugin script. If the response code is -1, then the command hasn't started running on the managed node, or it wasn't received by the node.
    public var responseCode: Swift.Int
    /// The first 8,000 characters written by the plugin to stderr. If the command hasn't finished running, then this string is empty.
    public var standardErrorContent: Swift.String?
    /// The URL for the complete text written by the plugin to stderr. If the command hasn't finished running, then this string is empty.
    public var standardErrorUrl: Swift.String?
    /// The first 24,000 characters written by the plugin to stdout. If the command hasn't finished running, if ExecutionStatus is neither Succeeded nor Failed, then this string is empty.
    public var standardOutputContent: Swift.String?
    /// The URL for the complete text written by the plugin to stdout in Amazon Simple Storage Service (Amazon S3). If an S3 bucket wasn't specified, then this string is empty.
    public var standardOutputUrl: Swift.String?
    /// The status of this invocation plugin. This status can be different than StatusDetails.
    public var status: SsmClientTypes.CommandInvocationStatus?
    /// A detailed status of the command execution for an invocation. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
    ///
    /// * Pending: The command hasn't been sent to the managed node.
    ///
    /// * In Progress: The command has been sent to the managed node but hasn't reached a terminal state.
    ///
    /// * Delayed: The system attempted to send the command to the target, but the target wasn't available. The managed node might not be available because of network issues, because the node was stopped, or for similar reasons. The system will try to send the command again.
    ///
    /// * Success: The command or plugin ran successfully. This is a terminal state.
    ///
    /// * Delivery Timed Out: The command wasn't delivered to the managed node before the delivery timeout expired. Delivery timeouts don't count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
    ///
    /// * Execution Timed Out: The command started to run on the managed node, but the execution wasn't complete before the timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.
    ///
    /// * Failed: The command wasn't run successfully on the managed node. For a plugin, this indicates that the result code wasn't zero. For a command invocation, this indicates that the result code for one or more plugins wasn't zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.
    ///
    /// * Canceled: The command was terminated before it was completed. This is a terminal state.
    ///
    /// * Undeliverable: The command can't be delivered to the managed node. The node might not exist or might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit and don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
    ///
    /// * Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.
    public var statusDetails: Swift.String?

    public init (
        cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig? = nil,
        commandId: Swift.String? = nil,
        comment: Swift.String? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        executionElapsedTime: Swift.String? = nil,
        executionEndDateTime: Swift.String? = nil,
        executionStartDateTime: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        pluginName: Swift.String? = nil,
        responseCode: Swift.Int = 0,
        standardErrorContent: Swift.String? = nil,
        standardErrorUrl: Swift.String? = nil,
        standardOutputContent: Swift.String? = nil,
        standardOutputUrl: Swift.String? = nil,
        status: SsmClientTypes.CommandInvocationStatus? = nil,
        statusDetails: Swift.String? = nil
    )
    {
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.commandId = commandId
        self.comment = comment
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.executionElapsedTime = executionElapsedTime
        self.executionEndDateTime = executionEndDateTime
        self.executionStartDateTime = executionStartDateTime
        self.instanceId = instanceId
        self.pluginName = pluginName
        self.responseCode = responseCode
        self.standardErrorContent = standardErrorContent
        self.standardErrorUrl = standardErrorUrl
        self.standardOutputContent = standardOutputContent
        self.standardOutputUrl = standardOutputUrl
        self.status = status
        self.statusDetails = statusDetails
    }
}

struct GetCommandInvocationOutputResponseBody: Swift.Equatable {
    public let commandId: Swift.String?
    public let instanceId: Swift.String?
    public let comment: Swift.String?
    public let documentName: Swift.String?
    public let documentVersion: Swift.String?
    public let pluginName: Swift.String?
    public let responseCode: Swift.Int
    public let executionStartDateTime: Swift.String?
    public let executionElapsedTime: Swift.String?
    public let executionEndDateTime: Swift.String?
    public let status: SsmClientTypes.CommandInvocationStatus?
    public let statusDetails: Swift.String?
    public let standardOutputContent: Swift.String?
    public let standardOutputUrl: Swift.String?
    public let standardErrorContent: Swift.String?
    public let standardErrorUrl: Swift.String?
    public let cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
}

extension GetCommandInvocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case commandId = "CommandId"
        case comment = "Comment"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case executionElapsedTime = "ExecutionElapsedTime"
        case executionEndDateTime = "ExecutionEndDateTime"
        case executionStartDateTime = "ExecutionStartDateTime"
        case instanceId = "InstanceId"
        case pluginName = "PluginName"
        case responseCode = "ResponseCode"
        case standardErrorContent = "StandardErrorContent"
        case standardErrorUrl = "StandardErrorUrl"
        case standardOutputContent = "StandardOutputContent"
        case standardOutputUrl = "StandardOutputUrl"
        case status = "Status"
        case statusDetails = "StatusDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let pluginNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginName)
        pluginName = pluginNameDecoded
        let responseCodeDecoded = try containerValues.decode(Swift.Int.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let executionStartDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionStartDateTime)
        executionStartDateTime = executionStartDateTimeDecoded
        let executionElapsedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionElapsedTime)
        executionElapsedTime = executionElapsedTimeDecoded
        let executionEndDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionEndDateTime)
        executionEndDateTime = executionEndDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CommandInvocationStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let standardOutputContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardOutputContent)
        standardOutputContent = standardOutputContentDecoded
        let standardOutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardOutputUrl)
        standardOutputUrl = standardOutputUrlDecoded
        let standardErrorContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardErrorContent)
        standardErrorContent = standardErrorContentDecoded
        let standardErrorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardErrorUrl)
        standardErrorUrl = standardErrorUrlDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
    }
}

public struct GetConnectionStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionStatusOutputError>
}

extension GetConnectionStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectionStatusInput(target: \(Swift.String(describing: target)))"}
}

extension GetConnectionStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct GetConnectionStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionStatusOutputError>
}

public struct GetConnectionStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionStatusOutputError>
}

public struct GetConnectionStatusInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionStatusInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetConnectionStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectionStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionStatusOutputError>
}

public struct GetConnectionStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionStatusInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetConnectionStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectionStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionStatusOutputError>
}

public struct GetConnectionStatusInput: Swift.Equatable {
    /// The managed node ID.
    /// This member is required.
    public var target: Swift.String?

    public init (
        target: Swift.String? = nil
    )
    {
        self.target = target
    }
}

struct GetConnectionStatusInputBody: Swift.Equatable {
    public let target: Swift.String?
}

extension GetConnectionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension GetConnectionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectionStatusOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectionStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectionStatusOutputResponse(status: \(Swift.String(describing: status)), target: \(Swift.String(describing: target)))"}
}

extension GetConnectionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConnectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.target = output.target
        } else {
            self.status = nil
            self.target = nil
        }
    }
}

public struct GetConnectionStatusOutputResponse: Swift.Equatable {
    /// The status of the connection to the managed node. For example, 'Connected' or 'Not Connected'.
    public var status: SsmClientTypes.ConnectionStatus?
    /// The ID of the managed node to check connection status.
    public var target: Swift.String?

    public init (
        status: SsmClientTypes.ConnectionStatus? = nil,
        target: Swift.String? = nil
    )
    {
        self.status = status
        self.target = target
    }
}

struct GetConnectionStatusOutputResponseBody: Swift.Equatable {
    public let target: Swift.String?
    public let status: SsmClientTypes.ConnectionStatus?
}

extension GetConnectionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct GetDefaultPatchBaselineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDefaultPatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDefaultPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDefaultPatchBaselineOutputError>
}

extension GetDefaultPatchBaselineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDefaultPatchBaselineInput(operatingSystem: \(Swift.String(describing: operatingSystem)))"}
}

extension GetDefaultPatchBaselineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operatingSystem = "OperatingSystem"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
    }
}

public struct GetDefaultPatchBaselineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDefaultPatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDefaultPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDefaultPatchBaselineOutputError>
}

public struct GetDefaultPatchBaselineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDefaultPatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDefaultPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDefaultPatchBaselineOutputError>
}

public struct GetDefaultPatchBaselineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDefaultPatchBaselineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDefaultPatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDefaultPatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDefaultPatchBaselineOutputError>
}

public struct GetDefaultPatchBaselineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDefaultPatchBaselineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDefaultPatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDefaultPatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDefaultPatchBaselineOutputError>
}

public struct GetDefaultPatchBaselineInput: Swift.Equatable {
    /// Returns the default patch baseline for the specified operating system.
    public var operatingSystem: SsmClientTypes.OperatingSystem?

    public init (
        operatingSystem: SsmClientTypes.OperatingSystem? = nil
    )
    {
        self.operatingSystem = operatingSystem
    }
}

struct GetDefaultPatchBaselineInputBody: Swift.Equatable {
    public let operatingSystem: SsmClientTypes.OperatingSystem?
}

extension GetDefaultPatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operatingSystem = "OperatingSystem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension GetDefaultPatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDefaultPatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDefaultPatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDefaultPatchBaselineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDefaultPatchBaselineOutputResponse(baselineId: \(Swift.String(describing: baselineId)), operatingSystem: \(Swift.String(describing: operatingSystem)))"}
}

extension GetDefaultPatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDefaultPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
            self.operatingSystem = output.operatingSystem
        } else {
            self.baselineId = nil
            self.operatingSystem = nil
        }
    }
}

public struct GetDefaultPatchBaselineOutputResponse: Swift.Equatable {
    /// The ID of the default patch baseline.
    public var baselineId: Swift.String?
    /// The operating system for the returned patch baseline.
    public var operatingSystem: SsmClientTypes.OperatingSystem?

    public init (
        baselineId: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil
    )
    {
        self.baselineId = baselineId
        self.operatingSystem = operatingSystem
    }
}

struct GetDefaultPatchBaselineOutputResponseBody: Swift.Equatable {
    public let baselineId: Swift.String?
    public let operatingSystem: SsmClientTypes.OperatingSystem?
}

extension GetDefaultPatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case operatingSystem = "OperatingSystem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

public struct GetDeployablePatchSnapshotForInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeployablePatchSnapshotForInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeployablePatchSnapshotForInstanceOutputError>
}

extension GetDeployablePatchSnapshotForInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeployablePatchSnapshotForInstanceInput(baselineOverride: \(Swift.String(describing: baselineOverride)), instanceId: \(Swift.String(describing: instanceId)), snapshotId: \(Swift.String(describing: snapshotId)))"}
}

extension GetDeployablePatchSnapshotForInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineOverride = "BaselineOverride"
        case instanceId = "InstanceId"
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineOverride = baselineOverride {
            try encodeContainer.encode(baselineOverride, forKey: .baselineOverride)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }
}

public struct GetDeployablePatchSnapshotForInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeployablePatchSnapshotForInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeployablePatchSnapshotForInstanceOutputError>
}

public struct GetDeployablePatchSnapshotForInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeployablePatchSnapshotForInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeployablePatchSnapshotForInstanceOutputError>
}

public struct GetDeployablePatchSnapshotForInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeployablePatchSnapshotForInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDeployablePatchSnapshotForInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeployablePatchSnapshotForInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeployablePatchSnapshotForInstanceOutputError>
}

public struct GetDeployablePatchSnapshotForInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeployablePatchSnapshotForInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDeployablePatchSnapshotForInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeployablePatchSnapshotForInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeployablePatchSnapshotForInstanceOutputError>
}

public struct GetDeployablePatchSnapshotForInstanceInput: Swift.Equatable {
    /// Defines the basic information about a patch baseline override.
    public var baselineOverride: SsmClientTypes.BaselineOverride?
    /// The ID of the managed node for which the appropriate patch snapshot should be retrieved.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The snapshot ID provided by the user when running AWS-RunPatchBaseline.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init (
        baselineOverride: SsmClientTypes.BaselineOverride? = nil,
        instanceId: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.baselineOverride = baselineOverride
        self.instanceId = instanceId
        self.snapshotId = snapshotId
    }
}

struct GetDeployablePatchSnapshotForInstanceInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let snapshotId: Swift.String?
    public let baselineOverride: SsmClientTypes.BaselineOverride?
}

extension GetDeployablePatchSnapshotForInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineOverride = "BaselineOverride"
        case instanceId = "InstanceId"
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let baselineOverrideDecoded = try containerValues.decodeIfPresent(SsmClientTypes.BaselineOverride.self, forKey: .baselineOverride)
        baselineOverride = baselineOverrideDecoded
    }
}

extension GetDeployablePatchSnapshotForInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeployablePatchSnapshotForInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedFeatureRequiredException" : self = .unsupportedFeatureRequiredException(try UnsupportedFeatureRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperatingSystem" : self = .unsupportedOperatingSystem(try UnsupportedOperatingSystem(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeployablePatchSnapshotForInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unsupportedFeatureRequiredException(UnsupportedFeatureRequiredException)
    case unsupportedOperatingSystem(UnsupportedOperatingSystem)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeployablePatchSnapshotForInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeployablePatchSnapshotForInstanceOutputResponse(instanceId: \(Swift.String(describing: instanceId)), product: \(Swift.String(describing: product)), snapshotDownloadUrl: \(Swift.String(describing: snapshotDownloadUrl)), snapshotId: \(Swift.String(describing: snapshotId)))"}
}

extension GetDeployablePatchSnapshotForInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeployablePatchSnapshotForInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceId = output.instanceId
            self.product = output.product
            self.snapshotDownloadUrl = output.snapshotDownloadUrl
            self.snapshotId = output.snapshotId
        } else {
            self.instanceId = nil
            self.product = nil
            self.snapshotDownloadUrl = nil
            self.snapshotId = nil
        }
    }
}

public struct GetDeployablePatchSnapshotForInstanceOutputResponse: Swift.Equatable {
    /// The managed node ID.
    public var instanceId: Swift.String?
    /// Returns the specific operating system (for example Windows Server 2012 or Amazon Linux 2015.09) on the managed node for the specified patch snapshot.
    public var product: Swift.String?
    /// A pre-signed Amazon Simple Storage Service (Amazon S3) URL that can be used to download the patch snapshot.
    public var snapshotDownloadUrl: Swift.String?
    /// The user-defined snapshot ID.
    public var snapshotId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        product: Swift.String? = nil,
        snapshotDownloadUrl: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.product = product
        self.snapshotDownloadUrl = snapshotDownloadUrl
        self.snapshotId = snapshotId
    }
}

struct GetDeployablePatchSnapshotForInstanceOutputResponseBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let snapshotId: Swift.String?
    public let snapshotDownloadUrl: Swift.String?
    public let product: Swift.String?
}

extension GetDeployablePatchSnapshotForInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case product = "Product"
        case snapshotDownloadUrl = "SnapshotDownloadUrl"
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let snapshotDownloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotDownloadUrl)
        snapshotDownloadUrl = snapshotDownloadUrlDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
    }
}

public struct GetDocumentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentOutputError>
}

extension GetDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentInput(documentFormat: \(Swift.String(describing: documentFormat)), documentVersion: \(Swift.String(describing: documentVersion)), name: \(Swift.String(describing: name)), versionName: \(Swift.String(describing: versionName)))"}
}

extension GetDocumentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

public struct GetDocumentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentOutputError>
}

public struct GetDocumentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentOutputError>
}

public struct GetDocumentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDocumentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDocumentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentOutputError>
}

public struct GetDocumentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDocumentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDocumentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDocumentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDocumentOutputError>
}

public struct GetDocumentInput: Swift.Equatable {
    /// Returns the document in the specified format. The document format can be either JSON or YAML. JSON is the default format.
    public var documentFormat: SsmClientTypes.DocumentFormat?
    /// The document version for which you want information.
    public var documentVersion: Swift.String?
    /// The name of the SSM document.
    /// This member is required.
    public var name: Swift.String?
    /// An optional field specifying the version of the artifact associated with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document and can't be changed.
    public var versionName: Swift.String?

    public init (
        documentFormat: SsmClientTypes.DocumentFormat? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.documentFormat = documentFormat
        self.documentVersion = documentVersion
        self.name = name
        self.versionName = versionName
    }
}

struct GetDocumentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let versionName: Swift.String?
    public let documentVersion: Swift.String?
    public let documentFormat: SsmClientTypes.DocumentFormat?
}

extension GetDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
    }
}

extension GetDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentOutputResponse(attachmentsContent: \(Swift.String(describing: attachmentsContent)), content: \(Swift.String(describing: content)), createdDate: \(Swift.String(describing: createdDate)), displayName: \(Swift.String(describing: displayName)), documentFormat: \(Swift.String(describing: documentFormat)), documentType: \(Swift.String(describing: documentType)), documentVersion: \(Swift.String(describing: documentVersion)), name: \(Swift.String(describing: name)), requires: \(Swift.String(describing: requires)), reviewStatus: \(Swift.String(describing: reviewStatus)), status: \(Swift.String(describing: status)), statusInformation: \(Swift.String(describing: statusInformation)), versionName: \(Swift.String(describing: versionName)))"}
}

extension GetDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachmentsContent = output.attachmentsContent
            self.content = output.content
            self.createdDate = output.createdDate
            self.displayName = output.displayName
            self.documentFormat = output.documentFormat
            self.documentType = output.documentType
            self.documentVersion = output.documentVersion
            self.name = output.name
            self.requires = output.requires
            self.reviewStatus = output.reviewStatus
            self.status = output.status
            self.statusInformation = output.statusInformation
            self.versionName = output.versionName
        } else {
            self.attachmentsContent = nil
            self.content = nil
            self.createdDate = nil
            self.displayName = nil
            self.documentFormat = nil
            self.documentType = nil
            self.documentVersion = nil
            self.name = nil
            self.requires = nil
            self.reviewStatus = nil
            self.status = nil
            self.statusInformation = nil
            self.versionName = nil
        }
    }
}

public struct GetDocumentOutputResponse: Swift.Equatable {
    /// A description of the document attachments, including names, locations, sizes, and so on.
    public var attachmentsContent: [SsmClientTypes.AttachmentContent]?
    /// The contents of the SSM document.
    public var content: Swift.String?
    /// The date the SSM document was created.
    public var createdDate: ClientRuntime.Date?
    /// The friendly name of the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
    public var displayName: Swift.String?
    /// The document format, either JSON or YAML.
    public var documentFormat: SsmClientTypes.DocumentFormat?
    /// The document type.
    public var documentType: SsmClientTypes.DocumentType?
    /// The document version.
    public var documentVersion: Swift.String?
    /// The name of the SSM document.
    public var name: Swift.String?
    /// A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.
    public var requires: [SsmClientTypes.DocumentRequires]?
    /// The current review status of a new custom Systems Manager document (SSM document) created by a member of your organization, or of the latest version of an existing SSM document. Only one version of an SSM document can be in the APPROVED state at a time. When a new version is approved, the status of the previous version changes to REJECTED. Only one version of an SSM document can be in review, or PENDING, at a time.
    public var reviewStatus: SsmClientTypes.ReviewStatus?
    /// The status of the SSM document, such as Creating, Active, Updating, Failed, and Deleting.
    public var status: SsmClientTypes.DocumentStatus?
    /// A message returned by Amazon Web Services Systems Manager that explains the Status value. For example, a Failed status might be explained by the StatusInformation message, "The specified S3 bucket doesn't exist. Verify that the URL of the S3 bucket is correct."
    public var statusInformation: Swift.String?
    /// The version of the artifact associated with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init (
        attachmentsContent: [SsmClientTypes.AttachmentContent]? = nil,
        content: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        documentFormat: SsmClientTypes.DocumentFormat? = nil,
        documentType: SsmClientTypes.DocumentType? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        requires: [SsmClientTypes.DocumentRequires]? = nil,
        reviewStatus: SsmClientTypes.ReviewStatus? = nil,
        status: SsmClientTypes.DocumentStatus? = nil,
        statusInformation: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attachmentsContent = attachmentsContent
        self.content = content
        self.createdDate = createdDate
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentType = documentType
        self.documentVersion = documentVersion
        self.name = name
        self.requires = requires
        self.reviewStatus = reviewStatus
        self.status = status
        self.statusInformation = statusInformation
        self.versionName = versionName
    }
}

struct GetDocumentOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let createdDate: ClientRuntime.Date?
    public let displayName: Swift.String?
    public let versionName: Swift.String?
    public let documentVersion: Swift.String?
    public let status: SsmClientTypes.DocumentStatus?
    public let statusInformation: Swift.String?
    public let content: Swift.String?
    public let documentType: SsmClientTypes.DocumentType?
    public let documentFormat: SsmClientTypes.DocumentFormat?
    public let requires: [SsmClientTypes.DocumentRequires]?
    public let attachmentsContent: [SsmClientTypes.AttachmentContent]?
    public let reviewStatus: SsmClientTypes.ReviewStatus?
}

extension GetDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentsContent = "AttachmentsContent"
        case content = "Content"
        case createdDate = "CreatedDate"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case requires = "Requires"
        case reviewStatus = "ReviewStatus"
        case status = "Status"
        case statusInformation = "StatusInformation"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentStatus.self, forKey: .status)
        status = statusDecoded
        let statusInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusInformation)
        statusInformation = statusInformationDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let requiresContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[SsmClientTypes.DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [SsmClientTypes.DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let attachmentsContentContainer = try containerValues.decodeIfPresent([SsmClientTypes.AttachmentContent?].self, forKey: .attachmentsContent)
        var attachmentsContentDecoded0:[SsmClientTypes.AttachmentContent]? = nil
        if let attachmentsContentContainer = attachmentsContentContainer {
            attachmentsContentDecoded0 = [SsmClientTypes.AttachmentContent]()
            for structure0 in attachmentsContentContainer {
                if let structure0 = structure0 {
                    attachmentsContentDecoded0?.append(structure0)
                }
            }
        }
        attachmentsContent = attachmentsContentDecoded0
        let reviewStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
    }
}

public struct GetInventoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInventoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInventoryOutputError>
}

extension GetInventoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInventoryInput(aggregators: \(Swift.String(describing: aggregators)), filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resultAttributes: \(Swift.String(describing: resultAttributes)))"}
}

extension GetInventoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for inventoryaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(inventoryaggregatorlist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resultAttributes = resultAttributes {
            var resultAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultAttributes)
            for resultattributelist0 in resultAttributes {
                try resultAttributesContainer.encode(resultattributelist0)
            }
        }
    }
}

public struct GetInventoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInventoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInventoryOutputError>
}

public struct GetInventoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInventoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInventoryOutputError>
}

public struct GetInventoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInventoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetInventoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInventoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInventoryOutputError>
}

public struct GetInventoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInventoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetInventoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInventoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInventoryOutputError>
}

public struct GetInventoryInput: Swift.Equatable {
    /// Returns counts of inventory types based on one or more expressions. For example, if you aggregate by using an expression that uses the AWS:InstanceInformation.PlatformType type, you can see a count of how many Windows and Linux managed nodes exist in your inventoried fleet.
    public var aggregators: [SsmClientTypes.InventoryAggregator]?
    /// One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.InventoryFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The list of inventory item types to return.
    public var resultAttributes: [SsmClientTypes.ResultAttribute]?

    public init (
        aggregators: [SsmClientTypes.InventoryAggregator]? = nil,
        filters: [SsmClientTypes.InventoryFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resultAttributes: [SsmClientTypes.ResultAttribute]? = nil
    )
    {
        self.aggregators = aggregators
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resultAttributes = resultAttributes
    }
}

struct GetInventoryInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.InventoryFilter]?
    public let aggregators: [SsmClientTypes.InventoryAggregator]?
    public let resultAttributes: [SsmClientTypes.ResultAttribute]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension GetInventoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let aggregatorsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[SsmClientTypes.InventoryAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [SsmClientTypes.InventoryAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
        let resultAttributesContainer = try containerValues.decodeIfPresent([SsmClientTypes.ResultAttribute?].self, forKey: .resultAttributes)
        var resultAttributesDecoded0:[SsmClientTypes.ResultAttribute]? = nil
        if let resultAttributesContainer = resultAttributesContainer {
            resultAttributesDecoded0 = [SsmClientTypes.ResultAttribute]()
            for structure0 in resultAttributesContainer {
                if let structure0 = structure0 {
                    resultAttributesDecoded0?.append(structure0)
                }
            }
        }
        resultAttributes = resultAttributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetInventoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInventoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAggregator" : self = .invalidAggregatorException(try InvalidAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInventoryGroup" : self = .invalidInventoryGroupException(try InvalidInventoryGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResultAttribute" : self = .invalidResultAttributeException(try InvalidResultAttributeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInventoryOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidAggregatorException(InvalidAggregatorException)
    case invalidFilter(InvalidFilter)
    case invalidInventoryGroupException(InvalidInventoryGroupException)
    case invalidNextToken(InvalidNextToken)
    case invalidResultAttributeException(InvalidResultAttributeException)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInventoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInventoryOutputResponse(entities: \(Swift.String(describing: entities)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetInventoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInventoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct GetInventoryOutputResponse: Swift.Equatable {
    /// Collection of inventory entities such as a collection of managed node inventory.
    public var entities: [SsmClientTypes.InventoryResultEntity]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        entities: [SsmClientTypes.InventoryResultEntity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct GetInventoryOutputResponseBody: Swift.Equatable {
    public let entities: [SsmClientTypes.InventoryResultEntity]?
    public let nextToken: Swift.String?
}

extension GetInventoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryResultEntity?].self, forKey: .entities)
        var entitiesDecoded0:[SsmClientTypes.InventoryResultEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [SsmClientTypes.InventoryResultEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetInventorySchemaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInventorySchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInventorySchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInventorySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInventorySchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInventorySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInventorySchemaOutputError>
}

extension GetInventorySchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInventorySchemaInput(aggregator: \(Swift.String(describing: aggregator)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), subType: \(Swift.String(describing: subType)), typeName: \(Swift.String(describing: typeName)))"}
}

extension GetInventorySchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregator = "Aggregator"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subType = "SubType"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if aggregator != false {
            try encodeContainer.encode(aggregator, forKey: .aggregator)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if subType != false {
            try encodeContainer.encode(subType, forKey: .subType)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }
}

public struct GetInventorySchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInventorySchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInventorySchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInventorySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInventorySchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInventorySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInventorySchemaOutputError>
}

public struct GetInventorySchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInventorySchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInventorySchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInventorySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInventorySchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInventorySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInventorySchemaOutputError>
}

public struct GetInventorySchemaInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInventorySchemaInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetInventorySchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInventorySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInventorySchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInventorySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInventorySchemaOutputError>
}

public struct GetInventorySchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInventorySchemaInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetInventorySchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInventorySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInventorySchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInventorySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInventorySchemaOutputError>
}

public struct GetInventorySchemaInput: Swift.Equatable {
    /// Returns inventory schemas that support aggregation. For example, this call returns the AWS:InstanceInformation type, because it supports aggregation based on the PlatformName, PlatformType, and PlatformVersion attributes.
    public var aggregator: Swift.Bool
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Returns the sub-type schema for a specified inventory type.
    public var subType: Swift.Bool
    /// The type of inventory item to return.
    public var typeName: Swift.String?

    public init (
        aggregator: Swift.Bool = false,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        subType: Swift.Bool = false,
        typeName: Swift.String? = nil
    )
    {
        self.aggregator = aggregator
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subType = subType
        self.typeName = typeName
    }
}

struct GetInventorySchemaInputBody: Swift.Equatable {
    public let typeName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
    public let aggregator: Swift.Bool
    public let subType: Swift.Bool
}

extension GetInventorySchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregator = "Aggregator"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subType = "SubType"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let aggregatorDecoded = try containerValues.decode(Swift.Bool.self, forKey: .aggregator)
        aggregator = aggregatorDecoded
        let subTypeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .subType)
        subType = subTypeDecoded
    }
}

extension GetInventorySchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInventorySchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInventorySchemaOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInventorySchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInventorySchemaOutputResponse(nextToken: \(Swift.String(describing: nextToken)), schemas: \(Swift.String(describing: schemas)))"}
}

extension GetInventorySchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInventorySchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct GetInventorySchemaOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Inventory schemas returned by the request.
    public var schemas: [SsmClientTypes.InventoryItemSchema]?

    public init (
        nextToken: Swift.String? = nil,
        schemas: [SsmClientTypes.InventoryItemSchema]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct GetInventorySchemaOutputResponseBody: Swift.Equatable {
    public let schemas: [SsmClientTypes.InventoryItemSchema]?
    public let nextToken: Swift.String?
}

extension GetInventorySchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryItemSchema?].self, forKey: .schemas)
        var schemasDecoded0:[SsmClientTypes.InventoryItemSchema]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SsmClientTypes.InventoryItemSchema]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetMaintenanceWindowExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionOutputError>
}

extension GetMaintenanceWindowExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowExecutionInput(windowExecutionId: \(Swift.String(describing: windowExecutionId)))"}
}

extension GetMaintenanceWindowExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct GetMaintenanceWindowExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionOutputError>
}

public struct GetMaintenanceWindowExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionOutputError>
}

public struct GetMaintenanceWindowExecutionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMaintenanceWindowExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMaintenanceWindowExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionOutputError>
}

public struct GetMaintenanceWindowExecutionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMaintenanceWindowExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMaintenanceWindowExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionOutputError>
}

public struct GetMaintenanceWindowExecutionInput: Swift.Equatable {
    /// The ID of the maintenance window execution that includes the task.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        windowExecutionId: Swift.String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionInputBody: Swift.Equatable {
    public let windowExecutionId: Swift.String?
}

extension GetMaintenanceWindowExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
    }
}

extension GetMaintenanceWindowExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowExecutionOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowExecutionOutputResponse(endTime: \(Swift.String(describing: endTime)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), taskIds: \(Swift.String(describing: taskIds)), windowExecutionId: \(Swift.String(describing: windowExecutionId)))"}
}

extension GetMaintenanceWindowExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMaintenanceWindowExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.startTime = output.startTime
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.taskIds = output.taskIds
            self.windowExecutionId = output.windowExecutionId
        } else {
            self.endTime = nil
            self.startTime = nil
            self.status = nil
            self.statusDetails = nil
            self.taskIds = nil
            self.windowExecutionId = nil
        }
    }
}

public struct GetMaintenanceWindowExecutionOutputResponse: Swift.Equatable {
    /// The time the maintenance window finished running.
    public var endTime: ClientRuntime.Date?
    /// The time the maintenance window started running.
    public var startTime: ClientRuntime.Date?
    /// The status of the maintenance window execution.
    public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    /// The details explaining the status. Not available for all status values.
    public var statusDetails: Swift.String?
    /// The ID of the task executions from the maintenance window execution.
    public var taskIds: [Swift.String]?
    /// The ID of the maintenance window execution.
    public var windowExecutionId: Swift.String?

    public init (
        endTime: ClientRuntime.Date? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
        statusDetails: Swift.String? = nil,
        taskIds: [Swift.String]? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskIds = taskIds
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionOutputResponseBody: Swift.Equatable {
    public let windowExecutionId: Swift.String?
    public let taskIds: [Swift.String]?
    public let status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    public let statusDetails: Swift.String?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
}

extension GetMaintenanceWindowExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskIds = "TaskIds"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .taskIds)
        var taskIdsDecoded0:[Swift.String]? = nil
        if let taskIdsContainer = taskIdsContainer {
            taskIdsDecoded0 = [Swift.String]()
            for string0 in taskIdsContainer {
                if let string0 = string0 {
                    taskIdsDecoded0?.append(string0)
                }
            }
        }
        taskIds = taskIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

public struct GetMaintenanceWindowExecutionTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionTaskOutputError>
}

extension GetMaintenanceWindowExecutionTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowExecutionTaskInput(taskId: \(Swift.String(describing: taskId)), windowExecutionId: \(Swift.String(describing: windowExecutionId)))"}
}

extension GetMaintenanceWindowExecutionTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct GetMaintenanceWindowExecutionTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionTaskOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionTaskOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionTaskInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMaintenanceWindowExecutionTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMaintenanceWindowExecutionTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionTaskOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionTaskInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMaintenanceWindowExecutionTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMaintenanceWindowExecutionTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionTaskOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInput: Swift.Equatable {
    /// The ID of the specific task execution in the maintenance window task that should be retrieved.
    /// This member is required.
    public var taskId: Swift.String?
    /// The ID of the maintenance window execution that includes the task.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        taskId: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionTaskInputBody: Swift.Equatable {
    public let windowExecutionId: Swift.String?
    public let taskId: Swift.String?
}

extension GetMaintenanceWindowExecutionTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

public struct GetMaintenanceWindowExecutionTaskInvocationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionTaskInvocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionTaskInvocationOutputError>
}

extension GetMaintenanceWindowExecutionTaskInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowExecutionTaskInvocationInput(invocationId: \(Swift.String(describing: invocationId)), taskId: \(Swift.String(describing: taskId)), windowExecutionId: \(Swift.String(describing: windowExecutionId)))"}
}

extension GetMaintenanceWindowExecutionTaskInvocationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationId = "InvocationId"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invocationId = invocationId {
            try encodeContainer.encode(invocationId, forKey: .invocationId)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct GetMaintenanceWindowExecutionTaskInvocationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionTaskInvocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionTaskInvocationOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInvocationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionTaskInvocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionTaskInvocationOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInvocationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionTaskInvocationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMaintenanceWindowExecutionTaskInvocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMaintenanceWindowExecutionTaskInvocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionTaskInvocationOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInvocationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowExecutionTaskInvocationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMaintenanceWindowExecutionTaskInvocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMaintenanceWindowExecutionTaskInvocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowExecutionTaskInvocationOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInvocationInput: Swift.Equatable {
    /// The invocation ID to retrieve.
    /// This member is required.
    public var invocationId: Swift.String?
    /// The ID of the specific task in the maintenance window task that should be retrieved.
    /// This member is required.
    public var taskId: Swift.String?
    /// The ID of the maintenance window execution for which the task is a part.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        invocationId: Swift.String? = nil,
        taskId: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.invocationId = invocationId
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionTaskInvocationInputBody: Swift.Equatable {
    public let windowExecutionId: Swift.String?
    public let taskId: Swift.String?
    public let invocationId: Swift.String?
}

extension GetMaintenanceWindowExecutionTaskInvocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationId = "InvocationId"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let invocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowExecutionTaskInvocationOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowExecutionTaskInvocationOutputResponse(endTime: \(Swift.String(describing: endTime)), executionId: \(Swift.String(describing: executionId)), invocationId: \(Swift.String(describing: invocationId)), ownerInformation: \(Swift.String(describing: ownerInformation)), parameters: \(Swift.String(describing: parameters)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), taskExecutionId: \(Swift.String(describing: taskExecutionId)), taskType: \(Swift.String(describing: taskType)), windowExecutionId: \(Swift.String(describing: windowExecutionId)), windowTargetId: \(Swift.String(describing: windowTargetId)))"}
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMaintenanceWindowExecutionTaskInvocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.executionId = output.executionId
            self.invocationId = output.invocationId
            self.ownerInformation = output.ownerInformation
            self.parameters = output.parameters
            self.startTime = output.startTime
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.taskExecutionId = output.taskExecutionId
            self.taskType = output.taskType
            self.windowExecutionId = output.windowExecutionId
            self.windowTargetId = output.windowTargetId
        } else {
            self.endTime = nil
            self.executionId = nil
            self.invocationId = nil
            self.ownerInformation = nil
            self.parameters = nil
            self.startTime = nil
            self.status = nil
            self.statusDetails = nil
            self.taskExecutionId = nil
            self.taskType = nil
            self.windowExecutionId = nil
            self.windowTargetId = nil
        }
    }
}

public struct GetMaintenanceWindowExecutionTaskInvocationOutputResponse: Swift.Equatable {
    /// The time that the task finished running on the target.
    public var endTime: ClientRuntime.Date?
    /// The execution ID.
    public var executionId: Swift.String?
    /// The invocation ID.
    public var invocationId: Swift.String?
    /// User-provided value to be included in any Amazon CloudWatch Events or Amazon EventBridge events raised while running tasks for these targets in this maintenance window.
    public var ownerInformation: Swift.String?
    /// The parameters used at the time that the task ran.
    public var parameters: Swift.String?
    /// The time that the task started running on the target.
    public var startTime: ClientRuntime.Date?
    /// The task status for an invocation.
    public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    /// The details explaining the status. Details are only available for certain status values.
    public var statusDetails: Swift.String?
    /// The task execution ID.
    public var taskExecutionId: Swift.String?
    /// Retrieves the task type for a maintenance window.
    public var taskType: SsmClientTypes.MaintenanceWindowTaskType?
    /// The maintenance window execution ID.
    public var windowExecutionId: Swift.String?
    /// The maintenance window target ID.
    public var windowTargetId: Swift.String?

    public init (
        endTime: ClientRuntime.Date? = nil,
        executionId: Swift.String? = nil,
        invocationId: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        parameters: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
        statusDetails: Swift.String? = nil,
        taskExecutionId: Swift.String? = nil,
        taskType: SsmClientTypes.MaintenanceWindowTaskType? = nil,
        windowExecutionId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.executionId = executionId
        self.invocationId = invocationId
        self.ownerInformation = ownerInformation
        self.parameters = parameters
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskExecutionId = taskExecutionId
        self.taskType = taskType
        self.windowExecutionId = windowExecutionId
        self.windowTargetId = windowTargetId
    }
}

struct GetMaintenanceWindowExecutionTaskInvocationOutputResponseBody: Swift.Equatable {
    public let windowExecutionId: Swift.String?
    public let taskExecutionId: Swift.String?
    public let invocationId: Swift.String?
    public let executionId: Swift.String?
    public let taskType: SsmClientTypes.MaintenanceWindowTaskType?
    public let parameters: Swift.String?
    public let status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    public let statusDetails: Swift.String?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let ownerInformation: Swift.String?
    public let windowTargetId: Swift.String?
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case executionId = "ExecutionId"
        case invocationId = "InvocationId"
        case ownerInformation = "OwnerInformation"
        case parameters = "Parameters"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskExecutionId = "TaskExecutionId"
        case taskType = "TaskType"
        case windowExecutionId = "WindowExecutionId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let invocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

extension GetMaintenanceWindowExecutionTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowExecutionTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowExecutionTaskOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowExecutionTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowExecutionTaskOutputResponse(endTime: \(Swift.String(describing: endTime)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), priority: \(Swift.String(describing: priority)), serviceRole: \(Swift.String(describing: serviceRole)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), taskArn: \(Swift.String(describing: taskArn)), taskExecutionId: \(Swift.String(describing: taskExecutionId)), taskParameters: \(Swift.String(describing: taskParameters)), type: \(Swift.String(describing: type)), windowExecutionId: \(Swift.String(describing: windowExecutionId)))"}
}

extension GetMaintenanceWindowExecutionTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMaintenanceWindowExecutionTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.maxConcurrency = output.maxConcurrency
            self.maxErrors = output.maxErrors
            self.priority = output.priority
            self.serviceRole = output.serviceRole
            self.startTime = output.startTime
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.taskArn = output.taskArn
            self.taskExecutionId = output.taskExecutionId
            self.taskParameters = output.taskParameters
            self.type = output.type
            self.windowExecutionId = output.windowExecutionId
        } else {
            self.endTime = nil
            self.maxConcurrency = nil
            self.maxErrors = nil
            self.priority = 0
            self.serviceRole = nil
            self.startTime = nil
            self.status = nil
            self.statusDetails = nil
            self.taskArn = nil
            self.taskExecutionId = nil
            self.taskParameters = nil
            self.type = nil
            self.windowExecutionId = nil
        }
    }
}

public struct GetMaintenanceWindowExecutionTaskOutputResponse: Swift.Equatable {
    /// The time the task execution completed.
    public var endTime: ClientRuntime.Date?
    /// The defined maximum number of task executions that could be run in parallel.
    public var maxConcurrency: Swift.String?
    /// The defined maximum number of task execution errors allowed before scheduling of the task execution would have been stopped.
    public var maxErrors: Swift.String?
    /// The priority of the task.
    public var priority: Swift.Int
    /// The role that was assumed when running the task.
    public var serviceRole: Swift.String?
    /// The time the task execution started.
    public var startTime: ClientRuntime.Date?
    /// The status of the task.
    public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    /// The details explaining the status. Not available for all status values.
    public var statusDetails: Swift.String?
    /// The Amazon Resource Name (ARN) of the task that ran.
    public var taskArn: Swift.String?
    /// The ID of the specific task execution in the maintenance window task that was retrieved.
    public var taskExecutionId: Swift.String?
    /// The parameters passed to the task when it was run. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. The map has the following format:
    ///
    /// * Key: string, between 1 and 255 characters
    ///
    /// * Value: an array of strings, each between 1 and 255 characters
    public var taskParameters: [[Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]]?
    /// The type of task that was run.
    public var type: SsmClientTypes.MaintenanceWindowTaskType?
    /// The ID of the maintenance window execution that includes the task.
    public var windowExecutionId: Swift.String?

    public init (
        endTime: ClientRuntime.Date? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRole: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
        statusDetails: Swift.String? = nil,
        taskArn: Swift.String? = nil,
        taskExecutionId: Swift.String? = nil,
        taskParameters: [[Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]]? = nil,
        type: SsmClientTypes.MaintenanceWindowTaskType? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.priority = priority
        self.serviceRole = serviceRole
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskArn = taskArn
        self.taskExecutionId = taskExecutionId
        self.taskParameters = taskParameters
        self.type = type
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionTaskOutputResponseBody: Swift.Equatable {
    public let windowExecutionId: Swift.String?
    public let taskExecutionId: Swift.String?
    public let taskArn: Swift.String?
    public let serviceRole: Swift.String?
    public let type: SsmClientTypes.MaintenanceWindowTaskType?
    public let taskParameters: [[Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]]?
    public let priority: Swift.Int
    public let maxConcurrency: Swift.String?
    public let maxErrors: Swift.String?
    public let status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    public let statusDetails: Swift.String?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
}

extension GetMaintenanceWindowExecutionTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case priority = "Priority"
        case serviceRole = "ServiceRole"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskArn = "TaskArn"
        case taskExecutionId = "TaskExecutionId"
        case taskParameters = "TaskParameters"
        case type = "Type"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .type)
        type = typeDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([[Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?]?].self, forKey: .taskParameters)
        var taskParametersDecoded0:[[Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [[Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]]()
            for map0 in taskParametersContainer {
                var taskParametersContainerDecoded0: [Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
                if let map0 = map0 {
                    taskParametersContainerDecoded0 = [Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
                    for (key1, maintenancewindowtaskparametervalueexpression1) in map0 {
                        if let maintenancewindowtaskparametervalueexpression1 = maintenancewindowtaskparametervalueexpression1 {
                            taskParametersContainerDecoded0?[key1] = maintenancewindowtaskparametervalueexpression1
                        }
                    }
                }
                if let taskParametersContainerDecoded0 = taskParametersContainerDecoded0 {
                    taskParametersDecoded0?.append(taskParametersContainerDecoded0)
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

public struct GetMaintenanceWindowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowOutputError>
}

extension GetMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowInput(windowId: \(Swift.String(describing: windowId)))"}
}

extension GetMaintenanceWindowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct GetMaintenanceWindowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowOutputError>
}

public struct GetMaintenanceWindowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowOutputError>
}

public struct GetMaintenanceWindowInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowOutputError>
}

public struct GetMaintenanceWindowInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowOutputError>
}

public struct GetMaintenanceWindowInput: Swift.Equatable {
    /// The ID of the maintenance window for which you want to retrieve information.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct GetMaintenanceWindowInputBody: Swift.Equatable {
    public let windowId: Swift.String?
}

extension GetMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

extension GetMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowOutputResponse(allowUnassociatedTargets: \(Swift.String(describing: allowUnassociatedTargets)), createdDate: \(Swift.String(describing: createdDate)), cutoff: \(Swift.String(describing: cutoff)), description: \(Swift.String(describing: description)), duration: \(Swift.String(describing: duration)), enabled: \(Swift.String(describing: enabled)), endDate: \(Swift.String(describing: endDate)), modifiedDate: \(Swift.String(describing: modifiedDate)), name: \(Swift.String(describing: name)), nextExecutionTime: \(Swift.String(describing: nextExecutionTime)), schedule: \(Swift.String(describing: schedule)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleTimezone: \(Swift.String(describing: scheduleTimezone)), startDate: \(Swift.String(describing: startDate)), windowId: \(Swift.String(describing: windowId)))"}
}

extension GetMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowUnassociatedTargets = output.allowUnassociatedTargets
            self.createdDate = output.createdDate
            self.cutoff = output.cutoff
            self.description = output.description
            self.duration = output.duration
            self.enabled = output.enabled
            self.endDate = output.endDate
            self.modifiedDate = output.modifiedDate
            self.name = output.name
            self.nextExecutionTime = output.nextExecutionTime
            self.schedule = output.schedule
            self.scheduleOffset = output.scheduleOffset
            self.scheduleTimezone = output.scheduleTimezone
            self.startDate = output.startDate
            self.windowId = output.windowId
        } else {
            self.allowUnassociatedTargets = false
            self.createdDate = nil
            self.cutoff = 0
            self.description = nil
            self.duration = 0
            self.enabled = false
            self.endDate = nil
            self.modifiedDate = nil
            self.name = nil
            self.nextExecutionTime = nil
            self.schedule = nil
            self.scheduleOffset = 0
            self.scheduleTimezone = nil
            self.startDate = nil
            self.windowId = nil
        }
    }
}

public struct GetMaintenanceWindowOutputResponse: Swift.Equatable {
    /// Whether targets must be registered with the maintenance window before tasks can be defined for those targets.
    public var allowUnassociatedTargets: Swift.Bool
    /// The date the maintenance window was created.
    public var createdDate: ClientRuntime.Date?
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    public var cutoff: Swift.Int
    /// The description of the maintenance window.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    public var duration: Swift.Int
    /// Indicates whether the maintenance window is enabled.
    public var enabled: Swift.Bool
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive. The maintenance window won't run after this specified time.
    public var endDate: Swift.String?
    /// The date the maintenance window was last modified.
    public var modifiedDate: ClientRuntime.Date?
    /// The name of the maintenance window.
    public var name: Swift.String?
    /// The next time the maintenance window will actually run, taking into account any specified times for the maintenance window to become active or inactive.
    public var nextExecutionTime: Swift.String?
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    public var schedule: Swift.String?
    /// The number of days to wait to run a maintenance window after the scheduled cron expression date and time.
    public var scheduleOffset: Swift.Int
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active. The maintenance window won't run before this specified time.
    public var startDate: Swift.String?
    /// The ID of the created maintenance window.
    public var windowId: Swift.String?

    public init (
        allowUnassociatedTargets: Swift.Bool = false,
        createdDate: ClientRuntime.Date? = nil,
        cutoff: Swift.Int = 0,
        description: Swift.String? = nil,
        duration: Swift.Int = 0,
        enabled: Swift.Bool = false,
        endDate: Swift.String? = nil,
        modifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        nextExecutionTime: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int = 0,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.createdDate = createdDate
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.modifiedDate = modifiedDate
        self.name = name
        self.nextExecutionTime = nextExecutionTime
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

struct GetMaintenanceWindowOutputResponseBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let startDate: Swift.String?
    public let endDate: Swift.String?
    public let schedule: Swift.String?
    public let scheduleTimezone: Swift.String?
    public let scheduleOffset: Swift.Int
    public let nextExecutionTime: Swift.String?
    public let duration: Swift.Int
    public let cutoff: Swift.Int
    public let allowUnassociatedTargets: Swift.Bool
    public let enabled: Swift.Bool
    public let createdDate: ClientRuntime.Date?
    public let modifiedDate: ClientRuntime.Date?
}

extension GetMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case createdDate = "CreatedDate"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case modifiedDate = "ModifiedDate"
        case name = "Name"
        case nextExecutionTime = "NextExecutionTime"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let nextExecutionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextExecutionTime)
        nextExecutionTime = nextExecutionTimeDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Swift.Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
    }
}

public struct GetMaintenanceWindowTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowTaskOutputError>
}

extension GetMaintenanceWindowTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowTaskInput(windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)))"}
}

extension GetMaintenanceWindowTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }
}

public struct GetMaintenanceWindowTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowTaskOutputError>
}

public struct GetMaintenanceWindowTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMaintenanceWindowTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowTaskOutputError>
}

public struct GetMaintenanceWindowTaskInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowTaskInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMaintenanceWindowTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMaintenanceWindowTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowTaskOutputError>
}

public struct GetMaintenanceWindowTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMaintenanceWindowTaskInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMaintenanceWindowTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMaintenanceWindowTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMaintenanceWindowTaskOutputError>
}

public struct GetMaintenanceWindowTaskInput: Swift.Equatable {
    /// The maintenance window ID that includes the task to retrieve.
    /// This member is required.
    public var windowId: Swift.String?
    /// The maintenance window task ID to retrieve.
    /// This member is required.
    public var windowTaskId: Swift.String?

    public init (
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct GetMaintenanceWindowTaskInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let windowTaskId: Swift.String?
}

extension GetMaintenanceWindowTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension GetMaintenanceWindowTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowTaskOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowTaskOutputResponse(cutoffBehavior: \(Swift.String(describing: cutoffBehavior)), description: \(Swift.String(describing: description)), loggingInfo: \(Swift.String(describing: loggingInfo)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), taskArn: \(Swift.String(describing: taskArn)), taskInvocationParameters: \(Swift.String(describing: taskInvocationParameters)), taskParameters: \(Swift.String(describing: taskParameters)), taskType: \(Swift.String(describing: taskType)), windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)))"}
}

extension GetMaintenanceWindowTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMaintenanceWindowTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cutoffBehavior = output.cutoffBehavior
            self.description = output.description
            self.loggingInfo = output.loggingInfo
            self.maxConcurrency = output.maxConcurrency
            self.maxErrors = output.maxErrors
            self.name = output.name
            self.priority = output.priority
            self.serviceRoleArn = output.serviceRoleArn
            self.targets = output.targets
            self.taskArn = output.taskArn
            self.taskInvocationParameters = output.taskInvocationParameters
            self.taskParameters = output.taskParameters
            self.taskType = output.taskType
            self.windowId = output.windowId
            self.windowTaskId = output.windowTaskId
        } else {
            self.cutoffBehavior = nil
            self.description = nil
            self.loggingInfo = nil
            self.maxConcurrency = nil
            self.maxErrors = nil
            self.name = nil
            self.priority = 0
            self.serviceRoleArn = nil
            self.targets = nil
            self.taskArn = nil
            self.taskInvocationParameters = nil
            self.taskParameters = nil
            self.taskType = nil
            self.windowId = nil
            self.windowTaskId = nil
        }
    }
}

public struct GetMaintenanceWindowTaskOutputResponse: Swift.Equatable {
    /// The action to take on tasks when the maintenance window cutoff time is reached. CONTINUE_TASK means that tasks continue to run. For Automation, Lambda, Step Functions tasks, CANCEL_TASK means that currently running task invocations continue, but no new task invocations are started. For Run Command tasks, CANCEL_TASK means the system attempts to stop the task by sending a CancelCommand operation.
    public var cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// The retrieved task description.
    public var description: Swift.String?
    /// The location in Amazon Simple Storage Service (Amazon S3) where the task results are logged. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SsmClientTypes.LoggingInfo?
    /// The maximum number of targets allowed to run this task in parallel. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.
    public var maxConcurrency: Swift.String?
    /// The maximum number of errors allowed before the task stops being scheduled. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.
    public var maxErrors: Swift.String?
    /// The retrieved task name.
    public var name: Swift.String?
    /// The priority of the task when it runs. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.
    public var priority: Swift.Int
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
    public var serviceRoleArn: Swift.String?
    /// The targets where the task should run.
    public var targets: [SsmClientTypes.Target]?
    /// The resource that the task used during execution. For RUN_COMMAND and AUTOMATION task types, the value of TaskArn is the SSM document name/ARN. For LAMBDA tasks, the value is the function name/ARN. For STEP_FUNCTIONS tasks, the value is the state machine ARN.
    public var taskArn: Swift.String?
    /// The parameters to pass to the task when it runs.
    public var taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The parameters to pass to the task when it runs. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The type of task to run.
    public var taskType: SsmClientTypes.MaintenanceWindowTaskType?
    /// The retrieved maintenance window ID.
    public var windowId: Swift.String?
    /// The retrieved maintenance window task ID.
    public var windowTaskId: Swift.String?

    public init (
        cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SsmClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRoleArn: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        taskType: SsmClientTypes.MaintenanceWindowTaskType? = nil,
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.taskType = taskType
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct GetMaintenanceWindowTaskOutputResponseBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let windowTaskId: Swift.String?
    public let targets: [SsmClientTypes.Target]?
    public let taskArn: Swift.String?
    public let serviceRoleArn: Swift.String?
    public let taskType: SsmClientTypes.MaintenanceWindowTaskType?
    public let taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    public let taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    public let priority: Swift.Int
    public let maxConcurrency: Swift.String?
    public let maxErrors: Swift.String?
    public let loggingInfo: SsmClientTypes.LoggingInfo?
    public let name: Swift.String?
    public let description: Swift.String?
    public let cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
}

extension GetMaintenanceWindowTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case taskType = "TaskType"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cutoffBehaviorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskCutoffBehavior.self, forKey: .cutoffBehavior)
        cutoffBehavior = cutoffBehaviorDecoded
    }
}

public struct GetOpsItemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsItemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpsItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpsItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsItemOutputError>
}

extension GetOpsItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOpsItemInput(opsItemId: \(Swift.String(describing: opsItemId)))"}
}

extension GetOpsItemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }
}

public struct GetOpsItemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpsItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpsItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsItemOutputError>
}

public struct GetOpsItemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpsItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpsItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsItemOutputError>
}

public struct GetOpsItemInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsItemInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetOpsItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOpsItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsItemOutputError>
}

public struct GetOpsItemInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsItemInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetOpsItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOpsItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsItemOutputError>
}

public struct GetOpsItemInput: Swift.Equatable {
    /// The ID of the OpsItem that you want to get.
    /// This member is required.
    public var opsItemId: Swift.String?

    public init (
        opsItemId: Swift.String? = nil
    )
    {
        self.opsItemId = opsItemId
    }
}

struct GetOpsItemInputBody: Swift.Equatable {
    public let opsItemId: Swift.String?
}

extension GetOpsItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension GetOpsItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpsItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpsItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpsItemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOpsItemOutputResponse(opsItem: \(Swift.String(describing: opsItem)))"}
}

extension GetOpsItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOpsItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.opsItem = output.opsItem
        } else {
            self.opsItem = nil
        }
    }
}

public struct GetOpsItemOutputResponse: Swift.Equatable {
    /// The OpsItem.
    public var opsItem: SsmClientTypes.OpsItem?

    public init (
        opsItem: SsmClientTypes.OpsItem? = nil
    )
    {
        self.opsItem = opsItem
    }
}

struct GetOpsItemOutputResponseBody: Swift.Equatable {
    public let opsItem: SsmClientTypes.OpsItem?
}

extension GetOpsItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsItem = "OpsItem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItem.self, forKey: .opsItem)
        opsItem = opsItemDecoded
    }
}

public struct GetOpsMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsMetadataOutputError>
}

extension GetOpsMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOpsMetadataInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), opsMetadataArn: \(Swift.String(describing: opsMetadataArn)))"}
}

extension GetOpsMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
    }
}

public struct GetOpsMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsMetadataOutputError>
}

public struct GetOpsMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsMetadataOutputError>
}

public struct GetOpsMetadataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsMetadataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetOpsMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOpsMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsMetadataOutputError>
}

public struct GetOpsMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsMetadataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetOpsMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOpsMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsMetadataOutputError>
}

public struct GetOpsMetadataInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of an OpsMetadata Object to view.
    /// This member is required.
    public var opsMetadataArn: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsMetadataArn = opsMetadataArn
    }
}

struct GetOpsMetadataInputBody: Swift.Equatable {
    public let opsMetadataArn: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension GetOpsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOpsMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpsMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataNotFoundException" : self = .opsMetadataNotFoundException(try OpsMetadataNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpsMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataNotFoundException(OpsMetadataNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpsMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOpsMetadataOutputResponse(metadata: \(Swift.String(describing: metadata)), nextToken: \(Swift.String(describing: nextToken)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension GetOpsMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.nextToken = output.nextToken
            self.resourceId = output.resourceId
        } else {
            self.metadata = nil
            self.nextToken = nil
            self.resourceId = nil
        }
    }
}

public struct GetOpsMetadataOutputResponse: Swift.Equatable {
    /// OpsMetadata for an Application Manager application.
    public var metadata: [Swift.String:SsmClientTypes.MetadataValue]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The resource ID of the Application Manager application.
    public var resourceId: Swift.String?

    public init (
        metadata: [Swift.String:SsmClientTypes.MetadataValue]? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.metadata = metadata
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct GetOpsMetadataOutputResponseBody: Swift.Equatable {
    public let resourceId: Swift.String?
    public let metadata: [Swift.String:SsmClientTypes.MetadataValue]?
    public let nextToken: Swift.String?
}

extension GetOpsMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MetadataValue?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:SsmClientTypes.MetadataValue]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:SsmClientTypes.MetadataValue]()
            for (key0, metadatavalue0) in metadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetOpsSummaryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpsSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpsSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsSummaryOutputError>
}

extension GetOpsSummaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOpsSummaryInput(aggregators: \(Swift.String(describing: aggregators)), filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resultAttributes: \(Swift.String(describing: resultAttributes)), syncName: \(Swift.String(describing: syncName)))"}
}

extension GetOpsSummaryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
        case syncName = "SyncName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for opsaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(opsaggregatorlist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsfilterlist0 in filters {
                try filtersContainer.encode(opsfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resultAttributes = resultAttributes {
            var resultAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultAttributes)
            for opsresultattributelist0 in resultAttributes {
                try resultAttributesContainer.encode(opsresultattributelist0)
            }
        }
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
    }
}

public struct GetOpsSummaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpsSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpsSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsSummaryOutputError>
}

public struct GetOpsSummaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpsSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpsSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsSummaryOutputError>
}

public struct GetOpsSummaryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsSummaryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetOpsSummaryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOpsSummaryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsSummaryOutputError>
}

public struct GetOpsSummaryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpsSummaryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetOpsSummaryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpsSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOpsSummaryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpsSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpsSummaryOutputError>
}

public struct GetOpsSummaryInput: Swift.Equatable {
    /// Optional aggregators that return counts of OpsData based on one or more expressions.
    public var aggregators: [SsmClientTypes.OpsAggregator]?
    /// Optional filters used to scope down the returned OpsData.
    public var filters: [SsmClientTypes.OpsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The OpsData data type to return.
    public var resultAttributes: [SsmClientTypes.OpsResultAttribute]?
    /// Specify the name of a resource data sync to get.
    public var syncName: Swift.String?

    public init (
        aggregators: [SsmClientTypes.OpsAggregator]? = nil,
        filters: [SsmClientTypes.OpsFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resultAttributes: [SsmClientTypes.OpsResultAttribute]? = nil,
        syncName: Swift.String? = nil
    )
    {
        self.aggregators = aggregators
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resultAttributes = resultAttributes
        self.syncName = syncName
    }
}

struct GetOpsSummaryInputBody: Swift.Equatable {
    public let syncName: Swift.String?
    public let filters: [SsmClientTypes.OpsFilter]?
    public let aggregators: [SsmClientTypes.OpsAggregator]?
    public let resultAttributes: [SsmClientTypes.OpsResultAttribute]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension GetOpsSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
        case syncName = "SyncName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.OpsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.OpsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let aggregatorsContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[SsmClientTypes.OpsAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [SsmClientTypes.OpsAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
        let resultAttributesContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsResultAttribute?].self, forKey: .resultAttributes)
        var resultAttributesDecoded0:[SsmClientTypes.OpsResultAttribute]? = nil
        if let resultAttributesContainer = resultAttributesContainer {
            resultAttributesDecoded0 = [SsmClientTypes.OpsResultAttribute]()
            for structure0 in resultAttributesContainer {
                if let structure0 = structure0 {
                    resultAttributesDecoded0?.append(structure0)
                }
            }
        }
        resultAttributes = resultAttributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetOpsSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpsSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAggregator" : self = .invalidAggregatorException(try InvalidAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncNotFound" : self = .resourceDataSyncNotFoundException(try ResourceDataSyncNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpsSummaryOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidAggregatorException(InvalidAggregatorException)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case invalidTypeNameException(InvalidTypeNameException)
    case resourceDataSyncNotFoundException(ResourceDataSyncNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpsSummaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOpsSummaryOutputResponse(entities: \(Swift.String(describing: entities)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetOpsSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOpsSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct GetOpsSummaryOutputResponse: Swift.Equatable {
    /// The list of aggregated details and filtered OpsData.
    public var entities: [SsmClientTypes.OpsEntity]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        entities: [SsmClientTypes.OpsEntity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct GetOpsSummaryOutputResponseBody: Swift.Equatable {
    public let entities: [SsmClientTypes.OpsEntity]?
    public let nextToken: Swift.String?
}

extension GetOpsSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsEntity?].self, forKey: .entities)
        var entitiesDecoded0:[SsmClientTypes.OpsEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [SsmClientTypes.OpsEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetParameterHistoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParameterHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParameterHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParameterHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParameterHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParameterHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParameterHistoryOutputError>
}

extension GetParameterHistoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetParameterHistoryInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), withDecryption: \(Swift.String(describing: withDecryption)))"}
}

extension GetParameterHistoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

public struct GetParameterHistoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParameterHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParameterHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParameterHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParameterHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParameterHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParameterHistoryOutputError>
}

public struct GetParameterHistoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParameterHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParameterHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParameterHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParameterHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParameterHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParameterHistoryOutputError>
}

public struct GetParameterHistoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParameterHistoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetParameterHistoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParameterHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetParameterHistoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetParameterHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParameterHistoryOutputError>
}

public struct GetParameterHistoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParameterHistoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetParameterHistoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParameterHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetParameterHistoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetParameterHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParameterHistoryOutputError>
}

public struct GetParameterHistoryInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The name of the parameter for which you want to review history.
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.
    public var withDecryption: Swift.Bool

    public init (
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        withDecryption: Swift.Bool = false
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.withDecryption = withDecryption
    }
}

struct GetParameterHistoryInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let withDecryption: Swift.Bool
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension GetParameterHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let withDecryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetParameterHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParameterHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParameterHistoryOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidKeyId(InvalidKeyId)
    case invalidNextToken(InvalidNextToken)
    case parameterNotFound(ParameterNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParameterHistoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetParameterHistoryOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parameters: \(Swift.String(describing: parameters)))"}
}

extension GetParameterHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetParameterHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct GetParameterHistoryOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// A list of parameters returned by the request.
    public var parameters: [SsmClientTypes.ParameterHistory]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [SsmClientTypes.ParameterHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct GetParameterHistoryOutputResponseBody: Swift.Equatable {
    public let parameters: [SsmClientTypes.ParameterHistory]?
    public let nextToken: Swift.String?
}

extension GetParameterHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterHistory?].self, forKey: .parameters)
        var parametersDecoded0:[SsmClientTypes.ParameterHistory]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SsmClientTypes.ParameterHistory]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetParameterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParameterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParameterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParameterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParameterOutputError>
}

extension GetParameterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetParameterInput(name: \(Swift.String(describing: name)), withDecryption: \(Swift.String(describing: withDecryption)))"}
}

extension GetParameterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

public struct GetParameterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParameterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParameterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParameterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParameterOutputError>
}

public struct GetParameterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParameterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParameterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParameterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParameterOutputError>
}

public struct GetParameterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParameterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetParameterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetParameterInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParameterOutputError>
}

public struct GetParameterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParameterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetParameterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetParameterInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParameterOutputError>
}

public struct GetParameterInput: Swift.Equatable {
    /// The name of the parameter you want to query. To query by parameter label, use "Name": "name:label". To query by parameter version, use "Name": "name:version".
    /// This member is required.
    public var name: Swift.String?
    /// Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.
    public var withDecryption: Swift.Bool

    public init (
        name: Swift.String? = nil,
        withDecryption: Swift.Bool = false
    )
    {
        self.name = name
        self.withDecryption = withDecryption
    }
}

struct GetParameterInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let withDecryption: Swift.Bool
}

extension GetParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let withDecryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
    }
}

extension GetParameterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParameterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionNotFound" : self = .parameterVersionNotFound(try ParameterVersionNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParameterOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidKeyId(InvalidKeyId)
    case parameterNotFound(ParameterNotFound)
    case parameterVersionNotFound(ParameterVersionNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParameterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetParameterOutputResponse(parameter: \(Swift.String(describing: parameter)))"}
}

extension GetParameterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetParameterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.parameter = output.parameter
        } else {
            self.parameter = nil
        }
    }
}

public struct GetParameterOutputResponse: Swift.Equatable {
    /// Information about a parameter.
    public var parameter: SsmClientTypes.Parameter?

    public init (
        parameter: SsmClientTypes.Parameter? = nil
    )
    {
        self.parameter = parameter
    }
}

struct GetParameterOutputResponseBody: Swift.Equatable {
    public let parameter: SsmClientTypes.Parameter?
}

extension GetParameterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameter = "Parameter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterDecoded = try containerValues.decodeIfPresent(SsmClientTypes.Parameter.self, forKey: .parameter)
        parameter = parameterDecoded
    }
}

public struct GetParametersByPathInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParametersByPathInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParametersByPathInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParametersByPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParametersByPathInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParametersByPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParametersByPathOutputError>
}

extension GetParametersByPathInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetParametersByPathInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), parameterFilters: \(Swift.String(describing: parameterFilters)), path: \(Swift.String(describing: path)), recursive: \(Swift.String(describing: recursive)), withDecryption: \(Swift.String(describing: withDecryption)))"}
}

extension GetParametersByPathInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
        case path = "Path"
        case recursive = "Recursive"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterFilters = parameterFilters {
            var parameterFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterFilters)
            for parameterstringfilterlist0 in parameterFilters {
                try parameterFiltersContainer.encode(parameterstringfilterlist0)
            }
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if recursive != false {
            try encodeContainer.encode(recursive, forKey: .recursive)
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

public struct GetParametersByPathInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParametersByPathInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParametersByPathInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParametersByPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParametersByPathInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParametersByPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParametersByPathOutputError>
}

public struct GetParametersByPathInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParametersByPathInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParametersByPathInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParametersByPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParametersByPathInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParametersByPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParametersByPathOutputError>
}

public struct GetParametersByPathInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParametersByPathInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetParametersByPathInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParametersByPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetParametersByPathInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetParametersByPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParametersByPathOutputError>
}

public struct GetParametersByPathInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParametersByPathInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetParametersByPathInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParametersByPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetParametersByPathInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetParametersByPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParametersByPathOutputError>
}

public struct GetParametersByPathInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Filters to limit the request results. The following Key values are supported for GetParametersByPath: Type, KeyId, and Label. The following Key values aren't supported for GetParametersByPath: tag, DataType, Name, Path, and Tier.
    public var parameterFilters: [SsmClientTypes.ParameterStringFilter]?
    /// The hierarchy for the parameter. Hierarchies start with a forward slash (/). The hierachy is the parameter name except the last part of the parameter. For the API call to succeeed, the last part of the parameter name can't be in the path. A parameter name hierarchy can have a maximum of 15 levels. Here is an example of a hierarchy: /Finance/Prod/IAD/WinServ2016/license33
    /// This member is required.
    public var path: Swift.String?
    /// Retrieve all parameters within a hierarchy. If a user has access to a path, then the user can access all levels of that path. For example, if a user has permission to access path /a, then the user can also access /a/b. Even if a user has explicitly been denied access in IAM for parameter /a/b, they can still call the GetParametersByPath API operation recursively for /a and view /a/b.
    public var recursive: Swift.Bool
    /// Retrieve all parameters in a hierarchy with their value decrypted.
    public var withDecryption: Swift.Bool

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        parameterFilters: [SsmClientTypes.ParameterStringFilter]? = nil,
        path: Swift.String? = nil,
        recursive: Swift.Bool = false,
        withDecryption: Swift.Bool = false
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterFilters = parameterFilters
        self.path = path
        self.recursive = recursive
        self.withDecryption = withDecryption
    }
}

struct GetParametersByPathInputBody: Swift.Equatable {
    public let path: Swift.String?
    public let recursive: Swift.Bool
    public let parameterFilters: [SsmClientTypes.ParameterStringFilter]?
    public let withDecryption: Swift.Bool
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension GetParametersByPathInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
        case path = "Path"
        case recursive = "Recursive"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let recursiveDecoded = try containerValues.decode(Swift.Bool.self, forKey: .recursive)
        recursive = recursiveDecoded
        let parameterFiltersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterStringFilter?].self, forKey: .parameterFilters)
        var parameterFiltersDecoded0:[SsmClientTypes.ParameterStringFilter]? = nil
        if let parameterFiltersContainer = parameterFiltersContainer {
            parameterFiltersDecoded0 = [SsmClientTypes.ParameterStringFilter]()
            for structure0 in parameterFiltersContainer {
                if let structure0 = structure0 {
                    parameterFiltersDecoded0?.append(structure0)
                }
            }
        }
        parameterFilters = parameterFiltersDecoded0
        let withDecryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetParametersByPathOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParametersByPathOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterOption" : self = .invalidFilterOption(try InvalidFilterOption(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParametersByPathOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterOption(InvalidFilterOption)
    case invalidFilterValue(InvalidFilterValue)
    case invalidKeyId(InvalidKeyId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParametersByPathOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetParametersByPathOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parameters: \(Swift.String(describing: parameters)))"}
}

extension GetParametersByPathOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetParametersByPathOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct GetParametersByPathOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of parameters found in the specified hierarchy.
    public var parameters: [SsmClientTypes.Parameter]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [SsmClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct GetParametersByPathOutputResponseBody: Swift.Equatable {
    public let parameters: [SsmClientTypes.Parameter]?
    public let nextToken: Swift.String?
}

extension GetParametersByPathOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([SsmClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[SsmClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SsmClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParametersOutputError>
}

extension GetParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetParametersInput(names: \(Swift.String(describing: names)), withDecryption: \(Swift.String(describing: withDecryption)))"}
}

extension GetParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for parameternamelist0 in names {
                try namesContainer.encode(parameternamelist0)
            }
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

public struct GetParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParametersOutputError>
}

public struct GetParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParametersOutputError>
}

public struct GetParametersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParametersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParametersOutputError>
}

public struct GetParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParametersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParametersOutputError>
}

public struct GetParametersInput: Swift.Equatable {
    /// Names of the parameters for which you want to query information. To query by parameter label, use "Name": "name:label". To query by parameter version, use "Name": "name:version".
    /// This member is required.
    public var names: [Swift.String]?
    /// Return decrypted secure string value. Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.
    public var withDecryption: Swift.Bool

    public init (
        names: [Swift.String]? = nil,
        withDecryption: Swift.Bool = false
    )
    {
        self.names = names
        self.withDecryption = withDecryption
    }
}

struct GetParametersInputBody: Swift.Equatable {
    public let names: [Swift.String]?
    public let withDecryption: Swift.Bool
}

extension GetParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let withDecryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
    }
}

extension GetParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParametersOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidKeyId(InvalidKeyId)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetParametersOutputResponse(invalidParameters: \(Swift.String(describing: invalidParameters)), parameters: \(Swift.String(describing: parameters)))"}
}

extension GetParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invalidParameters = output.invalidParameters
            self.parameters = output.parameters
        } else {
            self.invalidParameters = nil
            self.parameters = nil
        }
    }
}

public struct GetParametersOutputResponse: Swift.Equatable {
    /// A list of parameters that aren't formatted correctly or don't run during an execution.
    public var invalidParameters: [Swift.String]?
    /// A list of details for a parameter.
    public var parameters: [SsmClientTypes.Parameter]?

    public init (
        invalidParameters: [Swift.String]? = nil,
        parameters: [SsmClientTypes.Parameter]? = nil
    )
    {
        self.invalidParameters = invalidParameters
        self.parameters = parameters
    }
}

struct GetParametersOutputResponseBody: Swift.Equatable {
    public let parameters: [SsmClientTypes.Parameter]?
    public let invalidParameters: [Swift.String]?
}

extension GetParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameters = "InvalidParameters"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([SsmClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[SsmClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SsmClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let invalidParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidParameters)
        var invalidParametersDecoded0:[Swift.String]? = nil
        if let invalidParametersContainer = invalidParametersContainer {
            invalidParametersDecoded0 = [Swift.String]()
            for string0 in invalidParametersContainer {
                if let string0 = string0 {
                    invalidParametersDecoded0?.append(string0)
                }
            }
        }
        invalidParameters = invalidParametersDecoded0
    }
}

public struct GetPatchBaselineForPatchGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPatchBaselineForPatchGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPatchBaselineForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPatchBaselineForPatchGroupOutputError>
}

extension GetPatchBaselineForPatchGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPatchBaselineForPatchGroupInput(operatingSystem: \(Swift.String(describing: operatingSystem)), patchGroup: \(Swift.String(describing: patchGroup)))"}
}

extension GetPatchBaselineForPatchGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operatingSystem = "OperatingSystem"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

public struct GetPatchBaselineForPatchGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPatchBaselineForPatchGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPatchBaselineForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPatchBaselineForPatchGroupOutputError>
}

public struct GetPatchBaselineForPatchGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPatchBaselineForPatchGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPatchBaselineForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPatchBaselineForPatchGroupOutputError>
}

public struct GetPatchBaselineForPatchGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPatchBaselineForPatchGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPatchBaselineForPatchGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPatchBaselineForPatchGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPatchBaselineForPatchGroupOutputError>
}

public struct GetPatchBaselineForPatchGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPatchBaselineForPatchGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPatchBaselineForPatchGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPatchBaselineForPatchGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPatchBaselineForPatchGroupOutputError>
}

public struct GetPatchBaselineForPatchGroupInput: Swift.Equatable {
    /// Returns he operating system rule specified for patch groups using the patch baseline.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// The name of the patch group whose patch baseline should be retrieved.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init (
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.operatingSystem = operatingSystem
        self.patchGroup = patchGroup
    }
}

struct GetPatchBaselineForPatchGroupInputBody: Swift.Equatable {
    public let patchGroup: Swift.String?
    public let operatingSystem: SsmClientTypes.OperatingSystem?
}

extension GetPatchBaselineForPatchGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operatingSystem = "OperatingSystem"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension GetPatchBaselineForPatchGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPatchBaselineForPatchGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPatchBaselineForPatchGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPatchBaselineForPatchGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPatchBaselineForPatchGroupOutputResponse(baselineId: \(Swift.String(describing: baselineId)), operatingSystem: \(Swift.String(describing: operatingSystem)), patchGroup: \(Swift.String(describing: patchGroup)))"}
}

extension GetPatchBaselineForPatchGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPatchBaselineForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
            self.operatingSystem = output.operatingSystem
            self.patchGroup = output.patchGroup
        } else {
            self.baselineId = nil
            self.operatingSystem = nil
            self.patchGroup = nil
        }
    }
}

public struct GetPatchBaselineForPatchGroupOutputResponse: Swift.Equatable {
    /// The ID of the patch baseline that should be used for the patch group.
    public var baselineId: Swift.String?
    /// The operating system rule specified for patch groups using the patch baseline.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// The name of the patch group.
    public var patchGroup: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.operatingSystem = operatingSystem
        self.patchGroup = patchGroup
    }
}

struct GetPatchBaselineForPatchGroupOutputResponseBody: Swift.Equatable {
    public let baselineId: Swift.String?
    public let patchGroup: Swift.String?
    public let operatingSystem: SsmClientTypes.OperatingSystem?
}

extension GetPatchBaselineForPatchGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case operatingSystem = "OperatingSystem"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

public struct GetPatchBaselineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPatchBaselineOutputError>
}

extension GetPatchBaselineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPatchBaselineInput(baselineId: \(Swift.String(describing: baselineId)))"}
}

extension GetPatchBaselineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
    }
}

public struct GetPatchBaselineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPatchBaselineOutputError>
}

public struct GetPatchBaselineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPatchBaselineOutputError>
}

public struct GetPatchBaselineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPatchBaselineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPatchBaselineOutputError>
}

public struct GetPatchBaselineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPatchBaselineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPatchBaselineOutputError>
}

public struct GetPatchBaselineInput: Swift.Equatable {
    /// The ID of the patch baseline to retrieve. To retrieve information about an Amazon Web Services managed patch baseline, specify the full Amazon Resource Name (ARN) of the baseline. For example, for the baseline AWS-AmazonLinuxDefaultPatchBaseline, specify arn:aws:ssm:us-east-2:733109147000:patchbaseline/pb-0e392de35e7c563b7 instead of pb-0e392de35e7c563b7.
    /// This member is required.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct GetPatchBaselineInputBody: Swift.Equatable {
    public let baselineId: Swift.String?
}

extension GetPatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension GetPatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPatchBaselineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPatchBaselineOutputResponse(approvalRules: \(Swift.String(describing: approvalRules)), approvedPatches: \(Swift.String(describing: approvedPatches)), approvedPatchesComplianceLevel: \(Swift.String(describing: approvedPatchesComplianceLevel)), approvedPatchesEnableNonSecurity: \(Swift.String(describing: approvedPatchesEnableNonSecurity)), baselineId: \(Swift.String(describing: baselineId)), createdDate: \(Swift.String(describing: createdDate)), description: \(Swift.String(describing: description)), globalFilters: \(Swift.String(describing: globalFilters)), modifiedDate: \(Swift.String(describing: modifiedDate)), name: \(Swift.String(describing: name)), operatingSystem: \(Swift.String(describing: operatingSystem)), patchGroups: \(Swift.String(describing: patchGroups)), rejectedPatches: \(Swift.String(describing: rejectedPatches)), rejectedPatchesAction: \(Swift.String(describing: rejectedPatchesAction)), sources: \(Swift.String(describing: sources)))"}
}

extension GetPatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRules = output.approvalRules
            self.approvedPatches = output.approvedPatches
            self.approvedPatchesComplianceLevel = output.approvedPatchesComplianceLevel
            self.approvedPatchesEnableNonSecurity = output.approvedPatchesEnableNonSecurity
            self.baselineId = output.baselineId
            self.createdDate = output.createdDate
            self.description = output.description
            self.globalFilters = output.globalFilters
            self.modifiedDate = output.modifiedDate
            self.name = output.name
            self.operatingSystem = output.operatingSystem
            self.patchGroups = output.patchGroups
            self.rejectedPatches = output.rejectedPatches
            self.rejectedPatchesAction = output.rejectedPatchesAction
            self.sources = output.sources
        } else {
            self.approvalRules = nil
            self.approvedPatches = nil
            self.approvedPatchesComplianceLevel = nil
            self.approvedPatchesEnableNonSecurity = false
            self.baselineId = nil
            self.createdDate = nil
            self.description = nil
            self.globalFilters = nil
            self.modifiedDate = nil
            self.name = nil
            self.operatingSystem = nil
            self.patchGroups = nil
            self.rejectedPatches = nil
            self.rejectedPatchesAction = nil
            self.sources = nil
        }
    }
}

public struct GetPatchBaselineOutputResponse: Swift.Equatable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SsmClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline.
    public var approvedPatches: [Swift.String]?
    /// Returns the specified compliance severity level for approved patches in the patch baseline.
    public var approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool
    /// The ID of the retrieved patch baseline.
    public var baselineId: Swift.String?
    /// The date the patch baseline was created.
    public var createdDate: ClientRuntime.Date?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to exclude patches from the baseline.
    public var globalFilters: SsmClientTypes.PatchFilterGroup?
    /// The date the patch baseline was last modified.
    public var modifiedDate: ClientRuntime.Date?
    /// The name of the patch baseline.
    public var name: Swift.String?
    /// Returns the operating system specified for the patch baseline.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// Patch groups included in the patch baseline.
    public var patchGroups: [Swift.String]?
    /// A list of explicitly rejected patches for the baseline.
    public var rejectedPatches: [Swift.String]?
    /// The action specified to take on patches included in the RejectedPatches list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.
    public var rejectedPatchesAction: SsmClientTypes.PatchAction?
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SsmClientTypes.PatchSource]?

    public init (
        approvalRules: SsmClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool = false,
        baselineId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        globalFilters: SsmClientTypes.PatchFilterGroup? = nil,
        modifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        patchGroups: [Swift.String]? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SsmClientTypes.PatchAction? = nil,
        sources: [SsmClientTypes.PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.createdDate = createdDate
        self.description = description
        self.globalFilters = globalFilters
        self.modifiedDate = modifiedDate
        self.name = name
        self.operatingSystem = operatingSystem
        self.patchGroups = patchGroups
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
    }
}

struct GetPatchBaselineOutputResponseBody: Swift.Equatable {
    public let baselineId: Swift.String?
    public let name: Swift.String?
    public let operatingSystem: SsmClientTypes.OperatingSystem?
    public let globalFilters: SsmClientTypes.PatchFilterGroup?
    public let approvalRules: SsmClientTypes.PatchRuleGroup?
    public let approvedPatches: [Swift.String]?
    public let approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    public let approvedPatchesEnableNonSecurity: Swift.Bool
    public let rejectedPatches: [Swift.String]?
    public let rejectedPatchesAction: SsmClientTypes.PatchAction?
    public let patchGroups: [Swift.String]?
    public let createdDate: ClientRuntime.Date?
    public let modifiedDate: ClientRuntime.Date?
    public let description: Swift.String?
    public let sources: [SsmClientTypes.PatchSource]?
}

extension GetPatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case createdDate = "CreatedDate"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case modifiedDate = "ModifiedDate"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case patchGroups = "PatchGroups"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let patchGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .patchGroups)
        var patchGroupsDecoded0:[Swift.String]? = nil
        if let patchGroupsContainer = patchGroupsContainer {
            patchGroupsDecoded0 = [Swift.String]()
            for string0 in patchGroupsContainer {
                if let string0 = string0 {
                    patchGroupsDecoded0?.append(string0)
                }
            }
        }
        patchGroups = patchGroupsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

public struct GetServiceSettingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceSettingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceSettingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceSettingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceSettingOutputError>
}

extension GetServiceSettingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceSettingInput(settingId: \(Swift.String(describing: settingId)))"}
}

extension GetServiceSettingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
    }
}

public struct GetServiceSettingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceSettingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceSettingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceSettingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceSettingOutputError>
}

public struct GetServiceSettingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceSettingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceSettingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceSettingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceSettingOutputError>
}

public struct GetServiceSettingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceSettingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetServiceSettingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceSettingInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceSettingOutputError>
}

public struct GetServiceSettingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceSettingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetServiceSettingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceSettingInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceSettingOutputError>
}

/// The request body of the GetServiceSetting API operation.
public struct GetServiceSettingInput: Swift.Equatable {
    /// The ID of the service setting to get. The setting ID can be one of the following.
    ///
    /// * /ssm/automation/customer-script-log-destination
    ///
    /// * /ssm/automation/customer-script-log-group-name
    ///
    /// * /ssm/documents/console/public-sharing-permission
    ///
    /// * /ssm/parameter-store/default-parameter-tier
    ///
    /// * /ssm/parameter-store/high-throughput-enabled
    ///
    /// * /ssm/managed-instance/activation-tier
    /// This member is required.
    public var settingId: Swift.String?

    public init (
        settingId: Swift.String? = nil
    )
    {
        self.settingId = settingId
    }
}

struct GetServiceSettingInputBody: Swift.Equatable {
    public let settingId: Swift.String?
}

extension GetServiceSettingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingId)
        settingId = settingIdDecoded
    }
}

extension GetServiceSettingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceSettingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceSettingNotFound" : self = .serviceSettingNotFound(try ServiceSettingNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceSettingOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case serviceSettingNotFound(ServiceSettingNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceSettingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceSettingOutputResponse(serviceSetting: \(Swift.String(describing: serviceSetting)))"}
}

extension GetServiceSettingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceSettingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceSetting = output.serviceSetting
        } else {
            self.serviceSetting = nil
        }
    }
}

/// The query result body of the GetServiceSetting API operation.
public struct GetServiceSettingOutputResponse: Swift.Equatable {
    /// The query result of the current service setting.
    public var serviceSetting: SsmClientTypes.ServiceSetting?

    public init (
        serviceSetting: SsmClientTypes.ServiceSetting? = nil
    )
    {
        self.serviceSetting = serviceSetting
    }
}

struct GetServiceSettingOutputResponseBody: Swift.Equatable {
    public let serviceSetting: SsmClientTypes.ServiceSetting?
}

extension GetServiceSettingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSetting = "ServiceSetting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSettingDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ServiceSetting.self, forKey: .serviceSetting)
        serviceSetting = serviceSettingDecoded
    }
}

extension HierarchyLevelLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HierarchyLevelLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension HierarchyLevelLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: HierarchyLevelLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A hierarchy can have a maximum of 15 levels. For more information, see [Requirements and constraints for parameter names](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html) in the Amazon Web Services Systems Manager User Guide.
public struct HierarchyLevelLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A hierarchy can have a maximum of 15 levels. For more information, see [Requirements and constraints for parameter names](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html) in the Amazon Web Services Systems Manager User Guide.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HierarchyLevelLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension HierarchyLevelLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HierarchyTypeMismatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HierarchyTypeMismatchException(message: \(Swift.String(describing: message)))"}
}

extension HierarchyTypeMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: HierarchyTypeMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Parameter Store doesn't support changing a parameter type in a hierarchy. For example, you can't change a parameter from a String type to a SecureString type. You must create a new, unique parameter.
public struct HierarchyTypeMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Parameter Store doesn't support changing a parameter type in a hierarchy. For example, you can't change a parameter from a String type to a SecureString type. You must create a new, unique parameter.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HierarchyTypeMismatchExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension HierarchyTypeMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IdempotentParameterMismatch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdempotentParameterMismatch(message: \(Swift.String(describing: message)))"}
}

extension IdempotentParameterMismatch {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IdempotentParameterMismatchBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Error returned when an idempotent operation is retried and the parameters don't match the original call to the API with the same idempotency token.
public struct IdempotentParameterMismatch: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IdempotentParameterMismatchBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncompatiblePolicyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncompatiblePolicyException(message: \(Swift.String(describing: message)))"}
}

extension IncompatiblePolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncompatiblePolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a conflict in the policies specified for this parameter. You can't, for example, specify two Expiration policies for a parameter. Review your policies, and try again.
public struct IncompatiblePolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatiblePolicyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IncompatiblePolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.InstanceAggregatedAssociationOverview: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detailedStatus = "DetailedStatus"
        case instanceAssociationStatusAggregatedCount = "InstanceAssociationStatusAggregatedCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let instanceAssociationStatusAggregatedCount = instanceAssociationStatusAggregatedCount {
            var instanceAssociationStatusAggregatedCountContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .instanceAssociationStatusAggregatedCount)
            for (dictKey0, instanceassociationstatusaggregatedcount0) in instanceAssociationStatusAggregatedCount {
                try instanceAssociationStatusAggregatedCountContainer.encode(instanceassociationstatusaggregatedcount0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let instanceAssociationStatusAggregatedCountContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .instanceAssociationStatusAggregatedCount)
        var instanceAssociationStatusAggregatedCountDecoded0: [Swift.String:Swift.Int]? = nil
        if let instanceAssociationStatusAggregatedCountContainer = instanceAssociationStatusAggregatedCountContainer {
            instanceAssociationStatusAggregatedCountDecoded0 = [Swift.String:Swift.Int]()
            for (key0, instancecount0) in instanceAssociationStatusAggregatedCountContainer {
                if let instancecount0 = instancecount0 {
                    instanceAssociationStatusAggregatedCountDecoded0?[key0] = instancecount0
                }
            }
        }
        instanceAssociationStatusAggregatedCount = instanceAssociationStatusAggregatedCountDecoded0
    }
}

extension SsmClientTypes.InstanceAggregatedAssociationOverview: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceAggregatedAssociationOverview(detailedStatus: \(Swift.String(describing: detailedStatus)), instanceAssociationStatusAggregatedCount: \(Swift.String(describing: instanceAssociationStatusAggregatedCount)))"}
}

extension SsmClientTypes {
    /// Status information about the aggregated associations.
    public struct InstanceAggregatedAssociationOverview: Swift.Equatable {
        /// Detailed status information about the aggregated associations.
        public var detailedStatus: Swift.String?
        /// The number of associations for the managed node(s).
        public var instanceAssociationStatusAggregatedCount: [Swift.String:Swift.Int]?

        public init (
            detailedStatus: Swift.String? = nil,
            instanceAssociationStatusAggregatedCount: [Swift.String:Swift.Int]? = nil
        )
        {
            self.detailedStatus = detailedStatus
            self.instanceAssociationStatusAggregatedCount = instanceAssociationStatusAggregatedCount
        }
    }

}

extension SsmClientTypes.InstanceAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case content = "Content"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
    }
}

extension SsmClientTypes.InstanceAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceAssociation(associationId: \(Swift.String(describing: associationId)), associationVersion: \(Swift.String(describing: associationVersion)), content: \(Swift.String(describing: content)), instanceId: \(Swift.String(describing: instanceId)))"}
}

extension SsmClientTypes {
    /// One or more association documents on the managed node.
    public struct InstanceAssociation: Swift.Equatable {
        /// The association ID.
        public var associationId: Swift.String?
        /// Version information for the association on the managed node.
        public var associationVersion: Swift.String?
        /// The content of the association document for the managed node(s).
        public var content: Swift.String?
        /// The managed node ID.
        public var instanceId: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            content: Swift.String? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationVersion = associationVersion
            self.content = content
            self.instanceId = instanceId
        }
    }

}

extension SsmClientTypes.InstanceAssociationOutputLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location = "S3Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.S3OutputLocation.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension SsmClientTypes.InstanceAssociationOutputLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceAssociationOutputLocation(s3Location: \(Swift.String(describing: s3Location)))"}
}

extension SsmClientTypes {
    /// An S3 bucket where you want to store the results of this request. For the minimal permissions required to enable Amazon S3 output for an association, see [Creating associations](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-state-assoc.html) in the Systems Manager User Guide.
    public struct InstanceAssociationOutputLocation: Swift.Equatable {
        /// An S3 bucket where you want to store the results of this request.
        public var s3Location: SsmClientTypes.S3OutputLocation?

        public init (
            s3Location: SsmClientTypes.S3OutputLocation? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension SsmClientTypes.InstanceAssociationOutputUrl: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3OutputUrl = "S3OutputUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3OutputUrl = s3OutputUrl {
            try encodeContainer.encode(s3OutputUrl, forKey: .s3OutputUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3OutputUrlDecoded = try containerValues.decodeIfPresent(SsmClientTypes.S3OutputUrl.self, forKey: .s3OutputUrl)
        s3OutputUrl = s3OutputUrlDecoded
    }
}

extension SsmClientTypes.InstanceAssociationOutputUrl: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceAssociationOutputUrl(s3OutputUrl: \(Swift.String(describing: s3OutputUrl)))"}
}

extension SsmClientTypes {
    /// The URL of S3 bucket where you want to store the results of this request.
    public struct InstanceAssociationOutputUrl: Swift.Equatable {
        /// The URL of S3 bucket where you want to store the results of this request.
        public var s3OutputUrl: SsmClientTypes.S3OutputUrl?

        public init (
            s3OutputUrl: SsmClientTypes.S3OutputUrl? = nil
        )
        {
            self.s3OutputUrl = s3OutputUrl
        }
    }

}

extension SsmClientTypes.InstanceAssociationStatusInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case detailedStatus = "DetailedStatus"
        case documentVersion = "DocumentVersion"
        case errorCode = "ErrorCode"
        case executionDate = "ExecutionDate"
        case executionSummary = "ExecutionSummary"
        case instanceId = "InstanceId"
        case name = "Name"
        case outputUrl = "OutputUrl"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let executionDate = executionDate {
            try encodeContainer.encode(executionDate.timeIntervalSince1970, forKey: .executionDate)
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputUrl = outputUrl {
            try encodeContainer.encode(outputUrl, forKey: .outputUrl)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let executionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionDate)
        executionDate = executionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let outputUrlDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputUrl.self, forKey: .outputUrl)
        outputUrl = outputUrlDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
    }
}

extension SsmClientTypes.InstanceAssociationStatusInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceAssociationStatusInfo(associationId: \(Swift.String(describing: associationId)), associationName: \(Swift.String(describing: associationName)), associationVersion: \(Swift.String(describing: associationVersion)), detailedStatus: \(Swift.String(describing: detailedStatus)), documentVersion: \(Swift.String(describing: documentVersion)), errorCode: \(Swift.String(describing: errorCode)), executionDate: \(Swift.String(describing: executionDate)), executionSummary: \(Swift.String(describing: executionSummary)), instanceId: \(Swift.String(describing: instanceId)), name: \(Swift.String(describing: name)), outputUrl: \(Swift.String(describing: outputUrl)), status: \(Swift.String(describing: status)))"}
}

extension SsmClientTypes {
    /// Status information about the association.
    public struct InstanceAssociationStatusInfo: Swift.Equatable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The name of the association applied to the managed node.
        public var associationName: Swift.String?
        /// The version of the association applied to the managed node.
        public var associationVersion: Swift.String?
        /// Detailed status information about the association.
        public var detailedStatus: Swift.String?
        /// The association document versions.
        public var documentVersion: Swift.String?
        /// An error code returned by the request to create the association.
        public var errorCode: Swift.String?
        /// The date the association ran.
        public var executionDate: ClientRuntime.Date?
        /// Summary information about association execution.
        public var executionSummary: Swift.String?
        /// The managed node ID where the association was created.
        public var instanceId: Swift.String?
        /// The name of the association.
        public var name: Swift.String?
        /// A URL for an S3 bucket where you want to store the results of this request.
        public var outputUrl: SsmClientTypes.InstanceAssociationOutputUrl?
        /// Status information about the association.
        public var status: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            detailedStatus: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            executionDate: ClientRuntime.Date? = nil,
            executionSummary: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            name: Swift.String? = nil,
            outputUrl: SsmClientTypes.InstanceAssociationOutputUrl? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.detailedStatus = detailedStatus
            self.documentVersion = documentVersion
            self.errorCode = errorCode
            self.executionDate = executionDate
            self.executionSummary = executionSummary
            self.instanceId = instanceId
            self.name = name
            self.outputUrl = outputUrl
            self.status = status
        }
    }

}

extension SsmClientTypes.InstanceInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationId = "ActivationId"
        case agentVersion = "AgentVersion"
        case associationOverview = "AssociationOverview"
        case associationStatus = "AssociationStatus"
        case computerName = "ComputerName"
        case iPAddress = "IPAddress"
        case iamRole = "IamRole"
        case instanceId = "InstanceId"
        case isLatestVersion = "IsLatestVersion"
        case lastAssociationExecutionDate = "LastAssociationExecutionDate"
        case lastPingDateTime = "LastPingDateTime"
        case lastSuccessfulAssociationExecutionDate = "LastSuccessfulAssociationExecutionDate"
        case name = "Name"
        case pingStatus = "PingStatus"
        case platformName = "PlatformName"
        case platformType = "PlatformType"
        case platformVersion = "PlatformVersion"
        case registrationDate = "RegistrationDate"
        case resourceType = "ResourceType"
        case sourceId = "SourceId"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationId = activationId {
            try encodeContainer.encode(activationId, forKey: .activationId)
        }
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let associationOverview = associationOverview {
            try encodeContainer.encode(associationOverview, forKey: .associationOverview)
        }
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus, forKey: .associationStatus)
        }
        if let computerName = computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
        if let iPAddress = iPAddress {
            try encodeContainer.encode(iPAddress, forKey: .iPAddress)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if isLatestVersion != false {
            try encodeContainer.encode(isLatestVersion, forKey: .isLatestVersion)
        }
        if let lastAssociationExecutionDate = lastAssociationExecutionDate {
            try encodeContainer.encode(lastAssociationExecutionDate.timeIntervalSince1970, forKey: .lastAssociationExecutionDate)
        }
        if let lastPingDateTime = lastPingDateTime {
            try encodeContainer.encode(lastPingDateTime.timeIntervalSince1970, forKey: .lastPingDateTime)
        }
        if let lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDate {
            try encodeContainer.encode(lastSuccessfulAssociationExecutionDate.timeIntervalSince1970, forKey: .lastSuccessfulAssociationExecutionDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pingStatus = pingStatus {
            try encodeContainer.encode(pingStatus.rawValue, forKey: .pingStatus)
        }
        if let platformName = platformName {
            try encodeContainer.encode(platformName, forKey: .platformName)
        }
        if let platformType = platformType {
            try encodeContainer.encode(platformType.rawValue, forKey: .platformType)
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let registrationDate = registrationDate {
            try encodeContainer.encode(registrationDate.timeIntervalSince1970, forKey: .registrationDate)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let pingStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PingStatus.self, forKey: .pingStatus)
        pingStatus = pingStatusDecoded
        let lastPingDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastPingDateTime)
        lastPingDateTime = lastPingDateTimeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let isLatestVersionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isLatestVersion)
        isLatestVersion = isLatestVersionDecoded
        let platformTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PlatformType.self, forKey: .platformType)
        platformType = platformTypeDecoded
        let platformNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformName)
        platformName = platformNameDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let activationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationId)
        activationId = activationIdDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let registrationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .registrationDate)
        registrationDate = registrationDateDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let iPAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iPAddress)
        iPAddress = iPAddressDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let lastAssociationExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAssociationExecutionDate)
        lastAssociationExecutionDate = lastAssociationExecutionDateDecoded
        let lastSuccessfulAssociationExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSuccessfulAssociationExecutionDate)
        lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDateDecoded
        let associationOverviewDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAggregatedAssociationOverview.self, forKey: .associationOverview)
        associationOverview = associationOverviewDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
    }
}

extension SsmClientTypes.InstanceInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceInformation(activationId: \(Swift.String(describing: activationId)), agentVersion: \(Swift.String(describing: agentVersion)), associationOverview: \(Swift.String(describing: associationOverview)), associationStatus: \(Swift.String(describing: associationStatus)), computerName: \(Swift.String(describing: computerName)), iPAddress: \(Swift.String(describing: iPAddress)), iamRole: \(Swift.String(describing: iamRole)), instanceId: \(Swift.String(describing: instanceId)), isLatestVersion: \(Swift.String(describing: isLatestVersion)), lastAssociationExecutionDate: \(Swift.String(describing: lastAssociationExecutionDate)), lastPingDateTime: \(Swift.String(describing: lastPingDateTime)), lastSuccessfulAssociationExecutionDate: \(Swift.String(describing: lastSuccessfulAssociationExecutionDate)), name: \(Swift.String(describing: name)), pingStatus: \(Swift.String(describing: pingStatus)), platformName: \(Swift.String(describing: platformName)), platformType: \(Swift.String(describing: platformType)), platformVersion: \(Swift.String(describing: platformVersion)), registrationDate: \(Swift.String(describing: registrationDate)), resourceType: \(Swift.String(describing: resourceType)), sourceId: \(Swift.String(describing: sourceId)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension SsmClientTypes {
    /// Describes a filter for a specific list of managed nodes.
    public struct InstanceInformation: Swift.Equatable {
        /// The activation ID created by Amazon Web Services Systems Manager when the server or virtual machine (VM) was registered.
        public var activationId: Swift.String?
        /// The version of SSM Agent running on your Linux managed node.
        public var agentVersion: Swift.String?
        /// Information about the association.
        public var associationOverview: SsmClientTypes.InstanceAggregatedAssociationOverview?
        /// The status of the association.
        public var associationStatus: Swift.String?
        /// The fully qualified host name of the managed node.
        public var computerName: Swift.String?
        /// The IP address of the managed node.
        public var iPAddress: Swift.String?
        /// The Identity and Access Management (IAM) role assigned to the on-premises Systems Manager managed node. This call doesn't return the IAM role for Amazon Elastic Compute Cloud (Amazon EC2) instances. To retrieve the IAM role for an EC2 instance, use the Amazon EC2 DescribeInstances operation. For information, see [DescribeInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html) in the Amazon EC2 API Reference or [describe-instances](https://docs.aws.amazon.com/cli/latest/ec2/describe-instances.html) in the Amazon Web Services CLI Command Reference.
        public var iamRole: Swift.String?
        /// The managed node ID.
        public var instanceId: Swift.String?
        /// Indicates whether the latest version of SSM Agent is running on your Linux managed node. This field doesn't indicate whether or not the latest version is installed on Windows managed nodes, because some older versions of Windows Server use the EC2Config service to process Systems Manager requests.
        public var isLatestVersion: Swift.Bool
        /// The date the association was last run.
        public var lastAssociationExecutionDate: ClientRuntime.Date?
        /// The date and time when the agent last pinged the Systems Manager service.
        public var lastPingDateTime: ClientRuntime.Date?
        /// The last date the association was successfully run.
        public var lastSuccessfulAssociationExecutionDate: ClientRuntime.Date?
        /// The name assigned to an on-premises server, edge device, or virtual machine (VM) when it is activated as a Systems Manager managed node. The name is specified as the DefaultInstanceName property using the [CreateActivation] command. It is applied to the managed node by specifying the Activation Code and Activation ID when you install SSM Agent on the node, as explained in [Install SSM Agent for a hybrid environment (Linux)](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-linux.html) and [Install SSM Agent for a hybrid environment (Windows)](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-win.html). To retrieve the Name tag of an EC2 instance, use the Amazon EC2 DescribeInstances operation. For information, see [DescribeInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html) in the Amazon EC2 API Reference or [describe-instances](https://docs.aws.amazon.com/cli/latest/ec2/describe-instances.html) in the Amazon Web Services CLI Command Reference.
        public var name: Swift.String?
        /// Connection status of SSM Agent. The status Inactive has been deprecated and is no longer in use.
        public var pingStatus: SsmClientTypes.PingStatus?
        /// The name of the operating system platform running on your managed node.
        public var platformName: Swift.String?
        /// The operating system platform type.
        public var platformType: SsmClientTypes.PlatformType?
        /// The version of the OS platform running on your managed node.
        public var platformVersion: Swift.String?
        /// The date the server or VM was registered with Amazon Web Services as a managed node.
        public var registrationDate: ClientRuntime.Date?
        /// The type of instance. Instances are either EC2 instances or managed instances.
        public var resourceType: SsmClientTypes.ResourceType?
        /// The ID of the source resource. For IoT Greengrass devices, SourceId is the Thing name.
        public var sourceId: Swift.String?
        /// The type of the source resource. For IoT Greengrass devices, SourceType is AWS::IoT::Thing.
        public var sourceType: SsmClientTypes.SourceType?

        public init (
            activationId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            associationOverview: SsmClientTypes.InstanceAggregatedAssociationOverview? = nil,
            associationStatus: Swift.String? = nil,
            computerName: Swift.String? = nil,
            iPAddress: Swift.String? = nil,
            iamRole: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            isLatestVersion: Swift.Bool = false,
            lastAssociationExecutionDate: ClientRuntime.Date? = nil,
            lastPingDateTime: ClientRuntime.Date? = nil,
            lastSuccessfulAssociationExecutionDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            pingStatus: SsmClientTypes.PingStatus? = nil,
            platformName: Swift.String? = nil,
            platformType: SsmClientTypes.PlatformType? = nil,
            platformVersion: Swift.String? = nil,
            registrationDate: ClientRuntime.Date? = nil,
            resourceType: SsmClientTypes.ResourceType? = nil,
            sourceId: Swift.String? = nil,
            sourceType: SsmClientTypes.SourceType? = nil
        )
        {
            self.activationId = activationId
            self.agentVersion = agentVersion
            self.associationOverview = associationOverview
            self.associationStatus = associationStatus
            self.computerName = computerName
            self.iPAddress = iPAddress
            self.iamRole = iamRole
            self.instanceId = instanceId
            self.isLatestVersion = isLatestVersion
            self.lastAssociationExecutionDate = lastAssociationExecutionDate
            self.lastPingDateTime = lastPingDateTime
            self.lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDate
            self.name = name
            self.pingStatus = pingStatus
            self.platformName = platformName
            self.platformType = platformType
            self.platformVersion = platformVersion
            self.registrationDate = registrationDate
            self.resourceType = resourceType
            self.sourceId = sourceId
            self.sourceType = sourceType
        }
    }

}

extension SsmClientTypes.InstanceInformationFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case valueSet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let valueSet = valueSet {
            var valueSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueSet)
            for instanceinformationfiltervalueset0 in valueSet {
                try valueSetContainer.encode(instanceinformationfiltervalueset0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceInformationFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueSetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueSet)
        var valueSetDecoded0:[Swift.String]? = nil
        if let valueSetContainer = valueSetContainer {
            valueSetDecoded0 = [Swift.String]()
            for string0 in valueSetContainer {
                if let string0 = string0 {
                    valueSetDecoded0?.append(string0)
                }
            }
        }
        valueSet = valueSetDecoded0
    }
}

extension SsmClientTypes.InstanceInformationFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceInformationFilter(key: \(Swift.String(describing: key)), valueSet: \(Swift.String(describing: valueSet)))"}
}

extension SsmClientTypes {
    /// Describes a filter for a specific list of managed nodes. You can filter node information by using tags. You specify tags by using a key-value mapping. Use this operation instead of the [DescribeInstanceInformationRequest$InstanceInformationFilterList] method. The InstanceInformationFilterList method is a legacy method and doesn't support tags.
    public struct InstanceInformationFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: SsmClientTypes.InstanceInformationFilterKey?
        /// The filter values.
        /// This member is required.
        public var valueSet: [Swift.String]?

        public init (
            key: SsmClientTypes.InstanceInformationFilterKey? = nil,
            valueSet: [Swift.String]? = nil
        )
        {
            self.key = key
            self.valueSet = valueSet
        }
    }

}

extension SsmClientTypes {
    public enum InstanceInformationFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activationIds
        case agentVersion
        case associationStatus
        case iamRole
        case instanceIds
        case pingStatus
        case platformTypes
        case resourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceInformationFilterKey] {
            return [
                .activationIds,
                .agentVersion,
                .associationStatus,
                .iamRole,
                .instanceIds,
                .pingStatus,
                .platformTypes,
                .resourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activationIds: return "ActivationIds"
            case .agentVersion: return "AgentVersion"
            case .associationStatus: return "AssociationStatus"
            case .iamRole: return "IamRole"
            case .instanceIds: return "InstanceIds"
            case .pingStatus: return "PingStatus"
            case .platformTypes: return "PlatformTypes"
            case .resourceType: return "ResourceType"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceInformationFilterKey(rawValue: rawValue) ?? InstanceInformationFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.InstanceInformationStringFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for instanceinformationfiltervalueset0 in values {
                try valuesContainer.encode(instanceinformationfiltervalueset0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.InstanceInformationStringFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceInformationStringFilter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// The filters to describe or get information about your managed nodes.
    public struct InstanceInformationStringFilter: Swift.Equatable {
        /// The filter key name to describe your managed nodes. For example: "InstanceIds"|"AgentVersion"|"PingStatus"|"PlatformTypes"|"ActivationIds"|"IamRole"|"ResourceType"|"AssociationStatus"|"Tag Key" Tag key isn't a valid filter. You must specify either tag-key or tag:keyname and a string. Here are some valid examples: tag-key, tag:123, tag:al!, tag:Windows. Here are some invalid examples: tag-keys, Tag Key, tag:, tagKey, abc:keyname.
        /// This member is required.
        public var key: Swift.String?
        /// The filter values.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes.InstancePatchState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case criticalNonCompliantCount = "CriticalNonCompliantCount"
        case failedCount = "FailedCount"
        case installOverrideList = "InstallOverrideList"
        case installedCount = "InstalledCount"
        case installedOtherCount = "InstalledOtherCount"
        case installedPendingRebootCount = "InstalledPendingRebootCount"
        case installedRejectedCount = "InstalledRejectedCount"
        case instanceId = "InstanceId"
        case lastNoRebootInstallOperationTime = "LastNoRebootInstallOperationTime"
        case missingCount = "MissingCount"
        case notApplicableCount = "NotApplicableCount"
        case operation = "Operation"
        case operationEndTime = "OperationEndTime"
        case operationStartTime = "OperationStartTime"
        case otherNonCompliantCount = "OtherNonCompliantCount"
        case ownerInformation = "OwnerInformation"
        case patchGroup = "PatchGroup"
        case rebootOption = "RebootOption"
        case securityNonCompliantCount = "SecurityNonCompliantCount"
        case snapshotId = "SnapshotId"
        case unreportedNotApplicableCount = "UnreportedNotApplicableCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if criticalNonCompliantCount != 0 {
            try encodeContainer.encode(criticalNonCompliantCount, forKey: .criticalNonCompliantCount)
        }
        if failedCount != 0 {
            try encodeContainer.encode(failedCount, forKey: .failedCount)
        }
        if let installOverrideList = installOverrideList {
            try encodeContainer.encode(installOverrideList, forKey: .installOverrideList)
        }
        if installedCount != 0 {
            try encodeContainer.encode(installedCount, forKey: .installedCount)
        }
        if installedOtherCount != 0 {
            try encodeContainer.encode(installedOtherCount, forKey: .installedOtherCount)
        }
        if installedPendingRebootCount != 0 {
            try encodeContainer.encode(installedPendingRebootCount, forKey: .installedPendingRebootCount)
        }
        if installedRejectedCount != 0 {
            try encodeContainer.encode(installedRejectedCount, forKey: .installedRejectedCount)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastNoRebootInstallOperationTime = lastNoRebootInstallOperationTime {
            try encodeContainer.encode(lastNoRebootInstallOperationTime.timeIntervalSince1970, forKey: .lastNoRebootInstallOperationTime)
        }
        if missingCount != 0 {
            try encodeContainer.encode(missingCount, forKey: .missingCount)
        }
        if notApplicableCount != 0 {
            try encodeContainer.encode(notApplicableCount, forKey: .notApplicableCount)
        }
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let operationEndTime = operationEndTime {
            try encodeContainer.encode(operationEndTime.timeIntervalSince1970, forKey: .operationEndTime)
        }
        if let operationStartTime = operationStartTime {
            try encodeContainer.encode(operationStartTime.timeIntervalSince1970, forKey: .operationStartTime)
        }
        if otherNonCompliantCount != 0 {
            try encodeContainer.encode(otherNonCompliantCount, forKey: .otherNonCompliantCount)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
        if let rebootOption = rebootOption {
            try encodeContainer.encode(rebootOption.rawValue, forKey: .rebootOption)
        }
        if securityNonCompliantCount != 0 {
            try encodeContainer.encode(securityNonCompliantCount, forKey: .securityNonCompliantCount)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if unreportedNotApplicableCount != 0 {
            try encodeContainer.encode(unreportedNotApplicableCount, forKey: .unreportedNotApplicableCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let installOverrideListDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installOverrideList)
        installOverrideList = installOverrideListDecoded
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let installedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .installedCount)
        installedCount = installedCountDecoded
        let installedOtherCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .installedOtherCount)
        installedOtherCount = installedOtherCountDecoded
        let installedPendingRebootCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .installedPendingRebootCount)
        installedPendingRebootCount = installedPendingRebootCountDecoded
        let installedRejectedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .installedRejectedCount)
        installedRejectedCount = installedRejectedCountDecoded
        let missingCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .missingCount)
        missingCount = missingCountDecoded
        let failedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .failedCount)
        failedCount = failedCountDecoded
        let unreportedNotApplicableCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .unreportedNotApplicableCount)
        unreportedNotApplicableCount = unreportedNotApplicableCountDecoded
        let notApplicableCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .notApplicableCount)
        notApplicableCount = notApplicableCountDecoded
        let operationStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .operationStartTime)
        operationStartTime = operationStartTimeDecoded
        let operationEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .operationEndTime)
        operationEndTime = operationEndTimeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchOperationType.self, forKey: .operation)
        operation = operationDecoded
        let lastNoRebootInstallOperationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastNoRebootInstallOperationTime)
        lastNoRebootInstallOperationTime = lastNoRebootInstallOperationTimeDecoded
        let rebootOptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.RebootOption.self, forKey: .rebootOption)
        rebootOption = rebootOptionDecoded
        let criticalNonCompliantCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .criticalNonCompliantCount)
        criticalNonCompliantCount = criticalNonCompliantCountDecoded
        let securityNonCompliantCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .securityNonCompliantCount)
        securityNonCompliantCount = securityNonCompliantCountDecoded
        let otherNonCompliantCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .otherNonCompliantCount)
        otherNonCompliantCount = otherNonCompliantCountDecoded
    }
}

extension SsmClientTypes.InstancePatchState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstancePatchState(baselineId: \(Swift.String(describing: baselineId)), criticalNonCompliantCount: \(Swift.String(describing: criticalNonCompliantCount)), failedCount: \(Swift.String(describing: failedCount)), installOverrideList: \(Swift.String(describing: installOverrideList)), installedCount: \(Swift.String(describing: installedCount)), installedOtherCount: \(Swift.String(describing: installedOtherCount)), installedPendingRebootCount: \(Swift.String(describing: installedPendingRebootCount)), installedRejectedCount: \(Swift.String(describing: installedRejectedCount)), instanceId: \(Swift.String(describing: instanceId)), lastNoRebootInstallOperationTime: \(Swift.String(describing: lastNoRebootInstallOperationTime)), missingCount: \(Swift.String(describing: missingCount)), notApplicableCount: \(Swift.String(describing: notApplicableCount)), operation: \(Swift.String(describing: operation)), operationEndTime: \(Swift.String(describing: operationEndTime)), operationStartTime: \(Swift.String(describing: operationStartTime)), otherNonCompliantCount: \(Swift.String(describing: otherNonCompliantCount)), ownerInformation: \(Swift.String(describing: ownerInformation)), patchGroup: \(Swift.String(describing: patchGroup)), rebootOption: \(Swift.String(describing: rebootOption)), securityNonCompliantCount: \(Swift.String(describing: securityNonCompliantCount)), snapshotId: \(Swift.String(describing: snapshotId)), unreportedNotApplicableCount: \(Swift.String(describing: unreportedNotApplicableCount)))"}
}

extension SsmClientTypes {
    /// Defines the high-level patch compliance state for a managed node, providing information about the number of installed, missing, not applicable, and failed patches along with metadata about the operation when this information was gathered for the managed node.
    public struct InstancePatchState: Swift.Equatable {
        /// The ID of the patch baseline used to patch the managed node.
        /// This member is required.
        public var baselineId: Swift.String?
        /// The number of managed nodes where patches that are specified as Critical for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
        public var criticalNonCompliantCount: Swift.Int
        /// The number of patches from the patch baseline that were attempted to be installed during the last patching operation, but failed to install.
        public var failedCount: Swift.Int
        /// An https URL or an Amazon Simple Storage Service (Amazon S3) path-style URL to a list of patches to be installed. This patch installation list, which you maintain in an S3 bucket in YAML format and specify in the SSM document AWS-RunPatchBaseline, overrides the patches specified by the default patch baseline. For more information about the InstallOverrideList parameter, see [About the ]AWS-RunPatchBaseline(https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html) SSM document in the Amazon Web Services Systems Manager User Guide.
        public var installOverrideList: Swift.String?
        /// The number of patches from the patch baseline that are installed on the managed node.
        public var installedCount: Swift.Int
        /// The number of patches not specified in the patch baseline that are installed on the managed node.
        public var installedOtherCount: Swift.Int
        /// The number of patches installed by Patch Manager since the last time the managed node was rebooted.
        public var installedPendingRebootCount: Swift.Int
        /// The number of patches installed on a managed node that are specified in a RejectedPatches list. Patches with a status of InstalledRejected were typically installed before they were added to a RejectedPatches list. If ALLOW_AS_DEPENDENCY is the specified option for RejectedPatchesAction, the value of InstalledRejectedCount will always be 0 (zero).
        public var installedRejectedCount: Swift.Int
        /// The ID of the managed node the high-level patch compliance information was collected for.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The time of the last attempt to patch the managed node with NoReboot specified as the reboot option.
        public var lastNoRebootInstallOperationTime: ClientRuntime.Date?
        /// The number of patches from the patch baseline that are applicable for the managed node but aren't currently installed.
        public var missingCount: Swift.Int
        /// The number of patches from the patch baseline that aren't applicable for the managed node and therefore aren't installed on the node. This number may be truncated if the list of patch names is very large. The number of patches beyond this limit are reported in UnreportedNotApplicableCount.
        public var notApplicableCount: Swift.Int
        /// The type of patching operation that was performed: or
        ///
        /// * SCAN assesses the patch compliance state.
        ///
        /// * INSTALL installs missing patches.
        /// This member is required.
        public var operation: SsmClientTypes.PatchOperationType?
        /// The time the most recent patching operation completed on the managed node.
        /// This member is required.
        public var operationEndTime: ClientRuntime.Date?
        /// The time the most recent patching operation was started on the managed node.
        /// This member is required.
        public var operationStartTime: ClientRuntime.Date?
        /// The number of managed nodes with patches installed that are specified as other than Critical or Security but aren't compliant with the patch baseline. The status of these managed nodes is NON_COMPLIANT.
        public var otherNonCompliantCount: Swift.Int
        /// Placeholder information. This field will always be empty in the current release of the service.
        public var ownerInformation: Swift.String?
        /// The name of the patch group the managed node belongs to.
        /// This member is required.
        public var patchGroup: Swift.String?
        /// Indicates the reboot option specified in the patch baseline. Reboot options apply to Install operations only. Reboots aren't attempted for Patch Manager Scan operations.
        ///
        /// * RebootIfNeeded: Patch Manager tries to reboot the managed node if it installed any patches, or if any patches are detected with a status of InstalledPendingReboot.
        ///
        /// * NoReboot: Patch Manager attempts to install missing packages without trying to reboot the system. Patches installed with this option are assigned a status of InstalledPendingReboot. These patches might not be in effect until a reboot is performed.
        public var rebootOption: SsmClientTypes.RebootOption?
        /// The number of managed nodes where patches that are specified as Security in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
        public var securityNonCompliantCount: Swift.Int
        /// The ID of the patch baseline snapshot used during the patching operation when this compliance data was collected.
        public var snapshotId: Swift.String?
        /// The number of patches beyond the supported limit of NotApplicableCount that aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.
        public var unreportedNotApplicableCount: Swift.Int

        public init (
            baselineId: Swift.String? = nil,
            criticalNonCompliantCount: Swift.Int = 0,
            failedCount: Swift.Int = 0,
            installOverrideList: Swift.String? = nil,
            installedCount: Swift.Int = 0,
            installedOtherCount: Swift.Int = 0,
            installedPendingRebootCount: Swift.Int = 0,
            installedRejectedCount: Swift.Int = 0,
            instanceId: Swift.String? = nil,
            lastNoRebootInstallOperationTime: ClientRuntime.Date? = nil,
            missingCount: Swift.Int = 0,
            notApplicableCount: Swift.Int = 0,
            operation: SsmClientTypes.PatchOperationType? = nil,
            operationEndTime: ClientRuntime.Date? = nil,
            operationStartTime: ClientRuntime.Date? = nil,
            otherNonCompliantCount: Swift.Int = 0,
            ownerInformation: Swift.String? = nil,
            patchGroup: Swift.String? = nil,
            rebootOption: SsmClientTypes.RebootOption? = nil,
            securityNonCompliantCount: Swift.Int = 0,
            snapshotId: Swift.String? = nil,
            unreportedNotApplicableCount: Swift.Int = 0
        )
        {
            self.baselineId = baselineId
            self.criticalNonCompliantCount = criticalNonCompliantCount
            self.failedCount = failedCount
            self.installOverrideList = installOverrideList
            self.installedCount = installedCount
            self.installedOtherCount = installedOtherCount
            self.installedPendingRebootCount = installedPendingRebootCount
            self.installedRejectedCount = installedRejectedCount
            self.instanceId = instanceId
            self.lastNoRebootInstallOperationTime = lastNoRebootInstallOperationTime
            self.missingCount = missingCount
            self.notApplicableCount = notApplicableCount
            self.operation = operation
            self.operationEndTime = operationEndTime
            self.operationStartTime = operationStartTime
            self.otherNonCompliantCount = otherNonCompliantCount
            self.ownerInformation = ownerInformation
            self.patchGroup = patchGroup
            self.rebootOption = rebootOption
            self.securityNonCompliantCount = securityNonCompliantCount
            self.snapshotId = snapshotId
            self.unreportedNotApplicableCount = unreportedNotApplicableCount
        }
    }

}

extension SsmClientTypes.InstancePatchStateFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for instancepatchstatefiltervalues0 in values {
                try valuesContainer.encode(instancepatchstatefiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstancePatchStateOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes.InstancePatchStateFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstancePatchStateFilter(key: \(Swift.String(describing: key)), type: \(Swift.String(describing: type)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// Defines a filter used in [DescribeInstancePatchStatesForPatchGroup] to scope down the information returned by the API. Example: To filter for all managed nodes in a patch group having more than three patches with a FailedCount status, use the following for the filter:
    ///
    /// * Value for Key: FailedCount
    ///
    /// * Value for Type: GreaterThan
    ///
    /// * Value for Values: 3
    public struct InstancePatchStateFilter: Swift.Equatable {
        /// The key for the filter. Supported values include the following:
        ///
        /// * InstalledCount
        ///
        /// * InstalledOtherCount
        ///
        /// * InstalledPendingRebootCount
        ///
        /// * InstalledRejectedCount
        ///
        /// * MissingCount
        ///
        /// * FailedCount
        ///
        /// * UnreportedNotApplicableCount
        ///
        /// * NotApplicableCount
        /// This member is required.
        public var key: Swift.String?
        /// The type of comparison that should be performed for the value.
        /// This member is required.
        public var type: SsmClientTypes.InstancePatchStateOperatorType?
        /// The value for the filter. Must be an integer greater than or equal to 0.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            type: SsmClientTypes.InstancePatchStateOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum InstancePatchStateOperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case greaterThan
        case lessThan
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [InstancePatchStateOperatorType] {
            return [
                .equal,
                .greaterThan,
                .lessThan,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "Equal"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstancePatchStateOperatorType(rawValue: rawValue) ?? InstancePatchStateOperatorType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerError(message: \(Swift.String(describing: message)))"}
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred on the server side.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidActivation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidActivation(message: \(Swift.String(describing: message)))"}
}

extension InvalidActivation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidActivationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The activation isn't valid. The activation might have been deleted, or the ActivationId and the ActivationCode don't match.
public struct InvalidActivation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidActivationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidActivationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidActivationId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidActivationId(message: \(Swift.String(describing: message)))"}
}

extension InvalidActivationId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidActivationIdBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The activation ID isn't valid. Verify the you entered the correct ActivationId or ActivationCode and try again.
public struct InvalidActivationId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidActivationIdBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidActivationIdBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAggregatorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAggregatorException(message: \(Swift.String(describing: message)))"}
}

extension InvalidAggregatorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAggregatorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified aggregator isn't valid for inventory groups. Verify that the aggregator uses a valid inventory type such as AWS:Application or AWS:InstanceInformation.
public struct InvalidAggregatorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAggregatorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAggregatorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAllowedPatternException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAllowedPatternException(message: \(Swift.String(describing: message)))"}
}

extension InvalidAllowedPatternException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAllowedPatternExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request doesn't meet the regular expression requirement.
public struct InvalidAllowedPatternException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The request doesn't meet the regular expression requirement.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAllowedPatternExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAllowedPatternExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAssociation(message: \(Swift.String(describing: message)))"}
}

extension InvalidAssociation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAssociationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The association isn't valid or doesn't exist.
public struct InvalidAssociation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAssociationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAssociationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAssociationVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAssociationVersion(message: \(Swift.String(describing: message)))"}
}

extension InvalidAssociationVersion {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAssociationVersionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The version you specified isn't valid. Use ListAssociationVersions to view all versions of an association according to the association ID. Or, use the $LATEST parameter to view the latest version of the association.
public struct InvalidAssociationVersion: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAssociationVersionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAssociationVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAutomationExecutionParametersException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAutomationExecutionParametersException(message: \(Swift.String(describing: message)))"}
}

extension InvalidAutomationExecutionParametersException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAutomationExecutionParametersExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The supplied parameters for invoking the specified Automation runbook are incorrect. For example, they may not match the set of parameters permitted for the specified Automation document.
public struct InvalidAutomationExecutionParametersException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAutomationExecutionParametersExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAutomationExecutionParametersExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAutomationSignalException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAutomationSignalException(message: \(Swift.String(describing: message)))"}
}

extension InvalidAutomationSignalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAutomationSignalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The signal isn't valid for the current Automation execution.
public struct InvalidAutomationSignalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAutomationSignalExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAutomationSignalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAutomationStatusUpdateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAutomationStatusUpdateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidAutomationStatusUpdateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAutomationStatusUpdateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified update status operation isn't valid.
public struct InvalidAutomationStatusUpdateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAutomationStatusUpdateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAutomationStatusUpdateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommandId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidCommandId()"}
}

extension InvalidCommandId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified command ID isn't valid. Verify the ID and try again.
public struct InvalidCommandId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension InvalidDeleteInventoryParametersException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDeleteInventoryParametersException(message: \(Swift.String(describing: message)))"}
}

extension InvalidDeleteInventoryParametersException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDeleteInventoryParametersExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the parameters specified for the delete operation isn't valid. Verify all parameters and try again.
public struct InvalidDeleteInventoryParametersException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeleteInventoryParametersExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDeleteInventoryParametersExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeletionIdException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDeletionIdException(message: \(Swift.String(describing: message)))"}
}

extension InvalidDeletionIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDeletionIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The ID specified for the delete operation doesn't exist or isn't valid. Verify the ID and try again.
public struct InvalidDeletionIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeletionIdExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDeletionIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocument: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDocument(message: \(Swift.String(describing: message)))"}
}

extension InvalidDocument {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified SSM document doesn't exist.
public struct InvalidDocument: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The SSM document doesn't exist or the document isn't available to the user. This exception can be issued by various API operations.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDocumentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDocumentContent(message: \(Swift.String(describing: message)))"}
}

extension InvalidDocumentContent {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentContentBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The content for the document isn't valid.
public struct InvalidDocumentContent: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the validation error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentContentBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDocumentContentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDocumentOperation(message: \(Swift.String(describing: message)))"}
}

extension InvalidDocumentOperation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentOperationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You attempted to delete a document while it is still shared. You must stop sharing the document before you can delete it.
public struct InvalidDocumentOperation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentOperationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDocumentOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentSchemaVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDocumentSchemaVersion(message: \(Swift.String(describing: message)))"}
}

extension InvalidDocumentSchemaVersion {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentSchemaVersionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The version of the document schema isn't supported.
public struct InvalidDocumentSchemaVersion: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentSchemaVersionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDocumentSchemaVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDocumentType(message: \(Swift.String(describing: message)))"}
}

extension InvalidDocumentType {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentTypeBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The SSM document type isn't valid. Valid document types are described in the DocumentType property.
public struct InvalidDocumentType: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentTypeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDocumentTypeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDocumentVersion(message: \(Swift.String(describing: message)))"}
}

extension InvalidDocumentVersion {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentVersionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The document version isn't valid or doesn't exist.
public struct InvalidDocumentVersion: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentVersionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDocumentVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidFilter(message: \(Swift.String(describing: message)))"}
}

extension InvalidFilter {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidFilterBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The filter name isn't valid. Verify the you entered the correct name and try again.
public struct InvalidFilter: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidFilterBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilterKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidFilterKey()"}
}

extension InvalidFilterKey {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified key isn't valid.
public struct InvalidFilterKey: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension InvalidFilterOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidFilterOption(message: \(Swift.String(describing: message)))"}
}

extension InvalidFilterOption {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidFilterOptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified filter option isn't valid. Valid options are Equals and BeginsWith. For Path filter, valid options are Recursive and OneLevel.
public struct InvalidFilterOption: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The specified filter option isn't valid. Valid options are Equals and BeginsWith. For Path filter, valid options are Recursive and OneLevel.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterOptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidFilterOptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilterValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidFilterValue(message: \(Swift.String(describing: message)))"}
}

extension InvalidFilterValue {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidFilterValueBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The filter value isn't valid. Verify the value and try again.
public struct InvalidFilterValue: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterValueBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidFilterValueBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInstanceId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInstanceId(message: \(Swift.String(describing: message)))"}
}

extension InvalidInstanceId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInstanceIdBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The following problems can cause this exception:
///
/// * You don't have permission to access the managed node.
///
/// * Amazon Web Services Systems Manager Agent(SSM Agent) isn't running. Verify that SSM Agent is running.
///
/// * SSM Agent isn't registered with the SSM endpoint. Try reinstalling SSM Agent.
///
/// * The managed node isn't in valid state. Valid states are: Running, Pending, Stopped, and Stopping. Invalid states are: Shutting-down and Terminated.
public struct InvalidInstanceId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInstanceIdBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInstanceIdBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInstanceInformationFilterValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInstanceInformationFilterValue(message: \(Swift.String(describing: message)))"}
}

extension InvalidInstanceInformationFilterValue {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInstanceInformationFilterValueBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified filter value isn't valid.
public struct InvalidInstanceInformationFilterValue: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInstanceInformationFilterValueBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInstanceInformationFilterValueBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInventoryGroupException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInventoryGroupException(message: \(Swift.String(describing: message)))"}
}

extension InvalidInventoryGroupException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInventoryGroupExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified inventory group isn't valid.
public struct InvalidInventoryGroupException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInventoryGroupExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInventoryGroupExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInventoryItemContextException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInventoryItemContextException(message: \(Swift.String(describing: message)))"}
}

extension InvalidInventoryItemContextException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInventoryItemContextExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You specified invalid keys or values in the Context attribute for InventoryItem. Verify the keys and values, and try again.
public struct InvalidInventoryItemContextException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInventoryItemContextExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInventoryItemContextExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInventoryRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInventoryRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidInventoryRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInventoryRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request isn't valid.
public struct InvalidInventoryRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInventoryRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInventoryRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidItemContentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidItemContentException(message: \(Swift.String(describing: message)), typeName: \(Swift.String(describing: typeName)))"}
}

extension InvalidItemContentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidItemContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more content items isn't valid.
public struct InvalidItemContentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var typeName: Swift.String?

    public init (
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct InvalidItemContentExceptionBody: Swift.Equatable {
    public let typeName: Swift.String?
    public let message: Swift.String?
}

extension InvalidItemContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidKeyId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidKeyId(message: \(Swift.String(describing: message)))"}
}

extension InvalidKeyId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidKeyIdBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The query key ID isn't valid.
public struct InvalidKeyId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidKeyIdBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidKeyIdBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextToken: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextToken(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextToken {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified token isn't valid.
public struct InvalidNextToken: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNotificationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNotificationConfig(message: \(Swift.String(describing: message)))"}
}

extension InvalidNotificationConfig {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNotificationConfigBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more configuration items isn't valid. Verify that a valid Amazon Resource Name (ARN) was provided for an Amazon Simple Notification Service topic.
public struct InvalidNotificationConfig: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNotificationConfigBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNotificationConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOptionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOptionException(message: \(Swift.String(describing: message)))"}
}

extension InvalidOptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidOptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The delete inventory option specified isn't valid. Verify the option and try again.
public struct InvalidOptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOptionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOutputFolder: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOutputFolder()"}
}

extension InvalidOutputFolder {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The S3 bucket doesn't exist.
public struct InvalidOutputFolder: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension InvalidOutputLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOutputLocation()"}
}

extension InvalidOutputLocation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The output location isn't valid or doesn't exist.
public struct InvalidOutputLocation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension InvalidParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameters(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameters {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParametersBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You must specify values for all required parameters in the Amazon Web Services Systems Manager document (SSM document). You can only supply values to parameters defined in the SSM document.
public struct InvalidParameters: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParametersBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParametersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPermissionType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPermissionType(message: \(Swift.String(describing: message)))"}
}

extension InvalidPermissionType {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPermissionTypeBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The permission type isn't supported. Share is the only supported permission type.
public struct InvalidPermissionType: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPermissionTypeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidPermissionTypeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPluginName: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPluginName()"}
}

extension InvalidPluginName {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The plugin name isn't valid.
public struct InvalidPluginName: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension InvalidPolicyAttributeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPolicyAttributeException(message: \(Swift.String(describing: message)))"}
}

extension InvalidPolicyAttributeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPolicyAttributeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A policy attribute or its value is invalid.
public struct InvalidPolicyAttributeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyAttributeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidPolicyAttributeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPolicyTypeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPolicyTypeException(message: \(Swift.String(describing: message)))"}
}

extension InvalidPolicyTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPolicyTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The policy type isn't supported. Parameter Store supports the following policy types: Expiration, ExpirationNotification, and NoChangeNotification.
public struct InvalidPolicyTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyTypeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidPolicyTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResourceId()"}
}

extension InvalidResourceId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource ID isn't valid. Verify that you entered the correct ID and try again.
public struct InvalidResourceId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension InvalidResourceType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResourceType()"}
}

extension InvalidResourceType {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource type isn't valid. For example, if you are attempting to tag an EC2 instance, the instance must be a registered managed node.
public struct InvalidResourceType: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension InvalidResultAttributeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResultAttributeException(message: \(Swift.String(describing: message)))"}
}

extension InvalidResultAttributeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResultAttributeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified inventory item result attribute isn't valid.
public struct InvalidResultAttributeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResultAttributeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidResultAttributeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRole: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRole(message: \(Swift.String(describing: message)))"}
}

extension InvalidRole {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRoleBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The role name can't contain invalid characters. Also verify that you specified an IAM role for notifications that includes the required trust policy. For information about configuring the IAM role for Run Command notifications, see [Configuring Amazon SNS Notifications for Run Command](https://docs.aws.amazon.com/systems-manager/latest/userguide/rc-sns-notifications.html) in the Amazon Web Services Systems Manager User Guide.
public struct InvalidRole: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRoleBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRoleBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSchedule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSchedule(message: \(Swift.String(describing: message)))"}
}

extension InvalidSchedule {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidScheduleBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The schedule is invalid. Verify your cron or rate expression and try again.
public struct InvalidSchedule: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidScheduleBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidScheduleBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTarget(message: \(Swift.String(describing: message)))"}
}

extension InvalidTarget {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTargetBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The target isn't valid or doesn't exist. It might not be configured for Systems Manager or you might not have permission to perform the operation.
public struct InvalidTarget: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTargetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTypeNameException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTypeNameException(message: \(Swift.String(describing: message)))"}
}

extension InvalidTypeNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTypeNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter type name isn't valid.
public struct InvalidTypeNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTypeNameExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTypeNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidUpdate(message: \(Swift.String(describing: message)))"}
}

extension InvalidUpdate {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidUpdateBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The update isn't valid.
public struct InvalidUpdate: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUpdateBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidUpdateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.InventoryAggregator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregators = "Aggregators"
        case expression = "Expression"
        case groups = "Groups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for inventoryaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(inventoryaggregatorlist0)
            }
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for inventorygrouplist0 in groups {
                try groupsContainer.encode(inventorygrouplist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let aggregatorsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[SsmClientTypes.InventoryAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [SsmClientTypes.InventoryAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryGroup?].self, forKey: .groups)
        var groupsDecoded0:[SsmClientTypes.InventoryGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [SsmClientTypes.InventoryGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension SsmClientTypes.InventoryAggregator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryAggregator(aggregators: \(Swift.String(describing: aggregators)), expression: \(Swift.String(describing: expression)), groups: \(Swift.String(describing: groups)))"}
}

extension SsmClientTypes {
    /// Specifies the inventory type and attribute for the aggregation execution.
    public struct InventoryAggregator: Swift.Equatable {
        /// Nested aggregators to further refine aggregation for an inventory type.
        public var aggregators: [SsmClientTypes.InventoryAggregator]?
        /// The inventory type and attribute name for aggregation.
        public var expression: Swift.String?
        /// A user-defined set of one or more filters on which to aggregate inventory data. Groups return a count of resources that match and don't match the specified criteria.
        public var groups: [SsmClientTypes.InventoryGroup]?

        public init (
            aggregators: [SsmClientTypes.InventoryAggregator]? = nil,
            expression: Swift.String? = nil,
            groups: [SsmClientTypes.InventoryGroup]? = nil
        )
        {
            self.aggregators = aggregators
            self.expression = expression
            self.groups = groups
        }
    }

}

extension SsmClientTypes {
    public enum InventoryAttributeDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryAttributeDataType] {
            return [
                .number,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .number: return "number"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryAttributeDataType(rawValue: rawValue) ?? InventoryAttributeDataType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum InventoryDeletionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryDeletionStatus] {
            return [
                .complete,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .inProgress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryDeletionStatus(rawValue: rawValue) ?? InventoryDeletionStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.InventoryDeletionStatusItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionId = "DeletionId"
        case deletionStartTime = "DeletionStartTime"
        case deletionSummary = "DeletionSummary"
        case lastStatus = "LastStatus"
        case lastStatusMessage = "LastStatusMessage"
        case lastStatusUpdateTime = "LastStatusUpdateTime"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionId = deletionId {
            try encodeContainer.encode(deletionId, forKey: .deletionId)
        }
        if let deletionStartTime = deletionStartTime {
            try encodeContainer.encode(deletionStartTime.timeIntervalSince1970, forKey: .deletionStartTime)
        }
        if let deletionSummary = deletionSummary {
            try encodeContainer.encode(deletionSummary, forKey: .deletionSummary)
        }
        if let lastStatus = lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastStatusMessage = lastStatusMessage {
            try encodeContainer.encode(lastStatusMessage, forKey: .lastStatusMessage)
        }
        if let lastStatusUpdateTime = lastStatusUpdateTime {
            try encodeContainer.encode(lastStatusUpdateTime.timeIntervalSince1970, forKey: .lastStatusUpdateTime)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionId)
        deletionId = deletionIdDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let deletionStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletionStartTime)
        deletionStartTime = deletionStartTimeDecoded
        let lastStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventoryDeletionStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let lastStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastStatusMessage)
        lastStatusMessage = lastStatusMessageDecoded
        let deletionSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventoryDeletionSummary.self, forKey: .deletionSummary)
        deletionSummary = deletionSummaryDecoded
        let lastStatusUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStatusUpdateTime)
        lastStatusUpdateTime = lastStatusUpdateTimeDecoded
    }
}

extension SsmClientTypes.InventoryDeletionStatusItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryDeletionStatusItem(deletionId: \(Swift.String(describing: deletionId)), deletionStartTime: \(Swift.String(describing: deletionStartTime)), deletionSummary: \(Swift.String(describing: deletionSummary)), lastStatus: \(Swift.String(describing: lastStatus)), lastStatusMessage: \(Swift.String(describing: lastStatusMessage)), lastStatusUpdateTime: \(Swift.String(describing: lastStatusUpdateTime)), typeName: \(Swift.String(describing: typeName)))"}
}

extension SsmClientTypes {
    /// Status information returned by the DeleteInventory operation.
    public struct InventoryDeletionStatusItem: Swift.Equatable {
        /// The deletion ID returned by the DeleteInventory operation.
        public var deletionId: Swift.String?
        /// The UTC timestamp when the delete operation started.
        public var deletionStartTime: ClientRuntime.Date?
        /// Information about the delete operation. For more information about this summary, see [Understanding the delete inventory summary](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-custom.html#sysman-inventory-delete) in the Amazon Web Services Systems Manager User Guide.
        public var deletionSummary: SsmClientTypes.InventoryDeletionSummary?
        /// The status of the operation. Possible values are InProgress and Complete.
        public var lastStatus: SsmClientTypes.InventoryDeletionStatus?
        /// Information about the status.
        public var lastStatusMessage: Swift.String?
        /// The UTC timestamp of when the last status report.
        public var lastStatusUpdateTime: ClientRuntime.Date?
        /// The name of the inventory data type.
        public var typeName: Swift.String?

        public init (
            deletionId: Swift.String? = nil,
            deletionStartTime: ClientRuntime.Date? = nil,
            deletionSummary: SsmClientTypes.InventoryDeletionSummary? = nil,
            lastStatus: SsmClientTypes.InventoryDeletionStatus? = nil,
            lastStatusMessage: Swift.String? = nil,
            lastStatusUpdateTime: ClientRuntime.Date? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.deletionId = deletionId
            self.deletionStartTime = deletionStartTime
            self.deletionSummary = deletionSummary
            self.lastStatus = lastStatus
            self.lastStatusMessage = lastStatusMessage
            self.lastStatusUpdateTime = lastStatusUpdateTime
            self.typeName = typeName
        }
    }

}

extension SsmClientTypes.InventoryDeletionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remainingCount = "RemainingCount"
        case summaryItems = "SummaryItems"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if remainingCount != 0 {
            try encodeContainer.encode(remainingCount, forKey: .remainingCount)
        }
        if let summaryItems = summaryItems {
            var summaryItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .summaryItems)
            for inventorydeletionsummaryitems0 in summaryItems {
                try summaryItemsContainer.encode(inventorydeletionsummaryitems0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let remainingCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .remainingCount)
        remainingCount = remainingCountDecoded
        let summaryItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryDeletionSummaryItem?].self, forKey: .summaryItems)
        var summaryItemsDecoded0:[SsmClientTypes.InventoryDeletionSummaryItem]? = nil
        if let summaryItemsContainer = summaryItemsContainer {
            summaryItemsDecoded0 = [SsmClientTypes.InventoryDeletionSummaryItem]()
            for structure0 in summaryItemsContainer {
                if let structure0 = structure0 {
                    summaryItemsDecoded0?.append(structure0)
                }
            }
        }
        summaryItems = summaryItemsDecoded0
    }
}

extension SsmClientTypes.InventoryDeletionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryDeletionSummary(remainingCount: \(Swift.String(describing: remainingCount)), summaryItems: \(Swift.String(describing: summaryItems)), totalCount: \(Swift.String(describing: totalCount)))"}
}

extension SsmClientTypes {
    /// Information about the delete operation.
    public struct InventoryDeletionSummary: Swift.Equatable {
        /// Remaining number of items to delete.
        public var remainingCount: Swift.Int
        /// A list of counts and versions for deleted items.
        public var summaryItems: [SsmClientTypes.InventoryDeletionSummaryItem]?
        /// The total number of items to delete. This count doesn't change during the delete operation.
        public var totalCount: Swift.Int

        public init (
            remainingCount: Swift.Int = 0,
            summaryItems: [SsmClientTypes.InventoryDeletionSummaryItem]? = nil,
            totalCount: Swift.Int = 0
        )
        {
            self.remainingCount = remainingCount
            self.summaryItems = summaryItems
            self.totalCount = totalCount
        }
    }

}

extension SsmClientTypes.InventoryDeletionSummaryItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case remainingCount = "RemainingCount"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if remainingCount != 0 {
            try encodeContainer.encode(remainingCount, forKey: .remainingCount)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let remainingCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .remainingCount)
        remainingCount = remainingCountDecoded
    }
}

extension SsmClientTypes.InventoryDeletionSummaryItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryDeletionSummaryItem(count: \(Swift.String(describing: count)), remainingCount: \(Swift.String(describing: remainingCount)), version: \(Swift.String(describing: version)))"}
}

extension SsmClientTypes {
    /// Either a count, remaining count, or a version number in a delete inventory summary.
    public struct InventoryDeletionSummaryItem: Swift.Equatable {
        /// A count of the number of deleted items.
        public var count: Swift.Int
        /// The remaining number of items to delete.
        public var remainingCount: Swift.Int
        /// The inventory type version.
        public var version: Swift.String?

        public init (
            count: Swift.Int = 0,
            remainingCount: Swift.Int = 0,
            version: Swift.String? = nil
        )
        {
            self.count = count
            self.remainingCount = remainingCount
            self.version = version
        }
    }

}

extension SsmClientTypes.InventoryFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for inventoryfiltervaluelist0 in values {
                try valuesContainer.encode(inventoryfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventoryQueryOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes.InventoryFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryFilter(key: \(Swift.String(describing: key)), type: \(Swift.String(describing: type)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// One or more filters. Use a filter to return a more specific list of results.
    public struct InventoryFilter: Swift.Equatable {
        /// The name of the filter key.
        /// This member is required.
        public var key: Swift.String?
        /// The type of filter. The Exists filter must be used with aggregators. For more information, see [Aggregating inventory data](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-aggregate.html) in the Amazon Web Services Systems Manager User Guide.
        public var type: SsmClientTypes.InventoryQueryOperatorType?
        /// Inventory filter values. Example: inventory filter where managed node IDs are specified as values Key=AWS:InstanceInformation.InstanceId,Values= i-a12b3c4d5e6g, i-1a2b3c4d5e6,Type=Equal.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            type: SsmClientTypes.InventoryQueryOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }

}

extension SsmClientTypes.InventoryGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SsmClientTypes.InventoryGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryGroup(filters: \(Swift.String(describing: filters)), name: \(Swift.String(describing: name)))"}
}

extension SsmClientTypes {
    /// A user-defined set of one or more filters on which to aggregate inventory data. Groups return a count of resources that match and don't match the specified criteria.
    public struct InventoryGroup: Swift.Equatable {
        /// Filters define the criteria for the group. The matchingCount field displays the number of resources that match the criteria. The notMatchingCount field displays the number of resources that don't match the criteria.
        /// This member is required.
        public var filters: [SsmClientTypes.InventoryFilter]?
        /// The name of the group.
        /// This member is required.
        public var name: Swift.String?

        public init (
            filters: [SsmClientTypes.InventoryFilter]? = nil,
            name: Swift.String? = nil
        )
        {
            self.filters = filters
            self.name = name
        }
    }

}

extension SsmClientTypes.InventoryItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captureTime = "CaptureTime"
        case content = "Content"
        case contentHash = "ContentHash"
        case context = "Context"
        case schemaVersion = "SchemaVersion"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captureTime = captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let content = content {
            var contentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .content)
            for inventoryitementrylist0 in content {
                var inventoryitementrylist0Container = contentContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, inventoryitementry1) in inventoryitementrylist0 {
                    try inventoryitementrylist0Container.encode(inventoryitementry1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let contentHash = contentHash {
            try encodeContainer.encode(contentHash, forKey: .contentHash)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, inventoryitemcontentcontext0) in context {
                try contextContainer.encode(inventoryitemcontentcontext0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let contentHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentHash)
        contentHash = contentHashDecoded
        let contentContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .content)
        var contentDecoded0:[[Swift.String:Swift.String]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in contentContainer {
                var contentContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    contentContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            contentContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let contentContainerDecoded0 = contentContainerDecoded0 {
                    contentDecoded0?.append(contentContainerDecoded0)
                }
            }
        }
        content = contentDecoded0
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in contextContainer {
                if let attributevalue0 = attributevalue0 {
                    contextDecoded0?[key0] = attributevalue0
                }
            }
        }
        context = contextDecoded0
    }
}

extension SsmClientTypes.InventoryItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryItem(captureTime: \(Swift.String(describing: captureTime)), content: \(Swift.String(describing: content)), contentHash: \(Swift.String(describing: contentHash)), context: \(Swift.String(describing: context)), schemaVersion: \(Swift.String(describing: schemaVersion)), typeName: \(Swift.String(describing: typeName)))"}
}

extension SsmClientTypes {
    /// Information collected from managed nodes based on your inventory policy document
    public struct InventoryItem: Swift.Equatable {
        /// The time the inventory information was collected.
        /// This member is required.
        public var captureTime: Swift.String?
        /// The inventory data of the inventory type.
        public var content: [[Swift.String:Swift.String]]?
        /// MD5 hash of the inventory item type contents. The content hash is used to determine whether to update inventory information. The PutInventory API doesn't update the inventory item type contents if the MD5 hash hasn't changed since last update.
        public var contentHash: Swift.String?
        /// A map of associated properties for a specified inventory type. For example, with this attribute, you can specify the ExecutionId, ExecutionType, ComplianceType properties of the AWS:ComplianceItem type.
        public var context: [Swift.String:Swift.String]?
        /// The schema version for the inventory item.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The name of the inventory type. Default inventory item type names start with AWS. Custom inventory type names will start with Custom. Default inventory item types include the following: AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and AWS:WindowsUpdate.
        /// This member is required.
        public var typeName: Swift.String?

        public init (
            captureTime: Swift.String? = nil,
            content: [[Swift.String:Swift.String]]? = nil,
            contentHash: Swift.String? = nil,
            context: [Swift.String:Swift.String]? = nil,
            schemaVersion: Swift.String? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.captureTime = captureTime
            self.content = content
            self.contentHash = contentHash
            self.context = context
            self.schemaVersion = schemaVersion
            self.typeName = typeName
        }
    }

}

extension SsmClientTypes.InventoryItemAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType = "DataType"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventoryAttributeDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension SsmClientTypes.InventoryItemAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryItemAttribute(dataType: \(Swift.String(describing: dataType)), name: \(Swift.String(describing: name)))"}
}

extension SsmClientTypes {
    /// Attributes are the entries within the inventory item content. It contains name and value.
    public struct InventoryItemAttribute: Swift.Equatable {
        /// The data type of the inventory item attribute.
        /// This member is required.
        public var dataType: SsmClientTypes.InventoryAttributeDataType?
        /// Name of the inventory item attribute.
        /// This member is required.
        public var name: Swift.String?

        public init (
            dataType: SsmClientTypes.InventoryAttributeDataType? = nil,
            name: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.name = name
        }
    }

}

extension SsmClientTypes.InventoryItemSchema: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case displayName = "DisplayName"
        case typeName = "TypeName"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for inventoryitemattributelist0 in attributes {
                try attributesContainer.encode(inventoryitemattributelist0)
            }
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryItemAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[SsmClientTypes.InventoryItemAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [SsmClientTypes.InventoryItemAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension SsmClientTypes.InventoryItemSchema: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryItemSchema(attributes: \(Swift.String(describing: attributes)), displayName: \(Swift.String(describing: displayName)), typeName: \(Swift.String(describing: typeName)), version: \(Swift.String(describing: version)))"}
}

extension SsmClientTypes {
    /// The inventory item schema definition. Users can use this to compose inventory query filters.
    public struct InventoryItemSchema: Swift.Equatable {
        /// The schema attributes for inventory. This contains data type and attribute name.
        /// This member is required.
        public var attributes: [SsmClientTypes.InventoryItemAttribute]?
        /// The alias name of the inventory type. The alias name is used for display purposes.
        public var displayName: Swift.String?
        /// The name of the inventory type. Default inventory item type names start with Amazon Web Services. Custom inventory type names will start with Custom. Default inventory item types include the following: AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and AWS:WindowsUpdate.
        /// This member is required.
        public var typeName: Swift.String?
        /// The schema version for the inventory item.
        public var version: Swift.String?

        public init (
            attributes: [SsmClientTypes.InventoryItemAttribute]? = nil,
            displayName: Swift.String? = nil,
            typeName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.displayName = displayName
            self.typeName = typeName
            self.version = version
        }
    }

}

extension SsmClientTypes {
    public enum InventoryQueryOperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginWith
        case equal
        case exists
        case greaterThan
        case lessThan
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryQueryOperatorType] {
            return [
                .beginWith,
                .equal,
                .exists,
                .greaterThan,
                .lessThan,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginWith: return "BeginWith"
            case .equal: return "Equal"
            case .exists: return "Exists"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryQueryOperatorType(rawValue: rawValue) ?? InventoryQueryOperatorType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.InventoryResultEntity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .data)
            for (dictKey0, inventoryresultitemmap0) in data {
                try dataContainer.encode(inventoryresultitemmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.InventoryResultItem?].self, forKey: .data)
        var dataDecoded0: [Swift.String:SsmClientTypes.InventoryResultItem]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [Swift.String:SsmClientTypes.InventoryResultItem]()
            for (key0, inventoryresultitem0) in dataContainer {
                if let inventoryresultitem0 = inventoryresultitem0 {
                    dataDecoded0?[key0] = inventoryresultitem0
                }
            }
        }
        data = dataDecoded0
    }
}

extension SsmClientTypes.InventoryResultEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryResultEntity(data: \(Swift.String(describing: data)), id: \(Swift.String(describing: id)))"}
}

extension SsmClientTypes {
    /// Inventory query results.
    public struct InventoryResultEntity: Swift.Equatable {
        /// The data section in the inventory result entity JSON.
        public var data: [Swift.String:SsmClientTypes.InventoryResultItem]?
        /// ID of the inventory result entity. For example, for managed node inventory the result will be the managed node ID. For EC2 instance inventory, the result will be the instance ID.
        public var id: Swift.String?

        public init (
            data: [Swift.String:SsmClientTypes.InventoryResultItem]? = nil,
            id: Swift.String? = nil
        )
        {
            self.data = data
            self.id = id
        }
    }

}

extension SsmClientTypes.InventoryResultItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captureTime = "CaptureTime"
        case content = "Content"
        case contentHash = "ContentHash"
        case schemaVersion = "SchemaVersion"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captureTime = captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let content = content {
            var contentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .content)
            for inventoryitementrylist0 in content {
                var inventoryitementrylist0Container = contentContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, inventoryitementry1) in inventoryitementrylist0 {
                    try inventoryitementrylist0Container.encode(inventoryitementry1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let contentHash = contentHash {
            try encodeContainer.encode(contentHash, forKey: .contentHash)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let contentHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentHash)
        contentHash = contentHashDecoded
        let contentContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .content)
        var contentDecoded0:[[Swift.String:Swift.String]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in contentContainer {
                var contentContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    contentContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            contentContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let contentContainerDecoded0 = contentContainerDecoded0 {
                    contentDecoded0?.append(contentContainerDecoded0)
                }
            }
        }
        content = contentDecoded0
    }
}

extension SsmClientTypes.InventoryResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryResultItem(captureTime: \(Swift.String(describing: captureTime)), content: \(Swift.String(describing: content)), contentHash: \(Swift.String(describing: contentHash)), schemaVersion: \(Swift.String(describing: schemaVersion)), typeName: \(Swift.String(describing: typeName)))"}
}

extension SsmClientTypes {
    /// The inventory result item.
    public struct InventoryResultItem: Swift.Equatable {
        /// The time inventory item data was captured.
        public var captureTime: Swift.String?
        /// Contains all the inventory data of the item type. Results include attribute names and values.
        /// This member is required.
        public var content: [[Swift.String:Swift.String]]?
        /// MD5 hash of the inventory item type contents. The content hash is used to determine whether to update inventory information. The PutInventory API doesn't update the inventory item type contents if the MD5 hash hasn't changed since last update.
        public var contentHash: Swift.String?
        /// The schema version for the inventory result item/
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The name of the inventory result item type.
        /// This member is required.
        public var typeName: Swift.String?

        public init (
            captureTime: Swift.String? = nil,
            content: [[Swift.String:Swift.String]]? = nil,
            contentHash: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.captureTime = captureTime
            self.content = content
            self.contentHash = contentHash
            self.schemaVersion = schemaVersion
            self.typeName = typeName
        }
    }

}

extension SsmClientTypes {
    public enum InventorySchemaDeleteOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteSchema
        case disableSchema
        case sdkUnknown(Swift.String)

        public static var allCases: [InventorySchemaDeleteOption] {
            return [
                .deleteSchema,
                .disableSchema,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteSchema: return "DeleteSchema"
            case .disableSchema: return "DisableSchema"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventorySchemaDeleteOption(rawValue: rawValue) ?? InventorySchemaDeleteOption.sdkUnknown(rawValue)
        }
    }
}

extension InvocationDoesNotExist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvocationDoesNotExist()"}
}

extension InvocationDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The command ID and managed node ID you specified didn't match any invocations. Verify the command ID and the managed node ID and try again.
public struct InvocationDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension ItemContentMismatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ItemContentMismatchException(message: \(Swift.String(describing: message)), typeName: \(Swift.String(describing: typeName)))"}
}

extension ItemContentMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ItemContentMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The inventory item has invalid content.
public struct ItemContentMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var typeName: Swift.String?

    public init (
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct ItemContentMismatchExceptionBody: Swift.Equatable {
    public let typeName: Swift.String?
    public let message: Swift.String?
}

extension ItemContentMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ItemSizeLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ItemSizeLimitExceededException(message: \(Swift.String(describing: message)), typeName: \(Swift.String(describing: typeName)))"}
}

extension ItemSizeLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ItemSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The inventory item size has exceeded the size limit.
public struct ItemSizeLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var typeName: Swift.String?

    public init (
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct ItemSizeLimitExceededExceptionBody: Swift.Equatable {
    public let typeName: Swift.String?
    public let message: Swift.String?
}

extension ItemSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct LabelParameterVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LabelParameterVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LabelParameterVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LabelParameterVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LabelParameterVersionOutputError>
}

extension LabelParameterVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LabelParameterVersionInput(labels: \(Swift.String(describing: labels)), name: \(Swift.String(describing: name)), parameterVersion: \(Swift.String(describing: parameterVersion)))"}
}

extension LabelParameterVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for parameterlabellist0 in labels {
                try labelsContainer.encode(parameterlabellist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if parameterVersion != 0 {
            try encodeContainer.encode(parameterVersion, forKey: .parameterVersion)
        }
    }
}

public struct LabelParameterVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LabelParameterVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LabelParameterVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LabelParameterVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LabelParameterVersionOutputError>
}

public struct LabelParameterVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LabelParameterVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LabelParameterVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LabelParameterVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LabelParameterVersionOutputError>
}

public struct LabelParameterVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LabelParameterVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: LabelParameterVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = LabelParameterVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<LabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LabelParameterVersionOutputError>
}

public struct LabelParameterVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LabelParameterVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: LabelParameterVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = LabelParameterVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<LabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LabelParameterVersionOutputError>
}

public struct LabelParameterVersionInput: Swift.Equatable {
    /// One or more labels to attach to the specified parameter version.
    /// This member is required.
    public var labels: [Swift.String]?
    /// The parameter name on which you want to attach one or more labels.
    /// This member is required.
    public var name: Swift.String?
    /// The specific version of the parameter on which you want to attach one or more labels. If no version is specified, the system attaches the label to the latest version.
    public var parameterVersion: Swift.Int

    public init (
        labels: [Swift.String]? = nil,
        name: Swift.String? = nil,
        parameterVersion: Swift.Int = 0
    )
    {
        self.labels = labels
        self.name = name
        self.parameterVersion = parameterVersion
    }
}

struct LabelParameterVersionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let parameterVersion: Swift.Int
    public let labels: [Swift.String]?
}

extension LabelParameterVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parameterVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .parameterVersion)
        parameterVersion = parameterVersionDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension LabelParameterVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LabelParameterVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionLabelLimitExceeded" : self = .parameterVersionLabelLimitExceeded(try ParameterVersionLabelLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionNotFound" : self = .parameterVersionNotFound(try ParameterVersionNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LabelParameterVersionOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case parameterNotFound(ParameterNotFound)
    case parameterVersionLabelLimitExceeded(ParameterVersionLabelLimitExceeded)
    case parameterVersionNotFound(ParameterVersionNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension LabelParameterVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LabelParameterVersionOutputResponse(invalidLabels: \(Swift.String(describing: invalidLabels)), parameterVersion: \(Swift.String(describing: parameterVersion)))"}
}

extension LabelParameterVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LabelParameterVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invalidLabels = output.invalidLabels
            self.parameterVersion = output.parameterVersion
        } else {
            self.invalidLabels = nil
            self.parameterVersion = 0
        }
    }
}

public struct LabelParameterVersionOutputResponse: Swift.Equatable {
    /// The label doesn't meet the requirements. For information about parameter label requirements, see [Labeling parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html) in the Amazon Web Services Systems Manager User Guide.
    public var invalidLabels: [Swift.String]?
    /// The version of the parameter that has been labeled.
    public var parameterVersion: Swift.Int

    public init (
        invalidLabels: [Swift.String]? = nil,
        parameterVersion: Swift.Int = 0
    )
    {
        self.invalidLabels = invalidLabels
        self.parameterVersion = parameterVersion
    }
}

struct LabelParameterVersionOutputResponseBody: Swift.Equatable {
    public let invalidLabels: [Swift.String]?
    public let parameterVersion: Swift.Int
}

extension LabelParameterVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidLabels = "InvalidLabels"
        case parameterVersion = "ParameterVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidLabels)
        var invalidLabelsDecoded0:[Swift.String]? = nil
        if let invalidLabelsContainer = invalidLabelsContainer {
            invalidLabelsDecoded0 = [Swift.String]()
            for string0 in invalidLabelsContainer {
                if let string0 = string0 {
                    invalidLabelsDecoded0?.append(string0)
                }
            }
        }
        invalidLabels = invalidLabelsDecoded0
        let parameterVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .parameterVersion)
        parameterVersion = parameterVersionDecoded
    }
}

extension SsmClientTypes {
    public enum LastResourceDataSyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [LastResourceDataSyncStatus] {
            return [
                .failed,
                .inprogress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastResourceDataSyncStatus(rawValue: rawValue) ?? LastResourceDataSyncStatus.sdkUnknown(rawValue)
        }
    }
}

public struct ListAssociationVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociationVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociationVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationVersionsOutputError>
}

extension ListAssociationVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociationVersionsInput(associationId: \(Swift.String(describing: associationId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociationVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssociationVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociationVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociationVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationVersionsOutputError>
}

public struct ListAssociationVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociationVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociationVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationVersionsOutputError>
}

public struct ListAssociationVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAssociationVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociationVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationVersionsOutputError>
}

public struct ListAssociationVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAssociationVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociationVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationVersionsOutputError>
}

public struct ListAssociationVersionsInput: Swift.Equatable {
    /// The association ID for which you want to view all versions.
    /// This member is required.
    public var associationId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociationVersionsInputBody: Swift.Equatable {
    public let associationId: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListAssociationVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociationVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociationVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociationVersionsOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociationVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociationVersionsOutputResponse(associationVersions: \(Swift.String(describing: associationVersions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociationVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationVersions = output.associationVersions
            self.nextToken = output.nextToken
        } else {
            self.associationVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociationVersionsOutputResponse: Swift.Equatable {
    /// Information about all versions of the association for the specified association ID.
    public var associationVersions: [SsmClientTypes.AssociationVersionInfo]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationVersions: [SsmClientTypes.AssociationVersionInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationVersions = associationVersions
        self.nextToken = nextToken
    }
}

struct ListAssociationVersionsOutputResponseBody: Swift.Equatable {
    public let associationVersions: [SsmClientTypes.AssociationVersionInfo]?
    public let nextToken: Swift.String?
}

extension ListAssociationVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationVersions = "AssociationVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationVersionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationVersionInfo?].self, forKey: .associationVersions)
        var associationVersionsDecoded0:[SsmClientTypes.AssociationVersionInfo]? = nil
        if let associationVersionsContainer = associationVersionsContainer {
            associationVersionsDecoded0 = [SsmClientTypes.AssociationVersionInfo]()
            for structure0 in associationVersionsContainer {
                if let structure0 = structure0 {
                    associationVersionsDecoded0?.append(structure0)
                }
            }
        }
        associationVersions = associationVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssociationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationsOutputError>
}

extension ListAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociationsInput(associationFilterList: \(Swift.String(describing: associationFilterList)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationFilterList = "AssociationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationFilterList = associationFilterList {
            var associationFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associationFilterList)
            for associationfilterlist0 in associationFilterList {
                try associationFilterListContainer.encode(associationfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationsOutputError>
}

public struct ListAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationsOutputError>
}

public struct ListAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationsOutputError>
}

public struct ListAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationsOutputError>
}

public struct ListAssociationsInput: Swift.Equatable {
    /// One or more filters. Use a filter to return a more specific list of results. Filtering associations using the InstanceID attribute only returns legacy associations created using the InstanceID attribute. Associations targeting the managed node that are part of the Target Attributes ResourceGroup or Tags aren't returned.
    public var associationFilterList: [SsmClientTypes.AssociationFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        associationFilterList: [SsmClientTypes.AssociationFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.associationFilterList = associationFilterList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociationsInputBody: Swift.Equatable {
    public let associationFilterList: [SsmClientTypes.AssociationFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationFilterList = "AssociationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationFilterListContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationFilter?].self, forKey: .associationFilterList)
        var associationFilterListDecoded0:[SsmClientTypes.AssociationFilter]? = nil
        if let associationFilterListContainer = associationFilterListContainer {
            associationFilterListDecoded0 = [SsmClientTypes.AssociationFilter]()
            for structure0 in associationFilterListContainer {
                if let structure0 = structure0 {
                    associationFilterListDecoded0?.append(structure0)
                }
            }
        }
        associationFilterList = associationFilterListDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociationsOutputResponse(associations: \(Swift.String(describing: associations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associations = output.associations
            self.nextToken = output.nextToken
        } else {
            self.associations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociationsOutputResponse: Swift.Equatable {
    /// The associations.
    public var associations: [SsmClientTypes.Association]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        associations: [SsmClientTypes.Association]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

struct ListAssociationsOutputResponseBody: Swift.Equatable {
    public let associations: [SsmClientTypes.Association]?
    public let nextToken: Swift.String?
}

extension ListAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Association?].self, forKey: .associations)
        var associationsDecoded0:[SsmClientTypes.Association]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [SsmClientTypes.Association]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCommandInvocationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCommandInvocationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCommandInvocationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCommandInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCommandInvocationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCommandInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCommandInvocationsOutputError>
}

extension ListCommandInvocationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCommandInvocationsInput(commandId: \(Swift.String(describing: commandId)), details: \(Swift.String(describing: details)), filters: \(Swift.String(describing: filters)), instanceId: \(Swift.String(describing: instanceId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCommandInvocationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case details = "Details"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if details != false {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for commandfilterlist0 in filters {
                try filtersContainer.encode(commandfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCommandInvocationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCommandInvocationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCommandInvocationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCommandInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCommandInvocationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCommandInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCommandInvocationsOutputError>
}

public struct ListCommandInvocationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCommandInvocationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCommandInvocationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCommandInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCommandInvocationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCommandInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCommandInvocationsOutputError>
}

public struct ListCommandInvocationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCommandInvocationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCommandInvocationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCommandInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCommandInvocationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCommandInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCommandInvocationsOutputError>
}

public struct ListCommandInvocationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCommandInvocationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCommandInvocationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCommandInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCommandInvocationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCommandInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCommandInvocationsOutputError>
}

public struct ListCommandInvocationsInput: Swift.Equatable {
    /// (Optional) The invocations for a specific command ID.
    public var commandId: Swift.String?
    /// (Optional) If set this returns the response of the command executions and any command output. The default value is false.
    public var details: Swift.Bool
    /// (Optional) One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.CommandFilter]?
    /// (Optional) The command execution details for a specific managed node ID.
    public var instanceId: Swift.String?
    /// (Optional) The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        commandId: Swift.String? = nil,
        details: Swift.Bool = false,
        filters: [SsmClientTypes.CommandFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.commandId = commandId
        self.details = details
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCommandInvocationsInputBody: Swift.Equatable {
    public let commandId: Swift.String?
    public let instanceId: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
    public let filters: [SsmClientTypes.CommandFilter]?
    public let details: Swift.Bool
}

extension ListCommandInvocationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case details = "Details"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.CommandFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.CommandFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.CommandFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let detailsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .details)
        details = detailsDecoded
    }
}

extension ListCommandInvocationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCommandInvocationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCommandInvocationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidFilterKey(InvalidFilterKey)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCommandInvocationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCommandInvocationsOutputResponse(commandInvocations: \(Swift.String(describing: commandInvocations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCommandInvocationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCommandInvocationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commandInvocations = output.commandInvocations
            self.nextToken = output.nextToken
        } else {
            self.commandInvocations = nil
            self.nextToken = nil
        }
    }
}

public struct ListCommandInvocationsOutputResponse: Swift.Equatable {
    /// (Optional) A list of all invocations.
    public var commandInvocations: [SsmClientTypes.CommandInvocation]?
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        commandInvocations: [SsmClientTypes.CommandInvocation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commandInvocations = commandInvocations
        self.nextToken = nextToken
    }
}

struct ListCommandInvocationsOutputResponseBody: Swift.Equatable {
    public let commandInvocations: [SsmClientTypes.CommandInvocation]?
    public let nextToken: Swift.String?
}

extension ListCommandInvocationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandInvocations = "CommandInvocations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandInvocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.CommandInvocation?].self, forKey: .commandInvocations)
        var commandInvocationsDecoded0:[SsmClientTypes.CommandInvocation]? = nil
        if let commandInvocationsContainer = commandInvocationsContainer {
            commandInvocationsDecoded0 = [SsmClientTypes.CommandInvocation]()
            for structure0 in commandInvocationsContainer {
                if let structure0 = structure0 {
                    commandInvocationsDecoded0?.append(structure0)
                }
            }
        }
        commandInvocations = commandInvocationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCommandsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCommandsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCommandsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCommandsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCommandsOutputError>
}

extension ListCommandsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCommandsInput(commandId: \(Swift.String(describing: commandId)), filters: \(Swift.String(describing: filters)), instanceId: \(Swift.String(describing: instanceId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCommandsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for commandfilterlist0 in filters {
                try filtersContainer.encode(commandfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCommandsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCommandsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCommandsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCommandsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCommandsOutputError>
}

public struct ListCommandsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCommandsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCommandsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCommandsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCommandsOutputError>
}

public struct ListCommandsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCommandsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCommandsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCommandsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCommandsOutputError>
}

public struct ListCommandsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCommandsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCommandsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCommandsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCommandsOutputError>
}

public struct ListCommandsInput: Swift.Equatable {
    /// (Optional) If provided, lists only the specified command.
    public var commandId: Swift.String?
    /// (Optional) One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.CommandFilter]?
    /// (Optional) Lists commands issued against this managed node ID. You can't specify a managed node ID in the same command that you specify Status = Pending. This is because the command hasn't reached the managed node yet.
    public var instanceId: Swift.String?
    /// (Optional) The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        commandId: Swift.String? = nil,
        filters: [SsmClientTypes.CommandFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.commandId = commandId
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCommandsInputBody: Swift.Equatable {
    public let commandId: Swift.String?
    public let instanceId: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
    public let filters: [SsmClientTypes.CommandFilter]?
}

extension ListCommandsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.CommandFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.CommandFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.CommandFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListCommandsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCommandsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCommandsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidFilterKey(InvalidFilterKey)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCommandsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCommandsOutputResponse(commands: \(Swift.String(describing: commands)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCommandsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCommandsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commands = output.commands
            self.nextToken = output.nextToken
        } else {
            self.commands = nil
            self.nextToken = nil
        }
    }
}

public struct ListCommandsOutputResponse: Swift.Equatable {
    /// (Optional) The list of commands requested by the user.
    public var commands: [SsmClientTypes.Command]?
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        commands: [SsmClientTypes.Command]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commands = commands
        self.nextToken = nextToken
    }
}

struct ListCommandsOutputResponseBody: Swift.Equatable {
    public let commands: [SsmClientTypes.Command]?
    public let nextToken: Swift.String?
}

extension ListCommandsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commands = "Commands"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Command?].self, forKey: .commands)
        var commandsDecoded0:[SsmClientTypes.Command]? = nil
        if let commandsContainer = commandsContainer {
            commandsDecoded0 = [SsmClientTypes.Command]()
            for structure0 in commandsContainer {
                if let structure0 = structure0 {
                    commandsDecoded0?.append(structure0)
                }
            }
        }
        commands = commandsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListComplianceItemsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComplianceItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComplianceItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComplianceItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComplianceItemsOutputError>
}

extension ListComplianceItemsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComplianceItemsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceIds: \(Swift.String(describing: resourceIds)), resourceTypes: \(Swift.String(describing: resourceTypes)))"}
}

extension ListComplianceItemsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceIds = "ResourceIds"
        case resourceTypes = "ResourceTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for compliancestringfilterlist0 in filters {
                try filtersContainer.encode(compliancestringfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for complianceresourceidlist0 in resourceIds {
                try resourceIdsContainer.encode(complianceresourceidlist0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for complianceresourcetypelist0 in resourceTypes {
                try resourceTypesContainer.encode(complianceresourcetypelist0)
            }
        }
    }
}

public struct ListComplianceItemsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComplianceItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComplianceItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComplianceItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComplianceItemsOutputError>
}

public struct ListComplianceItemsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComplianceItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComplianceItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComplianceItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComplianceItemsOutputError>
}

public struct ListComplianceItemsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComplianceItemsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListComplianceItemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListComplianceItemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComplianceItemsOutputError>
}

public struct ListComplianceItemsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComplianceItemsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListComplianceItemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListComplianceItemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComplianceItemsOutputError>
}

public struct ListComplianceItemsInput: Swift.Equatable {
    /// One or more compliance filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.ComplianceStringFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The ID for the resources from which to get compliance information. Currently, you can only specify one resource ID.
    public var resourceIds: [Swift.String]?
    /// The type of resource from which to get compliance information. Currently, the only supported resource type is ManagedInstance.
    public var resourceTypes: [Swift.String]?

    public init (
        filters: [SsmClientTypes.ComplianceStringFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceIds: [Swift.String]? = nil,
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIds = resourceIds
        self.resourceTypes = resourceTypes
    }
}

struct ListComplianceItemsInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.ComplianceStringFilter]?
    public let resourceIds: [Swift.String]?
    public let resourceTypes: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListComplianceItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceIds = "ResourceIds"
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.ComplianceStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.ComplianceStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComplianceItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComplianceItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComplianceItemsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComplianceItemsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComplianceItemsOutputResponse(complianceItems: \(Swift.String(describing: complianceItems)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListComplianceItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComplianceItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.complianceItems = output.complianceItems
            self.nextToken = output.nextToken
        } else {
            self.complianceItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListComplianceItemsOutputResponse: Swift.Equatable {
    /// A list of compliance information for the specified resource ID.
    public var complianceItems: [SsmClientTypes.ComplianceItem]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        complianceItems: [SsmClientTypes.ComplianceItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceItems = complianceItems
        self.nextToken = nextToken
    }
}

struct ListComplianceItemsOutputResponseBody: Swift.Equatable {
    public let complianceItems: [SsmClientTypes.ComplianceItem]?
    public let nextToken: Swift.String?
}

extension ListComplianceItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceItems = "ComplianceItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceItem?].self, forKey: .complianceItems)
        var complianceItemsDecoded0:[SsmClientTypes.ComplianceItem]? = nil
        if let complianceItemsContainer = complianceItemsContainer {
            complianceItemsDecoded0 = [SsmClientTypes.ComplianceItem]()
            for structure0 in complianceItemsContainer {
                if let structure0 = structure0 {
                    complianceItemsDecoded0?.append(structure0)
                }
            }
        }
        complianceItems = complianceItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListComplianceSummariesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComplianceSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComplianceSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComplianceSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComplianceSummariesOutputError>
}

extension ListComplianceSummariesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComplianceSummariesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListComplianceSummariesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for compliancestringfilterlist0 in filters {
                try filtersContainer.encode(compliancestringfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListComplianceSummariesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComplianceSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComplianceSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComplianceSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComplianceSummariesOutputError>
}

public struct ListComplianceSummariesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComplianceSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComplianceSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComplianceSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComplianceSummariesOutputError>
}

public struct ListComplianceSummariesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComplianceSummariesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListComplianceSummariesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListComplianceSummariesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComplianceSummariesOutputError>
}

public struct ListComplianceSummariesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComplianceSummariesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListComplianceSummariesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListComplianceSummariesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComplianceSummariesOutputError>
}

public struct ListComplianceSummariesInput: Swift.Equatable {
    /// One or more compliance or inventory filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.ComplianceStringFilter]?
    /// The maximum number of items to return for this call. Currently, you can specify null or 50. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.ComplianceStringFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComplianceSummariesInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.ComplianceStringFilter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListComplianceSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.ComplianceStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.ComplianceStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComplianceSummariesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComplianceSummariesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComplianceSummariesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComplianceSummariesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComplianceSummariesOutputResponse(complianceSummaryItems: \(Swift.String(describing: complianceSummaryItems)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListComplianceSummariesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComplianceSummariesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.complianceSummaryItems = output.complianceSummaryItems
            self.nextToken = output.nextToken
        } else {
            self.complianceSummaryItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListComplianceSummariesOutputResponse: Swift.Equatable {
    /// A list of compliant and non-compliant summary counts based on compliance types. For example, this call returns State Manager associations, patches, or custom compliance types according to the filter criteria that you specified.
    public var complianceSummaryItems: [SsmClientTypes.ComplianceSummaryItem]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        complianceSummaryItems: [SsmClientTypes.ComplianceSummaryItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceSummaryItems = complianceSummaryItems
        self.nextToken = nextToken
    }
}

struct ListComplianceSummariesOutputResponseBody: Swift.Equatable {
    public let complianceSummaryItems: [SsmClientTypes.ComplianceSummaryItem]?
    public let nextToken: Swift.String?
}

extension ListComplianceSummariesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceSummaryItems = "ComplianceSummaryItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummaryItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceSummaryItem?].self, forKey: .complianceSummaryItems)
        var complianceSummaryItemsDecoded0:[SsmClientTypes.ComplianceSummaryItem]? = nil
        if let complianceSummaryItemsContainer = complianceSummaryItemsContainer {
            complianceSummaryItemsDecoded0 = [SsmClientTypes.ComplianceSummaryItem]()
            for structure0 in complianceSummaryItemsContainer {
                if let structure0 = structure0 {
                    complianceSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        complianceSummaryItems = complianceSummaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDocumentMetadataHistoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentMetadataHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDocumentMetadataHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentMetadataHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDocumentMetadataHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentMetadataHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentMetadataHistoryOutputError>
}

extension ListDocumentMetadataHistoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDocumentMetadataHistoryInput(documentVersion: \(Swift.String(describing: documentVersion)), maxResults: \(Swift.String(describing: maxResults)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDocumentMetadataHistoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case maxResults = "MaxResults"
        case metadata = "Metadata"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata.rawValue, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDocumentMetadataHistoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentMetadataHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDocumentMetadataHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentMetadataHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDocumentMetadataHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentMetadataHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentMetadataHistoryOutputError>
}

public struct ListDocumentMetadataHistoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentMetadataHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDocumentMetadataHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentMetadataHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDocumentMetadataHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentMetadataHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentMetadataHistoryOutputError>
}

public struct ListDocumentMetadataHistoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentMetadataHistoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDocumentMetadataHistoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentMetadataHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDocumentMetadataHistoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentMetadataHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentMetadataHistoryOutputError>
}

public struct ListDocumentMetadataHistoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentMetadataHistoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDocumentMetadataHistoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentMetadataHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDocumentMetadataHistoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentMetadataHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentMetadataHistoryOutputError>
}

public struct ListDocumentMetadataHistoryInput: Swift.Equatable {
    /// The version of the change template.
    public var documentVersion: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The type of data for which details are being requested. Currently, the only supported value is DocumentReviews.
    /// This member is required.
    public var metadata: SsmClientTypes.DocumentMetadataEnum?
    /// The name of the change template.
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        documentVersion: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        metadata: SsmClientTypes.DocumentMetadataEnum? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.maxResults = maxResults
        self.metadata = metadata
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDocumentMetadataHistoryInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let documentVersion: Swift.String?
    public let metadata: SsmClientTypes.DocumentMetadataEnum?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListDocumentMetadataHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case maxResults = "MaxResults"
        case metadata = "Metadata"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentMetadataEnum.self, forKey: .metadata)
        metadata = metadataDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDocumentMetadataHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentMetadataHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentMetadataHistoryOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentMetadataHistoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDocumentMetadataHistoryOutputResponse(author: \(Swift.String(describing: author)), documentVersion: \(Swift.String(describing: documentVersion)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDocumentMetadataHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDocumentMetadataHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.author = output.author
            self.documentVersion = output.documentVersion
            self.metadata = output.metadata
            self.name = output.name
            self.nextToken = output.nextToken
        } else {
            self.author = nil
            self.documentVersion = nil
            self.metadata = nil
            self.name = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentMetadataHistoryOutputResponse: Swift.Equatable {
    /// The user ID of the person in the organization who requested the review of the change template.
    public var author: Swift.String?
    /// The version of the change template.
    public var documentVersion: Swift.String?
    /// Information about the response to the change template approval request.
    public var metadata: SsmClientTypes.DocumentMetadataResponseInfo?
    /// The name of the change template.
    public var name: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        author: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        metadata: SsmClientTypes.DocumentMetadataResponseInfo? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.author = author
        self.documentVersion = documentVersion
        self.metadata = metadata
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDocumentMetadataHistoryOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let documentVersion: Swift.String?
    public let author: Swift.String?
    public let metadata: SsmClientTypes.DocumentMetadataResponseInfo?
    public let nextToken: Swift.String?
}

extension ListDocumentMetadataHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "Author"
        case documentVersion = "DocumentVersion"
        case metadata = "Metadata"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentMetadataResponseInfo.self, forKey: .metadata)
        metadata = metadataDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDocumentVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDocumentVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDocumentVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentVersionsOutputError>
}

extension ListDocumentVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDocumentVersionsInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDocumentVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDocumentVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDocumentVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDocumentVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentVersionsOutputError>
}

public struct ListDocumentVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDocumentVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDocumentVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentVersionsOutputError>
}

public struct ListDocumentVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDocumentVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDocumentVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentVersionsOutputError>
}

public struct ListDocumentVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDocumentVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDocumentVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentVersionsOutputError>
}

public struct ListDocumentVersionsInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The name of the document. You can specify an Amazon Resource Name (ARN).
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDocumentVersionsInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListDocumentVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDocumentVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDocumentVersionsOutputResponse(documentVersions: \(Swift.String(describing: documentVersions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDocumentVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDocumentVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documentVersions = output.documentVersions
            self.nextToken = output.nextToken
        } else {
            self.documentVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentVersionsOutputResponse: Swift.Equatable {
    /// The document versions.
    public var documentVersions: [SsmClientTypes.DocumentVersionInfo]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        documentVersions: [SsmClientTypes.DocumentVersionInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentVersions = documentVersions
        self.nextToken = nextToken
    }
}

struct ListDocumentVersionsOutputResponseBody: Swift.Equatable {
    public let documentVersions: [SsmClientTypes.DocumentVersionInfo]?
    public let nextToken: Swift.String?
}

extension ListDocumentVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersions = "DocumentVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentVersionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentVersionInfo?].self, forKey: .documentVersions)
        var documentVersionsDecoded0:[SsmClientTypes.DocumentVersionInfo]? = nil
        if let documentVersionsContainer = documentVersionsContainer {
            documentVersionsDecoded0 = [SsmClientTypes.DocumentVersionInfo]()
            for structure0 in documentVersionsContainer {
                if let structure0 = structure0 {
                    documentVersionsDecoded0?.append(structure0)
                }
            }
        }
        documentVersions = documentVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDocumentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDocumentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDocumentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentsOutputError>
}

extension ListDocumentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDocumentsInput(documentFilterList: \(Swift.String(describing: documentFilterList)), filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDocumentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentFilterList = "DocumentFilterList"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentFilterList = documentFilterList {
            var documentFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentFilterList)
            for documentfilterlist0 in documentFilterList {
                try documentFilterListContainer.encode(documentfilterlist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for documentkeyvaluesfilterlist0 in filters {
                try filtersContainer.encode(documentkeyvaluesfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDocumentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDocumentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDocumentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentsOutputError>
}

public struct ListDocumentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDocumentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDocumentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentsOutputError>
}

public struct ListDocumentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDocumentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDocumentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentsOutputError>
}

public struct ListDocumentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDocumentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDocumentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDocumentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDocumentsOutputError>
}

public struct ListDocumentsInput: Swift.Equatable {
    /// This data type is deprecated. Instead, use Filters.
    public var documentFilterList: [SsmClientTypes.DocumentFilter]?
    /// One or more DocumentKeyValuesFilter objects. Use a filter to return a more specific list of results. For keys, you can specify one or more key-value pair tags that have been applied to a document. Other valid keys include Owner, Name, PlatformTypes, DocumentType, and TargetType. For example, to return documents you own use Key=Owner,Values=Self. To specify a custom key-value pair, use the format Key=tag:tagName,Values=valueName. This API operation only supports filtering documents by using a single tag key and one or more tag values. For example: Key=tag:tagName,Values=valueName1,valueName2
    public var filters: [SsmClientTypes.DocumentKeyValuesFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        documentFilterList: [SsmClientTypes.DocumentFilter]? = nil,
        filters: [SsmClientTypes.DocumentKeyValuesFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.documentFilterList = documentFilterList
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDocumentsInputBody: Swift.Equatable {
    public let documentFilterList: [SsmClientTypes.DocumentFilter]?
    public let filters: [SsmClientTypes.DocumentKeyValuesFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListDocumentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentFilterList = "DocumentFilterList"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentFilterListContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentFilter?].self, forKey: .documentFilterList)
        var documentFilterListDecoded0:[SsmClientTypes.DocumentFilter]? = nil
        if let documentFilterListContainer = documentFilterListContainer {
            documentFilterListDecoded0 = [SsmClientTypes.DocumentFilter]()
            for structure0 in documentFilterListContainer {
                if let structure0 = structure0 {
                    documentFilterListDecoded0?.append(structure0)
                }
            }
        }
        documentFilterList = documentFilterListDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentKeyValuesFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.DocumentKeyValuesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.DocumentKeyValuesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDocumentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDocumentsOutputResponse(documentIdentifiers: \(Swift.String(describing: documentIdentifiers)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDocumentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDocumentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documentIdentifiers = output.documentIdentifiers
            self.nextToken = output.nextToken
        } else {
            self.documentIdentifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentsOutputResponse: Swift.Equatable {
    /// The names of the SSM documents.
    public var documentIdentifiers: [SsmClientTypes.DocumentIdentifier]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        documentIdentifiers: [SsmClientTypes.DocumentIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentIdentifiers = documentIdentifiers
        self.nextToken = nextToken
    }
}

struct ListDocumentsOutputResponseBody: Swift.Equatable {
    public let documentIdentifiers: [SsmClientTypes.DocumentIdentifier]?
    public let nextToken: Swift.String?
}

extension ListDocumentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentIdentifiers = "DocumentIdentifiers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentIdentifiersContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentIdentifier?].self, forKey: .documentIdentifiers)
        var documentIdentifiersDecoded0:[SsmClientTypes.DocumentIdentifier]? = nil
        if let documentIdentifiersContainer = documentIdentifiersContainer {
            documentIdentifiersDecoded0 = [SsmClientTypes.DocumentIdentifier]()
            for structure0 in documentIdentifiersContainer {
                if let structure0 = structure0 {
                    documentIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        documentIdentifiers = documentIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInventoryEntriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInventoryEntriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInventoryEntriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInventoryEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInventoryEntriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInventoryEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInventoryEntriesOutputError>
}

extension ListInventoryEntriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInventoryEntriesInput(filters: \(Swift.String(describing: filters)), instanceId: \(Swift.String(describing: instanceId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), typeName: \(Swift.String(describing: typeName)))"}
}

extension ListInventoryEntriesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }
}

public struct ListInventoryEntriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInventoryEntriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInventoryEntriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInventoryEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInventoryEntriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInventoryEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInventoryEntriesOutputError>
}

public struct ListInventoryEntriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInventoryEntriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInventoryEntriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInventoryEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInventoryEntriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInventoryEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInventoryEntriesOutputError>
}

public struct ListInventoryEntriesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInventoryEntriesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListInventoryEntriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInventoryEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListInventoryEntriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListInventoryEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInventoryEntriesOutputError>
}

public struct ListInventoryEntriesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInventoryEntriesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListInventoryEntriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInventoryEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListInventoryEntriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListInventoryEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInventoryEntriesOutputError>
}

public struct ListInventoryEntriesInput: Swift.Equatable {
    /// One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.InventoryFilter]?
    /// The managed node ID for which you want inventory information.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The type of inventory item for which you want information.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        filters: [SsmClientTypes.InventoryFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeName = typeName
    }
}

struct ListInventoryEntriesInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let typeName: Swift.String?
    public let filters: [SsmClientTypes.InventoryFilter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListInventoryEntriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListInventoryEntriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInventoryEntriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInventoryEntriesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInventoryEntriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInventoryEntriesOutputResponse(captureTime: \(Swift.String(describing: captureTime)), entries: \(Swift.String(describing: entries)), instanceId: \(Swift.String(describing: instanceId)), nextToken: \(Swift.String(describing: nextToken)), schemaVersion: \(Swift.String(describing: schemaVersion)), typeName: \(Swift.String(describing: typeName)))"}
}

extension ListInventoryEntriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInventoryEntriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.captureTime = output.captureTime
            self.entries = output.entries
            self.instanceId = output.instanceId
            self.nextToken = output.nextToken
            self.schemaVersion = output.schemaVersion
            self.typeName = output.typeName
        } else {
            self.captureTime = nil
            self.entries = nil
            self.instanceId = nil
            self.nextToken = nil
            self.schemaVersion = nil
            self.typeName = nil
        }
    }
}

public struct ListInventoryEntriesOutputResponse: Swift.Equatable {
    /// The time that inventory information was collected for the managed node(s).
    public var captureTime: Swift.String?
    /// A list of inventory items on the managed node(s).
    public var entries: [[Swift.String:Swift.String]]?
    /// The managed node ID targeted by the request to query inventory information.
    public var instanceId: Swift.String?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// The inventory schema version used by the managed node(s).
    public var schemaVersion: Swift.String?
    /// The type of inventory item returned by the request.
    public var typeName: Swift.String?

    public init (
        captureTime: Swift.String? = nil,
        entries: [[Swift.String:Swift.String]]? = nil,
        instanceId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.captureTime = captureTime
        self.entries = entries
        self.instanceId = instanceId
        self.nextToken = nextToken
        self.schemaVersion = schemaVersion
        self.typeName = typeName
    }
}

struct ListInventoryEntriesOutputResponseBody: Swift.Equatable {
    public let typeName: Swift.String?
    public let instanceId: Swift.String?
    public let schemaVersion: Swift.String?
    public let captureTime: Swift.String?
    public let entries: [[Swift.String:Swift.String]]?
    public let nextToken: Swift.String?
}

extension ListInventoryEntriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captureTime = "CaptureTime"
        case entries = "Entries"
        case instanceId = "InstanceId"
        case nextToken = "NextToken"
        case schemaVersion = "SchemaVersion"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let entriesContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .entries)
        var entriesDecoded0:[[Swift.String:Swift.String]]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in entriesContainer {
                var entriesContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    entriesContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            entriesContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let entriesContainerDecoded0 = entriesContainerDecoded0 {
                    entriesDecoded0?.append(entriesContainerDecoded0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOpsItemEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsItemEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOpsItemEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsItemEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOpsItemEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsItemEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsItemEventsOutputError>
}

extension ListOpsItemEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOpsItemEventsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOpsItemEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsitemeventfilters0 in filters {
                try filtersContainer.encode(opsitemeventfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOpsItemEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsItemEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOpsItemEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsItemEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOpsItemEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsItemEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsItemEventsOutputError>
}

public struct ListOpsItemEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsItemEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOpsItemEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsItemEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOpsItemEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsItemEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsItemEventsOutputError>
}

public struct ListOpsItemEventsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsItemEventsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOpsItemEventsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsItemEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOpsItemEventsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsItemEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsItemEventsOutputError>
}

public struct ListOpsItemEventsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsItemEventsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOpsItemEventsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsItemEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOpsItemEventsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsItemEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsItemEventsOutputError>
}

public struct ListOpsItemEventsInput: Swift.Equatable {
    /// One or more OpsItem filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.OpsItemEventFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.OpsItemEventFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOpsItemEventsInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.OpsItemEventFilter]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListOpsItemEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemEventFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.OpsItemEventFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.OpsItemEventFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOpsItemEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOpsItemEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpsItemEventsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpsItemEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOpsItemEventsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), summaries: \(Swift.String(describing: summaries)))"}
}

extension ListOpsItemEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOpsItemEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListOpsItemEventsOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of event information for the specified OpsItems.
    public var summaries: [SsmClientTypes.OpsItemEventSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [SsmClientTypes.OpsItemEventSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListOpsItemEventsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let summaries: [SsmClientTypes.OpsItemEventSummary]?
}

extension ListOpsItemEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let summariesContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemEventSummary?].self, forKey: .summaries)
        var summariesDecoded0:[SsmClientTypes.OpsItemEventSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [SsmClientTypes.OpsItemEventSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
    }
}

public struct ListOpsItemRelatedItemsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsItemRelatedItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOpsItemRelatedItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsItemRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOpsItemRelatedItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsItemRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsItemRelatedItemsOutputError>
}

extension ListOpsItemRelatedItemsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOpsItemRelatedItemsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), opsItemId: \(Swift.String(describing: opsItemId)))"}
}

extension ListOpsItemRelatedItemsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsitemrelateditemsfilters0 in filters {
                try filtersContainer.encode(opsitemrelateditemsfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }
}

public struct ListOpsItemRelatedItemsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsItemRelatedItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOpsItemRelatedItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsItemRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOpsItemRelatedItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsItemRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsItemRelatedItemsOutputError>
}

public struct ListOpsItemRelatedItemsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsItemRelatedItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOpsItemRelatedItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsItemRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOpsItemRelatedItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsItemRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsItemRelatedItemsOutputError>
}

public struct ListOpsItemRelatedItemsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsItemRelatedItemsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOpsItemRelatedItemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsItemRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOpsItemRelatedItemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsItemRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsItemRelatedItemsOutputError>
}

public struct ListOpsItemRelatedItemsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsItemRelatedItemsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOpsItemRelatedItemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsItemRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOpsItemRelatedItemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsItemRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsItemRelatedItemsOutputError>
}

public struct ListOpsItemRelatedItemsInput: Swift.Equatable {
    /// One or more OpsItem filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.OpsItemRelatedItemsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the OpsItem for which you want to list all related-item resources.
    public var opsItemId: Swift.String?

    public init (
        filters: [SsmClientTypes.OpsItemRelatedItemsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsItemId = opsItemId
    }
}

struct ListOpsItemRelatedItemsInputBody: Swift.Equatable {
    public let opsItemId: Swift.String?
    public let filters: [SsmClientTypes.OpsItemRelatedItemsFilter]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListOpsItemRelatedItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemRelatedItemsFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.OpsItemRelatedItemsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.OpsItemRelatedItemsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOpsItemRelatedItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOpsItemRelatedItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpsItemRelatedItemsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpsItemRelatedItemsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOpsItemRelatedItemsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), summaries: \(Swift.String(describing: summaries)))"}
}

extension ListOpsItemRelatedItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOpsItemRelatedItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListOpsItemRelatedItemsOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of related-item resources for the specified OpsItem.
    public var summaries: [SsmClientTypes.OpsItemRelatedItemSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [SsmClientTypes.OpsItemRelatedItemSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListOpsItemRelatedItemsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let summaries: [SsmClientTypes.OpsItemRelatedItemSummary]?
}

extension ListOpsItemRelatedItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let summariesContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemRelatedItemSummary?].self, forKey: .summaries)
        var summariesDecoded0:[SsmClientTypes.OpsItemRelatedItemSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [SsmClientTypes.OpsItemRelatedItemSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
    }
}

public struct ListOpsMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsMetadataOutputError>
}

extension ListOpsMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOpsMetadataInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOpsMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsmetadatafilterlist0 in filters {
                try filtersContainer.encode(opsmetadatafilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOpsMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsMetadataOutputError>
}

public struct ListOpsMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsMetadataOutputError>
}

public struct ListOpsMetadataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsMetadataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOpsMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOpsMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsMetadataOutputError>
}

public struct ListOpsMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOpsMetadataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOpsMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOpsMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOpsMetadataOutputError>
}

public struct ListOpsMetadataInput: Swift.Equatable {
    /// One or more filters to limit the number of OpsMetadata objects returned by the call.
    public var filters: [SsmClientTypes.OpsMetadataFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.OpsMetadataFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOpsMetadataInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.OpsMetadataFilter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListOpsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsMetadataFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.OpsMetadataFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.OpsMetadataFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOpsMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOpsMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpsMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpsMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOpsMetadataOutputResponse(nextToken: \(Swift.String(describing: nextToken)), opsMetadataList: \(Swift.String(describing: opsMetadataList)))"}
}

extension ListOpsMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.opsMetadataList = output.opsMetadataList
        } else {
            self.nextToken = nil
            self.opsMetadataList = nil
        }
    }
}

public struct ListOpsMetadataOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Returns a list of OpsMetadata objects.
    public var opsMetadataList: [SsmClientTypes.OpsMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        opsMetadataList: [SsmClientTypes.OpsMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.opsMetadataList = opsMetadataList
    }
}

struct ListOpsMetadataOutputResponseBody: Swift.Equatable {
    public let opsMetadataList: [SsmClientTypes.OpsMetadata]?
    public let nextToken: Swift.String?
}

extension ListOpsMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case opsMetadataList = "OpsMetadataList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataListContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsMetadata?].self, forKey: .opsMetadataList)
        var opsMetadataListDecoded0:[SsmClientTypes.OpsMetadata]? = nil
        if let opsMetadataListContainer = opsMetadataListContainer {
            opsMetadataListDecoded0 = [SsmClientTypes.OpsMetadata]()
            for structure0 in opsMetadataListContainer {
                if let structure0 = structure0 {
                    opsMetadataListDecoded0?.append(structure0)
                }
            }
        }
        opsMetadataList = opsMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceComplianceSummariesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceComplianceSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceComplianceSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceComplianceSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceComplianceSummariesOutputError>
}

extension ListResourceComplianceSummariesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceComplianceSummariesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListResourceComplianceSummariesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for compliancestringfilterlist0 in filters {
                try filtersContainer.encode(compliancestringfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResourceComplianceSummariesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceComplianceSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceComplianceSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceComplianceSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceComplianceSummariesOutputError>
}

public struct ListResourceComplianceSummariesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceComplianceSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceComplianceSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceComplianceSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceComplianceSummariesOutputError>
}

public struct ListResourceComplianceSummariesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceComplianceSummariesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListResourceComplianceSummariesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceComplianceSummariesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceComplianceSummariesOutputError>
}

public struct ListResourceComplianceSummariesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceComplianceSummariesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListResourceComplianceSummariesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceComplianceSummariesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceComplianceSummariesOutputError>
}

public struct ListResourceComplianceSummariesInput: Swift.Equatable {
    /// One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.ComplianceStringFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.ComplianceStringFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceComplianceSummariesInputBody: Swift.Equatable {
    public let filters: [SsmClientTypes.ComplianceStringFilter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListResourceComplianceSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.ComplianceStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.ComplianceStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceComplianceSummariesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceComplianceSummariesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceComplianceSummariesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceComplianceSummariesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceComplianceSummariesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceComplianceSummaryItems: \(Swift.String(describing: resourceComplianceSummaryItems)))"}
}

extension ListResourceComplianceSummariesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceComplianceSummariesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceComplianceSummaryItems = output.resourceComplianceSummaryItems
        } else {
            self.nextToken = nil
            self.resourceComplianceSummaryItems = nil
        }
    }
}

public struct ListResourceComplianceSummariesOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A summary count for specified or targeted managed nodes. Summary count includes information about compliant and non-compliant State Manager associations, patch status, or custom items according to the filter criteria that you specify.
    public var resourceComplianceSummaryItems: [SsmClientTypes.ResourceComplianceSummaryItem]?

    public init (
        nextToken: Swift.String? = nil,
        resourceComplianceSummaryItems: [SsmClientTypes.ResourceComplianceSummaryItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceComplianceSummaryItems = resourceComplianceSummaryItems
    }
}

struct ListResourceComplianceSummariesOutputResponseBody: Swift.Equatable {
    public let resourceComplianceSummaryItems: [SsmClientTypes.ResourceComplianceSummaryItem]?
    public let nextToken: Swift.String?
}

extension ListResourceComplianceSummariesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceComplianceSummaryItems = "ResourceComplianceSummaryItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceComplianceSummaryItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ResourceComplianceSummaryItem?].self, forKey: .resourceComplianceSummaryItems)
        var resourceComplianceSummaryItemsDecoded0:[SsmClientTypes.ResourceComplianceSummaryItem]? = nil
        if let resourceComplianceSummaryItemsContainer = resourceComplianceSummaryItemsContainer {
            resourceComplianceSummaryItemsDecoded0 = [SsmClientTypes.ResourceComplianceSummaryItem]()
            for structure0 in resourceComplianceSummaryItemsContainer {
                if let structure0 = structure0 {
                    resourceComplianceSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        resourceComplianceSummaryItems = resourceComplianceSummaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceDataSyncInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceDataSyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceDataSyncOutputError>
}

extension ListResourceDataSyncInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceDataSyncInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), syncType: \(Swift.String(describing: syncType)))"}
}

extension ListResourceDataSyncInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

public struct ListResourceDataSyncInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceDataSyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceDataSyncOutputError>
}

public struct ListResourceDataSyncInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceDataSyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceDataSyncOutputError>
}

public struct ListResourceDataSyncInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceDataSyncInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListResourceDataSyncInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceDataSyncInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceDataSyncOutputError>
}

public struct ListResourceDataSyncInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceDataSyncInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListResourceDataSyncInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceDataSyncInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceDataSyncOutputError>
}

public struct ListResourceDataSyncInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// View a list of resource data syncs according to the sync type. Specify SyncToDestination to view resource data syncs that synchronize data to an Amazon S3 bucket. Specify SyncFromSource to view resource data syncs from Organizations or from multiple Amazon Web Services Regions.
    public var syncType: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.syncType = syncType
    }
}

struct ListResourceDataSyncInputBody: Swift.Equatable {
    public let syncType: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListResourceDataSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case syncType = "SyncType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceDataSyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceDataSyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfiguration" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceDataSyncOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceDataSyncOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceDataSyncOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceDataSyncItems: \(Swift.String(describing: resourceDataSyncItems)))"}
}

extension ListResourceDataSyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceDataSyncOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceDataSyncItems = output.resourceDataSyncItems
        } else {
            self.nextToken = nil
            self.resourceDataSyncItems = nil
        }
    }
}

public struct ListResourceDataSyncOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of your current resource data sync configurations and their statuses.
    public var resourceDataSyncItems: [SsmClientTypes.ResourceDataSyncItem]?

    public init (
        nextToken: Swift.String? = nil,
        resourceDataSyncItems: [SsmClientTypes.ResourceDataSyncItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceDataSyncItems = resourceDataSyncItems
    }
}

struct ListResourceDataSyncOutputResponseBody: Swift.Equatable {
    public let resourceDataSyncItems: [SsmClientTypes.ResourceDataSyncItem]?
    public let nextToken: Swift.String?
}

extension ListResourceDataSyncOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceDataSyncItems = "ResourceDataSyncItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDataSyncItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ResourceDataSyncItem?].self, forKey: .resourceDataSyncItems)
        var resourceDataSyncItemsDecoded0:[SsmClientTypes.ResourceDataSyncItem]? = nil
        if let resourceDataSyncItemsContainer = resourceDataSyncItemsContainer {
            resourceDataSyncItemsDecoded0 = [SsmClientTypes.ResourceDataSyncItem]()
            for structure0 in resourceDataSyncItemsContainer {
                if let structure0 = structure0 {
                    resourceDataSyncItemsDecoded0?.append(structure0)
                }
            }
        }
        resourceDataSyncItems = resourceDataSyncItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ID for which you want to see a list of tags.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Returns a list of tags for a specific resource type.
    /// This member is required.
    public var resourceType: SsmClientTypes.ResourceTypeForTagging?

    public init (
        resourceId: Swift.String? = nil,
        resourceType: SsmClientTypes.ResourceTypeForTagging? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceType: SsmClientTypes.ResourceTypeForTagging?
    public let resourceId: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceTypeForTagging.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tagList: \(Swift.String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tags.
    public var tagList: [SsmClientTypes.Tag]?

    public init (
        tagList: [SsmClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tagList: [SsmClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension SsmClientTypes.LoggingInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case s3Region = "S3Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let s3Region = s3Region {
            try encodeContainer.encode(s3Region, forKey: .s3Region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let s3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Region)
        s3Region = s3RegionDecoded
    }
}

extension SsmClientTypes.LoggingInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoggingInfo(s3BucketName: \(Swift.String(describing: s3BucketName)), s3KeyPrefix: \(Swift.String(describing: s3KeyPrefix)), s3Region: \(Swift.String(describing: s3Region)))"}
}

extension SsmClientTypes {
    /// Information about an Amazon Simple Storage Service (Amazon S3) bucket to write managed node-level logs to. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public struct LoggingInfo: Swift.Equatable {
        /// The name of an S3 bucket where execution logs are stored .
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// (Optional) The S3 bucket subfolder.
        public var s3KeyPrefix: Swift.String?
        /// The Amazon Web Services Region where the S3 bucket is located.
        /// This member is required.
        public var s3Region: Swift.String?

        public init (
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            s3Region: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.s3Region = s3Region
        }
    }

}

extension SsmClientTypes.MaintenanceWindowAutomationParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension SsmClientTypes.MaintenanceWindowAutomationParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowAutomationParameters(documentVersion: \(Swift.String(describing: documentVersion)), parameters: \(Swift.String(describing: parameters)))"}
}

extension SsmClientTypes {
    /// The parameters for an AUTOMATION task type.
    public struct MaintenanceWindowAutomationParameters: Swift.Equatable {
        /// The version of an Automation runbook to use during task execution.
        public var documentVersion: Swift.String?
        /// The parameters for the AUTOMATION task. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For AUTOMATION task types, Amazon Web Services Systems Manager ignores any values specified for these parameters.
        public var parameters: [Swift.String:[Swift.String]]?

        public init (
            documentVersion: Swift.String? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil
        )
        {
            self.documentVersion = documentVersion
            self.parameters = parameters
        }
    }

}

extension SsmClientTypes.MaintenanceWindowExecution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case windowExecutionId = "WindowExecutionId"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowExecution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowExecution(endTime: \(Swift.String(describing: endTime)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), windowExecutionId: \(Swift.String(describing: windowExecutionId)), windowId: \(Swift.String(describing: windowId)))"}
}

extension SsmClientTypes {
    /// Describes the information about an execution of a maintenance window.
    public struct MaintenanceWindowExecution: Swift.Equatable {
        /// The time the execution finished.
        public var endTime: ClientRuntime.Date?
        /// The time the execution started.
        public var startTime: ClientRuntime.Date?
        /// The status of the execution.
        public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
        /// The details explaining the status. Not available for all status values.
        public var statusDetails: Swift.String?
        /// The ID of the maintenance window execution.
        public var windowExecutionId: Swift.String?
        /// The ID of the maintenance window.
        public var windowId: Swift.String?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
            statusDetails: Swift.String? = nil,
            windowExecutionId: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
            self.statusDetails = statusDetails
            self.windowExecutionId = windowExecutionId
            self.windowId = windowId
        }
    }

}

extension SsmClientTypes {
    public enum MaintenanceWindowExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case inprogress
        case pending
        case skippedoverlapping
        case success
        case timedout
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowExecutionStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .inprogress,
                .pending,
                .skippedoverlapping,
                .success,
                .timedout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .inprogress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .skippedoverlapping: return "SKIPPED_OVERLAPPING"
            case .success: return "SUCCESS"
            case .timedout: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceWindowExecutionStatus(rawValue: rawValue) ?? MaintenanceWindowExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.MaintenanceWindowExecutionTaskIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskArn = "TaskArn"
        case taskExecutionId = "TaskExecutionId"
        case taskType = "TaskType"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskExecutionId = taskExecutionId {
            try encodeContainer.encode(taskExecutionId, forKey: .taskExecutionId)
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowExecutionTaskIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowExecutionTaskIdentity(endTime: \(Swift.String(describing: endTime)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), taskArn: \(Swift.String(describing: taskArn)), taskExecutionId: \(Swift.String(describing: taskExecutionId)), taskType: \(Swift.String(describing: taskType)), windowExecutionId: \(Swift.String(describing: windowExecutionId)))"}
}

extension SsmClientTypes {
    /// Information about a task execution performed as part of a maintenance window execution.
    public struct MaintenanceWindowExecutionTaskIdentity: Swift.Equatable {
        /// The time the task execution finished.
        public var endTime: ClientRuntime.Date?
        /// The time the task execution started.
        public var startTime: ClientRuntime.Date?
        /// The status of the task execution.
        public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
        /// The details explaining the status of the task execution. Not available for all status values.
        public var statusDetails: Swift.String?
        /// The Amazon Resource Name (ARN) of the task that ran.
        public var taskArn: Swift.String?
        /// The ID of the specific task execution in the maintenance window execution.
        public var taskExecutionId: Swift.String?
        /// The type of task that ran.
        public var taskType: SsmClientTypes.MaintenanceWindowTaskType?
        /// The ID of the maintenance window execution that ran the task.
        public var windowExecutionId: Swift.String?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
            statusDetails: Swift.String? = nil,
            taskArn: Swift.String? = nil,
            taskExecutionId: Swift.String? = nil,
            taskType: SsmClientTypes.MaintenanceWindowTaskType? = nil,
            windowExecutionId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
            self.statusDetails = statusDetails
            self.taskArn = taskArn
            self.taskExecutionId = taskExecutionId
            self.taskType = taskType
            self.windowExecutionId = windowExecutionId
        }
    }

}

extension SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case executionId = "ExecutionId"
        case invocationId = "InvocationId"
        case ownerInformation = "OwnerInformation"
        case parameters = "Parameters"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskExecutionId = "TaskExecutionId"
        case taskType = "TaskType"
        case windowExecutionId = "WindowExecutionId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let invocationId = invocationId {
            try encodeContainer.encode(invocationId, forKey: .invocationId)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let taskExecutionId = taskExecutionId {
            try encodeContainer.encode(taskExecutionId, forKey: .taskExecutionId)
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let invocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowExecutionTaskInvocationIdentity(endTime: \(Swift.String(describing: endTime)), executionId: \(Swift.String(describing: executionId)), invocationId: \(Swift.String(describing: invocationId)), ownerInformation: \(Swift.String(describing: ownerInformation)), parameters: \(Swift.String(describing: parameters)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), taskExecutionId: \(Swift.String(describing: taskExecutionId)), taskType: \(Swift.String(describing: taskType)), windowExecutionId: \(Swift.String(describing: windowExecutionId)), windowTargetId: \(Swift.String(describing: windowTargetId)))"}
}

extension SsmClientTypes {
    /// Describes the information about a task invocation for a particular target as part of a task execution performed as part of a maintenance window execution.
    public struct MaintenanceWindowExecutionTaskInvocationIdentity: Swift.Equatable {
        /// The time the invocation finished.
        public var endTime: ClientRuntime.Date?
        /// The ID of the action performed in the service that actually handled the task invocation. If the task type is RUN_COMMAND, this value is the command ID.
        public var executionId: Swift.String?
        /// The ID of the task invocation.
        public var invocationId: Swift.String?
        /// User-provided value that was specified when the target was registered with the maintenance window. This was also included in any Amazon CloudWatch Events events raised during the task invocation.
        public var ownerInformation: Swift.String?
        /// The parameters that were provided for the invocation when it was run.
        public var parameters: Swift.String?
        /// The time the invocation started.
        public var startTime: ClientRuntime.Date?
        /// The status of the task invocation.
        public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
        /// The details explaining the status of the task invocation. Not available for all status values.
        public var statusDetails: Swift.String?
        /// The ID of the specific task execution in the maintenance window execution.
        public var taskExecutionId: Swift.String?
        /// The task type.
        public var taskType: SsmClientTypes.MaintenanceWindowTaskType?
        /// The ID of the maintenance window execution that ran the task.
        public var windowExecutionId: Swift.String?
        /// The ID of the target definition in this maintenance window the invocation was performed for.
        public var windowTargetId: Swift.String?

        public init (
            endTime: ClientRuntime.Date? = nil,
            executionId: Swift.String? = nil,
            invocationId: Swift.String? = nil,
            ownerInformation: Swift.String? = nil,
            parameters: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
            statusDetails: Swift.String? = nil,
            taskExecutionId: Swift.String? = nil,
            taskType: SsmClientTypes.MaintenanceWindowTaskType? = nil,
            windowExecutionId: Swift.String? = nil,
            windowTargetId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.executionId = executionId
            self.invocationId = invocationId
            self.ownerInformation = ownerInformation
            self.parameters = parameters
            self.startTime = startTime
            self.status = status
            self.statusDetails = statusDetails
            self.taskExecutionId = taskExecutionId
            self.taskType = taskType
            self.windowExecutionId = windowExecutionId
            self.windowTargetId = windowTargetId
        }
    }

}

extension SsmClientTypes.MaintenanceWindowFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for maintenancewindowfiltervalues0 in values {
                try valuesContainer.encode(maintenancewindowfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.MaintenanceWindowFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowFilter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// Filter used in the request. Supported filter keys depend on the API operation that includes the filter. API operations that use MaintenanceWindowFilter> include the following:
    ///
    /// * [DescribeMaintenanceWindowExecutions]
    ///
    /// * [DescribeMaintenanceWindowExecutionTaskInvocations]
    ///
    /// * [DescribeMaintenanceWindowExecutionTasks]
    ///
    /// * [DescribeMaintenanceWindows]
    ///
    /// * [DescribeMaintenanceWindowTargets]
    ///
    /// * [DescribeMaintenanceWindowTasks]
    public struct MaintenanceWindowFilter: Swift.Equatable {
        /// The name of the filter.
        public var key: Swift.String?
        /// The filter values.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes.MaintenanceWindowIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case nextExecutionTime = "NextExecutionTime"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cutoff != 0 {
            try encodeContainer.encode(cutoff, forKey: .cutoff)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextExecutionTime = nextExecutionTime {
            try encodeContainer.encode(nextExecutionTime, forKey: .nextExecutionTime)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleTimezone = scheduleTimezone {
            try encodeContainer.encode(scheduleTimezone, forKey: .scheduleTimezone)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Swift.Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let nextExecutionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextExecutionTime)
        nextExecutionTime = nextExecutionTimeDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowIdentity(cutoff: \(Swift.String(describing: cutoff)), description: \(Swift.String(describing: description)), duration: \(Swift.String(describing: duration)), enabled: \(Swift.String(describing: enabled)), endDate: \(Swift.String(describing: endDate)), name: \(Swift.String(describing: name)), nextExecutionTime: \(Swift.String(describing: nextExecutionTime)), schedule: \(Swift.String(describing: schedule)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleTimezone: \(Swift.String(describing: scheduleTimezone)), startDate: \(Swift.String(describing: startDate)), windowId: \(Swift.String(describing: windowId)))"}
}

extension SsmClientTypes {
    /// Information about the maintenance window.
    public struct MaintenanceWindowIdentity: Swift.Equatable {
        /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
        public var cutoff: Swift.Int
        /// A description of the maintenance window.
        public var description: Swift.String?
        /// The duration of the maintenance window in hours.
        public var duration: Swift.Int
        /// Indicates whether the maintenance window is enabled.
        public var enabled: Swift.Bool
        /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive.
        public var endDate: Swift.String?
        /// The name of the maintenance window.
        public var name: Swift.String?
        /// The next time the maintenance window will actually run, taking into account any specified times for the maintenance window to become active or inactive.
        public var nextExecutionTime: Swift.String?
        /// The schedule of the maintenance window in the form of a cron or rate expression.
        public var schedule: Swift.String?
        /// The number of days to wait to run a maintenance window after the scheduled cron expression date and time.
        public var scheduleOffset: Swift.Int
        /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format.
        public var scheduleTimezone: Swift.String?
        /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active.
        public var startDate: Swift.String?
        /// The ID of the maintenance window.
        public var windowId: Swift.String?

        public init (
            cutoff: Swift.Int = 0,
            description: Swift.String? = nil,
            duration: Swift.Int = 0,
            enabled: Swift.Bool = false,
            endDate: Swift.String? = nil,
            name: Swift.String? = nil,
            nextExecutionTime: Swift.String? = nil,
            schedule: Swift.String? = nil,
            scheduleOffset: Swift.Int = 0,
            scheduleTimezone: Swift.String? = nil,
            startDate: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.cutoff = cutoff
            self.description = description
            self.duration = duration
            self.enabled = enabled
            self.endDate = endDate
            self.name = name
            self.nextExecutionTime = nextExecutionTime
            self.schedule = schedule
            self.scheduleOffset = scheduleOffset
            self.scheduleTimezone = scheduleTimezone
            self.startDate = startDate
            self.windowId = windowId
        }
    }

}

extension SsmClientTypes.MaintenanceWindowIdentityForTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowIdentityForTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowIdentityForTarget(name: \(Swift.String(describing: name)), windowId: \(Swift.String(describing: windowId)))"}
}

extension SsmClientTypes {
    /// The maintenance window to which the specified target belongs.
    public struct MaintenanceWindowIdentityForTarget: Swift.Equatable {
        /// The name of the maintenance window.
        public var name: Swift.String?
        /// The ID of the maintenance window.
        public var windowId: Swift.String?

        public init (
            name: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.name = name
            self.windowId = windowId
        }
    }

}

extension SsmClientTypes.MaintenanceWindowLambdaParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientContext = "ClientContext"
        case payload = "Payload"
        case qualifier = "Qualifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientContext = clientContext {
            try encodeContainer.encode(clientContext, forKey: .clientContext)
        }
        if let payload = payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
        if let qualifier = qualifier {
            try encodeContainer.encode(qualifier, forKey: .qualifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientContext)
        clientContext = clientContextDecoded
        let qualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualifier)
        qualifier = qualifierDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowLambdaParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowLambdaParameters(clientContext: \(Swift.String(describing: clientContext)), payload: \(Swift.String(describing: payload)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension SsmClientTypes {
    /// The parameters for a LAMBDA task type. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For Lambda tasks, Systems Manager ignores any values specified for TaskParameters and LoggingInfo.
    public struct MaintenanceWindowLambdaParameters: Swift.Equatable {
        /// Pass client-specific information to the Lambda function that you are invoking. You can then process the client information in your Lambda function as you choose through the context variable.
        public var clientContext: Swift.String?
        /// JSON to provide to your Lambda function as input.
        public var payload: ClientRuntime.Data?
        /// (Optional) Specify an Lambda function version or alias name. If you specify a function version, the operation uses the qualified function Amazon Resource Name (ARN) to invoke a specific Lambda function. If you specify an alias name, the operation uses the alias ARN to invoke the Lambda function version to which the alias points.
        public var qualifier: Swift.String?

        public init (
            clientContext: Swift.String? = nil,
            payload: ClientRuntime.Data? = nil,
            qualifier: Swift.String? = nil
        )
        {
            self.clientContext = clientContext
            self.payload = payload
            self.qualifier = qualifier
        }
    }

}

extension SsmClientTypes {
    public enum MaintenanceWindowResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instance
        case resourcegroup
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowResourceType] {
            return [
                .instance,
                .resourcegroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instance: return "INSTANCE"
            case .resourcegroup: return "RESOURCE_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceWindowResourceType(rawValue: rawValue) ?? MaintenanceWindowResourceType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.MaintenanceWindowRunCommandParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case comment = "Comment"
        case documentHash = "DocumentHash"
        case documentHashType = "DocumentHashType"
        case documentVersion = "DocumentVersion"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case parameters = "Parameters"
        case serviceRoleArn = "ServiceRoleArn"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let documentHash = documentHash {
            try encodeContainer.encode(documentHash, forKey: .documentHash)
        }
        if let documentHashType = documentHashType {
            try encodeContainer.encode(documentHashType.rawValue, forKey: .documentHashType)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
        let documentHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentHash)
        documentHash = documentHashDecoded
        let documentHashTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentHashType.self, forKey: .documentHashType)
        documentHashType = documentHashTypeDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowRunCommandParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowRunCommandParameters(cloudWatchOutputConfig: \(Swift.String(describing: cloudWatchOutputConfig)), comment: \(Swift.String(describing: comment)), documentHash: \(Swift.String(describing: documentHash)), documentHashType: \(Swift.String(describing: documentHashType)), documentVersion: \(Swift.String(describing: documentVersion)), notificationConfig: \(Swift.String(describing: notificationConfig)), outputS3BucketName: \(Swift.String(describing: outputS3BucketName)), outputS3KeyPrefix: \(Swift.String(describing: outputS3KeyPrefix)), parameters: \(Swift.String(describing: parameters)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), timeoutSeconds: \(Swift.String(describing: timeoutSeconds)))"}
}

extension SsmClientTypes {
    /// The parameters for a RUN_COMMAND task type. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For RUN_COMMAND tasks, Systems Manager uses specified values for TaskParameters and LoggingInfo only if no values are specified for TaskInvocationParameters.
    public struct MaintenanceWindowRunCommandParameters: Swift.Equatable {
        /// Configuration options for sending command output to Amazon CloudWatch Logs.
        public var cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
        /// Information about the commands to run.
        public var comment: Swift.String?
        /// The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        public var documentHash: Swift.String?
        /// SHA-256 or SHA-1. SHA-1 hashes have been deprecated.
        public var documentHashType: SsmClientTypes.DocumentHashType?
        /// The Amazon Web Services Systems Manager document (SSM document) version to use in the request. You can specify $DEFAULT, $LATEST, or a specific version number. If you run commands by using the Amazon Web Services CLI, then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example: --document-version "\$DEFAULT"
        ///     --document-version "\$LATEST"
        ///
        ///
        ///     --document-version "3"
        public var documentVersion: Swift.String?
        /// Configurations for sending notifications about command status changes on a per-managed node basis.
        public var notificationConfig: SsmClientTypes.NotificationConfig?
        /// The name of the Amazon Simple Storage Service (Amazon S3) bucket.
        public var outputS3BucketName: Swift.String?
        /// The S3 bucket subfolder.
        public var outputS3KeyPrefix: Swift.String?
        /// The parameters for the RUN_COMMAND task execution.
        public var parameters: [Swift.String:[Swift.String]]?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
        public var serviceRoleArn: Swift.String?
        /// If this time is reached and the command hasn't already started running, it doesn't run.
        public var timeoutSeconds: Swift.Int

        public init (
            cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig? = nil,
            comment: Swift.String? = nil,
            documentHash: Swift.String? = nil,
            documentHashType: SsmClientTypes.DocumentHashType? = nil,
            documentVersion: Swift.String? = nil,
            notificationConfig: SsmClientTypes.NotificationConfig? = nil,
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            serviceRoleArn: Swift.String? = nil,
            timeoutSeconds: Swift.Int = 0
        )
        {
            self.cloudWatchOutputConfig = cloudWatchOutputConfig
            self.comment = comment
            self.documentHash = documentHash
            self.documentHashType = documentHashType
            self.documentVersion = documentVersion
            self.notificationConfig = notificationConfig
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.parameters = parameters
            self.serviceRoleArn = serviceRoleArn
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension SsmClientTypes.MaintenanceWindowStepFunctionsParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input = "Input"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowStepFunctionsParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowStepFunctionsParameters(input: \(Swift.String(describing: input)), name: \(Swift.String(describing: name)))"}
}

extension SsmClientTypes {
    /// The parameters for a STEP_FUNCTIONS task. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For Step Functions tasks, Systems Manager ignores any values specified for TaskParameters and LoggingInfo.
    public struct MaintenanceWindowStepFunctionsParameters: Swift.Equatable {
        /// The inputs for the STEP_FUNCTIONS task.
        public var input: Swift.String?
        /// The name of the STEP_FUNCTIONS task.
        public var name: Swift.String?

        public init (
            input: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.input = input
            self.name = name
        }
    }

}

extension SsmClientTypes.MaintenanceWindowTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowTarget(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), ownerInformation: \(Swift.String(describing: ownerInformation)), resourceType: \(Swift.String(describing: resourceType)), targets: \(Swift.String(describing: targets)), windowId: \(Swift.String(describing: windowId)), windowTargetId: \(Swift.String(describing: windowTargetId)))"}
}

extension SsmClientTypes {
    /// The target registered with the maintenance window.
    public struct MaintenanceWindowTarget: Swift.Equatable {
        /// A description for the target.
        public var description: Swift.String?
        /// The name for the maintenance window target.
        public var name: Swift.String?
        /// A user-provided value that will be included in any Amazon CloudWatch Events events that are raised while running tasks for these targets in this maintenance window.
        public var ownerInformation: Swift.String?
        /// The type of target that is being registered with the maintenance window.
        public var resourceType: SsmClientTypes.MaintenanceWindowResourceType?
        /// The targets, either managed nodes or tags. Specify managed nodes using the following format: Key=instanceids,Values=, Tags are specified using the following format: Key=,Values=.
        public var targets: [SsmClientTypes.Target]?
        /// The ID of the maintenance window to register the target with.
        public var windowId: Swift.String?
        /// The ID of the target.
        public var windowTargetId: Swift.String?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerInformation: Swift.String? = nil,
            resourceType: SsmClientTypes.MaintenanceWindowResourceType? = nil,
            targets: [SsmClientTypes.Target]? = nil,
            windowId: Swift.String? = nil,
            windowTargetId: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.ownerInformation = ownerInformation
            self.resourceType = resourceType
            self.targets = targets
            self.windowId = windowId
            self.windowTargetId = windowTargetId
        }
    }

}

extension SsmClientTypes.MaintenanceWindowTask: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskParameters = "TaskParameters"
        case type = "Type"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cutoffBehavior = cutoffBehavior {
            try encodeContainer.encode(cutoffBehavior.rawValue, forKey: .cutoffBehavior)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskParameters = taskParameters {
            var taskParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskParameters)
            for (dictKey0, maintenancewindowtaskparameters0) in taskParameters {
                try taskParametersContainer.encode(maintenancewindowtaskparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .type)
        type = typeDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskParametersContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cutoffBehaviorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskCutoffBehavior.self, forKey: .cutoffBehavior)
        cutoffBehavior = cutoffBehaviorDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowTask: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowTask(cutoffBehavior: \(Swift.String(describing: cutoffBehavior)), description: \(Swift.String(describing: description)), loggingInfo: \(Swift.String(describing: loggingInfo)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), taskArn: \(Swift.String(describing: taskArn)), taskParameters: \(Swift.String(describing: taskParameters)), type: \(Swift.String(describing: type)), windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)))"}
}

extension SsmClientTypes {
    /// Information about a task defined for a maintenance window.
    public struct MaintenanceWindowTask: Swift.Equatable {
        /// The specification for whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
        public var cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
        /// A description of the task.
        public var description: Swift.String?
        /// Information about an S3 bucket to write task-level logs to. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
        public var loggingInfo: SsmClientTypes.LoggingInfo?
        /// The maximum number of targets this task can be run for, in parallel.
        public var maxConcurrency: Swift.String?
        /// The maximum number of errors allowed before this task stops being scheduled.
        public var maxErrors: Swift.String?
        /// The task name.
        public var name: Swift.String?
        /// The priority of the task in the maintenance window. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.
        public var priority: Swift.Int
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
        public var serviceRoleArn: Swift.String?
        /// The targets (either managed nodes or tags). Managed nodes are specified using Key=instanceids,Values=,. Tags are specified using Key=,Values=.
        public var targets: [SsmClientTypes.Target]?
        /// The resource that the task uses during execution. For RUN_COMMAND and AUTOMATION task types, TaskArn is the Amazon Web Services Systems Manager (SSM document) name or ARN. For LAMBDA tasks, it's the function name or ARN. For STEP_FUNCTIONS tasks, it's the state machine ARN.
        public var taskArn: Swift.String?
        /// The parameters that should be passed to the task when it is run. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
        public var taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
        /// The type of task.
        public var type: SsmClientTypes.MaintenanceWindowTaskType?
        /// The ID of the maintenance window where the task is registered.
        public var windowId: Swift.String?
        /// The task ID.
        public var windowTaskId: Swift.String?

        public init (
            cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
            description: Swift.String? = nil,
            loggingInfo: SsmClientTypes.LoggingInfo? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int = 0,
            serviceRoleArn: Swift.String? = nil,
            targets: [SsmClientTypes.Target]? = nil,
            taskArn: Swift.String? = nil,
            taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
            type: SsmClientTypes.MaintenanceWindowTaskType? = nil,
            windowId: Swift.String? = nil,
            windowTaskId: Swift.String? = nil
        )
        {
            self.cutoffBehavior = cutoffBehavior
            self.description = description
            self.loggingInfo = loggingInfo
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.priority = priority
            self.serviceRoleArn = serviceRoleArn
            self.targets = targets
            self.taskArn = taskArn
            self.taskParameters = taskParameters
            self.type = type
            self.windowId = windowId
            self.windowTaskId = windowTaskId
        }
    }

}

extension SsmClientTypes {
    public enum MaintenanceWindowTaskCutoffBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceltask
        case continuetask
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowTaskCutoffBehavior] {
            return [
                .canceltask,
                .continuetask,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceltask: return "CANCEL_TASK"
            case .continuetask: return "CONTINUE_TASK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceWindowTaskCutoffBehavior(rawValue: rawValue) ?? MaintenanceWindowTaskCutoffBehavior.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.MaintenanceWindowTaskInvocationParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automation = "Automation"
        case lambda = "Lambda"
        case runCommand = "RunCommand"
        case stepFunctions = "StepFunctions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automation = automation {
            try encodeContainer.encode(automation, forKey: .automation)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let runCommand = runCommand {
            try encodeContainer.encode(runCommand, forKey: .runCommand)
        }
        if let stepFunctions = stepFunctions {
            try encodeContainer.encode(stepFunctions, forKey: .stepFunctions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runCommandDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowRunCommandParameters.self, forKey: .runCommand)
        runCommand = runCommandDecoded
        let automationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowAutomationParameters.self, forKey: .automation)
        automation = automationDecoded
        let stepFunctionsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowStepFunctionsParameters.self, forKey: .stepFunctions)
        stepFunctions = stepFunctionsDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowLambdaParameters.self, forKey: .lambda)
        lambda = lambdaDecoded
    }
}

extension SsmClientTypes.MaintenanceWindowTaskInvocationParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowTaskInvocationParameters(automation: \(Swift.String(describing: automation)), lambda: \(Swift.String(describing: lambda)), runCommand: \(Swift.String(describing: runCommand)), stepFunctions: \(Swift.String(describing: stepFunctions)))"}
}

extension SsmClientTypes {
    /// The parameters for task execution.
    public struct MaintenanceWindowTaskInvocationParameters: Swift.Equatable {
        /// The parameters for an AUTOMATION task type.
        public var automation: SsmClientTypes.MaintenanceWindowAutomationParameters?
        /// The parameters for a LAMBDA task type.
        public var lambda: SsmClientTypes.MaintenanceWindowLambdaParameters?
        /// The parameters for a RUN_COMMAND task type.
        public var runCommand: SsmClientTypes.MaintenanceWindowRunCommandParameters?
        /// The parameters for a STEP_FUNCTIONS task type.
        public var stepFunctions: SsmClientTypes.MaintenanceWindowStepFunctionsParameters?

        public init (
            automation: SsmClientTypes.MaintenanceWindowAutomationParameters? = nil,
            lambda: SsmClientTypes.MaintenanceWindowLambdaParameters? = nil,
            runCommand: SsmClientTypes.MaintenanceWindowRunCommandParameters? = nil,
            stepFunctions: SsmClientTypes.MaintenanceWindowStepFunctionsParameters? = nil
        )
        {
            self.automation = automation
            self.lambda = lambda
            self.runCommand = runCommand
            self.stepFunctions = stepFunctions
        }
    }

}

extension SsmClientTypes.MaintenanceWindowTaskParameterValueExpression: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for maintenancewindowtaskparametervaluelist0 in values {
                try valuesContainer.encode(maintenancewindowtaskparametervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.MaintenanceWindowTaskParameterValueExpression: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension SsmClientTypes {
    /// Defines the values for a task parameter.
    public struct MaintenanceWindowTaskParameterValueExpression: Swift.Equatable {
        /// This field contains an array of 0 or more strings, each 1 to 255 characters in length.
        public var values: [Swift.String]?

        public init (
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum MaintenanceWindowTaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automation
        case lambda
        case runcommand
        case stepfunctions
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowTaskType] {
            return [
                .automation,
                .lambda,
                .runcommand,
                .stepfunctions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automation: return "AUTOMATION"
            case .lambda: return "LAMBDA"
            case .runcommand: return "RUN_COMMAND"
            case .stepfunctions: return "STEP_FUNCTIONS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceWindowTaskType(rawValue: rawValue) ?? MaintenanceWindowTaskType.sdkUnknown(rawValue)
        }
    }
}

extension MaxDocumentSizeExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaxDocumentSizeExceeded(message: \(Swift.String(describing: message)))"}
}

extension MaxDocumentSizeExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MaxDocumentSizeExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The size limit of a document is 64 KB.
public struct MaxDocumentSizeExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxDocumentSizeExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MaxDocumentSizeExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.MetadataValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes.MetadataValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MetadataValue(value: \(Swift.String(describing: value)))"}
}

extension SsmClientTypes {
    /// Metadata to assign to an Application Manager application.
    public struct MetadataValue: Swift.Equatable {
        /// Metadata value to assign to an Application Manager application.
        public var value: Swift.String?

        public init (
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

public struct ModifyDocumentPermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDocumentPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDocumentPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDocumentPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDocumentPermissionOutputError>
}

extension ModifyDocumentPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDocumentPermissionInput(accountIdsToAdd: \(Swift.String(describing: accountIdsToAdd)), accountIdsToRemove: \(Swift.String(describing: accountIdsToRemove)), name: \(Swift.String(describing: name)), permissionType: \(Swift.String(describing: permissionType)), sharedDocumentVersion: \(Swift.String(describing: sharedDocumentVersion)))"}
}

extension ModifyDocumentPermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIdsToAdd = "AccountIdsToAdd"
        case accountIdsToRemove = "AccountIdsToRemove"
        case name = "Name"
        case permissionType = "PermissionType"
        case sharedDocumentVersion = "SharedDocumentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIdsToAdd = accountIdsToAdd {
            var accountIdsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIdsToAdd)
            for accountidlist0 in accountIdsToAdd {
                try accountIdsToAddContainer.encode(accountidlist0)
            }
        }
        if let accountIdsToRemove = accountIdsToRemove {
            var accountIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIdsToRemove)
            for accountidlist0 in accountIdsToRemove {
                try accountIdsToRemoveContainer.encode(accountidlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let sharedDocumentVersion = sharedDocumentVersion {
            try encodeContainer.encode(sharedDocumentVersion, forKey: .sharedDocumentVersion)
        }
    }
}

public struct ModifyDocumentPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDocumentPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDocumentPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDocumentPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDocumentPermissionOutputError>
}

public struct ModifyDocumentPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDocumentPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDocumentPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDocumentPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDocumentPermissionOutputError>
}

public struct ModifyDocumentPermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDocumentPermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ModifyDocumentPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDocumentPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDocumentPermissionOutputError>
}

public struct ModifyDocumentPermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDocumentPermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ModifyDocumentPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDocumentPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDocumentPermissionOutputError>
}

public struct ModifyDocumentPermissionInput: Swift.Equatable {
    /// The Amazon Web Services user accounts that should have access to the document. The account IDs can either be a group of account IDs or All.
    public var accountIdsToAdd: [Swift.String]?
    /// The Amazon Web Services user accounts that should no longer have access to the document. The Amazon Web Services user account can either be a group of account IDs or All. This action has a higher priority than AccountIdsToAdd. If you specify an account ID to add and the same ID to remove, the system removes access to the document.
    public var accountIdsToRemove: [Swift.String]?
    /// The name of the document that you want to share.
    /// This member is required.
    public var name: Swift.String?
    /// The permission type for the document. The permission type can be Share.
    /// This member is required.
    public var permissionType: SsmClientTypes.DocumentPermissionType?
    /// (Optional) The version of the document to share. If it isn't specified, the system choose the Default version to share.
    public var sharedDocumentVersion: Swift.String?

    public init (
        accountIdsToAdd: [Swift.String]? = nil,
        accountIdsToRemove: [Swift.String]? = nil,
        name: Swift.String? = nil,
        permissionType: SsmClientTypes.DocumentPermissionType? = nil,
        sharedDocumentVersion: Swift.String? = nil
    )
    {
        self.accountIdsToAdd = accountIdsToAdd
        self.accountIdsToRemove = accountIdsToRemove
        self.name = name
        self.permissionType = permissionType
        self.sharedDocumentVersion = sharedDocumentVersion
    }
}

struct ModifyDocumentPermissionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let permissionType: SsmClientTypes.DocumentPermissionType?
    public let accountIdsToAdd: [Swift.String]?
    public let accountIdsToRemove: [Swift.String]?
    public let sharedDocumentVersion: Swift.String?
}

extension ModifyDocumentPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIdsToAdd = "AccountIdsToAdd"
        case accountIdsToRemove = "AccountIdsToRemove"
        case name = "Name"
        case permissionType = "PermissionType"
        case sharedDocumentVersion = "SharedDocumentVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentPermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let accountIdsToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIdsToAdd)
        var accountIdsToAddDecoded0:[Swift.String]? = nil
        if let accountIdsToAddContainer = accountIdsToAddContainer {
            accountIdsToAddDecoded0 = [Swift.String]()
            for string0 in accountIdsToAddContainer {
                if let string0 = string0 {
                    accountIdsToAddDecoded0?.append(string0)
                }
            }
        }
        accountIdsToAdd = accountIdsToAddDecoded0
        let accountIdsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIdsToRemove)
        var accountIdsToRemoveDecoded0:[Swift.String]? = nil
        if let accountIdsToRemoveContainer = accountIdsToRemoveContainer {
            accountIdsToRemoveDecoded0 = [Swift.String]()
            for string0 in accountIdsToRemoveContainer {
                if let string0 = string0 {
                    accountIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        accountIdsToRemove = accountIdsToRemoveDecoded0
        let sharedDocumentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedDocumentVersion)
        sharedDocumentVersion = sharedDocumentVersionDecoded
    }
}

extension ModifyDocumentPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyDocumentPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DocumentLimitExceeded" : self = .documentLimitExceeded(try DocumentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentPermissionLimit" : self = .documentPermissionLimit(try DocumentPermissionLimit(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPermissionType" : self = .invalidPermissionType(try InvalidPermissionType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDocumentPermissionOutputError: Swift.Error, Swift.Equatable {
    case documentLimitExceeded(DocumentLimitExceeded)
    case documentPermissionLimit(DocumentPermissionLimit)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidPermissionType(InvalidPermissionType)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDocumentPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDocumentPermissionOutputResponse()"}
}

extension ModifyDocumentPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyDocumentPermissionOutputResponse: Swift.Equatable {

    public init() {}
}

struct ModifyDocumentPermissionOutputResponseBody: Swift.Equatable {
}

extension ModifyDocumentPermissionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SsmClientTypes.NonCompliantSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nonCompliantCount = "NonCompliantCount"
        case severitySummary = "SeveritySummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if nonCompliantCount != 0 {
            try encodeContainer.encode(nonCompliantCount, forKey: .nonCompliantCount)
        }
        if let severitySummary = severitySummary {
            try encodeContainer.encode(severitySummary, forKey: .severitySummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nonCompliantCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .nonCompliantCount)
        nonCompliantCount = nonCompliantCountDecoded
        let severitySummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SeveritySummary.self, forKey: .severitySummary)
        severitySummary = severitySummaryDecoded
    }
}

extension SsmClientTypes.NonCompliantSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NonCompliantSummary(nonCompliantCount: \(Swift.String(describing: nonCompliantCount)), severitySummary: \(Swift.String(describing: severitySummary)))"}
}

extension SsmClientTypes {
    /// A summary of resources that aren't compliant. The summary is organized according to resource type.
    public struct NonCompliantSummary: Swift.Equatable {
        /// The total number of compliance items that aren't compliant.
        public var nonCompliantCount: Swift.Int
        /// A summary of the non-compliance severity by compliance type
        public var severitySummary: SsmClientTypes.SeveritySummary?

        public init (
            nonCompliantCount: Swift.Int = 0,
            severitySummary: SsmClientTypes.SeveritySummary? = nil
        )
        {
            self.nonCompliantCount = nonCompliantCount
            self.severitySummary = severitySummary
        }
    }

}

extension SsmClientTypes.NotificationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationArn = "NotificationArn"
        case notificationEvents = "NotificationEvents"
        case notificationType = "NotificationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationArn = notificationArn {
            try encodeContainer.encode(notificationArn, forKey: .notificationArn)
        }
        if let notificationEvents = notificationEvents {
            var notificationEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationEvents)
            for notificationeventlist0 in notificationEvents {
                try notificationEventsContainer.encode(notificationeventlist0.rawValue)
            }
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationArn)
        notificationArn = notificationArnDecoded
        let notificationEventsContainer = try containerValues.decodeIfPresent([SsmClientTypes.NotificationEvent?].self, forKey: .notificationEvents)
        var notificationEventsDecoded0:[SsmClientTypes.NotificationEvent]? = nil
        if let notificationEventsContainer = notificationEventsContainer {
            notificationEventsDecoded0 = [SsmClientTypes.NotificationEvent]()
            for string0 in notificationEventsContainer {
                if let string0 = string0 {
                    notificationEventsDecoded0?.append(string0)
                }
            }
        }
        notificationEvents = notificationEventsDecoded0
        let notificationTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
    }
}

extension SsmClientTypes.NotificationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationConfig(notificationArn: \(Swift.String(describing: notificationArn)), notificationEvents: \(Swift.String(describing: notificationEvents)), notificationType: \(Swift.String(describing: notificationType)))"}
}

extension SsmClientTypes {
    /// Configurations for sending notifications.
    public struct NotificationConfig: Swift.Equatable {
        /// An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes notifications about command status changes to this topic.
        public var notificationArn: Swift.String?
        /// The different events for which you can receive notifications. To learn more about these events, see [Monitoring Systems Manager status changes using Amazon SNS notifications](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html) in the Amazon Web Services Systems Manager User Guide.
        public var notificationEvents: [SsmClientTypes.NotificationEvent]?
        /// The type of notification.
        ///
        /// * Command: Receive notification when the status of a command changes.
        ///
        /// * Invocation: For commands sent to multiple managed nodes, receive notification on a per-node basis when the status of a command changes.
        public var notificationType: SsmClientTypes.NotificationType?

        public init (
            notificationArn: Swift.String? = nil,
            notificationEvents: [SsmClientTypes.NotificationEvent]? = nil,
            notificationType: SsmClientTypes.NotificationType? = nil
        )
        {
            self.notificationArn = notificationArn
            self.notificationEvents = notificationEvents
            self.notificationType = notificationType
        }
    }

}

extension SsmClientTypes {
    public enum NotificationEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case cancelled
        case failed
        case inProgress
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationEvent] {
            return [
                .all,
                .cancelled,
                .failed,
                .inProgress,
                .success,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .cancelled: return "Cancelled"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationEvent(rawValue: rawValue) ?? NotificationEvent.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case command
        case invocation
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .command,
                .invocation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .command: return "Command"
            case .invocation: return "Invocation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum OperatingSystem: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonlinux
        case amazonlinux2
        case centos
        case debian
        case macos
        case oraclelinux
        case raspbian
        case redhatenterpriselinux
        case suse
        case ubuntu
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatingSystem] {
            return [
                .amazonlinux,
                .amazonlinux2,
                .centos,
                .debian,
                .macos,
                .oraclelinux,
                .raspbian,
                .redhatenterpriselinux,
                .suse,
                .ubuntu,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonlinux: return "AMAZON_LINUX"
            case .amazonlinux2: return "AMAZON_LINUX_2"
            case .centos: return "CENTOS"
            case .debian: return "DEBIAN"
            case .macos: return "MACOS"
            case .oraclelinux: return "ORACLE_LINUX"
            case .raspbian: return "RASPBIAN"
            case .redhatenterpriselinux: return "REDHAT_ENTERPRISE_LINUX"
            case .suse: return "SUSE"
            case .ubuntu: return "UBUNTU"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatingSystem(rawValue: rawValue) ?? OperatingSystem.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsAggregator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatorType = "AggregatorType"
        case aggregators = "Aggregators"
        case attributeName = "AttributeName"
        case filters = "Filters"
        case typeName = "TypeName"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregatorType = aggregatorType {
            try encodeContainer.encode(aggregatorType, forKey: .aggregatorType)
        }
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for opsaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(opsaggregatorlist0)
            }
        }
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsfilterlist0 in filters {
                try filtersContainer.encode(opsfilterlist0)
            }
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .values)
            for (dictKey0, opsaggregatorvaluemap0) in values {
                try valuesContainer.encode(opsaggregatorvaluemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregatorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregatorType)
        aggregatorType = aggregatorTypeDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .values)
        var valuesDecoded0: [Swift.String:Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, opsaggregatorvalue0) in valuesContainer {
                if let opsaggregatorvalue0 = opsaggregatorvalue0 {
                    valuesDecoded0?[key0] = opsaggregatorvalue0
                }
            }
        }
        values = valuesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.OpsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.OpsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let aggregatorsContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[SsmClientTypes.OpsAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [SsmClientTypes.OpsAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
    }
}

extension SsmClientTypes.OpsAggregator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsAggregator(aggregatorType: \(Swift.String(describing: aggregatorType)), aggregators: \(Swift.String(describing: aggregators)), attributeName: \(Swift.String(describing: attributeName)), filters: \(Swift.String(describing: filters)), typeName: \(Swift.String(describing: typeName)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// One or more aggregators for viewing counts of OpsData using different dimensions such as Source, CreatedTime, or Source and CreatedTime, to name a few.
    public struct OpsAggregator: Swift.Equatable {
        /// Either a Range or Count aggregator for limiting an OpsData summary.
        public var aggregatorType: Swift.String?
        /// A nested aggregator for viewing counts of OpsData.
        public var aggregators: [SsmClientTypes.OpsAggregator]?
        /// The name of an OpsData attribute on which to limit the count of OpsData.
        public var attributeName: Swift.String?
        /// The aggregator filters.
        public var filters: [SsmClientTypes.OpsFilter]?
        /// The data type name to use for viewing counts of OpsData.
        public var typeName: Swift.String?
        /// The aggregator value.
        public var values: [Swift.String:Swift.String]?

        public init (
            aggregatorType: Swift.String? = nil,
            aggregators: [SsmClientTypes.OpsAggregator]? = nil,
            attributeName: Swift.String? = nil,
            filters: [SsmClientTypes.OpsFilter]? = nil,
            typeName: Swift.String? = nil,
            values: [Swift.String:Swift.String]? = nil
        )
        {
            self.aggregatorType = aggregatorType
            self.aggregators = aggregators
            self.attributeName = attributeName
            self.filters = filters
            self.typeName = typeName
            self.values = values
        }
    }

}

extension SsmClientTypes.OpsEntity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .data)
            for (dictKey0, opsentityitemmap0) in data {
                try dataContainer.encode(opsentityitemmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.OpsEntityItem?].self, forKey: .data)
        var dataDecoded0: [Swift.String:SsmClientTypes.OpsEntityItem]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [Swift.String:SsmClientTypes.OpsEntityItem]()
            for (key0, opsentityitem0) in dataContainer {
                if let opsentityitem0 = opsentityitem0 {
                    dataDecoded0?[key0] = opsentityitem0
                }
            }
        }
        data = dataDecoded0
    }
}

extension SsmClientTypes.OpsEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsEntity(data: \(Swift.String(describing: data)), id: \(Swift.String(describing: id)))"}
}

extension SsmClientTypes {
    /// The result of the query.
    public struct OpsEntity: Swift.Equatable {
        /// The data returned by the query.
        public var data: [Swift.String:SsmClientTypes.OpsEntityItem]?
        /// The query ID.
        public var id: Swift.String?

        public init (
            data: [Swift.String:SsmClientTypes.OpsEntityItem]? = nil,
            id: Swift.String? = nil
        )
        {
            self.data = data
            self.id = id
        }
    }

}

extension SsmClientTypes.OpsEntityItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captureTime = "CaptureTime"
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captureTime = captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let content = content {
            var contentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .content)
            for opsentityitementrylist0 in content {
                var opsentityitementrylist0Container = contentContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, opsentityitementry1) in opsentityitementrylist0 {
                    try opsentityitementrylist0Container.encode(opsentityitementry1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let captureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let contentContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .content)
        var contentDecoded0:[[Swift.String:Swift.String]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in contentContainer {
                var contentContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    contentContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            contentContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let contentContainerDecoded0 = contentContainerDecoded0 {
                    contentDecoded0?.append(contentContainerDecoded0)
                }
            }
        }
        content = contentDecoded0
    }
}

extension SsmClientTypes.OpsEntityItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsEntityItem(captureTime: \(Swift.String(describing: captureTime)), content: \(Swift.String(describing: content)))"}
}

extension SsmClientTypes {
    /// The OpsData summary.
    public struct OpsEntityItem: Swift.Equatable {
        /// The time the OpsData was captured.
        public var captureTime: Swift.String?
        /// The details of an OpsData summary.
        public var content: [[Swift.String:Swift.String]]?

        public init (
            captureTime: Swift.String? = nil,
            content: [[Swift.String:Swift.String]]? = nil
        )
        {
            self.captureTime = captureTime
            self.content = content
        }
    }

}

extension SsmClientTypes.OpsFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsfiltervaluelist0 in values {
                try valuesContainer.encode(opsfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsFilterOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes.OpsFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsFilter(key: \(Swift.String(describing: key)), type: \(Swift.String(describing: type)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// A filter for viewing OpsData summaries.
    public struct OpsFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: Swift.String?
        /// The type of filter.
        public var type: SsmClientTypes.OpsFilterOperatorType?
        /// The filter value.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            type: SsmClientTypes.OpsFilterOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum OpsFilterOperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginWith
        case equal
        case exists
        case greaterThan
        case lessThan
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsFilterOperatorType] {
            return [
                .beginWith,
                .equal,
                .exists,
                .greaterThan,
                .lessThan,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginWith: return "BeginWith"
            case .equal: return "Equal"
            case .exists: return "Exists"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsFilterOperatorType(rawValue: rawValue) ?? OpsFilterOperatorType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case description = "Description"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case opsItemId = "OpsItemId"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case source = "Source"
        case status = "Status"
        case title = "Title"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for opsitemnotifications0 in notifications {
                try notificationsContainer.encode(opsitemnotifications0)
            }
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let opsItemType = opsItemType {
            try encodeContainer.encode(opsItemType, forKey: .opsItemType)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let relatedOpsItems = relatedOpsItems {
            var relatedOpsItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedOpsItems)
            for relatedopsitems0 in relatedOpsItems {
                try relatedOpsItemsContainer.encode(relatedopsitems0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let opsItemTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemType)
        opsItemType = opsItemTypeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let notificationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[SsmClientTypes.OpsItemNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [SsmClientTypes.OpsItemNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let relatedOpsItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.RelatedOpsItem?].self, forKey: .relatedOpsItems)
        var relatedOpsItemsDecoded0:[SsmClientTypes.RelatedOpsItem]? = nil
        if let relatedOpsItemsContainer = relatedOpsItemsContainer {
            relatedOpsItemsDecoded0 = [SsmClientTypes.RelatedOpsItem]()
            for structure0 in relatedOpsItemsContainer {
                if let structure0 = structure0 {
                    relatedOpsItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedOpsItems = relatedOpsItemsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemStatus.self, forKey: .status)
        status = statusDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [Swift.String:SsmClientTypes.OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension SsmClientTypes.OpsItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItem(actualEndTime: \(Swift.String(describing: actualEndTime)), actualStartTime: \(Swift.String(describing: actualStartTime)), category: \(Swift.String(describing: category)), createdBy: \(Swift.String(describing: createdBy)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), notifications: \(Swift.String(describing: notifications)), operationalData: \(Swift.String(describing: operationalData)), opsItemId: \(Swift.String(describing: opsItemId)), opsItemType: \(Swift.String(describing: opsItemType)), plannedEndTime: \(Swift.String(describing: plannedEndTime)), plannedStartTime: \(Swift.String(describing: plannedStartTime)), priority: \(Swift.String(describing: priority)), relatedOpsItems: \(Swift.String(describing: relatedOpsItems)), severity: \(Swift.String(describing: severity)), source: \(Swift.String(describing: source)), status: \(Swift.String(describing: status)), title: \(Swift.String(describing: title)), version: \(Swift.String(describing: version)))"}
}

extension SsmClientTypes {
    /// Operations engineers and IT professionals use Amazon Web Services Systems Manager OpsCenter to view, investigate, and remediate operational work items (OpsItems) impacting the performance and health of their Amazon Web Services resources. OpsCenter is integrated with Amazon EventBridge and Amazon CloudWatch. This means you can configure these services to automatically create an OpsItem in OpsCenter when a CloudWatch alarm enters the ALARM state or when EventBridge processes an event from any Amazon Web Services service that publishes events. Configuring Amazon CloudWatch alarms and EventBridge events to automatically create OpsItems allows you to quickly diagnose and remediate issues with Amazon Web Services resources from a single console. To help you diagnose issues, each OpsItem includes contextually relevant information such as the name and ID of the Amazon Web Services resource that generated the OpsItem, alarm or event details, alarm history, and an alarm timeline graph. For the Amazon Web Services resource, OpsCenter aggregates information from Config, CloudTrail logs, and EventBridge, so you don't have to navigate across multiple console pages during your investigation. For more information, see [OpsCenter](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter.html) in the Amazon Web Services Systems Manager User Guide.
    public struct OpsItem: Swift.Equatable {
        /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualEndTime: ClientRuntime.Date?
        /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualStartTime: ClientRuntime.Date?
        /// An OpsItem category. Category options include: Availability, Cost, Performance, Recovery, Security.
        public var category: Swift.String?
        /// The ARN of the Amazon Web Services account that created the OpsItem.
        public var createdBy: Swift.String?
        /// The date and time the OpsItem was created.
        public var createdTime: ClientRuntime.Date?
        /// The OpsItem description.
        public var description: Swift.String?
        /// The ARN of the Amazon Web Services account that last updated the OpsItem.
        public var lastModifiedBy: Swift.String?
        /// The date and time the OpsItem was last updated.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of an Amazon Simple Notification Service (Amazon SNS) topic where notifications are sent when this OpsItem is edited or changed.
        public var notifications: [SsmClientTypes.OpsItemNotification]?
        /// Operational data is custom data that provides useful reference details about the OpsItem. For example, you can specify log files, error strings, license keys, troubleshooting tips, or other relevant data. You enter operational data as key-value pairs. The key has a maximum length of 128 characters. The value has a maximum size of 20 KB. Operational data keys can't begin with the following: amazon, aws, amzn, ssm, /amazon, /aws, /amzn, /ssm. You can choose to make the data searchable by other users in the account or you can restrict search access. Searchable data means that all users with access to the OpsItem Overview page (as provided by the [DescribeOpsItems] API operation) can view and search on the specified data. Operational data that isn't searchable is only viewable by users who have access to the OpsItem (as provided by the [GetOpsItem] API operation). Use the /aws/resources key in OperationalData to specify a related resource in the request. Use the /aws/automations key in OperationalData to associate an Automation runbook with the OpsItem. To view Amazon Web Services CLI example commands that use these keys, see [Creating OpsItems manually](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems) in the Amazon Web Services Systems Manager User Guide.
        public var operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
        /// The ID of the OpsItem.
        public var opsItemId: Swift.String?
        /// The type of OpsItem. Currently, the only valid values are /aws/changerequest and /aws/issue.
        public var opsItemType: Swift.String?
        /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedEndTime: ClientRuntime.Date?
        /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedStartTime: ClientRuntime.Date?
        /// The importance of this OpsItem in relation to other OpsItems in the system.
        public var priority: Swift.Int?
        /// One or more OpsItems that share something in common with the current OpsItem. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
        public var relatedOpsItems: [SsmClientTypes.RelatedOpsItem]?
        /// The severity of the OpsItem. Severity options range from 1 to 4.
        public var severity: Swift.String?
        /// The origin of the OpsItem, such as Amazon EC2 or Systems Manager. The impacted resource is a subset of source.
        public var source: Swift.String?
        /// The OpsItem status. Status can be Open, In Progress, or Resolved. For more information, see [Editing OpsItem details](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems-editing-details.html) in the Amazon Web Services Systems Manager User Guide.
        public var status: SsmClientTypes.OpsItemStatus?
        /// A short heading that describes the nature of the OpsItem and the impacted resource.
        public var title: Swift.String?
        /// The version of this OpsItem. Each time the OpsItem is edited the version number increments by one.
        public var version: Swift.String?

        public init (
            actualEndTime: ClientRuntime.Date? = nil,
            actualStartTime: ClientRuntime.Date? = nil,
            category: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            notifications: [SsmClientTypes.OpsItemNotification]? = nil,
            operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil,
            opsItemId: Swift.String? = nil,
            opsItemType: Swift.String? = nil,
            plannedEndTime: ClientRuntime.Date? = nil,
            plannedStartTime: ClientRuntime.Date? = nil,
            priority: Swift.Int? = nil,
            relatedOpsItems: [SsmClientTypes.RelatedOpsItem]? = nil,
            severity: Swift.String? = nil,
            source: Swift.String? = nil,
            status: SsmClientTypes.OpsItemStatus? = nil,
            title: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.actualEndTime = actualEndTime
            self.actualStartTime = actualStartTime
            self.category = category
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.notifications = notifications
            self.operationalData = operationalData
            self.opsItemId = opsItemId
            self.opsItemType = opsItemType
            self.plannedEndTime = plannedEndTime
            self.plannedStartTime = plannedStartTime
            self.priority = priority
            self.relatedOpsItems = relatedOpsItems
            self.severity = severity
            self.source = source
            self.status = status
            self.title = title
            self.version = version
        }
    }

}

extension OpsItemAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemAlreadyExistsException(message: \(Swift.String(describing: message)), opsItemId: \(Swift.String(describing: opsItemId)))"}
}

extension OpsItemAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.opsItemId = output.opsItemId
        } else {
            self.message = nil
            self.opsItemId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The OpsItem already exists.
public struct OpsItemAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var opsItemId: Swift.String?

    public init (
        message: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.message = message
        self.opsItemId = opsItemId
    }
}

struct OpsItemAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let opsItemId: Swift.String?
}

extension OpsItemAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension SsmClientTypes {
    public enum OpsItemDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case searchableString
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemDataType] {
            return [
                .searchableString,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .searchableString: return "SearchableString"
            case .string: return "String"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemDataType(rawValue: rawValue) ?? OpsItemDataType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsItemDataValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemDataType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes.OpsItemDataValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemDataValue(type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension SsmClientTypes {
    /// An object that defines the value of the key and its type in the OperationalData map.
    public struct OpsItemDataValue: Swift.Equatable {
        /// The type of key-value pair. Valid types include SearchableString and String.
        public var type: SsmClientTypes.OpsItemDataType?
        /// The value of the OperationalData key.
        public var value: Swift.String?

        public init (
            type: SsmClientTypes.OpsItemDataType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension SsmClientTypes.OpsItemEventFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsitemeventfiltervalues0 in values {
                try valuesContainer.encode(opsitemeventfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemEventFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemEventFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension SsmClientTypes.OpsItemEventFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemEventFilter(key: \(Swift.String(describing: key)), operator: \(Swift.String(describing: `operator`)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// Describes a filter for a specific list of OpsItem events. You can filter event information by using tags. You specify tags by using a key-value pair mapping.
    public struct OpsItemEventFilter: Swift.Equatable {
        /// The operator used by the filter call. Currently, the only supported value is Equal.
        /// This member is required.
        public var `operator`: SsmClientTypes.OpsItemEventFilterOperator?
        /// The name of the filter key. Currently, the only supported value is OpsItemId.
        /// This member is required.
        public var key: SsmClientTypes.OpsItemEventFilterKey?
        /// The values for the filter, consisting of one or more OpsItem IDs.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            `operator`: SsmClientTypes.OpsItemEventFilterOperator? = nil,
            key: SsmClientTypes.OpsItemEventFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.`operator` = `operator`
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum OpsItemEventFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case opsitemId
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemEventFilterKey] {
            return [
                .opsitemId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .opsitemId: return "OpsItemId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemEventFilterKey(rawValue: rawValue) ?? OpsItemEventFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum OpsItemEventFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemEventFilterOperator] {
            return [
                .equal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "Equal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemEventFilterOperator(rawValue: rawValue) ?? OpsItemEventFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsItemEventSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case detail = "Detail"
        case detailType = "DetailType"
        case eventId = "EventId"
        case opsItemId = "OpsItemId"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let detail = detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType, forKey: .detailType)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let detailTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemIdentity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension SsmClientTypes.OpsItemEventSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemEventSummary(createdBy: \(Swift.String(describing: createdBy)), createdTime: \(Swift.String(describing: createdTime)), detail: \(Swift.String(describing: detail)), detailType: \(Swift.String(describing: detailType)), eventId: \(Swift.String(describing: eventId)), opsItemId: \(Swift.String(describing: opsItemId)), source: \(Swift.String(describing: source)))"}
}

extension SsmClientTypes {
    /// Summary information about an OpsItem event or that associated an OpsItem with a related item.
    public struct OpsItemEventSummary: Swift.Equatable {
        /// Information about the user or resource that created the OpsItem event.
        public var createdBy: SsmClientTypes.OpsItemIdentity?
        /// The date and time the OpsItem event was created.
        public var createdTime: ClientRuntime.Date?
        /// Specific information about the OpsItem event.
        public var detail: Swift.String?
        /// The type of information provided as a detail.
        public var detailType: Swift.String?
        /// The ID of the OpsItem event.
        public var eventId: Swift.String?
        /// The ID of the OpsItem.
        public var opsItemId: Swift.String?
        /// The source of the OpsItem event.
        public var source: Swift.String?

        public init (
            createdBy: SsmClientTypes.OpsItemIdentity? = nil,
            createdTime: ClientRuntime.Date? = nil,
            detail: Swift.String? = nil,
            detailType: Swift.String? = nil,
            eventId: Swift.String? = nil,
            opsItemId: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.detail = detail
            self.detailType = detailType
            self.eventId = eventId
            self.opsItemId = opsItemId
            self.source = source
        }
    }

}

extension SsmClientTypes.OpsItemFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsitemfiltervalues0 in values {
                try valuesContainer.encode(opsitemfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension SsmClientTypes.OpsItemFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemFilter(key: \(Swift.String(describing: key)), operator: \(Swift.String(describing: `operator`)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// Describes an OpsItem filter.
    public struct OpsItemFilter: Swift.Equatable {
        /// The operator used by the filter call.
        /// This member is required.
        public var `operator`: SsmClientTypes.OpsItemFilterOperator?
        /// The name of the filter.
        /// This member is required.
        public var key: SsmClientTypes.OpsItemFilterKey?
        /// The filter value.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            `operator`: SsmClientTypes.OpsItemFilterOperator? = nil,
            key: SsmClientTypes.OpsItemFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.`operator` = `operator`
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum OpsItemFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actualEndTime
        case actualStartTime
        case automationId
        case category
        case changeRequestApproverArn
        case changeRequestApproverName
        case changeRequestRequesterArn
        case changeRequestRequesterName
        case changeRequestTargetsResourceGroup
        case changeRequestTemplate
        case createdBy
        case createdTime
        case insightType
        case lastModifiedTime
        case operationalData
        case operationalDataKey
        case operationalDataValue
        case opsitemId
        case opsitemType
        case plannedEndTime
        case plannedStartTime
        case priority
        case resourceId
        case severity
        case source
        case status
        case title
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemFilterKey] {
            return [
                .actualEndTime,
                .actualStartTime,
                .automationId,
                .category,
                .changeRequestApproverArn,
                .changeRequestApproverName,
                .changeRequestRequesterArn,
                .changeRequestRequesterName,
                .changeRequestTargetsResourceGroup,
                .changeRequestTemplate,
                .createdBy,
                .createdTime,
                .insightType,
                .lastModifiedTime,
                .operationalData,
                .operationalDataKey,
                .operationalDataValue,
                .opsitemId,
                .opsitemType,
                .plannedEndTime,
                .plannedStartTime,
                .priority,
                .resourceId,
                .severity,
                .source,
                .status,
                .title,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actualEndTime: return "ActualEndTime"
            case .actualStartTime: return "ActualStartTime"
            case .automationId: return "AutomationId"
            case .category: return "Category"
            case .changeRequestApproverArn: return "ChangeRequestByApproverArn"
            case .changeRequestApproverName: return "ChangeRequestByApproverName"
            case .changeRequestRequesterArn: return "ChangeRequestByRequesterArn"
            case .changeRequestRequesterName: return "ChangeRequestByRequesterName"
            case .changeRequestTargetsResourceGroup: return "ChangeRequestByTargetsResourceGroup"
            case .changeRequestTemplate: return "ChangeRequestByTemplate"
            case .createdBy: return "CreatedBy"
            case .createdTime: return "CreatedTime"
            case .insightType: return "InsightByType"
            case .lastModifiedTime: return "LastModifiedTime"
            case .operationalData: return "OperationalData"
            case .operationalDataKey: return "OperationalDataKey"
            case .operationalDataValue: return "OperationalDataValue"
            case .opsitemId: return "OpsItemId"
            case .opsitemType: return "OpsItemType"
            case .plannedEndTime: return "PlannedEndTime"
            case .plannedStartTime: return "PlannedStartTime"
            case .priority: return "Priority"
            case .resourceId: return "ResourceId"
            case .severity: return "Severity"
            case .source: return "Source"
            case .status: return "Status"
            case .title: return "Title"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemFilterKey(rawValue: rawValue) ?? OpsItemFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum OpsItemFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equal
        case greaterThan
        case lessThan
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemFilterOperator] {
            return [
                .contains,
                .equal,
                .greaterThan,
                .lessThan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "Contains"
            case .equal: return "Equal"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemFilterOperator(rawValue: rawValue) ?? OpsItemFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsItemIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SsmClientTypes.OpsItemIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemIdentity(arn: \(Swift.String(describing: arn)))"}
}

extension SsmClientTypes {
    /// Information about the user or resource that created an OpsItem event.
    public struct OpsItemIdentity: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem event.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension OpsItemInvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemInvalidParameterException(message: \(Swift.String(describing: message)), parameterNames: \(Swift.String(describing: parameterNames)))"}
}

extension OpsItemInvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemInvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterNames = output.parameterNames
        } else {
            self.message = nil
            self.parameterNames = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A specified parameter argument isn't valid. Verify the available arguments and try again.
public struct OpsItemInvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var parameterNames: [Swift.String]?

    public init (
        message: Swift.String? = nil,
        parameterNames: [Swift.String]? = nil
    )
    {
        self.message = message
        self.parameterNames = parameterNames
    }
}

struct OpsItemInvalidParameterExceptionBody: Swift.Equatable {
    public let parameterNames: [Swift.String]?
    public let message: Swift.String?
}

extension OpsItemInvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case parameterNames = "ParameterNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parameterNames)
        var parameterNamesDecoded0:[Swift.String]? = nil
        if let parameterNamesContainer = parameterNamesContainer {
            parameterNamesDecoded0 = [Swift.String]()
            for string0 in parameterNamesContainer {
                if let string0 = string0 {
                    parameterNamesDecoded0?.append(string0)
                }
            }
        }
        parameterNames = parameterNamesDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsItemLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemLimitExceededException(limit: \(Swift.String(describing: limit)), limitType: \(Swift.String(describing: limitType)), message: \(Swift.String(describing: message)), resourceTypes: \(Swift.String(describing: resourceTypes)))"}
}

extension OpsItemLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.limitType = output.limitType
            self.message = output.message
            self.resourceTypes = output.resourceTypes
        } else {
            self.limit = 0
            self.limitType = nil
            self.message = nil
            self.resourceTypes = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request caused OpsItems to exceed one or more quotas. For information about OpsItem quotas, see [What are the resource limits for OpsCenter?](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-learn-more.html#OpsCenter-learn-more-limits).
public struct OpsItemLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var limit: Swift.Int
    public var limitType: Swift.String?
    public var message: Swift.String?
    public var resourceTypes: [Swift.String]?

    public init (
        limit: Swift.Int = 0,
        limitType: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.limitType = limitType
        self.message = message
        self.resourceTypes = resourceTypes
    }
}

struct OpsItemLimitExceededExceptionBody: Swift.Equatable {
    public let resourceTypes: [Swift.String]?
    public let limit: Swift.Int
    public let limitType: Swift.String?
    public let message: Swift.String?
}

extension OpsItemLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case limitType = "LimitType"
        case message = "Message"
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let limitDecoded = try containerValues.decode(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let limitTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsItemNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension OpsItemNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified OpsItem ID doesn't exist. Verify the ID and try again.
public struct OpsItemNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsItemNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OpsItemNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.OpsItemNotification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SsmClientTypes.OpsItemNotification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemNotification(arn: \(Swift.String(describing: arn)))"}
}

extension SsmClientTypes {
    /// A notification about the OpsItem.
    public struct OpsItemNotification: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon Simple Notification Service (Amazon SNS) topic where notifications are sent when this OpsItem is edited or changed.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension OpsItemRelatedItemAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemRelatedItemAlreadyExistsException(message: \(Swift.String(describing: message)), opsItemId: \(Swift.String(describing: opsItemId)), resourceUri: \(Swift.String(describing: resourceUri)))"}
}

extension OpsItemRelatedItemAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemRelatedItemAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.opsItemId = output.opsItemId
            self.resourceUri = output.resourceUri
        } else {
            self.message = nil
            self.opsItemId = nil
            self.resourceUri = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Resource Name (ARN) is already associated with the OpsItem.
public struct OpsItemRelatedItemAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var opsItemId: Swift.String?
    public var resourceUri: Swift.String?

    public init (
        message: Swift.String? = nil,
        opsItemId: Swift.String? = nil,
        resourceUri: Swift.String? = nil
    )
    {
        self.message = message
        self.opsItemId = opsItemId
        self.resourceUri = resourceUri
    }
}

struct OpsItemRelatedItemAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceUri: Swift.String?
    public let opsItemId: Swift.String?
}

extension OpsItemRelatedItemAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case opsItemId = "OpsItemId"
        case resourceUri = "ResourceUri"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceUri)
        resourceUri = resourceUriDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension OpsItemRelatedItemAssociationNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemRelatedItemAssociationNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension OpsItemRelatedItemAssociationNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemRelatedItemAssociationNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The association wasn't found using the parameters you specified in the call. Verify the information and try again.
public struct OpsItemRelatedItemAssociationNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsItemRelatedItemAssociationNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OpsItemRelatedItemAssociationNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.OpsItemRelatedItemSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationType = "AssociationType"
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case opsItemId = "OpsItemId"
        case resourceType = "ResourceType"
        case resourceUri = "ResourceUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType, forKey: .associationType)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceUri = resourceUri {
            try encodeContainer.encode(resourceUri, forKey: .resourceUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceUri)
        resourceUri = resourceUriDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemIdentity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemIdentity.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension SsmClientTypes.OpsItemRelatedItemSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemRelatedItemSummary(associationId: \(Swift.String(describing: associationId)), associationType: \(Swift.String(describing: associationType)), createdBy: \(Swift.String(describing: createdBy)), createdTime: \(Swift.String(describing: createdTime)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), opsItemId: \(Swift.String(describing: opsItemId)), resourceType: \(Swift.String(describing: resourceType)), resourceUri: \(Swift.String(describing: resourceUri)))"}
}

extension SsmClientTypes {
    /// Summary information about related-item resources for an OpsItem.
    public struct OpsItemRelatedItemSummary: Swift.Equatable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The association type.
        public var associationType: Swift.String?
        /// Information about the user or resource that created an OpsItem event.
        public var createdBy: SsmClientTypes.OpsItemIdentity?
        /// The time the related-item association was created.
        public var createdTime: ClientRuntime.Date?
        /// Information about the user or resource that created an OpsItem event.
        public var lastModifiedBy: SsmClientTypes.OpsItemIdentity?
        /// The time the related-item association was last updated.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The OpsItem ID.
        public var opsItemId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?
        /// The Amazon Resource Name (ARN) of the related-item resource.
        public var resourceUri: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            associationType: Swift.String? = nil,
            createdBy: SsmClientTypes.OpsItemIdentity? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastModifiedBy: SsmClientTypes.OpsItemIdentity? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            opsItemId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            resourceUri: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationType = associationType
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.opsItemId = opsItemId
            self.resourceType = resourceType
            self.resourceUri = resourceUri
        }
    }

}

extension SsmClientTypes.OpsItemRelatedItemsFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsitemrelateditemsfiltervalues0 in values {
                try valuesContainer.encode(opsitemrelateditemsfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemRelatedItemsFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemRelatedItemsFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension SsmClientTypes.OpsItemRelatedItemsFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemRelatedItemsFilter(key: \(Swift.String(describing: key)), operator: \(Swift.String(describing: `operator`)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// Describes a filter for a specific list of related-item resources.
    public struct OpsItemRelatedItemsFilter: Swift.Equatable {
        /// The operator used by the filter call. The only supported operator is EQUAL.
        /// This member is required.
        public var `operator`: SsmClientTypes.OpsItemRelatedItemsFilterOperator?
        /// The name of the filter key. Supported values include ResourceUri, ResourceType, or AssociationId.
        /// This member is required.
        public var key: SsmClientTypes.OpsItemRelatedItemsFilterKey?
        /// The values for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            `operator`: SsmClientTypes.OpsItemRelatedItemsFilterOperator? = nil,
            key: SsmClientTypes.OpsItemRelatedItemsFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.`operator` = `operator`
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum OpsItemRelatedItemsFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associationId
        case resourceType
        case resourceUri
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemRelatedItemsFilterKey] {
            return [
                .associationId,
                .resourceType,
                .resourceUri,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associationId: return "AssociationId"
            case .resourceType: return "ResourceType"
            case .resourceUri: return "ResourceUri"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemRelatedItemsFilterKey(rawValue: rawValue) ?? OpsItemRelatedItemsFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum OpsItemRelatedItemsFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemRelatedItemsFilterOperator] {
            return [
                .equal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "Equal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemRelatedItemsFilterOperator(rawValue: rawValue) ?? OpsItemRelatedItemsFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum OpsItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case cancelled
        case cancelling
        case changeCalendarOverrideApproved
        case changeCalendarOverrideRejected
        case closed
        case completedWithFailure
        case completedWithSuccess
        case failed
        case inProgress
        case `open`
        case pending
        case pendingApproval
        case pendingChangeCalendarOverride
        case rejected
        case resolved
        case runbookInProgress
        case scheduled
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemStatus] {
            return [
                .approved,
                .cancelled,
                .cancelling,
                .changeCalendarOverrideApproved,
                .changeCalendarOverrideRejected,
                .closed,
                .completedWithFailure,
                .completedWithSuccess,
                .failed,
                .inProgress,
                .open,
                .pending,
                .pendingApproval,
                .pendingChangeCalendarOverride,
                .rejected,
                .resolved,
                .runbookInProgress,
                .scheduled,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "Approved"
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .changeCalendarOverrideApproved: return "ChangeCalendarOverrideApproved"
            case .changeCalendarOverrideRejected: return "ChangeCalendarOverrideRejected"
            case .closed: return "Closed"
            case .completedWithFailure: return "CompletedWithFailure"
            case .completedWithSuccess: return "CompletedWithSuccess"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .open: return "Open"
            case .pending: return "Pending"
            case .pendingApproval: return "PendingApproval"
            case .pendingChangeCalendarOverride: return "PendingChangeCalendarOverride"
            case .rejected: return "Rejected"
            case .resolved: return "Resolved"
            case .runbookInProgress: return "RunbookInProgress"
            case .scheduled: return "Scheduled"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemStatus(rawValue: rawValue) ?? OpsItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsItemSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case operationalData = "OperationalData"
        case opsItemId = "OpsItemId"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case severity = "Severity"
        case source = "Source"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let opsItemType = opsItemType {
            try encodeContainer.encode(opsItemType, forKey: .opsItemType)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemStatus.self, forKey: .status)
        status = statusDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [Swift.String:SsmClientTypes.OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let opsItemTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemType)
        opsItemType = opsItemTypeDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension SsmClientTypes.OpsItemSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsItemSummary(actualEndTime: \(Swift.String(describing: actualEndTime)), actualStartTime: \(Swift.String(describing: actualStartTime)), category: \(Swift.String(describing: category)), createdBy: \(Swift.String(describing: createdBy)), createdTime: \(Swift.String(describing: createdTime)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), operationalData: \(Swift.String(describing: operationalData)), opsItemId: \(Swift.String(describing: opsItemId)), opsItemType: \(Swift.String(describing: opsItemType)), plannedEndTime: \(Swift.String(describing: plannedEndTime)), plannedStartTime: \(Swift.String(describing: plannedStartTime)), priority: \(Swift.String(describing: priority)), severity: \(Swift.String(describing: severity)), source: \(Swift.String(describing: source)), status: \(Swift.String(describing: status)), title: \(Swift.String(describing: title)))"}
}

extension SsmClientTypes {
    /// A count of OpsItems.
    public struct OpsItemSummary: Swift.Equatable {
        /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualEndTime: ClientRuntime.Date?
        /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualStartTime: ClientRuntime.Date?
        /// A list of OpsItems by category.
        public var category: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.
        public var createdBy: Swift.String?
        /// The date and time the OpsItem was created.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.
        public var lastModifiedBy: Swift.String?
        /// The date and time the OpsItem was last updated.
        public var lastModifiedTime: ClientRuntime.Date?
        /// Operational data is custom data that provides useful reference details about the OpsItem.
        public var operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
        /// The ID of the OpsItem.
        public var opsItemId: Swift.String?
        /// The type of OpsItem. Currently, the only valid values are /aws/changerequest and /aws/issue.
        public var opsItemType: Swift.String?
        /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedEndTime: ClientRuntime.Date?
        /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedStartTime: ClientRuntime.Date?
        /// The importance of this OpsItem in relation to other OpsItems in the system.
        public var priority: Swift.Int?
        /// A list of OpsItems by severity.
        public var severity: Swift.String?
        /// The impacted Amazon Web Services resource.
        public var source: Swift.String?
        /// The OpsItem status. Status can be Open, In Progress, or Resolved.
        public var status: SsmClientTypes.OpsItemStatus?
        /// A short heading that describes the nature of the OpsItem and the impacted resource.
        public var title: Swift.String?

        public init (
            actualEndTime: ClientRuntime.Date? = nil,
            actualStartTime: ClientRuntime.Date? = nil,
            category: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil,
            opsItemId: Swift.String? = nil,
            opsItemType: Swift.String? = nil,
            plannedEndTime: ClientRuntime.Date? = nil,
            plannedStartTime: ClientRuntime.Date? = nil,
            priority: Swift.Int? = nil,
            severity: Swift.String? = nil,
            source: Swift.String? = nil,
            status: SsmClientTypes.OpsItemStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.actualEndTime = actualEndTime
            self.actualStartTime = actualStartTime
            self.category = category
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.operationalData = operationalData
            self.opsItemId = opsItemId
            self.opsItemType = opsItemType
            self.plannedEndTime = plannedEndTime
            self.plannedStartTime = plannedStartTime
            self.priority = priority
            self.severity = severity
            self.source = source
            self.status = status
            self.title = title
        }
    }

}

extension SsmClientTypes.OpsMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case opsMetadataArn = "OpsMetadataArn"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension SsmClientTypes.OpsMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsMetadata(creationDate: \(Swift.String(describing: creationDate)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), lastModifiedUser: \(Swift.String(describing: lastModifiedUser)), opsMetadataArn: \(Swift.String(describing: opsMetadataArn)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension SsmClientTypes {
    /// Operational metadata for an application in Application Manager.
    public struct OpsMetadata: Swift.Equatable {
        /// The date the OpsMetadata objects was created.
        public var creationDate: ClientRuntime.Date?
        /// The date the OpsMetadata object was last updated.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The user name who last updated the OpsMetadata object.
        public var lastModifiedUser: Swift.String?
        /// The Amazon Resource Name (ARN) of the OpsMetadata Object or blob.
        public var opsMetadataArn: Swift.String?
        /// The ID of the Application Manager application.
        public var resourceId: Swift.String?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            opsMetadataArn: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.opsMetadataArn = opsMetadataArn
            self.resourceId = resourceId
        }
    }

}

extension OpsMetadataAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsMetadataAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension OpsMetadataAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An OpsMetadata object already exists for the selected resource.
public struct OpsMetadataAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OpsMetadataAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.OpsMetadataFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsmetadatafiltervaluelist0 in values {
                try valuesContainer.encode(opsmetadatafiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.OpsMetadataFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsMetadataFilter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// A filter to limit the number of OpsMetadata objects displayed.
    public struct OpsMetadataFilter: Swift.Equatable {
        /// A filter key.
        /// This member is required.
        public var key: Swift.String?
        /// A filter value.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension OpsMetadataInvalidArgumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsMetadataInvalidArgumentException(message: \(Swift.String(describing: message)))"}
}

extension OpsMetadataInvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataInvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the arguments passed is invalid.
public struct OpsMetadataInvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataInvalidArgumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OpsMetadataInvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataKeyLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsMetadataKeyLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension OpsMetadataKeyLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataKeyLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The OpsMetadata object exceeds the maximum number of OpsMetadata keys that you can assign to an application in Application Manager.
public struct OpsMetadataKeyLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataKeyLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OpsMetadataKeyLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsMetadataLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension OpsMetadataLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your account reached the maximum number of OpsMetadata objects allowed by Application Manager. The maximum is 200 OpsMetadata objects. Delete one or more OpsMetadata object and try again.
public struct OpsMetadataLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OpsMetadataLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsMetadataNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension OpsMetadataNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The OpsMetadata object doesn't exist.
public struct OpsMetadataNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OpsMetadataNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataTooManyUpdatesException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsMetadataTooManyUpdatesException(message: \(Swift.String(describing: message)))"}
}

extension OpsMetadataTooManyUpdatesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataTooManyUpdatesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The system is processing too many concurrent updates. Wait a few moments and try again.
public struct OpsMetadataTooManyUpdatesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataTooManyUpdatesExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OpsMetadataTooManyUpdatesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.OpsResultAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
    }
}

extension SsmClientTypes.OpsResultAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpsResultAttribute(typeName: \(Swift.String(describing: typeName)))"}
}

extension SsmClientTypes {
    /// The OpsItem data type to return.
    public struct OpsResultAttribute: Swift.Equatable {
        /// Name of the data type. Valid value: AWS:OpsItem, AWS:EC2InstanceInformation, AWS:OpsItemTrendline, or AWS:ComplianceSummary.
        /// This member is required.
        public var typeName: Swift.String?

        public init (
            typeName: Swift.String? = nil
        )
        {
            self.typeName = typeName
        }
    }

}

extension SsmClientTypes.OutputSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputSourceId = "OutputSourceId"
        case outputSourceType = "OutputSourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputSourceId = outputSourceId {
            try encodeContainer.encode(outputSourceId, forKey: .outputSourceId)
        }
        if let outputSourceType = outputSourceType {
            try encodeContainer.encode(outputSourceType, forKey: .outputSourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputSourceId)
        outputSourceId = outputSourceIdDecoded
        let outputSourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputSourceType)
        outputSourceType = outputSourceTypeDecoded
    }
}

extension SsmClientTypes.OutputSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputSource(outputSourceId: \(Swift.String(describing: outputSourceId)), outputSourceType: \(Swift.String(describing: outputSourceType)))"}
}

extension SsmClientTypes {
    /// Information about the source where the association execution details are stored.
    public struct OutputSource: Swift.Equatable {
        /// The ID of the output source, for example the URL of an S3 bucket.
        public var outputSourceId: Swift.String?
        /// The type of source where the association execution details are stored, for example, Amazon S3.
        public var outputSourceType: Swift.String?

        public init (
            outputSourceId: Swift.String? = nil,
            outputSourceType: Swift.String? = nil
        )
        {
            self.outputSourceId = outputSourceId
            self.outputSourceType = outputSourceType
        }
    }

}

extension SsmClientTypes.Parameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case dataType = "DataType"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case selector = "Selector"
        case sourceResult = "SourceResult"
        case type = "Type"
        case value = "Value"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let selector = selector {
            try encodeContainer.encode(selector, forKey: .selector)
        }
        if let sourceResult = sourceResult {
            try encodeContainer.encode(sourceResult, forKey: .sourceResult)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let selectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selector)
        selector = selectorDecoded
        let sourceResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceResult)
        sourceResult = sourceResultDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension SsmClientTypes.Parameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Parameter(aRN: \(Swift.String(describing: aRN)), dataType: \(Swift.String(describing: dataType)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), name: \(Swift.String(describing: name)), selector: \(Swift.String(describing: selector)), sourceResult: \(Swift.String(describing: sourceResult)), type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)), version: \(Swift.String(describing: version)))"}
}

extension SsmClientTypes {
    /// An Amazon Web Services Systems Manager parameter in Parameter Store.
    public struct Parameter: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the parameter.
        public var aRN: Swift.String?
        /// The data type of the parameter, such as text or aws:ec2:image. The default is text.
        public var dataType: Swift.String?
        /// Date the parameter was last changed or updated and the parameter version was created.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The name of the parameter.
        public var name: Swift.String?
        /// Either the version number or the label used to retrieve the parameter value. Specify selectors by using one of the following formats: parameter_name:version parameter_name:label
        public var selector: Swift.String?
        /// Applies to parameters that reference information in other Amazon Web Services services. SourceResult is the raw result or response from the source.
        public var sourceResult: Swift.String?
        /// The type of parameter. Valid values include the following: String, StringList, and SecureString.
        public var type: SsmClientTypes.ParameterType?
        /// The parameter value.
        public var value: Swift.String?
        /// The parameter version.
        public var version: Swift.Int

        public init (
            aRN: Swift.String? = nil,
            dataType: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            selector: Swift.String? = nil,
            sourceResult: Swift.String? = nil,
            type: SsmClientTypes.ParameterType? = nil,
            value: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.aRN = aRN
            self.dataType = dataType
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.selector = selector
            self.sourceResult = sourceResult
            self.type = type
            self.value = value
            self.version = version
        }
    }

}

extension ParameterAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension ParameterAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter already exists. You can't create duplicate parameters.
public struct ParameterAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ParameterHistory: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case labels = "Labels"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case name = "Name"
        case policies = "Policies"
        case tier = "Tier"
        case type = "Type"
        case value = "Value"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for parameterlabellist0 in labels {
                try labelsContainer.encode(parameterlabellist0)
            }
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for parameterpolicylist0 in policies {
                try policiesContainer.encode(parameterpolicylist0)
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterType.self, forKey: .type)
        type = typeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let allowedPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterTier.self, forKey: .tier)
        tier = tierDecoded
        let policiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterInlinePolicy?].self, forKey: .policies)
        var policiesDecoded0:[SsmClientTypes.ParameterInlinePolicy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [SsmClientTypes.ParameterInlinePolicy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension SsmClientTypes.ParameterHistory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterHistory(allowedPattern: \(Swift.String(describing: allowedPattern)), dataType: \(Swift.String(describing: dataType)), description: \(Swift.String(describing: description)), keyId: \(Swift.String(describing: keyId)), labels: \(Swift.String(describing: labels)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), lastModifiedUser: \(Swift.String(describing: lastModifiedUser)), name: \(Swift.String(describing: name)), policies: \(Swift.String(describing: policies)), tier: \(Swift.String(describing: tier)), type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)), version: \(Swift.String(describing: version)))"}
}

extension SsmClientTypes {
    /// Information about parameter usage.
    public struct ParameterHistory: Swift.Equatable {
        /// Parameter names can include the following letters and symbols. a-zA-Z0-9_.-
        public var allowedPattern: Swift.String?
        /// The data type of the parameter, such as text or aws:ec2:image. The default is text.
        public var dataType: Swift.String?
        /// Information about the parameter.
        public var description: Swift.String?
        /// The ID of the query key used for this parameter.
        public var keyId: Swift.String?
        /// Labels assigned to the parameter version.
        public var labels: [Swift.String]?
        /// Date the parameter was last changed or updated.
        public var lastModifiedDate: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of the Amazon Web Services user who last changed the parameter.
        public var lastModifiedUser: Swift.String?
        /// The name of the parameter.
        public var name: Swift.String?
        /// Information about the policies assigned to a parameter. [Assigning parameter policies](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html) in the Amazon Web Services Systems Manager User Guide.
        public var policies: [SsmClientTypes.ParameterInlinePolicy]?
        /// The parameter tier.
        public var tier: SsmClientTypes.ParameterTier?
        /// The type of parameter used.
        public var type: SsmClientTypes.ParameterType?
        /// The parameter value.
        public var value: Swift.String?
        /// The parameter version.
        public var version: Swift.Int

        public init (
            allowedPattern: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            keyId: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            name: Swift.String? = nil,
            policies: [SsmClientTypes.ParameterInlinePolicy]? = nil,
            tier: SsmClientTypes.ParameterTier? = nil,
            type: SsmClientTypes.ParameterType? = nil,
            value: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.allowedPattern = allowedPattern
            self.dataType = dataType
            self.description = description
            self.keyId = keyId
            self.labels = labels
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.name = name
            self.policies = policies
            self.tier = tier
            self.type = type
            self.value = value
            self.version = version
        }
    }

}

extension SsmClientTypes.ParameterInlinePolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStatus = "PolicyStatus"
        case policyText = "PolicyText"
        case policyType = "PolicyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyStatus = policyStatus {
            try encodeContainer.encode(policyStatus, forKey: .policyStatus)
        }
        if let policyText = policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType, forKey: .policyType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let policyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

extension SsmClientTypes.ParameterInlinePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterInlinePolicy(policyStatus: \(Swift.String(describing: policyStatus)), policyText: \(Swift.String(describing: policyText)), policyType: \(Swift.String(describing: policyType)))"}
}

extension SsmClientTypes {
    /// One or more policies assigned to a parameter.
    public struct ParameterInlinePolicy: Swift.Equatable {
        /// The status of the policy. Policies report the following statuses: Pending (the policy hasn't been enforced or applied yet), Finished (the policy was applied), Failed (the policy wasn't applied), or InProgress (the policy is being applied now).
        public var policyStatus: Swift.String?
        /// The JSON text of the policy.
        public var policyText: Swift.String?
        /// The type of policy. Parameter Store, a capablility of Amazon Web Services Systems Manager, supports the following policy types: Expiration, ExpirationNotification, and NoChangeNotification.
        public var policyType: Swift.String?

        public init (
            policyStatus: Swift.String? = nil,
            policyText: Swift.String? = nil,
            policyType: Swift.String? = nil
        )
        {
            self.policyStatus = policyStatus
            self.policyText = policyText
            self.policyType = policyType
        }
    }

}

extension ParameterLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension ParameterLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the number of parameters for this Amazon Web Services account. Delete one or more parameters and try again.
public struct ParameterLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterMaxVersionLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterMaxVersionLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension ParameterMaxVersionLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterMaxVersionLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Parameter Store retains the 100 most recently created versions of a parameter. After this number of versions has been created, Parameter Store deletes the oldest version when a new one is created. However, if the oldest version has a label attached to it, Parameter Store won't delete the version and instead presents this error message: An error occurred (ParameterMaxVersionLimitExceeded) when calling the PutParameter operation: You attempted to create a new version of parameter-name by calling the PutParameter API with the overwrite flag. Version version-number, the oldest version, can't be deleted because it has a label associated with it. Move the label to another version of the parameter, and try again. This safeguard is to prevent parameter versions with mission critical labels assigned to them from being deleted. To continue creating new parameters, first move the label from the oldest version of the parameter to a newer one for use in your operations. For information about moving parameter labels, see [Move a parameter label (console)](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html#sysman-paramstore-labels-console-move) or [Move a parameter label (CLI)](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html#sysman-paramstore-labels-cli-move) in the Amazon Web Services Systems Manager User Guide.
public struct ParameterMaxVersionLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterMaxVersionLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterMaxVersionLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ParameterMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case name = "Name"
        case policies = "Policies"
        case tier = "Tier"
        case type = "Type"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for parameterpolicylist0 in policies {
                try policiesContainer.encode(parameterpolicylist0)
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterType.self, forKey: .type)
        type = typeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let tierDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterTier.self, forKey: .tier)
        tier = tierDecoded
        let policiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterInlinePolicy?].self, forKey: .policies)
        var policiesDecoded0:[SsmClientTypes.ParameterInlinePolicy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [SsmClientTypes.ParameterInlinePolicy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension SsmClientTypes.ParameterMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterMetadata(allowedPattern: \(Swift.String(describing: allowedPattern)), dataType: \(Swift.String(describing: dataType)), description: \(Swift.String(describing: description)), keyId: \(Swift.String(describing: keyId)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), lastModifiedUser: \(Swift.String(describing: lastModifiedUser)), name: \(Swift.String(describing: name)), policies: \(Swift.String(describing: policies)), tier: \(Swift.String(describing: tier)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)))"}
}

extension SsmClientTypes {
    /// Metadata includes information like the ARN of the last user and the date/time the parameter was last used.
    public struct ParameterMetadata: Swift.Equatable {
        /// A parameter name can include only the following letters and symbols. a-zA-Z0-9_.-
        public var allowedPattern: Swift.String?
        /// The data type of the parameter, such as text or aws:ec2:image. The default is text.
        public var dataType: Swift.String?
        /// Description of the parameter actions.
        public var description: Swift.String?
        /// The ID of the query key used for this parameter.
        public var keyId: Swift.String?
        /// Date the parameter was last changed or updated.
        public var lastModifiedDate: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of the Amazon Web Services user who last changed the parameter.
        public var lastModifiedUser: Swift.String?
        /// The parameter name.
        public var name: Swift.String?
        /// A list of policies associated with a parameter.
        public var policies: [SsmClientTypes.ParameterInlinePolicy]?
        /// The parameter tier.
        public var tier: SsmClientTypes.ParameterTier?
        /// The type of parameter. Valid parameter types include the following: String, StringList, and SecureString.
        public var type: SsmClientTypes.ParameterType?
        /// The parameter version.
        public var version: Swift.Int

        public init (
            allowedPattern: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            keyId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            name: Swift.String? = nil,
            policies: [SsmClientTypes.ParameterInlinePolicy]? = nil,
            tier: SsmClientTypes.ParameterTier? = nil,
            type: SsmClientTypes.ParameterType? = nil,
            version: Swift.Int = 0
        )
        {
            self.allowedPattern = allowedPattern
            self.dataType = dataType
            self.description = description
            self.keyId = keyId
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.name = name
            self.policies = policies
            self.tier = tier
            self.type = type
            self.version = version
        }
    }

}

extension ParameterNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterNotFound(message: \(Swift.String(describing: message)))"}
}

extension ParameterNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter couldn't be found. Verify the name and try again.
public struct ParameterNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterPatternMismatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterPatternMismatchException(message: \(Swift.String(describing: message)))"}
}

extension ParameterPatternMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterPatternMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter name isn't valid.
public struct ParameterPatternMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The parameter name isn't valid.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterPatternMismatchExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterPatternMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ParameterStringFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case option = "Option"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let option = option {
            try encodeContainer.encode(option, forKey: .option)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for parameterstringfiltervaluelist0 in values {
                try valuesContainer.encode(parameterstringfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let optionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .option)
        option = optionDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.ParameterStringFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterStringFilter(key: \(Swift.String(describing: key)), option: \(Swift.String(describing: option)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// One or more filters. Use a filter to return a more specific list of results.
    public struct ParameterStringFilter: Swift.Equatable {
        /// The name of the filter. The ParameterStringFilter object is used by the [DescribeParameters] and [GetParametersByPath] API operations. However, not all of the pattern values listed for Key can be used with both operations. For DescribeParameters, all of the listed patterns are valid except Label. For GetParametersByPath, the following patterns listed for Key aren't valid: tag, DataType, Name, Path, and Tier. For examples of Amazon Web Services CLI commands demonstrating valid parameter filter constructions, see [Searching for Systems Manager parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-search.html) in the Amazon Web Services Systems Manager User Guide.
        /// This member is required.
        public var key: Swift.String?
        /// For all filters used with [DescribeParameters], valid options include Equals and BeginsWith. The Name filter additionally supports the Contains option. (Exception: For filters using the key Path, valid options include Recursive and OneLevel.) For filters used with [GetParametersByPath], valid options include Equals and BeginsWith. (Exception: For filters using Label as the Key name, the only valid option is Equals.)
        public var option: Swift.String?
        /// The value you want to search for.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            option: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.option = option
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum ParameterTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case advanced
        case intelligentTiering
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterTier] {
            return [
                .advanced,
                .intelligentTiering,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .advanced: return "Advanced"
            case .intelligentTiering: return "Intelligent-Tiering"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterTier(rawValue: rawValue) ?? ParameterTier.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum ParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case secureString
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterType] {
            return [
                .secureString,
                .string,
                .stringList,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .secureString: return "SecureString"
            case .string: return "String"
            case .stringList: return "StringList"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterType(rawValue: rawValue) ?? ParameterType.sdkUnknown(rawValue)
        }
    }
}

extension ParameterVersionLabelLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterVersionLabelLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension ParameterVersionLabelLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterVersionLabelLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parameter version can have a maximum of ten labels.
public struct ParameterVersionLabelLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterVersionLabelLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterVersionLabelLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterVersionNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterVersionNotFound(message: \(Swift.String(describing: message)))"}
}

extension ParameterVersionNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterVersionNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter version wasn't found. Verify the parameter name and version, and try again.
public struct ParameterVersionNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterVersionNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterVersionNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ParametersFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for parametersfiltervaluelist0 in values {
                try valuesContainer.encode(parametersfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParametersFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.ParametersFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParametersFilter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// This data type is deprecated. Instead, use [ParameterStringFilter].
    public struct ParametersFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: SsmClientTypes.ParametersFilterKey?
        /// The filter values.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.ParametersFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum ParametersFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case keyId
        case name
        case type
        case sdkUnknown(Swift.String)

        public static var allCases: [ParametersFilterKey] {
            return [
                .keyId,
                .name,
                .type,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .keyId: return "KeyId"
            case .name: return "Name"
            case .type: return "Type"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParametersFilterKey(rawValue: rawValue) ?? ParametersFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.Patch: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advisoryIds = "AdvisoryIds"
        case arch = "Arch"
        case bugzillaIds = "BugzillaIds"
        case cVEIds = "CVEIds"
        case classification = "Classification"
        case contentUrl = "ContentUrl"
        case description = "Description"
        case epoch = "Epoch"
        case id = "Id"
        case kbNumber = "KbNumber"
        case language = "Language"
        case msrcNumber = "MsrcNumber"
        case msrcSeverity = "MsrcSeverity"
        case name = "Name"
        case product = "Product"
        case productFamily = "ProductFamily"
        case release = "Release"
        case releaseDate = "ReleaseDate"
        case repository = "Repository"
        case severity = "Severity"
        case title = "Title"
        case vendor = "Vendor"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advisoryIds = advisoryIds {
            var advisoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advisoryIds)
            for patchadvisoryidlist0 in advisoryIds {
                try advisoryIdsContainer.encode(patchadvisoryidlist0)
            }
        }
        if let arch = arch {
            try encodeContainer.encode(arch, forKey: .arch)
        }
        if let bugzillaIds = bugzillaIds {
            var bugzillaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bugzillaIds)
            for patchbugzillaidlist0 in bugzillaIds {
                try bugzillaIdsContainer.encode(patchbugzillaidlist0)
            }
        }
        if let cVEIds = cVEIds {
            var cVEIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cVEIds)
            for patchcveidlist0 in cVEIds {
                try cVEIdsContainer.encode(patchcveidlist0)
            }
        }
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let contentUrl = contentUrl {
            try encodeContainer.encode(contentUrl, forKey: .contentUrl)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if epoch != 0 {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kbNumber = kbNumber {
            try encodeContainer.encode(kbNumber, forKey: .kbNumber)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let msrcNumber = msrcNumber {
            try encodeContainer.encode(msrcNumber, forKey: .msrcNumber)
        }
        if let msrcSeverity = msrcSeverity {
            try encodeContainer.encode(msrcSeverity, forKey: .msrcSeverity)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let product = product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let productFamily = productFamily {
            try encodeContainer.encode(productFamily, forKey: .productFamily)
        }
        if let release = release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let releaseDate = releaseDate {
            try encodeContainer.encode(releaseDate.timeIntervalSince1970, forKey: .releaseDate)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let releaseDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentUrl)
        contentUrl = contentUrlDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let productFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productFamily)
        productFamily = productFamilyDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classification)
        classification = classificationDecoded
        let msrcSeverityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .msrcSeverity)
        msrcSeverity = msrcSeverityDecoded
        let kbNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kbNumber)
        kbNumber = kbNumberDecoded
        let msrcNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .msrcNumber)
        msrcNumber = msrcNumberDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let advisoryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .advisoryIds)
        var advisoryIdsDecoded0:[Swift.String]? = nil
        if let advisoryIdsContainer = advisoryIdsContainer {
            advisoryIdsDecoded0 = [Swift.String]()
            for string0 in advisoryIdsContainer {
                if let string0 = string0 {
                    advisoryIdsDecoded0?.append(string0)
                }
            }
        }
        advisoryIds = advisoryIdsDecoded0
        let bugzillaIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bugzillaIds)
        var bugzillaIdsDecoded0:[Swift.String]? = nil
        if let bugzillaIdsContainer = bugzillaIdsContainer {
            bugzillaIdsDecoded0 = [Swift.String]()
            for string0 in bugzillaIdsContainer {
                if let string0 = string0 {
                    bugzillaIdsDecoded0?.append(string0)
                }
            }
        }
        bugzillaIds = bugzillaIdsDecoded0
        let cVEIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cVEIds)
        var cVEIdsDecoded0:[Swift.String]? = nil
        if let cVEIdsContainer = cVEIdsContainer {
            cVEIdsDecoded0 = [Swift.String]()
            for string0 in cVEIdsContainer {
                if let string0 = string0 {
                    cVEIdsDecoded0?.append(string0)
                }
            }
        }
        cVEIds = cVEIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let epochDecoded = try containerValues.decode(Swift.Int.self, forKey: .epoch)
        epoch = epochDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .release)
        release = releaseDecoded
        let archDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arch)
        arch = archDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension SsmClientTypes.Patch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Patch(advisoryIds: \(Swift.String(describing: advisoryIds)), arch: \(Swift.String(describing: arch)), bugzillaIds: \(Swift.String(describing: bugzillaIds)), cVEIds: \(Swift.String(describing: cVEIds)), classification: \(Swift.String(describing: classification)), contentUrl: \(Swift.String(describing: contentUrl)), description: \(Swift.String(describing: description)), epoch: \(Swift.String(describing: epoch)), id: \(Swift.String(describing: id)), kbNumber: \(Swift.String(describing: kbNumber)), language: \(Swift.String(describing: language)), msrcNumber: \(Swift.String(describing: msrcNumber)), msrcSeverity: \(Swift.String(describing: msrcSeverity)), name: \(Swift.String(describing: name)), product: \(Swift.String(describing: product)), productFamily: \(Swift.String(describing: productFamily)), release: \(Swift.String(describing: release)), releaseDate: \(Swift.String(describing: releaseDate)), repository: \(Swift.String(describing: repository)), severity: \(Swift.String(describing: severity)), title: \(Swift.String(describing: title)), vendor: \(Swift.String(describing: vendor)), version: \(Swift.String(describing: version)))"}
}

extension SsmClientTypes {
    /// Represents metadata about a patch.
    public struct Patch: Swift.Equatable {
        /// The Advisory ID of the patch. For example, RHSA-2020:3779. Applies to Linux-based managed nodes only.
        public var advisoryIds: [Swift.String]?
        /// The architecture of the patch. For example, in example-pkg-0.710.10-2.7.abcd.x86_64, the architecture is indicated by x86_64. Applies to Linux-based managed nodes only.
        public var arch: Swift.String?
        /// The Bugzilla ID of the patch. For example, 1600646. Applies to Linux-based managed nodes only.
        public var bugzillaIds: [Swift.String]?
        /// The Common Vulnerabilities and Exposures (CVE) ID of the patch. For example, CVE-2011-3192. Applies to Linux-based managed nodes only.
        public var cVEIds: [Swift.String]?
        /// The classification of the patch. For example, SecurityUpdates, Updates, or CriticalUpdates.
        public var classification: Swift.String?
        /// The URL where more information can be obtained about the patch.
        public var contentUrl: Swift.String?
        /// The description of the patch.
        public var description: Swift.String?
        /// The epoch of the patch. For example in pkg-example-EE-20180914-2.2.amzn1.noarch, the epoch value is 20180914-2. Applies to Linux-based managed nodes only.
        public var epoch: Swift.Int
        /// The ID of the patch. Applies to Windows patches only. This ID isn't the same as the Microsoft Knowledge Base ID.
        public var id: Swift.String?
        /// The Microsoft Knowledge Base ID of the patch. Applies to Windows patches only.
        public var kbNumber: Swift.String?
        /// The language of the patch if it's language-specific.
        public var language: Swift.String?
        /// The ID of the Microsoft Security Response Center (MSRC) bulletin the patch is related to. For example, MS14-045. Applies to Windows patches only.
        public var msrcNumber: Swift.String?
        /// The severity of the patch, such as Critical, Important, or Moderate. Applies to Windows patches only.
        public var msrcSeverity: Swift.String?
        /// The name of the patch. Applies to Linux-based managed nodes only.
        public var name: Swift.String?
        /// The specific product the patch is applicable for. For example, WindowsServer2016 or AmazonLinux2018.03.
        public var product: Swift.String?
        /// The product family the patch is applicable for. For example, Windows or Amazon Linux 2.
        public var productFamily: Swift.String?
        /// The particular release of a patch. For example, in pkg-example-EE-20180914-2.2.amzn1.noarch, the release is 2.amaz1. Applies to Linux-based managed nodes only.
        public var release: Swift.String?
        /// The date the patch was released.
        public var releaseDate: ClientRuntime.Date?
        /// The source patch repository for the operating system and version, such as trusty-security for Ubuntu Server 14.04 LTE and focal-security for Ubuntu Server 20.04 LTE. Applies to Linux-based managed nodes only.
        public var repository: Swift.String?
        /// The severity level of the patch. For example, CRITICAL or MODERATE.
        public var severity: Swift.String?
        /// The title of the patch.
        public var title: Swift.String?
        /// The name of the vendor providing the patch.
        public var vendor: Swift.String?
        /// The version number of the patch. For example, in example-pkg-1.710.10-2.7.abcd.x86_64, the version number is indicated by -1. Applies to Linux-based managed nodes only.
        public var version: Swift.String?

        public init (
            advisoryIds: [Swift.String]? = nil,
            arch: Swift.String? = nil,
            bugzillaIds: [Swift.String]? = nil,
            cVEIds: [Swift.String]? = nil,
            classification: Swift.String? = nil,
            contentUrl: Swift.String? = nil,
            description: Swift.String? = nil,
            epoch: Swift.Int = 0,
            id: Swift.String? = nil,
            kbNumber: Swift.String? = nil,
            language: Swift.String? = nil,
            msrcNumber: Swift.String? = nil,
            msrcSeverity: Swift.String? = nil,
            name: Swift.String? = nil,
            product: Swift.String? = nil,
            productFamily: Swift.String? = nil,
            release: Swift.String? = nil,
            releaseDate: ClientRuntime.Date? = nil,
            repository: Swift.String? = nil,
            severity: Swift.String? = nil,
            title: Swift.String? = nil,
            vendor: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.advisoryIds = advisoryIds
            self.arch = arch
            self.bugzillaIds = bugzillaIds
            self.cVEIds = cVEIds
            self.classification = classification
            self.contentUrl = contentUrl
            self.description = description
            self.epoch = epoch
            self.id = id
            self.kbNumber = kbNumber
            self.language = language
            self.msrcNumber = msrcNumber
            self.msrcSeverity = msrcSeverity
            self.name = name
            self.product = product
            self.productFamily = productFamily
            self.release = release
            self.releaseDate = releaseDate
            self.repository = repository
            self.severity = severity
            self.title = title
            self.vendor = vendor
            self.version = version
        }
    }

}

extension SsmClientTypes {
    public enum PatchAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowasdependency
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchAction] {
            return [
                .allowasdependency,
                .block,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowasdependency: return "ALLOW_AS_DEPENDENCY"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchAction(rawValue: rawValue) ?? PatchAction.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchBaselineIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineDescription = "BaselineDescription"
        case baselineId = "BaselineId"
        case baselineName = "BaselineName"
        case defaultBaseline = "DefaultBaseline"
        case operatingSystem = "OperatingSystem"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineDescription = baselineDescription {
            try encodeContainer.encode(baselineDescription, forKey: .baselineDescription)
        }
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let baselineName = baselineName {
            try encodeContainer.encode(baselineName, forKey: .baselineName)
        }
        if defaultBaseline != false {
            try encodeContainer.encode(defaultBaseline, forKey: .defaultBaseline)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let baselineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineName)
        baselineName = baselineNameDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let baselineDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineDescription)
        baselineDescription = baselineDescriptionDecoded
        let defaultBaselineDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultBaseline)
        defaultBaseline = defaultBaselineDecoded
    }
}

extension SsmClientTypes.PatchBaselineIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchBaselineIdentity(baselineDescription: \(Swift.String(describing: baselineDescription)), baselineId: \(Swift.String(describing: baselineId)), baselineName: \(Swift.String(describing: baselineName)), defaultBaseline: \(Swift.String(describing: defaultBaseline)), operatingSystem: \(Swift.String(describing: operatingSystem)))"}
}

extension SsmClientTypes {
    /// Defines the basic information about a patch baseline.
    public struct PatchBaselineIdentity: Swift.Equatable {
        /// The description of the patch baseline.
        public var baselineDescription: Swift.String?
        /// The ID of the patch baseline.
        public var baselineId: Swift.String?
        /// The name of the patch baseline.
        public var baselineName: Swift.String?
        /// Whether this is the default baseline. Amazon Web Services Systems Manager supports creating multiple default patch baselines. For example, you can create a default patch baseline for each operating system.
        public var defaultBaseline: Swift.Bool
        /// Defines the operating system the patch baseline applies to. The default value is WINDOWS.
        public var operatingSystem: SsmClientTypes.OperatingSystem?

        public init (
            baselineDescription: Swift.String? = nil,
            baselineId: Swift.String? = nil,
            baselineName: Swift.String? = nil,
            defaultBaseline: Swift.Bool = false,
            operatingSystem: SsmClientTypes.OperatingSystem? = nil
        )
        {
            self.baselineDescription = baselineDescription
            self.baselineId = baselineId
            self.baselineName = baselineName
            self.defaultBaseline = defaultBaseline
            self.operatingSystem = operatingSystem
        }
    }

}

extension SsmClientTypes.PatchComplianceData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cVEIds = "CVEIds"
        case classification = "Classification"
        case installedTime = "InstalledTime"
        case kBId = "KBId"
        case severity = "Severity"
        case state = "State"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cVEIds = cVEIds {
            try encodeContainer.encode(cVEIds, forKey: .cVEIds)
        }
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let installedTime = installedTime {
            try encodeContainer.encode(installedTime.timeIntervalSince1970, forKey: .installedTime)
        }
        if let kBId = kBId {
            try encodeContainer.encode(kBId, forKey: .kBId)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let kBIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kBId)
        kBId = kBIdDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classification)
        classification = classificationDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceDataState.self, forKey: .state)
        state = stateDecoded
        let installedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .installedTime)
        installedTime = installedTimeDecoded
        let cVEIdsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cVEIds)
        cVEIds = cVEIdsDecoded
    }
}

extension SsmClientTypes.PatchComplianceData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchComplianceData(cVEIds: \(Swift.String(describing: cVEIds)), classification: \(Swift.String(describing: classification)), installedTime: \(Swift.String(describing: installedTime)), kBId: \(Swift.String(describing: kBId)), severity: \(Swift.String(describing: severity)), state: \(Swift.String(describing: state)), title: \(Swift.String(describing: title)))"}
}

extension SsmClientTypes {
    /// Information about the state of a patch on a particular managed node as it relates to the patch baseline used to patch the node.
    public struct PatchComplianceData: Swift.Equatable {
        /// The IDs of one or more Common Vulnerabilities and Exposure (CVE) issues that are resolved by the patch.
        public var cVEIds: Swift.String?
        /// The classification of the patch, such as SecurityUpdates, Updates, and CriticalUpdates.
        /// This member is required.
        public var classification: Swift.String?
        /// The date/time the patch was installed on the managed node. Not all operating systems provide this level of information.
        /// This member is required.
        public var installedTime: ClientRuntime.Date?
        /// The operating system-specific ID of the patch.
        /// This member is required.
        public var kBId: Swift.String?
        /// The severity of the patchsuch as Critical, Important, and Moderate.
        /// This member is required.
        public var severity: Swift.String?
        /// The state of the patch on the managed node, such as INSTALLED or FAILED. For descriptions of each patch state, see [About patch compliance](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-compliance-about.html#sysman-compliance-monitor-patch) in the Amazon Web Services Systems Manager User Guide.
        /// This member is required.
        public var state: SsmClientTypes.PatchComplianceDataState?
        /// The title of the patch.
        /// This member is required.
        public var title: Swift.String?

        public init (
            cVEIds: Swift.String? = nil,
            classification: Swift.String? = nil,
            installedTime: ClientRuntime.Date? = nil,
            kBId: Swift.String? = nil,
            severity: Swift.String? = nil,
            state: SsmClientTypes.PatchComplianceDataState? = nil,
            title: Swift.String? = nil
        )
        {
            self.cVEIds = cVEIds
            self.classification = classification
            self.installedTime = installedTime
            self.kBId = kBId
            self.severity = severity
            self.state = state
            self.title = title
        }
    }

}

extension SsmClientTypes {
    public enum PatchComplianceDataState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case installed
        case installedother
        case installedpendingreboot
        case installedrejected
        case missing
        case notapplicable
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchComplianceDataState] {
            return [
                .failed,
                .installed,
                .installedother,
                .installedpendingreboot,
                .installedrejected,
                .missing,
                .notapplicable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .installed: return "INSTALLED"
            case .installedother: return "INSTALLED_OTHER"
            case .installedpendingreboot: return "INSTALLED_PENDING_REBOOT"
            case .installedrejected: return "INSTALLED_REJECTED"
            case .missing: return "MISSING"
            case .notapplicable: return "NOT_APPLICABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchComplianceDataState(rawValue: rawValue) ?? PatchComplianceDataState.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum PatchComplianceLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchComplianceLevel] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .unspecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchComplianceLevel(rawValue: rawValue) ?? PatchComplianceLevel.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum PatchDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case explicitapproved
        case explicitrejected
        case pendingapproval
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchDeploymentStatus] {
            return [
                .approved,
                .explicitapproved,
                .explicitrejected,
                .pendingapproval,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .explicitapproved: return "EXPLICIT_APPROVED"
            case .explicitrejected: return "EXPLICIT_REJECTED"
            case .pendingapproval: return "PENDING_APPROVAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchDeploymentStatus(rawValue: rawValue) ?? PatchDeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for patchfiltervaluelist0 in values {
                try valuesContainer.encode(patchfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.PatchFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchFilter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// Defines which patches should be included in a patch baseline. A patch filter consists of a key and a set of values. The filter key is a patch property. For example, the available filter keys for WINDOWS are PATCH_SET, PRODUCT, PRODUCT_FAMILY, CLASSIFICATION, and MSRC_SEVERITY. The filter values define a matching criterion for the patch property indicated by the key. For example, if the filter key is PRODUCT and the filter values are ["Office 2013", "Office 2016"], then the filter accepts all patches where product name is either "Office 2013" or "Office 2016". The filter values can be exact values for the patch property given as a key, or a wildcard (*), which matches all values. You can view lists of valid values for the patch properties by running the DescribePatchProperties command. For information about which patch properties can be used with each major operating system, see [DescribePatchProperties].
    public struct PatchFilter: Swift.Equatable {
        /// The key for the filter. Run the [DescribePatchProperties] command to view lists of valid keys for each operating system type.
        /// This member is required.
        public var key: SsmClientTypes.PatchFilterKey?
        /// The value for the filter key. Run the [DescribePatchProperties] command to view lists of valid values for each key based on operating system type.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.PatchFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes.PatchFilterGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchFilters = "PatchFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchFilters = patchFilters {
            var patchFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchFilters)
            for patchfilterlist0 in patchFilters {
                try patchFiltersContainer.encode(patchfilterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchFiltersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchFilter?].self, forKey: .patchFilters)
        var patchFiltersDecoded0:[SsmClientTypes.PatchFilter]? = nil
        if let patchFiltersContainer = patchFiltersContainer {
            patchFiltersDecoded0 = [SsmClientTypes.PatchFilter]()
            for structure0 in patchFiltersContainer {
                if let structure0 = structure0 {
                    patchFiltersDecoded0?.append(structure0)
                }
            }
        }
        patchFilters = patchFiltersDecoded0
    }
}

extension SsmClientTypes.PatchFilterGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchFilterGroup(patchFilters: \(Swift.String(describing: patchFilters)))"}
}

extension SsmClientTypes {
    /// A set of patch filters, typically used for approval rules.
    public struct PatchFilterGroup: Swift.Equatable {
        /// The set of patch filters that make up the group.
        /// This member is required.
        public var patchFilters: [SsmClientTypes.PatchFilter]?

        public init (
            patchFilters: [SsmClientTypes.PatchFilter]? = nil
        )
        {
            self.patchFilters = patchFilters
        }
    }

}

extension SsmClientTypes {
    public enum PatchFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case advisoryid
        case arch
        case bugzillaid
        case cveid
        case classification
        case epoch
        case msrcseverity
        case name
        case patchid
        case patchset
        case priority
        case product
        case productfamily
        case release
        case repository
        case section
        case security
        case severity
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchFilterKey] {
            return [
                .advisoryid,
                .arch,
                .bugzillaid,
                .cveid,
                .classification,
                .epoch,
                .msrcseverity,
                .name,
                .patchid,
                .patchset,
                .priority,
                .product,
                .productfamily,
                .release,
                .repository,
                .section,
                .security,
                .severity,
                .version,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .advisoryid: return "ADVISORY_ID"
            case .arch: return "ARCH"
            case .bugzillaid: return "BUGZILLA_ID"
            case .cveid: return "CVE_ID"
            case .classification: return "CLASSIFICATION"
            case .epoch: return "EPOCH"
            case .msrcseverity: return "MSRC_SEVERITY"
            case .name: return "NAME"
            case .patchid: return "PATCH_ID"
            case .patchset: return "PATCH_SET"
            case .priority: return "PRIORITY"
            case .product: return "PRODUCT"
            case .productfamily: return "PRODUCT_FAMILY"
            case .release: return "RELEASE"
            case .repository: return "REPOSITORY"
            case .section: return "SECTION"
            case .security: return "SECURITY"
            case .severity: return "SEVERITY"
            case .version: return "VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchFilterKey(rawValue: rawValue) ?? PatchFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchGroupPatchBaselineMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineIdentity = "BaselineIdentity"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineIdentity = baselineIdentity {
            try encodeContainer.encode(baselineIdentity, forKey: .baselineIdentity)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let baselineIdentityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchBaselineIdentity.self, forKey: .baselineIdentity)
        baselineIdentity = baselineIdentityDecoded
    }
}

extension SsmClientTypes.PatchGroupPatchBaselineMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchGroupPatchBaselineMapping(baselineIdentity: \(Swift.String(describing: baselineIdentity)), patchGroup: \(Swift.String(describing: patchGroup)))"}
}

extension SsmClientTypes {
    /// The mapping between a patch group and the patch baseline the patch group is registered with.
    public struct PatchGroupPatchBaselineMapping: Swift.Equatable {
        /// The patch baseline the patch group is registered with.
        public var baselineIdentity: SsmClientTypes.PatchBaselineIdentity?
        /// The name of the patch group registered with the patch baseline.
        public var patchGroup: Swift.String?

        public init (
            baselineIdentity: SsmClientTypes.PatchBaselineIdentity? = nil,
            patchGroup: Swift.String? = nil
        )
        {
            self.baselineIdentity = baselineIdentity
            self.patchGroup = patchGroup
        }
    }

}

extension SsmClientTypes {
    public enum PatchOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case install
        case scan
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchOperationType] {
            return [
                .install,
                .scan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .install: return "Install"
            case .scan: return "Scan"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchOperationType(rawValue: rawValue) ?? PatchOperationType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchOrchestratorFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for patchorchestratorfiltervalues0 in values {
                try valuesContainer.encode(patchorchestratorfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.PatchOrchestratorFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchOrchestratorFilter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// Defines a filter used in Patch Manager APIs. Supported filter keys depend on the API operation that includes the filter. Patch Manager API operations that use PatchOrchestratorFilter include the following:
    ///
    /// * [DescribeAvailablePatches]
    ///
    /// * [DescribeInstancePatches]
    ///
    /// * [DescribePatchBaselines]
    ///
    /// * [DescribePatchGroups]
    public struct PatchOrchestratorFilter: Swift.Equatable {
        /// The key for the filter.
        public var key: Swift.String?
        /// The value for the filter.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum PatchProperty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case patchclassification
        case patchmsrcseverity
        case patchpriority
        case patchproductfamily
        case patchseverity
        case product
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchProperty] {
            return [
                .patchclassification,
                .patchmsrcseverity,
                .patchpriority,
                .patchproductfamily,
                .patchseverity,
                .product,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .patchclassification: return "CLASSIFICATION"
            case .patchmsrcseverity: return "MSRC_SEVERITY"
            case .patchpriority: return "PRIORITY"
            case .patchproductfamily: return "PRODUCT_FAMILY"
            case .patchseverity: return "SEVERITY"
            case .product: return "PRODUCT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchProperty(rawValue: rawValue) ?? PatchProperty.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approveAfterDays = "ApproveAfterDays"
        case approveUntilDate = "ApproveUntilDate"
        case complianceLevel = "ComplianceLevel"
        case enableNonSecurity = "EnableNonSecurity"
        case patchFilterGroup = "PatchFilterGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if approveAfterDays != 0 {
            try encodeContainer.encode(approveAfterDays, forKey: .approveAfterDays)
        }
        if let approveUntilDate = approveUntilDate {
            try encodeContainer.encode(approveUntilDate, forKey: .approveUntilDate)
        }
        if let complianceLevel = complianceLevel {
            try encodeContainer.encode(complianceLevel.rawValue, forKey: .complianceLevel)
        }
        if enableNonSecurity != false {
            try encodeContainer.encode(enableNonSecurity, forKey: .enableNonSecurity)
        }
        if let patchFilterGroup = patchFilterGroup {
            try encodeContainer.encode(patchFilterGroup, forKey: .patchFilterGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchFilterGroupDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .patchFilterGroup)
        patchFilterGroup = patchFilterGroupDecoded
        let complianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .complianceLevel)
        complianceLevel = complianceLevelDecoded
        let approveAfterDaysDecoded = try containerValues.decode(Swift.Int.self, forKey: .approveAfterDays)
        approveAfterDays = approveAfterDaysDecoded
        let approveUntilDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approveUntilDate)
        approveUntilDate = approveUntilDateDecoded
        let enableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableNonSecurity)
        enableNonSecurity = enableNonSecurityDecoded
    }
}

extension SsmClientTypes.PatchRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchRule(approveAfterDays: \(Swift.String(describing: approveAfterDays)), approveUntilDate: \(Swift.String(describing: approveUntilDate)), complianceLevel: \(Swift.String(describing: complianceLevel)), enableNonSecurity: \(Swift.String(describing: enableNonSecurity)), patchFilterGroup: \(Swift.String(describing: patchFilterGroup)))"}
}

extension SsmClientTypes {
    /// Defines an approval rule for a patch baseline.
    public struct PatchRule: Swift.Equatable {
        /// The number of days after the release date of each patch matched by the rule that the patch is marked as approved in the patch baseline. For example, a value of 7 means that patches are approved seven days after they are released. Not supported on Debian Server or Ubuntu Server.
        public var approveAfterDays: Swift.Int
        /// The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Not supported on Debian Server or Ubuntu Server. Enter dates in the format YYYY-MM-DD. For example, 2021-12-31.
        public var approveUntilDate: Swift.String?
        /// A compliance severity level for all approved patches in a patch baseline.
        public var complianceLevel: SsmClientTypes.PatchComplianceLevel?
        /// For managed nodes identified by the approval rule filters, enables a patch baseline to apply non-security updates available in the specified repository. The default value is false. Applies to Linux managed nodes only.
        public var enableNonSecurity: Swift.Bool
        /// The patch filter group that defines the criteria for the rule.
        /// This member is required.
        public var patchFilterGroup: SsmClientTypes.PatchFilterGroup?

        public init (
            approveAfterDays: Swift.Int = 0,
            approveUntilDate: Swift.String? = nil,
            complianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
            enableNonSecurity: Swift.Bool = false,
            patchFilterGroup: SsmClientTypes.PatchFilterGroup? = nil
        )
        {
            self.approveAfterDays = approveAfterDays
            self.approveUntilDate = approveUntilDate
            self.complianceLevel = complianceLevel
            self.enableNonSecurity = enableNonSecurity
            self.patchFilterGroup = patchFilterGroup
        }
    }

}

extension SsmClientTypes.PatchRuleGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchRules = "PatchRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchRules = patchRules {
            var patchRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchRules)
            for patchrulelist0 in patchRules {
                try patchRulesContainer.encode(patchrulelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchRulesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchRule?].self, forKey: .patchRules)
        var patchRulesDecoded0:[SsmClientTypes.PatchRule]? = nil
        if let patchRulesContainer = patchRulesContainer {
            patchRulesDecoded0 = [SsmClientTypes.PatchRule]()
            for structure0 in patchRulesContainer {
                if let structure0 = structure0 {
                    patchRulesDecoded0?.append(structure0)
                }
            }
        }
        patchRules = patchRulesDecoded0
    }
}

extension SsmClientTypes.PatchRuleGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchRuleGroup(patchRules: \(Swift.String(describing: patchRules)))"}
}

extension SsmClientTypes {
    /// A set of rules defining the approval rules for a patch baseline.
    public struct PatchRuleGroup: Swift.Equatable {
        /// The rules that make up the rule group.
        /// This member is required.
        public var patchRules: [SsmClientTypes.PatchRule]?

        public init (
            patchRules: [SsmClientTypes.PatchRule]? = nil
        )
        {
            self.patchRules = patchRules
        }
    }

}

extension SsmClientTypes {
    public enum PatchSet: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case os
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchSet] {
            return [
                .application,
                .os,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .os: return "OS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchSet(rawValue: rawValue) ?? PatchSet.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case name = "Name"
        case products = "Products"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let products = products {
            var productsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .products)
            for patchsourceproductlist0 in products {
                try productsContainer.encode(patchsourceproductlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let productsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .products)
        var productsDecoded0:[Swift.String]? = nil
        if let productsContainer = productsContainer {
            productsDecoded0 = [Swift.String]()
            for string0 in productsContainer {
                if let string0 = string0 {
                    productsDecoded0?.append(string0)
                }
            }
        }
        products = productsDecoded0
        let configurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension SsmClientTypes.PatchSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchSource(configuration: \(Swift.String(describing: configuration)), name: \(Swift.String(describing: name)), products: \(Swift.String(describing: products)))"}
}

extension SsmClientTypes {
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repository. Applies to Linux managed nodes only.
    public struct PatchSource: Swift.Equatable {
        /// The value of the yum repo configuration. For example: [main]
        ///     name=MyCustomRepository
        ///
        ///
        ///     baseurl=https://my-custom-repository
        ///
        /// enabled=1 For information about other options available for your yum repository configuration, see [dnf.conf(5)](https://man7.org/linux/man-pages/man5/dnf.conf.5.html).
        /// This member is required.
        public var configuration: Swift.String?
        /// The name specified to identify the patch source.
        /// This member is required.
        public var name: Swift.String?
        /// The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "AmazonLinux2016.09", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see [PatchFilter].
        /// This member is required.
        public var products: [Swift.String]?

        public init (
            configuration: Swift.String? = nil,
            name: Swift.String? = nil,
            products: [Swift.String]? = nil
        )
        {
            self.configuration = configuration
            self.name = name
            self.products = products
        }
    }

}

extension SsmClientTypes.PatchStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalDate = "ApprovalDate"
        case complianceLevel = "ComplianceLevel"
        case deploymentStatus = "DeploymentStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalDate = approvalDate {
            try encodeContainer.encode(approvalDate.timeIntervalSince1970, forKey: .approvalDate)
        }
        if let complianceLevel = complianceLevel {
            try encodeContainer.encode(complianceLevel.rawValue, forKey: .complianceLevel)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchDeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let complianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .complianceLevel)
        complianceLevel = complianceLevelDecoded
        let approvalDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .approvalDate)
        approvalDate = approvalDateDecoded
    }
}

extension SsmClientTypes.PatchStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchStatus(approvalDate: \(Swift.String(describing: approvalDate)), complianceLevel: \(Swift.String(describing: complianceLevel)), deploymentStatus: \(Swift.String(describing: deploymentStatus)))"}
}

extension SsmClientTypes {
    /// Information about the approval status of a patch.
    public struct PatchStatus: Swift.Equatable {
        /// The date the patch was approved (or will be approved if the status is PENDING_APPROVAL).
        public var approvalDate: ClientRuntime.Date?
        /// The compliance severity level for a patch.
        public var complianceLevel: SsmClientTypes.PatchComplianceLevel?
        /// The approval status of a patch.
        public var deploymentStatus: SsmClientTypes.PatchDeploymentStatus?

        public init (
            approvalDate: ClientRuntime.Date? = nil,
            complianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
            deploymentStatus: SsmClientTypes.PatchDeploymentStatus? = nil
        )
        {
            self.approvalDate = approvalDate
            self.complianceLevel = complianceLevel
            self.deploymentStatus = deploymentStatus
        }
    }

}

extension SsmClientTypes {
    public enum PingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectionLost
        case inactive
        case online
        case sdkUnknown(Swift.String)

        public static var allCases: [PingStatus] {
            return [
                .connectionLost,
                .inactive,
                .online,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectionLost: return "ConnectionLost"
            case .inactive: return "Inactive"
            case .online: return "Online"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PingStatus(rawValue: rawValue) ?? PingStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum PlatformType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case macos
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformType] {
            return [
                .linux,
                .macos,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "Linux"
            case .macos: return "MacOS"
            case .windows: return "Windows"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlatformType(rawValue: rawValue) ?? PlatformType.sdkUnknown(rawValue)
        }
    }
}

extension PoliciesLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PoliciesLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension PoliciesLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PoliciesLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You specified more than the maximum number of allowed policies for the parameter. The maximum is 10.
public struct PoliciesLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PoliciesLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PoliciesLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ProgressCounters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancelledSteps = "CancelledSteps"
        case failedSteps = "FailedSteps"
        case successSteps = "SuccessSteps"
        case timedOutSteps = "TimedOutSteps"
        case totalSteps = "TotalSteps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cancelledSteps != 0 {
            try encodeContainer.encode(cancelledSteps, forKey: .cancelledSteps)
        }
        if failedSteps != 0 {
            try encodeContainer.encode(failedSteps, forKey: .failedSteps)
        }
        if successSteps != 0 {
            try encodeContainer.encode(successSteps, forKey: .successSteps)
        }
        if timedOutSteps != 0 {
            try encodeContainer.encode(timedOutSteps, forKey: .timedOutSteps)
        }
        if totalSteps != 0 {
            try encodeContainer.encode(totalSteps, forKey: .totalSteps)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalStepsDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalSteps)
        totalSteps = totalStepsDecoded
        let successStepsDecoded = try containerValues.decode(Swift.Int.self, forKey: .successSteps)
        successSteps = successStepsDecoded
        let failedStepsDecoded = try containerValues.decode(Swift.Int.self, forKey: .failedSteps)
        failedSteps = failedStepsDecoded
        let cancelledStepsDecoded = try containerValues.decode(Swift.Int.self, forKey: .cancelledSteps)
        cancelledSteps = cancelledStepsDecoded
        let timedOutStepsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timedOutSteps)
        timedOutSteps = timedOutStepsDecoded
    }
}

extension SsmClientTypes.ProgressCounters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProgressCounters(cancelledSteps: \(Swift.String(describing: cancelledSteps)), failedSteps: \(Swift.String(describing: failedSteps)), successSteps: \(Swift.String(describing: successSteps)), timedOutSteps: \(Swift.String(describing: timedOutSteps)), totalSteps: \(Swift.String(describing: totalSteps)))"}
}

extension SsmClientTypes {
    /// An aggregate of step execution statuses displayed in the Amazon Web Services Systems Manager console for a multi-Region and multi-account Automation execution.
    public struct ProgressCounters: Swift.Equatable {
        /// The total number of steps that the system cancelled in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var cancelledSteps: Swift.Int
        /// The total number of steps that failed to run in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var failedSteps: Swift.Int
        /// The total number of steps that successfully completed in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var successSteps: Swift.Int
        /// The total number of steps that timed out in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var timedOutSteps: Swift.Int
        /// The total number of steps run in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var totalSteps: Swift.Int

        public init (
            cancelledSteps: Swift.Int = 0,
            failedSteps: Swift.Int = 0,
            successSteps: Swift.Int = 0,
            timedOutSteps: Swift.Int = 0,
            totalSteps: Swift.Int = 0
        )
        {
            self.cancelledSteps = cancelledSteps
            self.failedSteps = failedSteps
            self.successSteps = successSteps
            self.timedOutSteps = timedOutSteps
            self.totalSteps = totalSteps
        }
    }

}

public struct PutComplianceItemsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutComplianceItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutComplianceItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutComplianceItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutComplianceItemsOutputError>
}

extension PutComplianceItemsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutComplianceItemsInput(complianceType: \(Swift.String(describing: complianceType)), executionSummary: \(Swift.String(describing: executionSummary)), itemContentHash: \(Swift.String(describing: itemContentHash)), items: \(Swift.String(describing: items)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), uploadType: \(Swift.String(describing: uploadType)))"}
}

extension PutComplianceItemsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case executionSummary = "ExecutionSummary"
        case itemContentHash = "ItemContentHash"
        case items = "Items"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case uploadType = "UploadType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let itemContentHash = itemContentHash {
            try encodeContainer.encode(itemContentHash, forKey: .itemContentHash)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for complianceitementrylist0 in items {
                try itemsContainer.encode(complianceitementrylist0)
            }
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let uploadType = uploadType {
            try encodeContainer.encode(uploadType.rawValue, forKey: .uploadType)
        }
    }
}

public struct PutComplianceItemsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutComplianceItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutComplianceItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutComplianceItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutComplianceItemsOutputError>
}

public struct PutComplianceItemsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutComplianceItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutComplianceItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutComplianceItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutComplianceItemsOutputError>
}

public struct PutComplianceItemsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutComplianceItemsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutComplianceItemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutComplianceItemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutComplianceItemsOutputError>
}

public struct PutComplianceItemsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutComplianceItemsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutComplianceItemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutComplianceItemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutComplianceItemsOutputError>
}

public struct PutComplianceItemsInput: Swift.Equatable {
    /// Specify the compliance type. For example, specify Association (for a State Manager association), Patch, or Custom:string.
    /// This member is required.
    public var complianceType: Swift.String?
    /// A summary of the call execution that includes an execution ID, the type of execution (for example, Command), and the date/time of the execution using a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.
    /// This member is required.
    public var executionSummary: SsmClientTypes.ComplianceExecutionSummary?
    /// MD5 or SHA-256 content hash. The content hash is used to determine if existing information should be overwritten or ignored. If the content hashes match, the request to put compliance information is ignored.
    public var itemContentHash: Swift.String?
    /// Information about the compliance as defined by the resource type. For example, for a patch compliance type, Items includes information about the PatchSeverity, Classification, and so on.
    /// This member is required.
    public var items: [SsmClientTypes.ComplianceItemEntry]?
    /// Specify an ID for this resource. For a managed node, this is the node ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specify the type of resource. ManagedInstance is currently the only supported resource type.
    /// This member is required.
    public var resourceType: Swift.String?
    /// The mode for uploading compliance items. You can specify COMPLETE or PARTIAL. In COMPLETE mode, the system overwrites all existing compliance information for the resource. You must provide a full list of compliance items each time you send the request. In PARTIAL mode, the system overwrites compliance information for a specific association. The association must be configured with SyncCompliance set to MANUAL. By default, all requests use COMPLETE mode. This attribute is only valid for association compliance.
    public var uploadType: SsmClientTypes.ComplianceUploadType?

    public init (
        complianceType: Swift.String? = nil,
        executionSummary: SsmClientTypes.ComplianceExecutionSummary? = nil,
        itemContentHash: Swift.String? = nil,
        items: [SsmClientTypes.ComplianceItemEntry]? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        uploadType: SsmClientTypes.ComplianceUploadType? = nil
    )
    {
        self.complianceType = complianceType
        self.executionSummary = executionSummary
        self.itemContentHash = itemContentHash
        self.items = items
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.uploadType = uploadType
    }
}

struct PutComplianceItemsInputBody: Swift.Equatable {
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
    public let complianceType: Swift.String?
    public let executionSummary: SsmClientTypes.ComplianceExecutionSummary?
    public let items: [SsmClientTypes.ComplianceItemEntry]?
    public let itemContentHash: Swift.String?
    public let uploadType: SsmClientTypes.ComplianceUploadType?
}

extension PutComplianceItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case executionSummary = "ExecutionSummary"
        case itemContentHash = "ItemContentHash"
        case items = "Items"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case uploadType = "UploadType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceExecutionSummary.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let itemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceItemEntry?].self, forKey: .items)
        var itemsDecoded0:[SsmClientTypes.ComplianceItemEntry]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SsmClientTypes.ComplianceItemEntry]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let itemContentHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemContentHash)
        itemContentHash = itemContentHashDecoded
        let uploadTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceUploadType.self, forKey: .uploadType)
        uploadType = uploadTypeDecoded
    }
}

extension PutComplianceItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutComplianceItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ComplianceTypeCountLimitExceeded" : self = .complianceTypeCountLimitExceededException(try ComplianceTypeCountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidItemContent" : self = .invalidItemContentException(try InvalidItemContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ItemSizeLimitExceeded" : self = .itemSizeLimitExceededException(try ItemSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TotalSizeLimitExceeded" : self = .totalSizeLimitExceededException(try TotalSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutComplianceItemsOutputError: Swift.Error, Swift.Equatable {
    case complianceTypeCountLimitExceededException(ComplianceTypeCountLimitExceededException)
    case internalServerError(InternalServerError)
    case invalidItemContentException(InvalidItemContentException)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case itemSizeLimitExceededException(ItemSizeLimitExceededException)
    case totalSizeLimitExceededException(TotalSizeLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutComplianceItemsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutComplianceItemsOutputResponse()"}
}

extension PutComplianceItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutComplianceItemsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutComplianceItemsOutputResponseBody: Swift.Equatable {
}

extension PutComplianceItemsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutInventoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutInventoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutInventoryOutputError>
}

extension PutInventoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutInventoryInput(instanceId: \(Swift.String(describing: instanceId)), items: \(Swift.String(describing: items)))"}
}

extension PutInventoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for inventoryitemlist0 in items {
                try itemsContainer.encode(inventoryitemlist0)
            }
        }
    }
}

public struct PutInventoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutInventoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutInventoryOutputError>
}

public struct PutInventoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutInventoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutInventoryOutputError>
}

public struct PutInventoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutInventoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutInventoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutInventoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutInventoryOutputError>
}

public struct PutInventoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutInventoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutInventoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutInventoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutInventoryOutputError>
}

public struct PutInventoryInput: Swift.Equatable {
    /// An managed node ID where you want to add or update inventory items.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The inventory items that you want to add or update on managed nodes.
    /// This member is required.
    public var items: [SsmClientTypes.InventoryItem]?

    public init (
        instanceId: Swift.String? = nil,
        items: [SsmClientTypes.InventoryItem]? = nil
    )
    {
        self.instanceId = instanceId
        self.items = items
    }
}

struct PutInventoryInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let items: [SsmClientTypes.InventoryItem]?
}

extension PutInventoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case items = "Items"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let itemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryItem?].self, forKey: .items)
        var itemsDecoded0:[SsmClientTypes.InventoryItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SsmClientTypes.InventoryItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension PutInventoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInventoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomSchemaCountLimitExceeded" : self = .customSchemaCountLimitExceededException(try CustomSchemaCountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInventoryItemContext" : self = .invalidInventoryItemContextException(try InvalidInventoryItemContextException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidItemContent" : self = .invalidItemContentException(try InvalidItemContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ItemContentMismatch" : self = .itemContentMismatchException(try ItemContentMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ItemSizeLimitExceeded" : self = .itemSizeLimitExceededException(try ItemSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubTypeCountLimitExceeded" : self = .subTypeCountLimitExceededException(try SubTypeCountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TotalSizeLimitExceeded" : self = .totalSizeLimitExceededException(try TotalSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedInventoryItemContext" : self = .unsupportedInventoryItemContextException(try UnsupportedInventoryItemContextException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedInventorySchemaVersion" : self = .unsupportedInventorySchemaVersionException(try UnsupportedInventorySchemaVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutInventoryOutputError: Swift.Error, Swift.Equatable {
    case customSchemaCountLimitExceededException(CustomSchemaCountLimitExceededException)
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case invalidInventoryItemContextException(InvalidInventoryItemContextException)
    case invalidItemContentException(InvalidItemContentException)
    case invalidTypeNameException(InvalidTypeNameException)
    case itemContentMismatchException(ItemContentMismatchException)
    case itemSizeLimitExceededException(ItemSizeLimitExceededException)
    case subTypeCountLimitExceededException(SubTypeCountLimitExceededException)
    case totalSizeLimitExceededException(TotalSizeLimitExceededException)
    case unsupportedInventoryItemContextException(UnsupportedInventoryItemContextException)
    case unsupportedInventorySchemaVersionException(UnsupportedInventorySchemaVersionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInventoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutInventoryOutputResponse(message: \(Swift.String(describing: message)))"}
}

extension PutInventoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutInventoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct PutInventoryOutputResponse: Swift.Equatable {
    /// Information about the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PutInventoryOutputResponseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PutInventoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutParameterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutParameterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutParameterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutParameterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutParameterOutputError>
}

extension PutParameterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutParameterInput(allowedPattern: \(Swift.String(describing: allowedPattern)), dataType: \(Swift.String(describing: dataType)), description: \(Swift.String(describing: description)), keyId: \(Swift.String(describing: keyId)), name: \(Swift.String(describing: name)), overwrite: \(Swift.String(describing: overwrite)), policies: \(Swift.String(describing: policies)), tags: \(Swift.String(describing: tags)), tier: \(Swift.String(describing: tier)), type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension PutParameterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case name = "Name"
        case overwrite = "Overwrite"
        case policies = "Policies"
        case tags = "Tags"
        case tier = "Tier"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if overwrite != false {
            try encodeContainer.encode(overwrite, forKey: .overwrite)
        }
        if let policies = policies {
            try encodeContainer.encode(policies, forKey: .policies)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

public struct PutParameterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutParameterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutParameterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutParameterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutParameterOutputError>
}

public struct PutParameterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutParameterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutParameterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutParameterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutParameterOutputError>
}

public struct PutParameterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutParameterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutParameterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutParameterInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutParameterOutputError>
}

public struct PutParameterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutParameterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutParameterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutParameterInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutParameterOutputError>
}

public struct PutParameterInput: Swift.Equatable {
    /// A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: AllowedPattern=^\d+$
    public var allowedPattern: Swift.String?
    /// The data type for a String parameter. Supported data types include plain text and Amazon Machine Image (AMI) IDs. The following data type values are supported.
    ///
    /// * text
    ///
    /// * aws:ec2:image
    ///
    ///
    /// When you create a String parameter and specify aws:ec2:image, Amazon Web Services Systems Manager validates the parameter value is in the required format, such as ami-12345abcdeEXAMPLE, and that the specified AMI is available in your Amazon Web Services account. For more information, see [Native parameter support for Amazon Machine Image (AMI) IDs](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-ec2-aliases.html) in the Amazon Web Services Systems Manager User Guide.
    public var dataType: Swift.String?
    /// Information about the parameter that you want to add to the system. Optional but recommended. Don't enter personally identifiable information in this field.
    public var description: Swift.String?
    /// The Key Management Service (KMS) ID that you want to use to encrypt a parameter. Either the default KMS key automatically assigned to your Amazon Web Services account or a custom key. Required for parameters that use the SecureString data type. If you don't specify a key ID, the system uses the default key associated with your Amazon Web Services account.
    ///
    /// * To use your default KMS key, choose the SecureString data type, and do not specify the Key ID when you create the parameter. The system automatically populates Key ID with your default KMS key.
    ///
    /// * To use a custom KMS key, choose the SecureString data type with the Key ID parameter.
    public var keyId: Swift.String?
    /// The fully qualified name of the parameter that you want to add to the system. The fully qualified name includes the complete hierarchy of the parameter path and name. For parameters in a hierarchy, you must include a leading forward slash character (/) when you create or reference a parameter. For example: /Dev/DBServer/MySQL/db-string13 Naming Constraints:
    ///
    /// * Parameter names are case sensitive.
    ///
    /// * A parameter name must be unique within an Amazon Web Services Region
    ///
    /// * A parameter name can't be prefixed with "aws" or "ssm" (case-insensitive).
    ///
    /// * Parameter names can include only the following symbols and letters: a-zA-Z0-9_.- In addition, the slash character ( / ) is used to delineate hierarchies in parameter names. For example: /Dev/Production/East/Project-ABC/MyParameter
    ///
    /// * A parameter name can't include spaces.
    ///
    /// * Parameter hierarchies are limited to a maximum depth of fifteen levels.
    ///
    ///
    /// For additional information about valid values for parameter names, see [Creating Systems Manager parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-su-create.html) in the Amazon Web Services Systems Manager User Guide. The maximum length constraint listed below includes capacity for additional system attributes that aren't part of the name. The maximum length for a parameter name, including the full length of the parameter ARN, is 1011 characters. For example, the length of the following parameter name is 65 characters, not 20 characters: arn:aws:ssm:us-east-2:111122223333:parameter/ExampleParameterName
    /// This member is required.
    public var name: Swift.String?
    /// Overwrite an existing parameter. The default value is false.
    public var overwrite: Swift.Bool
    /// One or more policies to apply to a parameter. This operation takes a JSON array. Parameter Store, a capability of Amazon Web Services Systems Manager supports the following policy types: Expiration: This policy deletes the parameter after it expires. When you create the policy, you specify the expiration date. You can update the expiration date and time by updating the policy. Updating the parameter doesn't affect the expiration date and time. When the expiration time is reached, Parameter Store deletes the parameter. ExpirationNotification: This policy initiates an event in Amazon CloudWatch Events that notifies you about the expiration. By using this policy, you can receive notification before or after the expiration time is reached, in units of days or hours. NoChangeNotification: This policy initiates a CloudWatch Events event if a parameter hasn't been modified for a specified period of time. This policy type is useful when, for example, a secret needs to be changed within a period of time, but it hasn't been changed. All existing policies are preserved until you send new policies or an empty policy. For more information about parameter policies, see [Assigning parameter policies](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html).
    public var policies: Swift.String?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a Systems Manager parameter to identify the type of resource to which it applies, the environment, or the type of configuration data referenced by the parameter. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=Resource,Value=S3bucket
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=ParameterType,Value=LicenseKey
    ///
    ///
    /// To add tags to an existing Systems Manager parameter, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?
    /// The parameter tier to assign to a parameter. Parameter Store offers a standard tier and an advanced tier for parameters. Standard parameters have a content size limit of 4 KB and can't be configured to use parameter policies. You can create a maximum of 10,000 standard parameters for each Region in an Amazon Web Services account. Standard parameters are offered at no additional cost. Advanced parameters have a content size limit of 8 KB and can be configured to use parameter policies. You can create a maximum of 100,000 advanced parameters for each Region in an Amazon Web Services account. Advanced parameters incur a charge. For more information, see [Standard and advanced parameter tiers](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-advanced-parameters.html) in the Amazon Web Services Systems Manager User Guide. You can change a standard parameter to an advanced parameter any time. But you can't revert an advanced parameter to a standard parameter. Reverting an advanced parameter to a standard parameter would result in data loss because the system would truncate the size of the parameter from 8 KB to 4 KB. Reverting would also remove any policies attached to the parameter. Lastly, advanced parameters use a different form of encryption than standard parameters. If you no longer need an advanced parameter, or if you no longer want to incur charges for an advanced parameter, you must delete it and recreate it as a new standard parameter. Using the Default Tier Configuration In PutParameter requests, you can specify the tier to create the parameter in. Whenever you specify a tier in the request, Parameter Store creates or updates the parameter according to that request. However, if you don't specify a tier in a request, Parameter Store assigns the tier based on the current Parameter Store default tier configuration. The default tier when you begin using Parameter Store is the standard-parameter tier. If you use the advanced-parameter tier, you can specify one of the following as the default:
    ///
    /// * Advanced: With this option, Parameter Store evaluates all requests as advanced parameters.
    ///
    /// * Intelligent-Tiering: With this option, Parameter Store evaluates each request to determine if the parameter is standard or advanced. If the request doesn't include any options that require an advanced parameter, the parameter is created in the standard-parameter tier. If one or more options requiring an advanced parameter are included in the request, Parameter Store create a parameter in the advanced-parameter tier. This approach helps control your parameter-related costs by always creating standard parameters unless an advanced parameter is necessary.
    ///
    ///
    /// Options that require an advanced parameter include the following:
    ///
    /// * The content size of the parameter is more than 4 KB.
    ///
    /// * The parameter uses a parameter policy.
    ///
    /// * More than 10,000 parameters already exist in your Amazon Web Services account in the current Amazon Web Services Region.
    ///
    ///
    /// For more information about configuring the default tier option, see [Specifying a default parameter tier](https://docs.aws.amazon.com/systems-manager/latest/userguide/ps-default-tier.html) in the Amazon Web Services Systems Manager User Guide.
    public var tier: SsmClientTypes.ParameterTier?
    /// The type of parameter that you want to add to the system. SecureString isn't currently supported for CloudFormation templates. Items in a StringList must be separated by a comma (,). You can't use other punctuation or special character to escape items in the list. If you have a parameter value that requires a comma, then use the String data type. Specifying a parameter type isn't required when updating a parameter. You must specify a parameter type when creating a parameter.
    public var type: SsmClientTypes.ParameterType?
    /// The parameter value that you want to add to the system. Standard parameters have a value limit of 4 KB. Advanced parameters have a value limit of 8 KB. Parameters can't be referenced or nested in the values of other parameters. You can't include {{}} or {{ssm:parameter-name}} in a parameter value.
    /// This member is required.
    public var value: Swift.String?

    public init (
        allowedPattern: Swift.String? = nil,
        dataType: Swift.String? = nil,
        description: Swift.String? = nil,
        keyId: Swift.String? = nil,
        name: Swift.String? = nil,
        overwrite: Swift.Bool = false,
        policies: Swift.String? = nil,
        tags: [SsmClientTypes.Tag]? = nil,
        tier: SsmClientTypes.ParameterTier? = nil,
        type: SsmClientTypes.ParameterType? = nil,
        value: Swift.String? = nil
    )
    {
        self.allowedPattern = allowedPattern
        self.dataType = dataType
        self.description = description
        self.keyId = keyId
        self.name = name
        self.overwrite = overwrite
        self.policies = policies
        self.tags = tags
        self.tier = tier
        self.type = type
        self.value = value
    }
}

struct PutParameterInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let value: Swift.String?
    public let type: SsmClientTypes.ParameterType?
    public let keyId: Swift.String?
    public let overwrite: Swift.Bool
    public let allowedPattern: Swift.String?
    public let tags: [SsmClientTypes.Tag]?
    public let tier: SsmClientTypes.ParameterTier?
    public let policies: Swift.String?
    public let dataType: Swift.String?
}

extension PutParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case name = "Name"
        case overwrite = "Overwrite"
        case policies = "Policies"
        case tags = "Tags"
        case tier = "Tier"
        case type = "Type"
        case value = "Value"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterType.self, forKey: .type)
        type = typeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let overwriteDecoded = try containerValues.decode(Swift.Bool.self, forKey: .overwrite)
        overwrite = overwriteDecoded
        let allowedPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterTier.self, forKey: .tier)
        tier = tierDecoded
        let policiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policies)
        policies = policiesDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension PutParameterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutParameterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "HierarchyLevelLimitExceededException" : self = .hierarchyLevelLimitExceededException(try HierarchyLevelLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HierarchyTypeMismatchException" : self = .hierarchyTypeMismatchException(try HierarchyTypeMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatiblePolicyException" : self = .incompatiblePolicyException(try IncompatiblePolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAllowedPatternException" : self = .invalidAllowedPatternException(try InvalidAllowedPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyAttributeException" : self = .invalidPolicyAttributeException(try InvalidPolicyAttributeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyTypeException" : self = .invalidPolicyTypeException(try InvalidPolicyTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterAlreadyExists" : self = .parameterAlreadyExists(try ParameterAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterLimitExceeded" : self = .parameterLimitExceeded(try ParameterLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterMaxVersionLimitExceeded" : self = .parameterMaxVersionLimitExceeded(try ParameterMaxVersionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterPatternMismatchException" : self = .parameterPatternMismatchException(try ParameterPatternMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PoliciesLimitExceededException" : self = .policiesLimitExceededException(try PoliciesLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedParameterType" : self = .unsupportedParameterType(try UnsupportedParameterType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutParameterOutputError: Swift.Error, Swift.Equatable {
    case hierarchyLevelLimitExceededException(HierarchyLevelLimitExceededException)
    case hierarchyTypeMismatchException(HierarchyTypeMismatchException)
    case incompatiblePolicyException(IncompatiblePolicyException)
    case internalServerError(InternalServerError)
    case invalidAllowedPatternException(InvalidAllowedPatternException)
    case invalidKeyId(InvalidKeyId)
    case invalidPolicyAttributeException(InvalidPolicyAttributeException)
    case invalidPolicyTypeException(InvalidPolicyTypeException)
    case parameterAlreadyExists(ParameterAlreadyExists)
    case parameterLimitExceeded(ParameterLimitExceeded)
    case parameterMaxVersionLimitExceeded(ParameterMaxVersionLimitExceeded)
    case parameterPatternMismatchException(ParameterPatternMismatchException)
    case policiesLimitExceededException(PoliciesLimitExceededException)
    case tooManyUpdates(TooManyUpdates)
    case unsupportedParameterType(UnsupportedParameterType)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutParameterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutParameterOutputResponse(tier: \(Swift.String(describing: tier)), version: \(Swift.String(describing: version)))"}
}

extension PutParameterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutParameterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tier = output.tier
            self.version = output.version
        } else {
            self.tier = nil
            self.version = 0
        }
    }
}

public struct PutParameterOutputResponse: Swift.Equatable {
    /// The tier assigned to the parameter.
    public var tier: SsmClientTypes.ParameterTier?
    /// The new version number of a parameter. If you edit a parameter value, Parameter Store automatically creates a new version and assigns this new version a unique ID. You can reference a parameter version ID in API operations or in Systems Manager documents (SSM documents). By default, if you don't specify a specific version, the system returns the latest parameter value when a parameter is called.
    public var version: Swift.Int

    public init (
        tier: SsmClientTypes.ParameterTier? = nil,
        version: Swift.Int = 0
    )
    {
        self.tier = tier
        self.version = version
    }
}

struct PutParameterOutputResponseBody: Swift.Equatable {
    public let version: Swift.Int
    public let tier: SsmClientTypes.ParameterTier?
}

extension PutParameterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tier = "Tier"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let tierDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterTier.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension SsmClientTypes {
    public enum RebootOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noReboot
        case rebootIfNeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RebootOption] {
            return [
                .noReboot,
                .rebootIfNeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noReboot: return "NoReboot"
            case .rebootIfNeeded: return "RebootIfNeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RebootOption(rawValue: rawValue) ?? RebootOption.sdkUnknown(rawValue)
        }
    }
}

public struct RegisterDefaultPatchBaselineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDefaultPatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterDefaultPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDefaultPatchBaselineOutputError>
}

extension RegisterDefaultPatchBaselineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterDefaultPatchBaselineInput(baselineId: \(Swift.String(describing: baselineId)))"}
}

extension RegisterDefaultPatchBaselineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
    }
}

public struct RegisterDefaultPatchBaselineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDefaultPatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterDefaultPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDefaultPatchBaselineOutputError>
}

public struct RegisterDefaultPatchBaselineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDefaultPatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterDefaultPatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDefaultPatchBaselineOutputError>
}

public struct RegisterDefaultPatchBaselineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDefaultPatchBaselineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RegisterDefaultPatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterDefaultPatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDefaultPatchBaselineOutputError>
}

public struct RegisterDefaultPatchBaselineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDefaultPatchBaselineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RegisterDefaultPatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterDefaultPatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDefaultPatchBaselineOutputError>
}

public struct RegisterDefaultPatchBaselineInput: Swift.Equatable {
    /// The ID of the patch baseline that should be the default patch baseline.
    /// This member is required.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct RegisterDefaultPatchBaselineInputBody: Swift.Equatable {
    public let baselineId: Swift.String?
}

extension RegisterDefaultPatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension RegisterDefaultPatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterDefaultPatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterDefaultPatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterDefaultPatchBaselineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterDefaultPatchBaselineOutputResponse(baselineId: \(Swift.String(describing: baselineId)))"}
}

extension RegisterDefaultPatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterDefaultPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
        } else {
            self.baselineId = nil
        }
    }
}

public struct RegisterDefaultPatchBaselineOutputResponse: Swift.Equatable {
    /// The ID of the default patch baseline.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct RegisterDefaultPatchBaselineOutputResponseBody: Swift.Equatable {
    public let baselineId: Swift.String?
}

extension RegisterDefaultPatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

public struct RegisterPatchBaselineForPatchGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterPatchBaselineForPatchGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterPatchBaselineForPatchGroupOutputError>
}

extension RegisterPatchBaselineForPatchGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterPatchBaselineForPatchGroupInput(baselineId: \(Swift.String(describing: baselineId)), patchGroup: \(Swift.String(describing: patchGroup)))"}
}

extension RegisterPatchBaselineForPatchGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

public struct RegisterPatchBaselineForPatchGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterPatchBaselineForPatchGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterPatchBaselineForPatchGroupOutputError>
}

public struct RegisterPatchBaselineForPatchGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterPatchBaselineForPatchGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterPatchBaselineForPatchGroupOutputError>
}

public struct RegisterPatchBaselineForPatchGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterPatchBaselineForPatchGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RegisterPatchBaselineForPatchGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterPatchBaselineForPatchGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterPatchBaselineForPatchGroupOutputError>
}

public struct RegisterPatchBaselineForPatchGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterPatchBaselineForPatchGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RegisterPatchBaselineForPatchGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterPatchBaselineForPatchGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterPatchBaselineForPatchGroupOutputError>
}

public struct RegisterPatchBaselineForPatchGroupInput: Swift.Equatable {
    /// The ID of the patch baseline to register with the patch group.
    /// This member is required.
    public var baselineId: Swift.String?
    /// The name of the patch group to be registered with the patch baseline.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct RegisterPatchBaselineForPatchGroupInputBody: Swift.Equatable {
    public let baselineId: Swift.String?
    public let patchGroup: Swift.String?
}

extension RegisterPatchBaselineForPatchGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension RegisterPatchBaselineForPatchGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterPatchBaselineForPatchGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterPatchBaselineForPatchGroupOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterPatchBaselineForPatchGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterPatchBaselineForPatchGroupOutputResponse(baselineId: \(Swift.String(describing: baselineId)), patchGroup: \(Swift.String(describing: patchGroup)))"}
}

extension RegisterPatchBaselineForPatchGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterPatchBaselineForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
            self.patchGroup = output.patchGroup
        } else {
            self.baselineId = nil
            self.patchGroup = nil
        }
    }
}

public struct RegisterPatchBaselineForPatchGroupOutputResponse: Swift.Equatable {
    /// The ID of the patch baseline the patch group was registered with.
    public var baselineId: Swift.String?
    /// The name of the patch group registered with the patch baseline.
    public var patchGroup: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct RegisterPatchBaselineForPatchGroupOutputResponseBody: Swift.Equatable {
    public let baselineId: Swift.String?
    public let patchGroup: Swift.String?
}

extension RegisterPatchBaselineForPatchGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

public struct RegisterTargetWithMaintenanceWindowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTargetWithMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTargetWithMaintenanceWindowOutputError>
}

extension RegisterTargetWithMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTargetWithMaintenanceWindowInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), ownerInformation: \(Swift.String(describing: ownerInformation)), resourceType: \(Swift.String(describing: resourceType)), targets: \(Swift.String(describing: targets)), windowId: \(Swift.String(describing: windowId)))"}
}

extension RegisterTargetWithMaintenanceWindowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct RegisterTargetWithMaintenanceWindowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTargetWithMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTargetWithMaintenanceWindowOutputError>
}

public struct RegisterTargetWithMaintenanceWindowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTargetWithMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTargetWithMaintenanceWindowOutputError>
}

public struct RegisterTargetWithMaintenanceWindowInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTargetWithMaintenanceWindowInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RegisterTargetWithMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterTargetWithMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTargetWithMaintenanceWindowOutputError>
}

public struct RegisterTargetWithMaintenanceWindowInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTargetWithMaintenanceWindowInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RegisterTargetWithMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterTargetWithMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTargetWithMaintenanceWindowOutputError>
}

public struct RegisterTargetWithMaintenanceWindowInput: Swift.Equatable {
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// An optional description for the target.
    public var description: Swift.String?
    /// An optional name for the target.
    public var name: Swift.String?
    /// User-provided value that will be included in any Amazon CloudWatch Events events raised while running tasks for these targets in this maintenance window.
    public var ownerInformation: Swift.String?
    /// The type of target being registered with the maintenance window.
    /// This member is required.
    public var resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    /// The targets to register with the maintenance window. In other words, the managed nodes to run commands on when the maintenance window runs. If a single maintenance window task is registered with multiple targets, its task invocations occur sequentially and not in parallel. If your task must run on multiple targets at the same time, register a task for each target individually and assign each task the same priority level. You can specify targets using managed node IDs, resource group names, or tags that have been applied to managed nodes. Example 1: Specify managed node IDs Key=InstanceIds,Values=,, Example 2: Use tag key-pairs applied to managed nodes Key=tag:,Values=, Example 3: Use tag-keys applied to managed nodes Key=tag-key,Values=, Example 4: Use resource group names Key=resource-groups:Name,Values= Example 5: Use filters for resource group types Key=resource-groups:ResourceTypeFilters,Values=, For Key=resource-groups:ResourceTypeFilters, specify resource types in the following format Key=resource-groups:ResourceTypeFilters,Values=AWS::EC2::INSTANCE,AWS::EC2::VPC For more information about these examples formats, including the best use case for each one, see [Examples: Register targets with a maintenance window](https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-tutorial-targets-examples.html) in the Amazon Web Services Systems Manager User Guide.
    /// This member is required.
    public var targets: [SsmClientTypes.Target]?
    /// The ID of the maintenance window the target should be registered with.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        resourceType: SsmClientTypes.MaintenanceWindowResourceType? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.resourceType = resourceType
        self.targets = targets
        self.windowId = windowId
    }
}

struct RegisterTargetWithMaintenanceWindowInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    public let targets: [SsmClientTypes.Target]?
    public let ownerInformation: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let clientToken: Swift.String?
}

extension RegisterTargetWithMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RegisterTargetWithMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTargetWithMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTargetWithMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTargetWithMaintenanceWindowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTargetWithMaintenanceWindowOutputResponse(windowTargetId: \(Swift.String(describing: windowTargetId)))"}
}

extension RegisterTargetWithMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterTargetWithMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowTargetId = output.windowTargetId
        } else {
            self.windowTargetId = nil
        }
    }
}

public struct RegisterTargetWithMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the target definition in this maintenance window.
    public var windowTargetId: Swift.String?

    public init (
        windowTargetId: Swift.String? = nil
    )
    {
        self.windowTargetId = windowTargetId
    }
}

struct RegisterTargetWithMaintenanceWindowOutputResponseBody: Swift.Equatable {
    public let windowTargetId: Swift.String?
}

extension RegisterTargetWithMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

public struct RegisterTaskWithMaintenanceWindowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTaskWithMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTaskWithMaintenanceWindowOutputError>
}

extension RegisterTaskWithMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTaskWithMaintenanceWindowInput(clientToken: \(Swift.String(describing: clientToken)), cutoffBehavior: \(Swift.String(describing: cutoffBehavior)), description: \(Swift.String(describing: description)), loggingInfo: \(Swift.String(describing: loggingInfo)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), taskArn: \(Swift.String(describing: taskArn)), taskInvocationParameters: \(Swift.String(describing: taskInvocationParameters)), taskParameters: \(Swift.String(describing: taskParameters)), taskType: \(Swift.String(describing: taskType)), windowId: \(Swift.String(describing: windowId)))"}
}

extension RegisterTaskWithMaintenanceWindowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case taskType = "TaskType"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cutoffBehavior = cutoffBehavior {
            try encodeContainer.encode(cutoffBehavior.rawValue, forKey: .cutoffBehavior)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskInvocationParameters = taskInvocationParameters {
            try encodeContainer.encode(taskInvocationParameters, forKey: .taskInvocationParameters)
        }
        if let taskParameters = taskParameters {
            var taskParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskParameters)
            for (dictKey0, maintenancewindowtaskparameters0) in taskParameters {
                try taskParametersContainer.encode(maintenancewindowtaskparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct RegisterTaskWithMaintenanceWindowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTaskWithMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTaskWithMaintenanceWindowOutputError>
}

public struct RegisterTaskWithMaintenanceWindowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTaskWithMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTaskWithMaintenanceWindowOutputError>
}

public struct RegisterTaskWithMaintenanceWindowInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTaskWithMaintenanceWindowInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RegisterTaskWithMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterTaskWithMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTaskWithMaintenanceWindowOutputError>
}

public struct RegisterTaskWithMaintenanceWindowInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTaskWithMaintenanceWindowInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RegisterTaskWithMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterTaskWithMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTaskWithMaintenanceWindowOutputError>
}

public struct RegisterTaskWithMaintenanceWindowInput: Swift.Equatable {
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// Indicates whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
    ///
    /// * CONTINUE_TASK: When the cutoff time is reached, any tasks that are running continue. The default value.
    ///
    /// * CANCEL_TASK:
    ///
    /// * For Automation, Lambda, Step Functions tasks: When the cutoff time is reached, any task invocations that are already running continue, but no new task invocations are started.
    ///
    /// * For Run Command tasks: When the cutoff time is reached, the system sends a [CancelCommand] operation that attempts to cancel the command associated with the task. However, there is no guarantee that the command will be terminated and the underlying process stopped.
    ///
    ///
    /// The status for tasks that are not completed is TIMED_OUT.
    public var cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// An optional description for the task.
    public var description: Swift.String?
    /// A structure containing information about an Amazon Simple Storage Service (Amazon S3) bucket to write managed node-level logs to. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SsmClientTypes.LoggingInfo?
    /// The maximum number of targets this task can be run for in parallel. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1. This value doesn't affect the running of your task.
    public var maxConcurrency: Swift.String?
    /// The maximum number of errors allowed before this task stops being scheduled. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1. This value doesn't affect the running of your task.
    public var maxErrors: Swift.String?
    /// An optional name for the task.
    public var name: Swift.String?
    /// The priority of the task in the maintenance window, the lower the number the higher the priority. Tasks in a maintenance window are scheduled in priority order with tasks that have the same priority scheduled in parallel.
    public var priority: Swift.Int
    /// The Amazon Resource Name (ARN) of the IAM service role for Amazon Web Services Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses your account's service-linked role. If no service-linked role for Systems Manager exists in your account, it is created when you run RegisterTaskWithMaintenanceWindow. For more information, see the following topics in the in the Amazon Web Services Systems Manager User Guide:
    ///
    /// * [Using service-linked roles for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions)
    ///
    /// * [Should I use a service-linked role or a custom service role to run maintenance window tasks? ](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role)
    public var serviceRoleArn: Swift.String?
    /// The targets (either managed nodes or maintenance window targets). One or more targets must be specified for maintenance window Run Command-type tasks. Depending on the task, targets are optional for other maintenance window task types (Automation, Lambda, and Step Functions). For more information about running tasks that don't specify targets, see [Registering maintenance window tasks without targets](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) in the Amazon Web Services Systems Manager User Guide. Specify managed nodes using the following format: Key=InstanceIds,Values=, Specify maintenance window targets using the following format: Key=WindowTargetIds,Values=,
    public var targets: [SsmClientTypes.Target]?
    /// The ARN of the task to run.
    /// This member is required.
    public var taskArn: Swift.String?
    /// The parameters that the task should use during execution. Populate only the fields that match the task type. All other fields should be empty.
    public var taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The parameters that should be passed to the task when it is run. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The type of task being registered.
    /// This member is required.
    public var taskType: SsmClientTypes.MaintenanceWindowTaskType?
    /// The ID of the maintenance window the task should be added to.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SsmClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRoleArn: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        taskType: SsmClientTypes.MaintenanceWindowTaskType? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.taskType = taskType
        self.windowId = windowId
    }
}

struct RegisterTaskWithMaintenanceWindowInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let targets: [SsmClientTypes.Target]?
    public let taskArn: Swift.String?
    public let serviceRoleArn: Swift.String?
    public let taskType: SsmClientTypes.MaintenanceWindowTaskType?
    public let taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    public let taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    public let priority: Swift.Int
    public let maxConcurrency: Swift.String?
    public let maxErrors: Swift.String?
    public let loggingInfo: SsmClientTypes.LoggingInfo?
    public let name: Swift.String?
    public let description: Swift.String?
    public let clientToken: Swift.String?
    public let cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
}

extension RegisterTaskWithMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case taskType = "TaskType"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let cutoffBehaviorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskCutoffBehavior.self, forKey: .cutoffBehavior)
        cutoffBehavior = cutoffBehaviorDecoded
    }
}

extension RegisterTaskWithMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTaskWithMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FeatureNotAvailableException" : self = .featureNotAvailableException(try FeatureNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTaskWithMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case featureNotAvailableException(FeatureNotAvailableException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTaskWithMaintenanceWindowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTaskWithMaintenanceWindowOutputResponse(windowTaskId: \(Swift.String(describing: windowTaskId)))"}
}

extension RegisterTaskWithMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterTaskWithMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowTaskId = output.windowTaskId
        } else {
            self.windowTaskId = nil
        }
    }
}

public struct RegisterTaskWithMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the task in the maintenance window.
    public var windowTaskId: Swift.String?

    public init (
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowTaskId = windowTaskId
    }
}

struct RegisterTaskWithMaintenanceWindowOutputResponseBody: Swift.Equatable {
    public let windowTaskId: Swift.String?
}

extension RegisterTaskWithMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension SsmClientTypes.RegistrationMetadataItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes.RegistrationMetadataItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegistrationMetadataItem(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SsmClientTypes {
    /// Reserved for internal use.
    public struct RegistrationMetadataItem: Swift.Equatable {
        /// Reserved for internal use.
        /// This member is required.
        public var key: Swift.String?
        /// Reserved for internal use.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes.RelatedOpsItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension SsmClientTypes.RelatedOpsItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RelatedOpsItem(opsItemId: \(Swift.String(describing: opsItemId)))"}
}

extension SsmClientTypes {
    /// An OpsItems that shares something in common with the current OpsItem. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
    public struct RelatedOpsItem: Swift.Equatable {
        /// The ID of an OpsItem related to the current OpsItem.
        /// This member is required.
        public var opsItemId: Swift.String?

        public init (
            opsItemId: Swift.String? = nil
        )
        {
            self.opsItemId = opsItemId
        }
    }

}

public struct RemoveTagsFromResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceInput(resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for keylist0 in tagKeys {
                try tagKeysContainer.encode(keylist0)
            }
        }
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RemoveTagsFromResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveTagsFromResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RemoveTagsFromResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveTagsFromResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// The ID of the resource from which you want to remove tags. For example: ManagedInstance: mi-012345abcde MaintenanceWindow: mw-012345abcde PatchBaseline: pb-012345abcde OpsMetadata object: ResourceID for tagging is created from the Amazon Resource Name (ARN) for the object. Specifically, ResourceID is created from the strings that come after the word opsmetadata in the ARN. For example, an OpsMetadata object with an ARN of arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager has a ResourceID of either aws/ssm/MyGroup/appmanager or /aws/ssm/MyGroup/appmanager. For the Document and Parameter values, use the name of the resource. The ManagedInstance type for this API operation is only for on-premises managed nodes. Specify the name of the managed node in the following format: mi-ID_number. For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of resource from which you want to remove a tag. The ManagedInstance type for this API operation is only for on-premises managed nodes. Specify the name of the managed node in the following format: mi-ID_number . For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceType: SsmClientTypes.ResourceTypeForTagging?
    /// Tag keys that you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceId: Swift.String? = nil,
        resourceType: SsmClientTypes.ResourceTypeForTagging? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    public let resourceType: SsmClientTypes.ResourceTypeForTagging?
    public let resourceId: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceTypeForTagging.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceOutputResponse()"}
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveTagsFromResourceOutputResponseBody: Swift.Equatable {
}

extension RemoveTagsFromResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct ResetServiceSettingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetServiceSettingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetServiceSettingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetServiceSettingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetServiceSettingOutputError>
}

extension ResetServiceSettingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetServiceSettingInput(settingId: \(Swift.String(describing: settingId)))"}
}

extension ResetServiceSettingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
    }
}

public struct ResetServiceSettingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetServiceSettingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetServiceSettingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetServiceSettingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetServiceSettingOutputError>
}

public struct ResetServiceSettingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetServiceSettingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetServiceSettingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetServiceSettingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetServiceSettingOutputError>
}

public struct ResetServiceSettingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetServiceSettingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ResetServiceSettingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetServiceSettingInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetServiceSettingOutputError>
}

public struct ResetServiceSettingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetServiceSettingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ResetServiceSettingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetServiceSettingInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetServiceSettingOutputError>
}

/// The request body of the ResetServiceSetting API operation.
public struct ResetServiceSettingInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service setting to reset. The setting ID can be one of the following.
    ///
    /// * /ssm/automation/customer-script-log-destination
    ///
    /// * /ssm/automation/customer-script-log-group-name
    ///
    /// * /ssm/documents/console/public-sharing-permission
    ///
    /// * /ssm/parameter-store/default-parameter-tier
    ///
    /// * /ssm/parameter-store/high-throughput-enabled
    ///
    /// * /ssm/managed-instance/activation-tier
    /// This member is required.
    public var settingId: Swift.String?

    public init (
        settingId: Swift.String? = nil
    )
    {
        self.settingId = settingId
    }
}

struct ResetServiceSettingInputBody: Swift.Equatable {
    public let settingId: Swift.String?
}

extension ResetServiceSettingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingId)
        settingId = settingIdDecoded
    }
}

extension ResetServiceSettingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetServiceSettingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceSettingNotFound" : self = .serviceSettingNotFound(try ServiceSettingNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetServiceSettingOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case serviceSettingNotFound(ServiceSettingNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetServiceSettingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetServiceSettingOutputResponse(serviceSetting: \(Swift.String(describing: serviceSetting)))"}
}

extension ResetServiceSettingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetServiceSettingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceSetting = output.serviceSetting
        } else {
            self.serviceSetting = nil
        }
    }
}

/// The result body of the ResetServiceSetting API operation.
public struct ResetServiceSettingOutputResponse: Swift.Equatable {
    /// The current, effective service setting after calling the ResetServiceSetting API operation.
    public var serviceSetting: SsmClientTypes.ServiceSetting?

    public init (
        serviceSetting: SsmClientTypes.ServiceSetting? = nil
    )
    {
        self.serviceSetting = serviceSetting
    }
}

struct ResetServiceSettingOutputResponseBody: Swift.Equatable {
    public let serviceSetting: SsmClientTypes.ServiceSetting?
}

extension ResetServiceSettingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSetting = "ServiceSetting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSettingDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ServiceSetting.self, forKey: .serviceSetting)
        serviceSetting = serviceSettingDecoded
    }
}

extension SsmClientTypes.ResolvedTargets: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterValues = "ParameterValues"
        case truncated = "Truncated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterValues = parameterValues {
            var parameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterValues)
            for targetparameterlist0 in parameterValues {
                try parameterValuesContainer.encode(targetparameterlist0)
            }
        }
        if truncated != false {
            try encodeContainer.encode(truncated, forKey: .truncated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[Swift.String]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [Swift.String]()
            for string0 in parameterValuesContainer {
                if let string0 = string0 {
                    parameterValuesDecoded0?.append(string0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
        let truncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

extension SsmClientTypes.ResolvedTargets: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResolvedTargets(parameterValues: \(Swift.String(describing: parameterValues)), truncated: \(Swift.String(describing: truncated)))"}
}

extension SsmClientTypes {
    /// Information about targets that resolved during the Automation execution.
    public struct ResolvedTargets: Swift.Equatable {
        /// A list of parameter values sent to targets that resolved during the Automation execution.
        public var parameterValues: [Swift.String]?
        /// A boolean value indicating whether the resolved target list is truncated.
        public var truncated: Swift.Bool

        public init (
            parameterValues: [Swift.String]? = nil,
            truncated: Swift.Bool = false
        )
        {
            self.parameterValues = parameterValues
            self.truncated = truncated
        }
    }

}

extension SsmClientTypes.ResourceComplianceSummaryItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case compliantSummary = "CompliantSummary"
        case executionSummary = "ExecutionSummary"
        case nonCompliantSummary = "NonCompliantSummary"
        case overallSeverity = "OverallSeverity"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let compliantSummary = compliantSummary {
            try encodeContainer.encode(compliantSummary, forKey: .compliantSummary)
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let nonCompliantSummary = nonCompliantSummary {
            try encodeContainer.encode(nonCompliantSummary, forKey: .nonCompliantSummary)
        }
        if let overallSeverity = overallSeverity {
            try encodeContainer.encode(overallSeverity.rawValue, forKey: .overallSeverity)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let overallSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceSeverity.self, forKey: .overallSeverity)
        overallSeverity = overallSeverityDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceExecutionSummary.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let compliantSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CompliantSummary.self, forKey: .compliantSummary)
        compliantSummary = compliantSummaryDecoded
        let nonCompliantSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NonCompliantSummary.self, forKey: .nonCompliantSummary)
        nonCompliantSummary = nonCompliantSummaryDecoded
    }
}

extension SsmClientTypes.ResourceComplianceSummaryItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceComplianceSummaryItem(complianceType: \(Swift.String(describing: complianceType)), compliantSummary: \(Swift.String(describing: compliantSummary)), executionSummary: \(Swift.String(describing: executionSummary)), nonCompliantSummary: \(Swift.String(describing: nonCompliantSummary)), overallSeverity: \(Swift.String(describing: overallSeverity)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), status: \(Swift.String(describing: status)))"}
}

extension SsmClientTypes {
    /// Compliance summary information for a specific resource.
    public struct ResourceComplianceSummaryItem: Swift.Equatable {
        /// The compliance type.
        public var complianceType: Swift.String?
        /// A list of items that are compliant for the resource.
        public var compliantSummary: SsmClientTypes.CompliantSummary?
        /// Information about the execution.
        public var executionSummary: SsmClientTypes.ComplianceExecutionSummary?
        /// A list of items that aren't compliant for the resource.
        public var nonCompliantSummary: SsmClientTypes.NonCompliantSummary?
        /// The highest severity item found for the resource. The resource is compliant for this item.
        public var overallSeverity: SsmClientTypes.ComplianceSeverity?
        /// The resource ID.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?
        /// The compliance status for the resource.
        public var status: SsmClientTypes.ComplianceStatus?

        public init (
            complianceType: Swift.String? = nil,
            compliantSummary: SsmClientTypes.CompliantSummary? = nil,
            executionSummary: SsmClientTypes.ComplianceExecutionSummary? = nil,
            nonCompliantSummary: SsmClientTypes.NonCompliantSummary? = nil,
            overallSeverity: SsmClientTypes.ComplianceSeverity? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            status: SsmClientTypes.ComplianceStatus? = nil
        )
        {
            self.complianceType = complianceType
            self.compliantSummary = compliantSummary
            self.executionSummary = executionSummary
            self.nonCompliantSummary = nonCompliantSummary
            self.overallSeverity = overallSeverity
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
        }
    }

}

extension ResourceDataSyncAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncAlreadyExistsException(syncName: \(Swift.String(describing: syncName)))"}
}

extension ResourceDataSyncAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDataSyncAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.syncName = output.syncName
        } else {
            self.syncName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A sync configuration with the same name already exists.
public struct ResourceDataSyncAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var syncName: Swift.String?

    public init (
        syncName: Swift.String? = nil
    )
    {
        self.syncName = syncName
    }
}

struct ResourceDataSyncAlreadyExistsExceptionBody: Swift.Equatable {
    public let syncName: Swift.String?
}

extension ResourceDataSyncAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncName = "SyncName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncAwsOrganizationsSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationSourceType = "OrganizationSourceType"
        case organizationalUnits = "OrganizationalUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationSourceType = organizationSourceType {
            try encodeContainer.encode(organizationSourceType, forKey: .organizationSourceType)
        }
        if let organizationalUnits = organizationalUnits {
            var organizationalUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnits)
            for resourcedatasyncorganizationalunitlist0 in organizationalUnits {
                try organizationalUnitsContainer.encode(resourcedatasyncorganizationalunitlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationSourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationSourceType)
        organizationSourceType = organizationSourceTypeDecoded
        let organizationalUnitsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ResourceDataSyncOrganizationalUnit?].self, forKey: .organizationalUnits)
        var organizationalUnitsDecoded0:[SsmClientTypes.ResourceDataSyncOrganizationalUnit]? = nil
        if let organizationalUnitsContainer = organizationalUnitsContainer {
            organizationalUnitsDecoded0 = [SsmClientTypes.ResourceDataSyncOrganizationalUnit]()
            for structure0 in organizationalUnitsContainer {
                if let structure0 = structure0 {
                    organizationalUnitsDecoded0?.append(structure0)
                }
            }
        }
        organizationalUnits = organizationalUnitsDecoded0
    }
}

extension SsmClientTypes.ResourceDataSyncAwsOrganizationsSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncAwsOrganizationsSource(organizationSourceType: \(Swift.String(describing: organizationSourceType)), organizationalUnits: \(Swift.String(describing: organizationalUnits)))"}
}

extension SsmClientTypes {
    /// Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from Organizations or, if an Amazon Web Services organization isn't present, from multiple Amazon Web Services Regions.
    public struct ResourceDataSyncAwsOrganizationsSource: Swift.Equatable {
        /// If an Amazon Web Services organization is present, this is either OrganizationalUnits or EntireOrganization. For OrganizationalUnits, the data is aggregated from a set of organization units. For EntireOrganization, the data is aggregated from the entire Amazon Web Services organization.
        /// This member is required.
        public var organizationSourceType: Swift.String?
        /// The Organizations organization units included in the sync.
        public var organizationalUnits: [SsmClientTypes.ResourceDataSyncOrganizationalUnit]?

        public init (
            organizationSourceType: Swift.String? = nil,
            organizationalUnits: [SsmClientTypes.ResourceDataSyncOrganizationalUnit]? = nil
        )
        {
            self.organizationSourceType = organizationSourceType
            self.organizationalUnits = organizationalUnits
        }
    }

}

extension ResourceDataSyncConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncConflictException(message: \(Swift.String(describing: message)))"}
}

extension ResourceDataSyncConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDataSyncConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Another UpdateResourceDataSync request is being processed. Wait a few minutes and try again.
public struct ResourceDataSyncConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDataSyncConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceDataSyncConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceDataSyncCountExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncCountExceededException(message: \(Swift.String(describing: message)))"}
}

extension ResourceDataSyncCountExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDataSyncCountExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the allowed maximum sync configurations.
public struct ResourceDataSyncCountExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDataSyncCountExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceDataSyncCountExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncDestinationDataSharing: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationDataSharingType = "DestinationDataSharingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationDataSharingType = destinationDataSharingType {
            try encodeContainer.encode(destinationDataSharingType, forKey: .destinationDataSharingType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDataSharingTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationDataSharingType)
        destinationDataSharingType = destinationDataSharingTypeDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncDestinationDataSharing: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncDestinationDataSharing(destinationDataSharingType: \(Swift.String(describing: destinationDataSharingType)))"}
}

extension SsmClientTypes {
    /// Synchronize Amazon Web Services Systems Manager Inventory data from multiple Amazon Web Services accounts defined in Organizations to a centralized Amazon S3 bucket. Data is synchronized to individual key prefixes in the central bucket. Each key prefix represents a different Amazon Web Services account ID.
    public struct ResourceDataSyncDestinationDataSharing: Swift.Equatable {
        /// The sharing data type. Only Organization is supported.
        public var destinationDataSharingType: Swift.String?

        public init (
            destinationDataSharingType: Swift.String? = nil
        )
        {
            self.destinationDataSharingType = destinationDataSharingType
        }
    }

}

extension ResourceDataSyncInvalidConfigurationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncInvalidConfigurationException(message: \(Swift.String(describing: message)))"}
}

extension ResourceDataSyncInvalidConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDataSyncInvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified sync configuration is invalid.
public struct ResourceDataSyncInvalidConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDataSyncInvalidConfigurationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceDataSyncInvalidConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastStatus = "LastStatus"
        case lastSuccessfulSyncTime = "LastSuccessfulSyncTime"
        case lastSyncStatusMessage = "LastSyncStatusMessage"
        case lastSyncTime = "LastSyncTime"
        case s3Destination = "S3Destination"
        case syncCreatedTime = "SyncCreatedTime"
        case syncLastModifiedTime = "SyncLastModifiedTime"
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastStatus = lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastSuccessfulSyncTime = lastSuccessfulSyncTime {
            try encodeContainer.encode(lastSuccessfulSyncTime.timeIntervalSince1970, forKey: .lastSuccessfulSyncTime)
        }
        if let lastSyncStatusMessage = lastSyncStatusMessage {
            try encodeContainer.encode(lastSyncStatusMessage, forKey: .lastSyncStatusMessage)
        }
        if let lastSyncTime = lastSyncTime {
            try encodeContainer.encode(lastSyncTime.timeIntervalSince1970, forKey: .lastSyncTime)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let syncCreatedTime = syncCreatedTime {
            try encodeContainer.encode(syncCreatedTime.timeIntervalSince1970, forKey: .syncCreatedTime)
        }
        if let syncLastModifiedTime = syncLastModifiedTime {
            try encodeContainer.encode(syncLastModifiedTime.timeIntervalSince1970, forKey: .syncLastModifiedTime)
        }
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncSource = syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncSourceWithState.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncS3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let lastSyncTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSyncTime)
        lastSyncTime = lastSyncTimeDecoded
        let lastSuccessfulSyncTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSuccessfulSyncTime)
        lastSuccessfulSyncTime = lastSuccessfulSyncTimeDecoded
        let syncLastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .syncLastModifiedTime)
        syncLastModifiedTime = syncLastModifiedTimeDecoded
        let lastStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LastResourceDataSyncStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let syncCreatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .syncCreatedTime)
        syncCreatedTime = syncCreatedTimeDecoded
        let lastSyncStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSyncStatusMessage)
        lastSyncStatusMessage = lastSyncStatusMessageDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncItem(lastStatus: \(Swift.String(describing: lastStatus)), lastSuccessfulSyncTime: \(Swift.String(describing: lastSuccessfulSyncTime)), lastSyncStatusMessage: \(Swift.String(describing: lastSyncStatusMessage)), lastSyncTime: \(Swift.String(describing: lastSyncTime)), s3Destination: \(Swift.String(describing: s3Destination)), syncCreatedTime: \(Swift.String(describing: syncCreatedTime)), syncLastModifiedTime: \(Swift.String(describing: syncLastModifiedTime)), syncName: \(Swift.String(describing: syncName)), syncSource: \(Swift.String(describing: syncSource)), syncType: \(Swift.String(describing: syncType)))"}
}

extension SsmClientTypes {
    /// Information about a resource data sync configuration, including its current status and last successful sync.
    public struct ResourceDataSyncItem: Swift.Equatable {
        /// The status reported by the last sync.
        public var lastStatus: SsmClientTypes.LastResourceDataSyncStatus?
        /// The last time the sync operations returned a status of SUCCESSFUL (UTC).
        public var lastSuccessfulSyncTime: ClientRuntime.Date?
        /// The status message details reported by the last sync.
        public var lastSyncStatusMessage: Swift.String?
        /// The last time the configuration attempted to sync (UTC).
        public var lastSyncTime: ClientRuntime.Date?
        /// Configuration information for the target S3 bucket.
        public var s3Destination: SsmClientTypes.ResourceDataSyncS3Destination?
        /// The date and time the configuration was created (UTC).
        public var syncCreatedTime: ClientRuntime.Date?
        /// The date and time the resource data sync was changed.
        public var syncLastModifiedTime: ClientRuntime.Date?
        /// The name of the resource data sync.
        public var syncName: Swift.String?
        /// Information about the source where the data was synchronized.
        public var syncSource: SsmClientTypes.ResourceDataSyncSourceWithState?
        /// The type of resource data sync. If SyncType is SyncToDestination, then the resource data sync synchronizes data to an S3 bucket. If the SyncType is SyncFromSource then the resource data sync synchronizes data from Organizations or from multiple Amazon Web Services Regions.
        public var syncType: Swift.String?

        public init (
            lastStatus: SsmClientTypes.LastResourceDataSyncStatus? = nil,
            lastSuccessfulSyncTime: ClientRuntime.Date? = nil,
            lastSyncStatusMessage: Swift.String? = nil,
            lastSyncTime: ClientRuntime.Date? = nil,
            s3Destination: SsmClientTypes.ResourceDataSyncS3Destination? = nil,
            syncCreatedTime: ClientRuntime.Date? = nil,
            syncLastModifiedTime: ClientRuntime.Date? = nil,
            syncName: Swift.String? = nil,
            syncSource: SsmClientTypes.ResourceDataSyncSourceWithState? = nil,
            syncType: Swift.String? = nil
        )
        {
            self.lastStatus = lastStatus
            self.lastSuccessfulSyncTime = lastSuccessfulSyncTime
            self.lastSyncStatusMessage = lastSyncStatusMessage
            self.lastSyncTime = lastSyncTime
            self.s3Destination = s3Destination
            self.syncCreatedTime = syncCreatedTime
            self.syncLastModifiedTime = syncLastModifiedTime
            self.syncName = syncName
            self.syncSource = syncSource
            self.syncType = syncType
        }
    }

}

extension ResourceDataSyncNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncNotFoundException(message: \(Swift.String(describing: message)), syncName: \(Swift.String(describing: syncName)), syncType: \(Swift.String(describing: syncType)))"}
}

extension ResourceDataSyncNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDataSyncNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.syncName = output.syncName
            self.syncType = output.syncType
        } else {
            self.message = nil
            self.syncName = nil
            self.syncType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified sync name wasn't found.
public struct ResourceDataSyncNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var syncName: Swift.String?
    public var syncType: Swift.String?

    public init (
        message: Swift.String? = nil,
        syncName: Swift.String? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.message = message
        self.syncName = syncName
        self.syncType = syncType
    }
}

struct ResourceDataSyncNotFoundExceptionBody: Swift.Equatable {
    public let syncName: Swift.String?
    public let syncType: Swift.String?
    public let message: Swift.String?
}

extension ResourceDataSyncNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case syncName = "SyncName"
        case syncType = "SyncType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncOrganizationalUnit: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationalUnitId = "OrganizationalUnitId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationalUnitId = organizationalUnitId {
            try encodeContainer.encode(organizationalUnitId, forKey: .organizationalUnitId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationalUnitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitId)
        organizationalUnitId = organizationalUnitIdDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncOrganizationalUnit: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncOrganizationalUnit(organizationalUnitId: \(Swift.String(describing: organizationalUnitId)))"}
}

extension SsmClientTypes {
    /// The Organizations organizational unit data source for the sync.
    public struct ResourceDataSyncOrganizationalUnit: Swift.Equatable {
        /// The Organizations unit ID data source for the sync.
        public var organizationalUnitId: Swift.String?

        public init (
            organizationalUnitId: Swift.String? = nil
        )
        {
            self.organizationalUnitId = organizationalUnitId
        }
    }

}

extension SsmClientTypes.ResourceDataSyncS3Destination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSKMSKeyARN = "AWSKMSKeyARN"
        case bucketName = "BucketName"
        case destinationDataSharing = "DestinationDataSharing"
        case `prefix` = "Prefix"
        case region = "Region"
        case syncFormat = "SyncFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSKMSKeyARN = aWSKMSKeyARN {
            try encodeContainer.encode(aWSKMSKeyARN, forKey: .aWSKMSKeyARN)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let destinationDataSharing = destinationDataSharing {
            try encodeContainer.encode(destinationDataSharing, forKey: .destinationDataSharing)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let syncFormat = syncFormat {
            try encodeContainer.encode(syncFormat.rawValue, forKey: .syncFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let syncFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncS3Format.self, forKey: .syncFormat)
        syncFormat = syncFormatDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let aWSKMSKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aWSKMSKeyARN)
        aWSKMSKeyARN = aWSKMSKeyARNDecoded
        let destinationDataSharingDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncDestinationDataSharing.self, forKey: .destinationDataSharing)
        destinationDataSharing = destinationDataSharingDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncS3Destination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncS3Destination(aWSKMSKeyARN: \(Swift.String(describing: aWSKMSKeyARN)), bucketName: \(Swift.String(describing: bucketName)), destinationDataSharing: \(Swift.String(describing: destinationDataSharing)), prefix: \(Swift.String(describing: `prefix`)), region: \(Swift.String(describing: region)), syncFormat: \(Swift.String(describing: syncFormat)))"}
}

extension SsmClientTypes {
    /// Information about the target S3 bucket for the resource data sync.
    public struct ResourceDataSyncS3Destination: Swift.Equatable {
        /// An Amazon S3 prefix for the bucket.
        public var `prefix`: Swift.String?
        /// The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as the destination S3 bucket.
        public var aWSKMSKeyARN: Swift.String?
        /// The name of the S3 bucket where the aggregated data is stored.
        /// This member is required.
        public var bucketName: Swift.String?
        /// Enables destination data sharing. By default, this field is null.
        public var destinationDataSharing: SsmClientTypes.ResourceDataSyncDestinationDataSharing?
        /// The Amazon Web Services Region with the S3 bucket targeted by the resource data sync.
        /// This member is required.
        public var region: Swift.String?
        /// A supported sync format. The following format is currently supported: JsonSerDe
        /// This member is required.
        public var syncFormat: SsmClientTypes.ResourceDataSyncS3Format?

        public init (
            `prefix`: Swift.String? = nil,
            aWSKMSKeyARN: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            destinationDataSharing: SsmClientTypes.ResourceDataSyncDestinationDataSharing? = nil,
            region: Swift.String? = nil,
            syncFormat: SsmClientTypes.ResourceDataSyncS3Format? = nil
        )
        {
            self.`prefix` = `prefix`
            self.aWSKMSKeyARN = aWSKMSKeyARN
            self.bucketName = bucketName
            self.destinationDataSharing = destinationDataSharing
            self.region = region
            self.syncFormat = syncFormat
        }
    }

}

extension SsmClientTypes {
    public enum ResourceDataSyncS3Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jsonSerde
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceDataSyncS3Format] {
            return [
                .jsonSerde,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jsonSerde: return "JsonSerDe"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceDataSyncS3Format(rawValue: rawValue) ?? ResourceDataSyncS3Format.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.ResourceDataSyncSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsOrganizationsSource = "AwsOrganizationsSource"
        case enableAllOpsDataSources = "EnableAllOpsDataSources"
        case includeFutureRegions = "IncludeFutureRegions"
        case sourceRegions = "SourceRegions"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsOrganizationsSource = awsOrganizationsSource {
            try encodeContainer.encode(awsOrganizationsSource, forKey: .awsOrganizationsSource)
        }
        if enableAllOpsDataSources != false {
            try encodeContainer.encode(enableAllOpsDataSources, forKey: .enableAllOpsDataSources)
        }
        if includeFutureRegions != false {
            try encodeContainer.encode(includeFutureRegions, forKey: .includeFutureRegions)
        }
        if let sourceRegions = sourceRegions {
            var sourceRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceRegions)
            for resourcedatasyncsourceregionlist0 in sourceRegions {
                try sourceRegionsContainer.encode(resourcedatasyncsourceregionlist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let awsOrganizationsSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncAwsOrganizationsSource.self, forKey: .awsOrganizationsSource)
        awsOrganizationsSource = awsOrganizationsSourceDecoded
        let sourceRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceRegions)
        var sourceRegionsDecoded0:[Swift.String]? = nil
        if let sourceRegionsContainer = sourceRegionsContainer {
            sourceRegionsDecoded0 = [Swift.String]()
            for string0 in sourceRegionsContainer {
                if let string0 = string0 {
                    sourceRegionsDecoded0?.append(string0)
                }
            }
        }
        sourceRegions = sourceRegionsDecoded0
        let includeFutureRegionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeFutureRegions)
        includeFutureRegions = includeFutureRegionsDecoded
        let enableAllOpsDataSourcesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableAllOpsDataSources)
        enableAllOpsDataSources = enableAllOpsDataSourcesDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncSource(awsOrganizationsSource: \(Swift.String(describing: awsOrganizationsSource)), enableAllOpsDataSources: \(Swift.String(describing: enableAllOpsDataSources)), includeFutureRegions: \(Swift.String(describing: includeFutureRegions)), sourceRegions: \(Swift.String(describing: sourceRegions)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension SsmClientTypes {
    /// Information about the source of the data included in the resource data sync.
    public struct ResourceDataSyncSource: Swift.Equatable {
        /// Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from Organizations.
        public var awsOrganizationsSource: SsmClientTypes.ResourceDataSyncAwsOrganizationsSource?
        /// When you create a resource data sync, if you choose one of the Organizations options, then Systems Manager automatically enables all OpsData sources in the selected Amazon Web Services Regions for all Amazon Web Services accounts in your organization (or in the selected organization units). For more information, see [About multiple account and Region resource data syncs](https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resouce-data-sync-multiple-accounts-and-regions.html) in the Amazon Web Services Systems Manager User Guide.
        public var enableAllOpsDataSources: Swift.Bool
        /// Whether to automatically synchronize and aggregate data from new Amazon Web Services Regions when those Regions come online.
        public var includeFutureRegions: Swift.Bool
        /// The SyncSource Amazon Web Services Regions included in the resource data sync.
        /// This member is required.
        public var sourceRegions: [Swift.String]?
        /// The type of data source for the resource data sync. SourceType is either AwsOrganizations (if an organization is present in Organizations) or SingleAccountMultiRegions.
        /// This member is required.
        public var sourceType: Swift.String?

        public init (
            awsOrganizationsSource: SsmClientTypes.ResourceDataSyncAwsOrganizationsSource? = nil,
            enableAllOpsDataSources: Swift.Bool = false,
            includeFutureRegions: Swift.Bool = false,
            sourceRegions: [Swift.String]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.awsOrganizationsSource = awsOrganizationsSource
            self.enableAllOpsDataSources = enableAllOpsDataSources
            self.includeFutureRegions = includeFutureRegions
            self.sourceRegions = sourceRegions
            self.sourceType = sourceType
        }
    }

}

extension SsmClientTypes.ResourceDataSyncSourceWithState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsOrganizationsSource = "AwsOrganizationsSource"
        case enableAllOpsDataSources = "EnableAllOpsDataSources"
        case includeFutureRegions = "IncludeFutureRegions"
        case sourceRegions = "SourceRegions"
        case sourceType = "SourceType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsOrganizationsSource = awsOrganizationsSource {
            try encodeContainer.encode(awsOrganizationsSource, forKey: .awsOrganizationsSource)
        }
        if enableAllOpsDataSources != false {
            try encodeContainer.encode(enableAllOpsDataSources, forKey: .enableAllOpsDataSources)
        }
        if includeFutureRegions != false {
            try encodeContainer.encode(includeFutureRegions, forKey: .includeFutureRegions)
        }
        if let sourceRegions = sourceRegions {
            var sourceRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceRegions)
            for resourcedatasyncsourceregionlist0 in sourceRegions {
                try sourceRegionsContainer.encode(resourcedatasyncsourceregionlist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let awsOrganizationsSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncAwsOrganizationsSource.self, forKey: .awsOrganizationsSource)
        awsOrganizationsSource = awsOrganizationsSourceDecoded
        let sourceRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceRegions)
        var sourceRegionsDecoded0:[Swift.String]? = nil
        if let sourceRegionsContainer = sourceRegionsContainer {
            sourceRegionsDecoded0 = [Swift.String]()
            for string0 in sourceRegionsContainer {
                if let string0 = string0 {
                    sourceRegionsDecoded0?.append(string0)
                }
            }
        }
        sourceRegions = sourceRegionsDecoded0
        let includeFutureRegionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeFutureRegions)
        includeFutureRegions = includeFutureRegionsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let enableAllOpsDataSourcesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableAllOpsDataSources)
        enableAllOpsDataSources = enableAllOpsDataSourcesDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncSourceWithState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDataSyncSourceWithState(awsOrganizationsSource: \(Swift.String(describing: awsOrganizationsSource)), enableAllOpsDataSources: \(Swift.String(describing: enableAllOpsDataSources)), includeFutureRegions: \(Swift.String(describing: includeFutureRegions)), sourceRegions: \(Swift.String(describing: sourceRegions)), sourceType: \(Swift.String(describing: sourceType)), state: \(Swift.String(describing: state)))"}
}

extension SsmClientTypes {
    /// The data type name for including resource data sync state. There are four sync states: OrganizationNotExists (Your organization doesn't exist) NoPermissions (The system can't locate the service-linked role. This role is automatically created when a user creates a resource data sync in Amazon Web Services Systems Manager Explorer.) InvalidOrganizationalUnit (You specified or selected an invalid unit in the resource data sync configuration.) TrustedAccessDisabled (You disabled Systems Manager access in the organization in Organizations.)
    public struct ResourceDataSyncSourceWithState: Swift.Equatable {
        /// The field name in SyncSource for the ResourceDataSyncAwsOrganizationsSource type.
        public var awsOrganizationsSource: SsmClientTypes.ResourceDataSyncAwsOrganizationsSource?
        /// When you create a resource data sync, if you choose one of the Organizations options, then Systems Manager automatically enables all OpsData sources in the selected Amazon Web Services Regions for all Amazon Web Services accounts in your organization (or in the selected organization units). For more information, see [About multiple account and Region resource data syncs](https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resouce-data-sync-multiple-accounts-and-regions.html) in the Amazon Web Services Systems Manager User Guide.
        public var enableAllOpsDataSources: Swift.Bool
        /// Whether to automatically synchronize and aggregate data from new Amazon Web Services Regions when those Regions come online.
        public var includeFutureRegions: Swift.Bool
        /// The SyncSource Amazon Web Services Regions included in the resource data sync.
        public var sourceRegions: [Swift.String]?
        /// The type of data source for the resource data sync. SourceType is either AwsOrganizations (if an organization is present in Organizations) or singleAccountMultiRegions.
        public var sourceType: Swift.String?
        /// The data type name for including resource data sync state. There are four sync states: OrganizationNotExists: Your organization doesn't exist. NoPermissions: The system can't locate the service-linked role. This role is automatically created when a user creates a resource data sync in Explorer. InvalidOrganizationalUnit: You specified or selected an invalid unit in the resource data sync configuration. TrustedAccessDisabled: You disabled Systems Manager access in the organization in Organizations.
        public var state: Swift.String?

        public init (
            awsOrganizationsSource: SsmClientTypes.ResourceDataSyncAwsOrganizationsSource? = nil,
            enableAllOpsDataSources: Swift.Bool = false,
            includeFutureRegions: Swift.Bool = false,
            sourceRegions: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.awsOrganizationsSource = awsOrganizationsSource
            self.enableAllOpsDataSources = enableAllOpsDataSources
            self.includeFutureRegions = includeFutureRegions
            self.sourceRegions = sourceRegions
            self.sourceType = sourceType
            self.state = state
        }
    }

}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Error returned if an attempt is made to delete a patch baseline that is registered for a patch group.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Error returned when the caller has exceeded the default resource quotas. For example, too many maintenance windows or patch baselines have been created. For information about resource quotas in Systems Manager, see [Systems Manager service quotas](https://docs.aws.amazon.com/general/latest/gr/ssm.html#limits_ssm) in the Amazon Web Services General Reference.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case document
        case ec2Instance
        case managedInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .document,
                .ec2Instance,
                .managedInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .document: return "Document"
            case .ec2Instance: return "EC2Instance"
            case .managedInstance: return "ManagedInstance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum ResourceTypeForTagging: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case document
        case maintenanceWindow
        case managedInstance
        case opsmetadata
        case opsItem
        case parameter
        case patchBaseline
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeForTagging] {
            return [
                .document,
                .maintenanceWindow,
                .managedInstance,
                .opsmetadata,
                .opsItem,
                .parameter,
                .patchBaseline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .document: return "Document"
            case .maintenanceWindow: return "MaintenanceWindow"
            case .managedInstance: return "ManagedInstance"
            case .opsmetadata: return "OpsMetadata"
            case .opsItem: return "OpsItem"
            case .parameter: return "Parameter"
            case .patchBaseline: return "PatchBaseline"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceTypeForTagging(rawValue: rawValue) ?? ResourceTypeForTagging.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.ResultAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
    }
}

extension SsmClientTypes.ResultAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResultAttribute(typeName: \(Swift.String(describing: typeName)))"}
}

extension SsmClientTypes {
    /// The inventory item result attribute.
    public struct ResultAttribute: Swift.Equatable {
        /// Name of the inventory item type. Valid value: AWS:InstanceInformation. Default Value: AWS:InstanceInformation.
        /// This member is required.
        public var typeName: Swift.String?

        public init (
            typeName: Swift.String? = nil
        )
        {
            self.typeName = typeName
        }
    }

}

public struct ResumeSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeSessionOutputError>
}

extension ResumeSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeSessionInput(sessionId: \(Swift.String(describing: sessionId)))"}
}

extension ResumeSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

public struct ResumeSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeSessionOutputError>
}

public struct ResumeSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeSessionOutputError>
}

public struct ResumeSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ResumeSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResumeSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeSessionOutputError>
}

public struct ResumeSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ResumeSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResumeSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeSessionOutputError>
}

public struct ResumeSessionInput: Swift.Equatable {
    /// The ID of the disconnected session to resume.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct ResumeSessionInputBody: Swift.Equatable {
    public let sessionId: Swift.String?
}

extension ResumeSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension ResumeSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeSessionOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeSessionOutputResponse(sessionId: \(Swift.String(describing: sessionId)), streamUrl: \(Swift.String(describing: streamUrl)), tokenValue: \(Swift.String(describing: tokenValue)))"}
}

extension ResumeSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResumeSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sessionId = output.sessionId
            self.streamUrl = output.streamUrl
            self.tokenValue = output.tokenValue
        } else {
            self.sessionId = nil
            self.streamUrl = nil
            self.tokenValue = nil
        }
    }
}

public struct ResumeSessionOutputResponse: Swift.Equatable {
    /// The ID of the session.
    public var sessionId: Swift.String?
    /// A URL back to SSM Agent on the managed node that the Session Manager client uses to send commands and receive output from the managed node. Format: wss://ssmmessages.region.amazonaws.com/v1/data-channel/session-id?stream=(input|output). region represents the Region identifier for an Amazon Web Services Region supported by Amazon Web Services Systems Manager, such as us-east-2 for the US East (Ohio) Region. For a list of supported region values, see the Region column in [Systems Manager service endpoints](https://docs.aws.amazon.com/general/latest/gr/ssm.html#ssm_region) in the Amazon Web Services General Reference. session-id represents the ID of a Session Manager session, such as 1a2b3c4dEXAMPLE.
    public var streamUrl: Swift.String?
    /// An encrypted token value containing session and caller information. Used to authenticate the connection to the managed node.
    public var tokenValue: Swift.String?

    public init (
        sessionId: Swift.String? = nil,
        streamUrl: Swift.String? = nil,
        tokenValue: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamUrl = streamUrl
        self.tokenValue = tokenValue
    }
}

struct ResumeSessionOutputResponseBody: Swift.Equatable {
    public let sessionId: Swift.String?
    public let tokenValue: Swift.String?
    public let streamUrl: Swift.String?
}

extension ResumeSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
        case streamUrl = "StreamUrl"
        case tokenValue = "TokenValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let tokenValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenValue)
        tokenValue = tokenValueDecoded
        let streamUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamUrl)
        streamUrl = streamUrlDecoded
    }
}

extension SsmClientTypes.ReviewInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reviewedTime = "ReviewedTime"
        case reviewer = "Reviewer"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reviewedTime = reviewedTime {
            try encodeContainer.encode(reviewedTime.timeIntervalSince1970, forKey: .reviewedTime)
        }
        if let reviewer = reviewer {
            try encodeContainer.encode(reviewer, forKey: .reviewer)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .reviewedTime)
        reviewedTime = reviewedTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .status)
        status = statusDecoded
        let reviewerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewer)
        reviewer = reviewerDecoded
    }
}

extension SsmClientTypes.ReviewInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReviewInformation(reviewedTime: \(Swift.String(describing: reviewedTime)), reviewer: \(Swift.String(describing: reviewer)), status: \(Swift.String(describing: status)))"}
}

extension SsmClientTypes {
    /// Information about the result of a document review request.
    public struct ReviewInformation: Swift.Equatable {
        /// The time that the reviewer took action on the document review request.
        public var reviewedTime: ClientRuntime.Date?
        /// The reviewer assigned to take action on the document review request.
        public var reviewer: Swift.String?
        /// The current status of the document review request.
        public var status: SsmClientTypes.ReviewStatus?

        public init (
            reviewedTime: ClientRuntime.Date? = nil,
            reviewer: Swift.String? = nil,
            status: SsmClientTypes.ReviewStatus? = nil
        )
        {
            self.reviewedTime = reviewedTime
            self.reviewer = reviewer
            self.status = status
        }
    }

}

extension SsmClientTypes {
    public enum ReviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case notReviewed
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewStatus] {
            return [
                .approved,
                .notReviewed,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .notReviewed: return "NOT_REVIEWED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReviewStatus(rawValue: rawValue) ?? ReviewStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.Runbook: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case parameters = "Parameters"
        case targetLocations = "TargetLocations"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension SsmClientTypes.Runbook: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Runbook(documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), parameters: \(Swift.String(describing: parameters)), targetLocations: \(Swift.String(describing: targetLocations)), targetParameterName: \(Swift.String(describing: targetParameterName)), targets: \(Swift.String(describing: targets)))"}
}

extension SsmClientTypes {
    /// Information about an Automation runbook used in a runbook workflow in Change Manager. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
    public struct Runbook: Swift.Equatable {
        /// The name of the Automation runbook used in a runbook workflow.
        /// This member is required.
        public var documentName: Swift.String?
        /// The version of the Automation runbook used in a runbook workflow.
        public var documentVersion: Swift.String?
        /// The MaxConcurrency value specified by the user when the operation started, indicating the maximum number of resources that the runbook operation can run on at the same time.
        public var maxConcurrency: Swift.String?
        /// The MaxErrors value specified by the user when the execution started, indicating the maximum number of errors that can occur during the operation before the updates are stopped or rolled back.
        public var maxErrors: Swift.String?
        /// The key-value map of execution parameters, which were supplied when calling StartChangeRequestExecution.
        public var parameters: [Swift.String:[Swift.String]]?
        /// Information about the Amazon Web Services Regions and Amazon Web Services accounts targeted by the current Runbook operation.
        public var targetLocations: [SsmClientTypes.TargetLocation]?
        /// The name of the parameter used as the target resource for the rate-controlled runbook workflow. Required if you specify Targets.
        public var targetParameterName: Swift.String?
        /// A key-value mapping to target resources that the runbook operation performs tasks on. Required if you specify TargetParameterName.
        public var targets: [SsmClientTypes.Target]?

        public init (
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            targetLocations: [SsmClientTypes.TargetLocation]? = nil,
            targetParameterName: Swift.String? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.parameters = parameters
            self.targetLocations = targetLocations
            self.targetParameterName = targetParameterName
            self.targets = targets
        }
    }

}

extension SsmClientTypes.S3OutputLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
    }
}

extension SsmClientTypes.S3OutputLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3OutputLocation(outputS3BucketName: \(Swift.String(describing: outputS3BucketName)), outputS3KeyPrefix: \(Swift.String(describing: outputS3KeyPrefix)), outputS3Region: \(Swift.String(describing: outputS3Region)))"}
}

extension SsmClientTypes {
    /// An S3 bucket where you want to store the results of this request.
    public struct S3OutputLocation: Swift.Equatable {
        /// The name of the S3 bucket.
        public var outputS3BucketName: Swift.String?
        /// The S3 bucket subfolder.
        public var outputS3KeyPrefix: Swift.String?
        /// The Amazon Web Services Region of the S3 bucket.
        public var outputS3Region: Swift.String?

        public init (
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            outputS3Region: Swift.String? = nil
        )
        {
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.outputS3Region = outputS3Region
        }
    }

}

extension SsmClientTypes.S3OutputUrl: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputUrl = "OutputUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputUrl = outputUrl {
            try encodeContainer.encode(outputUrl, forKey: .outputUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputUrl)
        outputUrl = outputUrlDecoded
    }
}

extension SsmClientTypes.S3OutputUrl: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3OutputUrl(outputUrl: \(Swift.String(describing: outputUrl)))"}
}

extension SsmClientTypes {
    /// A URL for the Amazon Web Services Systems Manager (Systems Manager) bucket where you want to store the results of this request.
    public struct S3OutputUrl: Swift.Equatable {
        /// A URL for an S3 bucket where you want to store the results of this request.
        public var outputUrl: Swift.String?

        public init (
            outputUrl: Swift.String? = nil
        )
        {
            self.outputUrl = outputUrl
        }
    }

}

extension SsmClientTypes.ScheduledWindowExecution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionTime = "ExecutionTime"
        case name = "Name"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionTime = executionTime {
            try encodeContainer.encode(executionTime, forKey: .executionTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let executionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
    }
}

extension SsmClientTypes.ScheduledWindowExecution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduledWindowExecution(executionTime: \(Swift.String(describing: executionTime)), name: \(Swift.String(describing: name)), windowId: \(Swift.String(describing: windowId)))"}
}

extension SsmClientTypes {
    /// Information about a scheduled execution for a maintenance window.
    public struct ScheduledWindowExecution: Swift.Equatable {
        /// The time, in ISO-8601 Extended format, that the maintenance window is scheduled to be run.
        public var executionTime: Swift.String?
        /// The name of the maintenance window to be run.
        public var name: Swift.String?
        /// The ID of the maintenance window to be run.
        public var windowId: Swift.String?

        public init (
            executionTime: Swift.String? = nil,
            name: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.executionTime = executionTime
            self.name = name
            self.windowId = windowId
        }
    }

}

public struct SendAutomationSignalInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendAutomationSignalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendAutomationSignalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendAutomationSignalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendAutomationSignalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendAutomationSignalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendAutomationSignalOutputError>
}

extension SendAutomationSignalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendAutomationSignalInput(automationExecutionId: \(Swift.String(describing: automationExecutionId)), payload: \(Swift.String(describing: payload)), signalType: \(Swift.String(describing: signalType)))"}
}

extension SendAutomationSignalInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case payload = "Payload"
        case signalType = "SignalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let payload = payload {
            var payloadContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .payload)
            for (dictKey0, automationparametermap0) in payload {
                try payloadContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let signalType = signalType {
            try encodeContainer.encode(signalType.rawValue, forKey: .signalType)
        }
    }
}

public struct SendAutomationSignalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendAutomationSignalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendAutomationSignalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendAutomationSignalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendAutomationSignalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendAutomationSignalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendAutomationSignalOutputError>
}

public struct SendAutomationSignalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendAutomationSignalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendAutomationSignalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendAutomationSignalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendAutomationSignalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendAutomationSignalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendAutomationSignalOutputError>
}

public struct SendAutomationSignalInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendAutomationSignalInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SendAutomationSignalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendAutomationSignalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendAutomationSignalInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendAutomationSignalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendAutomationSignalOutputError>
}

public struct SendAutomationSignalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendAutomationSignalInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SendAutomationSignalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendAutomationSignalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendAutomationSignalInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendAutomationSignalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendAutomationSignalOutputError>
}

public struct SendAutomationSignalInput: Swift.Equatable {
    /// The unique identifier for an existing Automation execution that you want to send the signal to.
    /// This member is required.
    public var automationExecutionId: Swift.String?
    /// The data sent with the signal. The data schema depends on the type of signal used in the request. For Approve and Reject signal types, the payload is an optional comment that you can send with the signal type. For example: Comment="Looks good" For StartStep and Resume signal types, you must send the name of the Automation step to start or resume as the payload. For example: StepName="step1" For the StopStep signal type, you must send the step execution ID as the payload. For example: StepExecutionId="97fff367-fc5a-4299-aed8-0123456789ab"
    public var payload: [Swift.String:[Swift.String]]?
    /// The type of signal to send to an Automation execution.
    /// This member is required.
    public var signalType: SsmClientTypes.SignalType?

    public init (
        automationExecutionId: Swift.String? = nil,
        payload: [Swift.String:[Swift.String]]? = nil,
        signalType: SsmClientTypes.SignalType? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
        self.payload = payload
        self.signalType = signalType
    }
}

struct SendAutomationSignalInputBody: Swift.Equatable {
    public let automationExecutionId: Swift.String?
    public let signalType: SsmClientTypes.SignalType?
    public let payload: [Swift.String:[Swift.String]]?
}

extension SendAutomationSignalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case payload = "Payload"
        case signalType = "SignalType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let signalTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SignalType.self, forKey: .signalType)
        signalType = signalTypeDecoded
        let payloadContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .payload)
        var payloadDecoded0: [Swift.String:[Swift.String]]? = nil
        if let payloadContainer = payloadContainer {
            payloadDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in payloadContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                payloadDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        payload = payloadDecoded0
    }
}

extension SendAutomationSignalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendAutomationSignalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFound" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationStepNotFoundException" : self = .automationStepNotFoundException(try AutomationStepNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationSignalException" : self = .invalidAutomationSignalException(try InvalidAutomationSignalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendAutomationSignalOutputError: Swift.Error, Swift.Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case automationStepNotFoundException(AutomationStepNotFoundException)
    case internalServerError(InternalServerError)
    case invalidAutomationSignalException(InvalidAutomationSignalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendAutomationSignalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendAutomationSignalOutputResponse()"}
}

extension SendAutomationSignalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendAutomationSignalOutputResponse: Swift.Equatable {

    public init() {}
}

struct SendAutomationSignalOutputResponseBody: Swift.Equatable {
}

extension SendAutomationSignalOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SendCommandInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendCommandInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendCommandInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendCommandOutputError>
}

extension SendCommandInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendCommandInput(cloudWatchOutputConfig: \(Swift.String(describing: cloudWatchOutputConfig)), comment: \(Swift.String(describing: comment)), documentHash: \(Swift.String(describing: documentHash)), documentHashType: \(Swift.String(describing: documentHashType)), documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), instanceIds: \(Swift.String(describing: instanceIds)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), notificationConfig: \(Swift.String(describing: notificationConfig)), outputS3BucketName: \(Swift.String(describing: outputS3BucketName)), outputS3KeyPrefix: \(Swift.String(describing: outputS3KeyPrefix)), outputS3Region: \(Swift.String(describing: outputS3Region)), parameters: \(Swift.String(describing: parameters)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), timeoutSeconds: \(Swift.String(describing: timeoutSeconds)))"}
}

extension SendCommandInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case comment = "Comment"
        case documentHash = "DocumentHash"
        case documentHashType = "DocumentHashType"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case instanceIds = "InstanceIds"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case parameters = "Parameters"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let documentHash = documentHash {
            try encodeContainer.encode(documentHash, forKey: .documentHash)
        }
        if let documentHashType = documentHashType {
            try encodeContainer.encode(documentHashType.rawValue, forKey: .documentHashType)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }
}

public struct SendCommandInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendCommandInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendCommandInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendCommandOutputError>
}

public struct SendCommandInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendCommandInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendCommandInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendCommandOutputError>
}

public struct SendCommandInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendCommandInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SendCommandInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendCommandInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendCommandOutputError>
}

public struct SendCommandInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendCommandInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SendCommandInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendCommandInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendCommandOutputError>
}

public struct SendCommandInput: Swift.Equatable {
    /// Enables Amazon Web Services Systems Manager to send Run Command output to Amazon CloudWatch Logs. Run Command is a capability of Amazon Web Services Systems Manager.
    public var cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
    /// User-specified information about the command, such as a brief description of what the command should do.
    public var comment: Swift.String?
    /// The Sha256 or Sha1 hash created by the system when the document was created. Sha1 hashes have been deprecated.
    public var documentHash: Swift.String?
    /// Sha256 or Sha1. Sha1 hashes have been deprecated.
    public var documentHashType: SsmClientTypes.DocumentHashType?
    /// The name of the Amazon Web Services Systems Manager document (SSM document) to run. This can be a public document or a custom document. To run a shared document belonging to another account, specify the document Amazon Resource Name (ARN). For more information about how to use shared documents, see [Using shared SSM documents](https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html) in the Amazon Web Services Systems Manager User Guide. If you specify a document name or ARN that hasn't been shared with your account, you receive an InvalidDocument error.
    /// This member is required.
    public var documentName: Swift.String?
    /// The SSM document version to use in the request. You can specify $DEFAULT, $LATEST, or a specific version number. If you run commands by using the Command Line Interface (Amazon Web Services CLI), then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example: --document-version "\$DEFAULT" --document-version "\$LATEST" --document-version "3"
    public var documentVersion: Swift.String?
    /// The IDs of the managed nodes where the command should run. Specifying managed node IDs is most useful when you are targeting a limited number of managed nodes, though you can specify up to 50 IDs. To target a larger number of managed nodes, or if you prefer not to list individual node IDs, we recommend using the Targets option instead. Using Targets, which accepts tag key-value pairs to identify the managed nodes to send commands to, you can a send command to tens, hundreds, or thousands of nodes at once. For more information about how to use targets, see [Using targets and rate controls to send commands to a fleet](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html) in the Amazon Web Services Systems Manager User Guide.
    public var instanceIds: [Swift.String]?
    /// (Optional) The maximum number of managed nodes that are allowed to run the command at the same time. You can specify a number such as 10 or a percentage such as 10%. The default value is 50. For more information about how to use MaxConcurrency, see [Using concurrency controls](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-velocity) in the Amazon Web Services Systems Manager User Guide.
    public var maxConcurrency: Swift.String?
    /// The maximum number of errors allowed without the command failing. When the command fails one more time beyond the value of MaxErrors, the systems stops sending the command to additional targets. You can specify a number like 10 or a percentage like 10%. The default value is 0. For more information about how to use MaxErrors, see [Using error controls](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-maxerrors) in the Amazon Web Services Systems Manager User Guide.
    public var maxErrors: Swift.String?
    /// Configurations for sending notifications.
    public var notificationConfig: SsmClientTypes.NotificationConfig?
    /// The name of the S3 bucket where command execution responses should be stored.
    public var outputS3BucketName: Swift.String?
    /// The directory structure within the S3 bucket where the responses should be stored.
    public var outputS3KeyPrefix: Swift.String?
    /// (Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager automatically determines the Amazon Web Services Region of the S3 bucket.
    public var outputS3Region: Swift.String?
    /// The required and optional parameters specified in the document being run.
    public var parameters: [Swift.String:[Swift.String]]?
    /// The ARN of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for Run Command commands.
    public var serviceRoleArn: Swift.String?
    /// An array of search criteria that targets managed nodes using a Key,Value combination that you specify. Specifying targets is most useful when you want to send a command to a large number of managed nodes at once. Using Targets, which accepts tag key-value pairs to identify managed nodes, you can send a command to tens, hundreds, or thousands of nodes at once. To send a command to a smaller number of managed nodes, you can use the InstanceIds option instead. For more information about how to use targets, see [Sending commands to a fleet](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html) in the Amazon Web Services Systems Manager User Guide.
    public var targets: [SsmClientTypes.Target]?
    /// If this time is reached and the command hasn't already started running, it won't run.
    public var timeoutSeconds: Swift.Int

    public init (
        cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig? = nil,
        comment: Swift.String? = nil,
        documentHash: Swift.String? = nil,
        documentHashType: SsmClientTypes.DocumentHashType? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        instanceIds: [Swift.String]? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        notificationConfig: SsmClientTypes.NotificationConfig? = nil,
        outputS3BucketName: Swift.String? = nil,
        outputS3KeyPrefix: Swift.String? = nil,
        outputS3Region: Swift.String? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        serviceRoleArn: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        timeoutSeconds: Swift.Int = 0
    )
    {
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.comment = comment
        self.documentHash = documentHash
        self.documentHashType = documentHashType
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.instanceIds = instanceIds
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.notificationConfig = notificationConfig
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.outputS3Region = outputS3Region
        self.parameters = parameters
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.timeoutSeconds = timeoutSeconds
    }
}

struct SendCommandInputBody: Swift.Equatable {
    public let instanceIds: [Swift.String]?
    public let targets: [SsmClientTypes.Target]?
    public let documentName: Swift.String?
    public let documentVersion: Swift.String?
    public let documentHash: Swift.String?
    public let documentHashType: SsmClientTypes.DocumentHashType?
    public let timeoutSeconds: Swift.Int
    public let comment: Swift.String?
    public let parameters: [Swift.String:[Swift.String]]?
    public let outputS3Region: Swift.String?
    public let outputS3BucketName: Swift.String?
    public let outputS3KeyPrefix: Swift.String?
    public let maxConcurrency: Swift.String?
    public let maxErrors: Swift.String?
    public let serviceRoleArn: Swift.String?
    public let notificationConfig: SsmClientTypes.NotificationConfig?
    public let cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
}

extension SendCommandInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case comment = "Comment"
        case documentHash = "DocumentHash"
        case documentHashType = "DocumentHashType"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case instanceIds = "InstanceIds"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case parameters = "Parameters"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentHash)
        documentHash = documentHashDecoded
        let documentHashTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentHashType.self, forKey: .documentHashType)
        documentHashType = documentHashTypeDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
    }
}

extension SendCommandOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendCommandOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateInstanceId" : self = .duplicateInstanceId(try DuplicateInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNotificationConfig" : self = .invalidNotificationConfig(try InvalidNotificationConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputFolder" : self = .invalidOutputFolder(try InvalidOutputFolder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRole" : self = .invalidRole(try InvalidRole(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxDocumentSizeExceeded" : self = .maxDocumentSizeExceeded(try MaxDocumentSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlatformType" : self = .unsupportedPlatformType(try UnsupportedPlatformType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendCommandOutputError: Swift.Error, Swift.Equatable {
    case duplicateInstanceId(DuplicateInstanceId)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNotificationConfig(InvalidNotificationConfig)
    case invalidOutputFolder(InvalidOutputFolder)
    case invalidParameters(InvalidParameters)
    case invalidRole(InvalidRole)
    case maxDocumentSizeExceeded(MaxDocumentSizeExceeded)
    case unsupportedPlatformType(UnsupportedPlatformType)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendCommandOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendCommandOutputResponse(command: \(Swift.String(describing: command)))"}
}

extension SendCommandOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendCommandOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.command = output.command
        } else {
            self.command = nil
        }
    }
}

public struct SendCommandOutputResponse: Swift.Equatable {
    /// The request as it was received by Systems Manager. Also provides the command ID which can be used future references to this request.
    public var command: SsmClientTypes.Command?

    public init (
        command: SsmClientTypes.Command? = nil
    )
    {
        self.command = command
    }
}

struct SendCommandOutputResponseBody: Swift.Equatable {
    public let command: SsmClientTypes.Command?
}

extension SendCommandOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command = "Command"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandDecoded = try containerValues.decodeIfPresent(SsmClientTypes.Command.self, forKey: .command)
        command = commandDecoded
    }
}

extension SsmClientTypes.ServiceSetting: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case settingId = "SettingId"
        case settingValue = "SettingValue"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
        if let settingValue = settingValue {
            try encodeContainer.encode(settingValue, forKey: .settingValue)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingId)
        settingId = settingIdDecoded
        let settingValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingValue)
        settingValue = settingValueDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SsmClientTypes.ServiceSetting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSetting(aRN: \(Swift.String(describing: aRN)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), lastModifiedUser: \(Swift.String(describing: lastModifiedUser)), settingId: \(Swift.String(describing: settingId)), settingValue: \(Swift.String(describing: settingValue)), status: \(Swift.String(describing: status)))"}
}

extension SsmClientTypes {
    /// The service setting data structure. ServiceSetting is an account-level setting for an Amazon Web Services service. This setting defines how a user interacts with or uses a service or a feature of a service. For example, if an Amazon Web Services service charges money to the account based on feature or service usage, then the Amazon Web Services service team might create a default setting of "false". This means the user can't use this feature unless they change the setting to "true" and intentionally opt in for a paid feature. Services map a SettingId object to a setting value. Amazon Web Services services teams define the default value for a SettingId. You can't create a new SettingId, but you can overwrite the default value if you have the ssm:UpdateServiceSetting permission for the setting. Use the [UpdateServiceSetting] API operation to change the default setting. Or, use the [ResetServiceSetting] to change the value back to the original value defined by the Amazon Web Services service team.
    public struct ServiceSetting: Swift.Equatable {
        /// The ARN of the service setting.
        public var aRN: Swift.String?
        /// The last time the service setting was modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The ARN of the last modified user. This field is populated only if the setting value was overwritten.
        public var lastModifiedUser: Swift.String?
        /// The ID of the service setting.
        public var settingId: Swift.String?
        /// The value of the service setting.
        public var settingValue: Swift.String?
        /// The status of the service setting. The value can be Default, Customized or PendingUpdate.
        ///
        /// * Default: The current setting uses a default value provisioned by the Amazon Web Services service team.
        ///
        /// * Customized: The current setting use a custom value specified by the customer.
        ///
        /// * PendingUpdate: The current setting uses a default or custom value, but a setting change request is pending approval.
        public var status: Swift.String?

        public init (
            aRN: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            settingId: Swift.String? = nil,
            settingValue: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.aRN = aRN
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.settingId = settingId
            self.settingValue = settingValue
            self.status = status
        }
    }

}

extension ServiceSettingNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSettingNotFound(message: \(Swift.String(describing: message)))"}
}

extension ServiceSettingNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceSettingNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified service setting wasn't found. Either the service name or the setting hasn't been provisioned by the Amazon Web Services service team.
public struct ServiceSettingNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceSettingNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceSettingNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.Session: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case documentName = "DocumentName"
        case endDate = "EndDate"
        case maxSessionDuration = "MaxSessionDuration"
        case outputUrl = "OutputUrl"
        case owner = "Owner"
        case reason = "Reason"
        case sessionId = "SessionId"
        case startDate = "StartDate"
        case status = "Status"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate.timeIntervalSince1970, forKey: .endDate)
        }
        if let maxSessionDuration = maxSessionDuration {
            try encodeContainer.encode(maxSessionDuration, forKey: .maxSessionDuration)
        }
        if let outputUrl = outputUrl {
            try encodeContainer.encode(outputUrl, forKey: .outputUrl)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SessionStatus.self, forKey: .status)
        status = statusDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endDate)
        endDate = endDateDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
        let outputUrlDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SessionManagerOutputUrl.self, forKey: .outputUrl)
        outputUrl = outputUrlDecoded
        let maxSessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxSessionDuration)
        maxSessionDuration = maxSessionDurationDecoded
    }
}

extension SsmClientTypes.Session: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Session(details: \(Swift.String(describing: details)), documentName: \(Swift.String(describing: documentName)), endDate: \(Swift.String(describing: endDate)), maxSessionDuration: \(Swift.String(describing: maxSessionDuration)), outputUrl: \(Swift.String(describing: outputUrl)), owner: \(Swift.String(describing: owner)), reason: \(Swift.String(describing: reason)), sessionId: \(Swift.String(describing: sessionId)), startDate: \(Swift.String(describing: startDate)), status: \(Swift.String(describing: status)), target: \(Swift.String(describing: target)))"}
}

extension SsmClientTypes {
    /// Information about a Session Manager connection to a managed node.
    public struct Session: Swift.Equatable {
        /// Reserved for future use.
        public var details: Swift.String?
        /// The name of the Session Manager SSM document used to define the parameters and plugin settings for the session. For example, SSM-SessionManagerRunShell.
        public var documentName: Swift.String?
        /// The date and time, in ISO-8601 Extended format, when the session was terminated.
        public var endDate: ClientRuntime.Date?
        /// The maximum duration of a session before it terminates.
        public var maxSessionDuration: Swift.String?
        /// Reserved for future use.
        public var outputUrl: SsmClientTypes.SessionManagerOutputUrl?
        /// The ID of the Amazon Web Services user account that started the session.
        public var owner: Swift.String?
        /// The reason for connecting to the instance.
        public var reason: Swift.String?
        /// The ID of the session.
        public var sessionId: Swift.String?
        /// The date and time, in ISO-8601 Extended format, when the session began.
        public var startDate: ClientRuntime.Date?
        /// The status of the session. For example, "Connected" or "Terminated".
        public var status: SsmClientTypes.SessionStatus?
        /// The managed node that the Session Manager session connected to.
        public var target: Swift.String?

        public init (
            details: Swift.String? = nil,
            documentName: Swift.String? = nil,
            endDate: ClientRuntime.Date? = nil,
            maxSessionDuration: Swift.String? = nil,
            outputUrl: SsmClientTypes.SessionManagerOutputUrl? = nil,
            owner: Swift.String? = nil,
            reason: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            startDate: ClientRuntime.Date? = nil,
            status: SsmClientTypes.SessionStatus? = nil,
            target: Swift.String? = nil
        )
        {
            self.details = details
            self.documentName = documentName
            self.endDate = endDate
            self.maxSessionDuration = maxSessionDuration
            self.outputUrl = outputUrl
            self.owner = owner
            self.reason = reason
            self.sessionId = sessionId
            self.startDate = startDate
            self.status = status
            self.target = target
        }
    }

}

extension SsmClientTypes.SessionFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SessionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes.SessionFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionFilter(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SsmClientTypes {
    /// Describes a filter for Session Manager information.
    public struct SessionFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: SsmClientTypes.SessionFilterKey?
        /// The filter value. Valid values for each filter key are as follows:
        ///
        /// * InvokedAfter: Specify a timestamp to limit your results. For example, specify 2018-08-29T00:00:00Z to see sessions that started August 29, 2018, and later.
        ///
        /// * InvokedBefore: Specify a timestamp to limit your results. For example, specify 2018-08-29T00:00:00Z to see sessions that started before August 29, 2018.
        ///
        /// * Target: Specify a managed node to which session connections have been made.
        ///
        /// * Owner: Specify an Amazon Web Services user account to see a list of sessions started by that user.
        ///
        /// * Status: Specify a valid session status to see a list of all sessions with that status. Status values you can specify include:
        ///
        /// * Connected
        ///
        /// * Connecting
        ///
        /// * Disconnected
        ///
        /// * Terminated
        ///
        /// * Terminating
        ///
        /// * Failed
        ///
        ///
        ///
        ///
        /// * SessionId: Specify a session ID to return details about the session.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.SessionFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum SessionFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invokedAfter
        case invokedBefore
        case owner
        case sessionId
        case status
        case targetId
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionFilterKey] {
            return [
                .invokedAfter,
                .invokedBefore,
                .owner,
                .sessionId,
                .status,
                .targetId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invokedAfter: return "InvokedAfter"
            case .invokedBefore: return "InvokedBefore"
            case .owner: return "Owner"
            case .sessionId: return "SessionId"
            case .status: return "Status"
            case .targetId: return "Target"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionFilterKey(rawValue: rawValue) ?? SessionFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.SessionManagerOutputUrl: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputUrl = "CloudWatchOutputUrl"
        case s3OutputUrl = "S3OutputUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputUrl = cloudWatchOutputUrl {
            try encodeContainer.encode(cloudWatchOutputUrl, forKey: .cloudWatchOutputUrl)
        }
        if let s3OutputUrl = s3OutputUrl {
            try encodeContainer.encode(s3OutputUrl, forKey: .s3OutputUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3OutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3OutputUrl)
        s3OutputUrl = s3OutputUrlDecoded
        let cloudWatchOutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchOutputUrl)
        cloudWatchOutputUrl = cloudWatchOutputUrlDecoded
    }
}

extension SsmClientTypes.SessionManagerOutputUrl: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionManagerOutputUrl(cloudWatchOutputUrl: \(Swift.String(describing: cloudWatchOutputUrl)), s3OutputUrl: \(Swift.String(describing: s3OutputUrl)))"}
}

extension SsmClientTypes {
    /// Reserved for future use.
    public struct SessionManagerOutputUrl: Swift.Equatable {
        /// Reserved for future use.
        public var cloudWatchOutputUrl: Swift.String?
        /// Reserved for future use.
        public var s3OutputUrl: Swift.String?

        public init (
            cloudWatchOutputUrl: Swift.String? = nil,
            s3OutputUrl: Swift.String? = nil
        )
        {
            self.cloudWatchOutputUrl = cloudWatchOutputUrl
            self.s3OutputUrl = s3OutputUrl
        }
    }

}

extension SsmClientTypes {
    public enum SessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case history
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionState] {
            return [
                .active,
                .history,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .history: return "History"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionState(rawValue: rawValue) ?? SessionState.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum SessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case connecting
        case disconnected
        case failed
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionStatus] {
            return [
                .connected,
                .connecting,
                .disconnected,
                .failed,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .connecting: return "Connecting"
            case .disconnected: return "Disconnected"
            case .failed: return "Failed"
            case .terminated: return "Terminated"
            case .terminating: return "Terminating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionStatus(rawValue: rawValue) ?? SessionStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.SeveritySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criticalCount = "CriticalCount"
        case highCount = "HighCount"
        case informationalCount = "InformationalCount"
        case lowCount = "LowCount"
        case mediumCount = "MediumCount"
        case unspecifiedCount = "UnspecifiedCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if criticalCount != 0 {
            try encodeContainer.encode(criticalCount, forKey: .criticalCount)
        }
        if highCount != 0 {
            try encodeContainer.encode(highCount, forKey: .highCount)
        }
        if informationalCount != 0 {
            try encodeContainer.encode(informationalCount, forKey: .informationalCount)
        }
        if lowCount != 0 {
            try encodeContainer.encode(lowCount, forKey: .lowCount)
        }
        if mediumCount != 0 {
            try encodeContainer.encode(mediumCount, forKey: .mediumCount)
        }
        if unspecifiedCount != 0 {
            try encodeContainer.encode(unspecifiedCount, forKey: .unspecifiedCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criticalCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .criticalCount)
        criticalCount = criticalCountDecoded
        let highCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .highCount)
        highCount = highCountDecoded
        let mediumCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .mediumCount)
        mediumCount = mediumCountDecoded
        let lowCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .lowCount)
        lowCount = lowCountDecoded
        let informationalCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .informationalCount)
        informationalCount = informationalCountDecoded
        let unspecifiedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .unspecifiedCount)
        unspecifiedCount = unspecifiedCountDecoded
    }
}

extension SsmClientTypes.SeveritySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SeveritySummary(criticalCount: \(Swift.String(describing: criticalCount)), highCount: \(Swift.String(describing: highCount)), informationalCount: \(Swift.String(describing: informationalCount)), lowCount: \(Swift.String(describing: lowCount)), mediumCount: \(Swift.String(describing: mediumCount)), unspecifiedCount: \(Swift.String(describing: unspecifiedCount)))"}
}

extension SsmClientTypes {
    /// The number of managed nodes found for each patch severity level defined in the request filter.
    public struct SeveritySummary: Swift.Equatable {
        /// The total number of resources or compliance items that have a severity level of critical. Critical severity is determined by the organization that published the compliance items.
        public var criticalCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of high. High severity is determined by the organization that published the compliance items.
        public var highCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of informational. Informational severity is determined by the organization that published the compliance items.
        public var informationalCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of low. Low severity is determined by the organization that published the compliance items.
        public var lowCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of medium. Medium severity is determined by the organization that published the compliance items.
        public var mediumCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of unspecified. Unspecified severity is determined by the organization that published the compliance items.
        public var unspecifiedCount: Swift.Int

        public init (
            criticalCount: Swift.Int = 0,
            highCount: Swift.Int = 0,
            informationalCount: Swift.Int = 0,
            lowCount: Swift.Int = 0,
            mediumCount: Swift.Int = 0,
            unspecifiedCount: Swift.Int = 0
        )
        {
            self.criticalCount = criticalCount
            self.highCount = highCount
            self.informationalCount = informationalCount
            self.lowCount = lowCount
            self.mediumCount = mediumCount
            self.unspecifiedCount = unspecifiedCount
        }
    }

}

extension SsmClientTypes {
    public enum SignalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approve
        case reject
        case resume
        case startStep
        case stopStep
        case sdkUnknown(Swift.String)

        public static var allCases: [SignalType] {
            return [
                .approve,
                .reject,
                .resume,
                .startStep,
                .stopStep,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approve: return "Approve"
            case .reject: return "Reject"
            case .resume: return "Resume"
            case .startStep: return "StartStep"
            case .stopStep: return "StopStep"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SignalType(rawValue: rawValue) ?? SignalType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsEc2Instance
        case awsIotThing
        case awsSsmManagedinstance
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .awsEc2Instance,
                .awsIotThing,
                .awsSsmManagedinstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS::EC2::Instance"
            case .awsIotThing: return "AWS::IoT::Thing"
            case .awsSsmManagedinstance: return "AWS::SSM::ManagedInstance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

public struct StartAssociationsOnceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAssociationsOnceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAssociationsOnceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAssociationsOnceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAssociationsOnceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAssociationsOnceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAssociationsOnceOutputError>
}

extension StartAssociationsOnceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAssociationsOnceInput(associationIds: \(Swift.String(describing: associationIds)))"}
}

extension StartAssociationsOnceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationIds = "AssociationIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationIds = associationIds {
            var associationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associationIds)
            for associationidlist0 in associationIds {
                try associationIdsContainer.encode(associationidlist0)
            }
        }
    }
}

public struct StartAssociationsOnceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAssociationsOnceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAssociationsOnceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAssociationsOnceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAssociationsOnceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAssociationsOnceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAssociationsOnceOutputError>
}

public struct StartAssociationsOnceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAssociationsOnceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAssociationsOnceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAssociationsOnceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAssociationsOnceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAssociationsOnceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAssociationsOnceOutputError>
}

public struct StartAssociationsOnceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAssociationsOnceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartAssociationsOnceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAssociationsOnceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartAssociationsOnceInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartAssociationsOnceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAssociationsOnceOutputError>
}

public struct StartAssociationsOnceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAssociationsOnceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartAssociationsOnceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAssociationsOnceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartAssociationsOnceInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartAssociationsOnceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAssociationsOnceOutputError>
}

public struct StartAssociationsOnceInput: Swift.Equatable {
    /// The association IDs that you want to run immediately and only one time.
    /// This member is required.
    public var associationIds: [Swift.String]?

    public init (
        associationIds: [Swift.String]? = nil
    )
    {
        self.associationIds = associationIds
    }
}

struct StartAssociationsOnceInputBody: Swift.Equatable {
    public let associationIds: [Swift.String]?
}

extension StartAssociationsOnceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationIds = "AssociationIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associationIds)
        var associationIdsDecoded0:[Swift.String]? = nil
        if let associationIdsContainer = associationIdsContainer {
            associationIdsDecoded0 = [Swift.String]()
            for string0 in associationIdsContainer {
                if let string0 = string0 {
                    associationIdsDecoded0?.append(string0)
                }
            }
        }
        associationIds = associationIdsDecoded0
    }
}

extension StartAssociationsOnceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAssociationsOnceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAssociation" : self = .invalidAssociation(try InvalidAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAssociationsOnceOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case invalidAssociation(InvalidAssociation)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAssociationsOnceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAssociationsOnceOutputResponse()"}
}

extension StartAssociationsOnceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartAssociationsOnceOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartAssociationsOnceOutputResponseBody: Swift.Equatable {
}

extension StartAssociationsOnceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct StartAutomationExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAutomationExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAutomationExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAutomationExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAutomationExecutionOutputError>
}

extension StartAutomationExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAutomationExecutionInput(clientToken: \(Swift.String(describing: clientToken)), documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), mode: \(Swift.String(describing: mode)), parameters: \(Swift.String(describing: parameters)), tags: \(Swift.String(describing: tags)), targetLocations: \(Swift.String(describing: targetLocations)), targetMaps: \(Swift.String(describing: targetMaps)), targetParameterName: \(Swift.String(describing: targetParameterName)), targets: \(Swift.String(describing: targets)))"}
}

extension StartAutomationExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case parameters = "Parameters"
        case tags = "Tags"
        case targetLocations = "TargetLocations"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targetMaps = targetMaps {
            var targetMapsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetMaps)
            for targetmaps0 in targetMaps {
                var targetmaps0Container = targetMapsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, targetmap1) in targetmaps0 {
                    var targetmap1Container = targetmaps0Container.nestedUnkeyedContainer(forKey: ClientRuntime.Key(dictKey1))
                    for targetmapvaluelist2 in targetmap1 {
                        try targetmap1Container.encode(targetmapvaluelist2)
                    }
                }
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct StartAutomationExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAutomationExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAutomationExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAutomationExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAutomationExecutionOutputError>
}

public struct StartAutomationExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAutomationExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAutomationExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAutomationExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAutomationExecutionOutputError>
}

public struct StartAutomationExecutionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAutomationExecutionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartAutomationExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartAutomationExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAutomationExecutionOutputError>
}

public struct StartAutomationExecutionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAutomationExecutionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartAutomationExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartAutomationExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAutomationExecutionOutputError>
}

public struct StartAutomationExecutionInput: Swift.Equatable {
    /// User-provided idempotency token. The token must be unique, is case insensitive, enforces the UUID format, and can't be reused.
    public var clientToken: Swift.String?
    /// The name of the SSM document to run. This can be a public document or a custom document. To run a shared document belonging to another account, specify the document ARN. For more information about how to use shared documents, see [Using shared SSM documents](https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html) in the Amazon Web Services Systems Manager User Guide.
    /// This member is required.
    public var documentName: Swift.String?
    /// The version of the Automation runbook to use for this execution.
    public var documentVersion: Swift.String?
    /// The maximum number of targets allowed to run this task in parallel. You can specify a number, such as 10, or a percentage, such as 10%. The default value is 10.
    public var maxConcurrency: Swift.String?
    /// The number of errors that are allowed before the system stops running the automation on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops running the automation when the fourth error is received. If you specify 0, then the system stops running the automation on additional targets after the first error result is returned. If you run an automation on 50 resources and set max-errors to 10%, then the system stops running the automation on additional targets when the sixth error is received. Executions that are already running an automation when max-errors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set max-concurrency to 1 so the executions proceed one at a time.
    public var maxErrors: Swift.String?
    /// The execution mode of the automation. Valid modes include the following: Auto and Interactive. The default mode is Auto.
    public var mode: SsmClientTypes.ExecutionMode?
    /// A key-value map of execution parameters, which match the declared parameters in the Automation runbook.
    public var parameters: [Swift.String:[Swift.String]]?
    /// Optional metadata that you assign to a resource. You can specify a maximum of five tags for an automation. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an automation to identify an environment or operating system. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=environment,Value=test
    ///
    /// * Key=OS,Value=Windows
    ///
    ///
    /// To add tags to an existing patch baseline, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?
    /// A location is a combination of Amazon Web Services Regions and/or Amazon Web Services accounts where you want to run the automation. Use this operation to start an automation in multiple Amazon Web Services Regions and multiple Amazon Web Services accounts. For more information, see [Running Automation workflows in multiple Amazon Web Services Regions and Amazon Web Services accounts](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html) in the Amazon Web Services Systems Manager User Guide.
    public var targetLocations: [SsmClientTypes.TargetLocation]?
    /// A key-value mapping of document parameters to target resources. Both Targets and TargetMaps can't be specified together.
    public var targetMaps: [[Swift.String:[Swift.String]]]?
    /// The name of the parameter used as the target resource for the rate-controlled execution. Required if you specify targets.
    public var targetParameterName: Swift.String?
    /// A key-value mapping to target resources. Required if you specify TargetParameterName.
    public var targets: [SsmClientTypes.Target]?

    public init (
        clientToken: Swift.String? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        mode: SsmClientTypes.ExecutionMode? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        tags: [SsmClientTypes.Tag]? = nil,
        targetLocations: [SsmClientTypes.TargetLocation]? = nil,
        targetMaps: [[Swift.String:[Swift.String]]]? = nil,
        targetParameterName: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil
    )
    {
        self.clientToken = clientToken
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.mode = mode
        self.parameters = parameters
        self.tags = tags
        self.targetLocations = targetLocations
        self.targetMaps = targetMaps
        self.targetParameterName = targetParameterName
        self.targets = targets
    }
}

struct StartAutomationExecutionInputBody: Swift.Equatable {
    public let documentName: Swift.String?
    public let documentVersion: Swift.String?
    public let parameters: [Swift.String:[Swift.String]]?
    public let clientToken: Swift.String?
    public let mode: SsmClientTypes.ExecutionMode?
    public let targetParameterName: Swift.String?
    public let targets: [SsmClientTypes.Target]?
    public let targetMaps: [[Swift.String:[Swift.String]]]?
    public let maxConcurrency: Swift.String?
    public let maxErrors: Swift.String?
    public let targetLocations: [SsmClientTypes.TargetLocation]?
    public let tags: [SsmClientTypes.Tag]?
}

extension StartAutomationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case parameters = "Parameters"
        case tags = "Tags"
        case targetLocations = "TargetLocations"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let modeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ExecutionMode.self, forKey: .mode)
        mode = modeDecoded
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetMapsContainer = try containerValues.decodeIfPresent([[Swift.String: [Swift.String?]?]?].self, forKey: .targetMaps)
        var targetMapsDecoded0:[[Swift.String:[Swift.String]]]? = nil
        if let targetMapsContainer = targetMapsContainer {
            targetMapsDecoded0 = [[Swift.String:[Swift.String]]]()
            for map0 in targetMapsContainer {
                var targetMapsContainerDecoded0: [Swift.String: [Swift.String]]? = nil
                if let map0 = map0 {
                    targetMapsContainerDecoded0 = [Swift.String: [Swift.String]]()
                    for (key1, targetmapvaluelist1) in map0 {
                        var targetmapvaluelist1Decoded1: [Swift.String]? = nil
                        if let targetmapvaluelist1 = targetmapvaluelist1 {
                            targetmapvaluelist1Decoded1 = [Swift.String]()
                            for string2 in targetmapvaluelist1 {
                                if let string2 = string2 {
                                    targetmapvaluelist1Decoded1?.append(string2)
                                }
                            }
                        }
                        targetMapsContainerDecoded0?[key1] = targetmapvaluelist1Decoded1
                    }
                }
                if let targetMapsContainerDecoded0 = targetMapsContainerDecoded0 {
                    targetMapsDecoded0?.append(targetMapsContainerDecoded0)
                }
            }
        }
        targetMaps = targetMapsDecoded0
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartAutomationExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAutomationExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationDefinitionNotFound" : self = .automationDefinitionNotFoundException(try AutomationDefinitionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationDefinitionVersionNotFound" : self = .automationDefinitionVersionNotFoundException(try AutomationDefinitionVersionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationExecutionLimitExceeded" : self = .automationExecutionLimitExceededException(try AutomationExecutionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationExecutionParameters" : self = .invalidAutomationExecutionParametersException(try InvalidAutomationExecutionParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAutomationExecutionOutputError: Swift.Error, Swift.Equatable {
    case automationDefinitionNotFoundException(AutomationDefinitionNotFoundException)
    case automationDefinitionVersionNotFoundException(AutomationDefinitionVersionNotFoundException)
    case automationExecutionLimitExceededException(AutomationExecutionLimitExceededException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case invalidAutomationExecutionParametersException(InvalidAutomationExecutionParametersException)
    case invalidTarget(InvalidTarget)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAutomationExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAutomationExecutionOutputResponse(automationExecutionId: \(Swift.String(describing: automationExecutionId)))"}
}

extension StartAutomationExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartAutomationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automationExecutionId = output.automationExecutionId
        } else {
            self.automationExecutionId = nil
        }
    }
}

public struct StartAutomationExecutionOutputResponse: Swift.Equatable {
    /// The unique ID of a newly scheduled automation execution.
    public var automationExecutionId: Swift.String?

    public init (
        automationExecutionId: Swift.String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

struct StartAutomationExecutionOutputResponseBody: Swift.Equatable {
    public let automationExecutionId: Swift.String?
}

extension StartAutomationExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
    }
}

public struct StartChangeRequestExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartChangeRequestExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartChangeRequestExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartChangeRequestExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartChangeRequestExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartChangeRequestExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartChangeRequestExecutionOutputError>
}

extension StartChangeRequestExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartChangeRequestExecutionInput(autoApprove: \(Swift.String(describing: autoApprove)), changeDetails: \(Swift.String(describing: changeDetails)), changeRequestName: \(Swift.String(describing: changeRequestName)), clientToken: \(Swift.String(describing: clientToken)), documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), parameters: \(Swift.String(describing: parameters)), runbooks: \(Swift.String(describing: runbooks)), scheduledEndTime: \(Swift.String(describing: scheduledEndTime)), scheduledTime: \(Swift.String(describing: scheduledTime)), tags: \(Swift.String(describing: tags)))"}
}

extension StartChangeRequestExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoApprove = "AutoApprove"
        case changeDetails = "ChangeDetails"
        case changeRequestName = "ChangeRequestName"
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case parameters = "Parameters"
        case runbooks = "Runbooks"
        case scheduledEndTime = "ScheduledEndTime"
        case scheduledTime = "ScheduledTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoApprove != false {
            try encodeContainer.encode(autoApprove, forKey: .autoApprove)
        }
        if let changeDetails = changeDetails {
            try encodeContainer.encode(changeDetails, forKey: .changeDetails)
        }
        if let changeRequestName = changeRequestName {
            try encodeContainer.encode(changeRequestName, forKey: .changeRequestName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let runbooks = runbooks {
            var runbooksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runbooks)
            for runbooks0 in runbooks {
                try runbooksContainer.encode(runbooks0)
            }
        }
        if let scheduledEndTime = scheduledEndTime {
            try encodeContainer.encode(scheduledEndTime.timeIntervalSince1970, forKey: .scheduledEndTime)
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct StartChangeRequestExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartChangeRequestExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartChangeRequestExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartChangeRequestExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartChangeRequestExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartChangeRequestExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartChangeRequestExecutionOutputError>
}

public struct StartChangeRequestExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartChangeRequestExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartChangeRequestExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartChangeRequestExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartChangeRequestExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartChangeRequestExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartChangeRequestExecutionOutputError>
}

public struct StartChangeRequestExecutionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartChangeRequestExecutionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartChangeRequestExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartChangeRequestExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartChangeRequestExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartChangeRequestExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartChangeRequestExecutionOutputError>
}

public struct StartChangeRequestExecutionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartChangeRequestExecutionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartChangeRequestExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartChangeRequestExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartChangeRequestExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartChangeRequestExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartChangeRequestExecutionOutputError>
}

public struct StartChangeRequestExecutionInput: Swift.Equatable {
    /// Indicates whether the change request can be approved automatically without the need for manual approvals. If AutoApprovable is enabled in a change template, then setting AutoApprove to true in StartChangeRequestExecution creates a change request that bypasses approver review. Change Calendar restrictions are not bypassed in this scenario. If the state of an associated calendar is CLOSED, change freeze approvers must still grant permission for this change request to run. If they don't, the change won't be processed until the calendar state is again OPEN.
    public var autoApprove: Swift.Bool
    /// User-provided details about the change. If no details are provided, content specified in the Template information section of the associated change template is added.
    public var changeDetails: Swift.String?
    /// The name of the change request associated with the runbook workflow to be run.
    public var changeRequestName: Swift.String?
    /// The user-provided idempotency token. The token must be unique, is case insensitive, enforces the UUID format, and can't be reused.
    public var clientToken: Swift.String?
    /// The name of the change template document to run during the runbook workflow.
    /// This member is required.
    public var documentName: Swift.String?
    /// The version of the change template document to run during the runbook workflow.
    public var documentVersion: Swift.String?
    /// A key-value map of parameters that match the declared parameters in the change template document.
    public var parameters: [Swift.String:[Swift.String]]?
    /// Information about the Automation runbooks that are run during the runbook workflow. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
    /// This member is required.
    public var runbooks: [SsmClientTypes.Runbook]?
    /// The time that the requester expects the runbook workflow related to the change request to complete. The time is an estimate only that the requester provides for reviewers.
    public var scheduledEndTime: ClientRuntime.Date?
    /// The date and time specified in the change request to run the Automation runbooks. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
    public var scheduledTime: ClientRuntime.Date?
    /// Optional metadata that you assign to a resource. You can specify a maximum of five tags for a change request. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a change request to identify an environment or target Amazon Web Services Region. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=Environment,Value=Production
    ///
    /// * Key=Region,Value=us-east-2
    public var tags: [SsmClientTypes.Tag]?

    public init (
        autoApprove: Swift.Bool = false,
        changeDetails: Swift.String? = nil,
        changeRequestName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        runbooks: [SsmClientTypes.Runbook]? = nil,
        scheduledEndTime: ClientRuntime.Date? = nil,
        scheduledTime: ClientRuntime.Date? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.autoApprove = autoApprove
        self.changeDetails = changeDetails
        self.changeRequestName = changeRequestName
        self.clientToken = clientToken
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.parameters = parameters
        self.runbooks = runbooks
        self.scheduledEndTime = scheduledEndTime
        self.scheduledTime = scheduledTime
        self.tags = tags
    }
}

struct StartChangeRequestExecutionInputBody: Swift.Equatable {
    public let scheduledTime: ClientRuntime.Date?
    public let documentName: Swift.String?
    public let documentVersion: Swift.String?
    public let parameters: [Swift.String:[Swift.String]]?
    public let changeRequestName: Swift.String?
    public let clientToken: Swift.String?
    public let autoApprove: Swift.Bool
    public let runbooks: [SsmClientTypes.Runbook]?
    public let tags: [SsmClientTypes.Tag]?
    public let scheduledEndTime: ClientRuntime.Date?
    public let changeDetails: Swift.String?
}

extension StartChangeRequestExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoApprove = "AutoApprove"
        case changeDetails = "ChangeDetails"
        case changeRequestName = "ChangeRequestName"
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case parameters = "Parameters"
        case runbooks = "Runbooks"
        case scheduledEndTime = "ScheduledEndTime"
        case scheduledTime = "ScheduledTime"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let changeRequestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeRequestName)
        changeRequestName = changeRequestNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let autoApproveDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoApprove)
        autoApprove = autoApproveDecoded
        let runbooksContainer = try containerValues.decodeIfPresent([SsmClientTypes.Runbook?].self, forKey: .runbooks)
        var runbooksDecoded0:[SsmClientTypes.Runbook]? = nil
        if let runbooksContainer = runbooksContainer {
            runbooksDecoded0 = [SsmClientTypes.Runbook]()
            for structure0 in runbooksContainer {
                if let structure0 = structure0 {
                    runbooksDecoded0?.append(structure0)
                }
            }
        }
        runbooks = runbooksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let scheduledEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledEndTime)
        scheduledEndTime = scheduledEndTimeDecoded
        let changeDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDetails)
        changeDetails = changeDetailsDecoded
    }
}

extension StartChangeRequestExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartChangeRequestExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationDefinitionNotApproved" : self = .automationDefinitionNotApprovedException(try AutomationDefinitionNotApprovedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationDefinitionNotFound" : self = .automationDefinitionNotFoundException(try AutomationDefinitionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationDefinitionVersionNotFound" : self = .automationDefinitionVersionNotFoundException(try AutomationDefinitionVersionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationExecutionLimitExceeded" : self = .automationExecutionLimitExceededException(try AutomationExecutionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationExecutionParameters" : self = .invalidAutomationExecutionParametersException(try InvalidAutomationExecutionParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartChangeRequestExecutionOutputError: Swift.Error, Swift.Equatable {
    case automationDefinitionNotApprovedException(AutomationDefinitionNotApprovedException)
    case automationDefinitionNotFoundException(AutomationDefinitionNotFoundException)
    case automationDefinitionVersionNotFoundException(AutomationDefinitionVersionNotFoundException)
    case automationExecutionLimitExceededException(AutomationExecutionLimitExceededException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case invalidAutomationExecutionParametersException(InvalidAutomationExecutionParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartChangeRequestExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartChangeRequestExecutionOutputResponse(automationExecutionId: \(Swift.String(describing: automationExecutionId)))"}
}

extension StartChangeRequestExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartChangeRequestExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automationExecutionId = output.automationExecutionId
        } else {
            self.automationExecutionId = nil
        }
    }
}

public struct StartChangeRequestExecutionOutputResponse: Swift.Equatable {
    /// The unique ID of a runbook workflow operation. (A runbook workflow is a type of Automation operation.)
    public var automationExecutionId: Swift.String?

    public init (
        automationExecutionId: Swift.String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

struct StartChangeRequestExecutionOutputResponseBody: Swift.Equatable {
    public let automationExecutionId: Swift.String?
}

extension StartChangeRequestExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
    }
}

public struct StartSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSessionOutputError>
}

extension StartSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSessionInput(documentName: \(Swift.String(describing: documentName)), parameters: \(Swift.String(describing: parameters)), reason: \(Swift.String(describing: reason)), target: \(Swift.String(describing: target)))"}
}

extension StartSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentName = "DocumentName"
        case parameters = "Parameters"
        case reason = "Reason"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, sessionmanagerparameters0) in parameters {
                try parametersContainer.encode(sessionmanagerparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct StartSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSessionOutputError>
}

public struct StartSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSessionOutputError>
}

public struct StartSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSessionOutputError>
}

public struct StartSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSessionOutputError>
}

public struct StartSessionInput: Swift.Equatable {
    /// The name of the SSM document to define the parameters and plugin settings for the session. For example, SSM-SessionManagerRunShell. You can call the [GetDocument] API to verify the document exists before attempting to start a session. If no document name is provided, a shell to the managed node is launched by default.
    public var documentName: Swift.String?
    /// Reserved for future use.
    public var parameters: [Swift.String:[Swift.String]]?
    /// The reason for connecting to the instance. This value is included in the details for the Amazon CloudWatch Events event created when you start the session.
    public var reason: Swift.String?
    /// The managed node to connect to for the session.
    /// This member is required.
    public var target: Swift.String?

    public init (
        documentName: Swift.String? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        reason: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.documentName = documentName
        self.parameters = parameters
        self.reason = reason
        self.target = target
    }
}

struct StartSessionInputBody: Swift.Equatable {
    public let target: Swift.String?
    public let documentName: Swift.String?
    public let reason: Swift.String?
    public let parameters: [Swift.String:[Swift.String]]?
}

extension StartSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentName = "DocumentName"
        case parameters = "Parameters"
        case reason = "Reason"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, sessionmanagerparametervaluelist0) in parametersContainer {
                var sessionmanagerparametervaluelist0Decoded0: [Swift.String]? = nil
                if let sessionmanagerparametervaluelist0 = sessionmanagerparametervaluelist0 {
                    sessionmanagerparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in sessionmanagerparametervaluelist0 {
                        if let string1 = string1 {
                            sessionmanagerparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = sessionmanagerparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension StartSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetNotConnected" : self = .targetNotConnected(try TargetNotConnected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSessionOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case targetNotConnected(TargetNotConnected)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSessionOutputResponse(sessionId: \(Swift.String(describing: sessionId)), streamUrl: \(Swift.String(describing: streamUrl)), tokenValue: \(Swift.String(describing: tokenValue)))"}
}

extension StartSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sessionId = output.sessionId
            self.streamUrl = output.streamUrl
            self.tokenValue = output.tokenValue
        } else {
            self.sessionId = nil
            self.streamUrl = nil
            self.tokenValue = nil
        }
    }
}

public struct StartSessionOutputResponse: Swift.Equatable {
    /// The ID of the session.
    public var sessionId: Swift.String?
    /// A URL back to SSM Agent on the managed node that the Session Manager client uses to send commands and receive output from the node. Format: wss://ssmmessages.region.amazonaws.com/v1/data-channel/session-id?stream=(input|output) region represents the Region identifier for an Amazon Web Services Region supported by Amazon Web Services Systems Manager, such as us-east-2 for the US East (Ohio) Region. For a list of supported region values, see the Region column in [Systems Manager service endpoints](https://docs.aws.amazon.com/general/latest/gr/ssm.html#ssm_region) in the Amazon Web Services General Reference. session-id represents the ID of a Session Manager session, such as 1a2b3c4dEXAMPLE.
    public var streamUrl: Swift.String?
    /// An encrypted token value containing session and caller information. Used to authenticate the connection to the managed node.
    public var tokenValue: Swift.String?

    public init (
        sessionId: Swift.String? = nil,
        streamUrl: Swift.String? = nil,
        tokenValue: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamUrl = streamUrl
        self.tokenValue = tokenValue
    }
}

struct StartSessionOutputResponseBody: Swift.Equatable {
    public let sessionId: Swift.String?
    public let tokenValue: Swift.String?
    public let streamUrl: Swift.String?
}

extension StartSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
        case streamUrl = "StreamUrl"
        case tokenValue = "TokenValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let tokenValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenValue)
        tokenValue = tokenValueDecoded
        let streamUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamUrl)
        streamUrl = streamUrlDecoded
    }
}

extension StatusUnchanged: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StatusUnchanged()"}
}

extension StatusUnchanged {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The updated status is the same as the current status.
public struct StatusUnchanged: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension SsmClientTypes.StepExecution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case executionEndTime = "ExecutionEndTime"
        case executionStartTime = "ExecutionStartTime"
        case failureDetails = "FailureDetails"
        case failureMessage = "FailureMessage"
        case inputs = "Inputs"
        case isCritical = "IsCritical"
        case isEnd = "IsEnd"
        case maxAttempts = "MaxAttempts"
        case nextStep = "NextStep"
        case onFailure = "OnFailure"
        case outputs = "Outputs"
        case overriddenParameters = "OverriddenParameters"
        case response = "Response"
        case responseCode = "ResponseCode"
        case stepExecutionId = "StepExecutionId"
        case stepName = "StepName"
        case stepStatus = "StepStatus"
        case targetLocation = "TargetLocation"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
        case validNextSteps = "ValidNextSteps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let executionEndTime = executionEndTime {
            try encodeContainer.encode(executionEndTime.timeIntervalSince1970, forKey: .executionEndTime)
        }
        if let executionStartTime = executionStartTime {
            try encodeContainer.encode(executionStartTime.timeIntervalSince1970, forKey: .executionStartTime)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .inputs)
            for (dictKey0, normalstringmap0) in inputs {
                try inputsContainer.encode(normalstringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if isCritical != false {
            try encodeContainer.encode(isCritical, forKey: .isCritical)
        }
        if isEnd != false {
            try encodeContainer.encode(isEnd, forKey: .isEnd)
        }
        if maxAttempts != 0 {
            try encodeContainer.encode(maxAttempts, forKey: .maxAttempts)
        }
        if let nextStep = nextStep {
            try encodeContainer.encode(nextStep, forKey: .nextStep)
        }
        if let onFailure = onFailure {
            try encodeContainer.encode(onFailure, forKey: .onFailure)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputs)
            for (dictKey0, automationparametermap0) in outputs {
                try outputsContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let overriddenParameters = overriddenParameters {
            var overriddenParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overriddenParameters)
            for (dictKey0, automationparametermap0) in overriddenParameters {
                try overriddenParametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let response = response {
            try encodeContainer.encode(response, forKey: .response)
        }
        if let responseCode = responseCode {
            try encodeContainer.encode(responseCode, forKey: .responseCode)
        }
        if let stepExecutionId = stepExecutionId {
            try encodeContainer.encode(stepExecutionId, forKey: .stepExecutionId)
        }
        if let stepName = stepName {
            try encodeContainer.encode(stepName, forKey: .stepName)
        }
        if let stepStatus = stepStatus {
            try encodeContainer.encode(stepStatus.rawValue, forKey: .stepStatus)
        }
        if let targetLocation = targetLocation {
            try encodeContainer.encode(targetLocation, forKey: .targetLocation)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
        if let validNextSteps = validNextSteps {
            var validNextStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validNextSteps)
            for validnextsteplist0 in validNextSteps {
                try validNextStepsContainer.encode(validnextsteplist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepName)
        stepName = stepNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let onFailureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onFailure)
        onFailure = onFailureDecoded
        let maxAttemptsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxAttempts)
        maxAttempts = maxAttemptsDecoded
        let executionStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionStartTime)
        executionStartTime = executionStartTimeDecoded
        let executionEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionEndTime)
        executionEndTime = executionEndTimeDecoded
        let stepStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecutionStatus.self, forKey: .stepStatus)
        stepStatus = stepStatusDecoded
        let responseCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let inputsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .inputs)
        var inputsDecoded0: [Swift.String:Swift.String]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in inputsContainer {
                if let string0 = string0 {
                    inputsDecoded0?[key0] = string0
                }
            }
        }
        inputs = inputsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .outputs)
        var outputsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in outputsContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                outputsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        outputs = outputsDecoded0
        let responseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .response)
        response = responseDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let stepExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepExecutionId)
        stepExecutionId = stepExecutionIdDecoded
        let overriddenParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .overriddenParameters)
        var overriddenParametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let overriddenParametersContainer = overriddenParametersContainer {
            overriddenParametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in overriddenParametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                overriddenParametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        overriddenParameters = overriddenParametersDecoded0
        let isEndDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isEnd)
        isEnd = isEndDecoded
        let nextStepDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextStep)
        nextStep = nextStepDecoded
        let isCriticalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isCritical)
        isCritical = isCriticalDecoded
        let validNextStepsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validNextSteps)
        var validNextStepsDecoded0:[Swift.String]? = nil
        if let validNextStepsContainer = validNextStepsContainer {
            validNextStepsDecoded0 = [Swift.String]()
            for string0 in validNextStepsContainer {
                if let string0 = string0 {
                    validNextStepsDecoded0?.append(string0)
                }
            }
        }
        validNextSteps = validNextStepsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.TargetLocation.self, forKey: .targetLocation)
        targetLocation = targetLocationDecoded
    }
}

extension SsmClientTypes.StepExecution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StepExecution(action: \(Swift.String(describing: action)), executionEndTime: \(Swift.String(describing: executionEndTime)), executionStartTime: \(Swift.String(describing: executionStartTime)), failureDetails: \(Swift.String(describing: failureDetails)), failureMessage: \(Swift.String(describing: failureMessage)), inputs: \(Swift.String(describing: inputs)), isCritical: \(Swift.String(describing: isCritical)), isEnd: \(Swift.String(describing: isEnd)), maxAttempts: \(Swift.String(describing: maxAttempts)), nextStep: \(Swift.String(describing: nextStep)), onFailure: \(Swift.String(describing: onFailure)), outputs: \(Swift.String(describing: outputs)), overriddenParameters: \(Swift.String(describing: overriddenParameters)), response: \(Swift.String(describing: response)), responseCode: \(Swift.String(describing: responseCode)), stepExecutionId: \(Swift.String(describing: stepExecutionId)), stepName: \(Swift.String(describing: stepName)), stepStatus: \(Swift.String(describing: stepStatus)), targetLocation: \(Swift.String(describing: targetLocation)), targets: \(Swift.String(describing: targets)), timeoutSeconds: \(Swift.String(describing: timeoutSeconds)), validNextSteps: \(Swift.String(describing: validNextSteps)))"}
}

extension SsmClientTypes {
    /// Detailed information about an the execution state of an Automation step.
    public struct StepExecution: Swift.Equatable {
        /// The action this step performs. The action determines the behavior of the step.
        public var action: Swift.String?
        /// If a step has finished execution, this contains the time the execution ended. If the step hasn't yet concluded, this field isn't populated.
        public var executionEndTime: ClientRuntime.Date?
        /// If a step has begun execution, this contains the time the step started. If the step is in Pending status, this field isn't populated.
        public var executionStartTime: ClientRuntime.Date?
        /// Information about the Automation failure.
        public var failureDetails: SsmClientTypes.FailureDetails?
        /// If a step failed, this message explains why the execution failed.
        public var failureMessage: Swift.String?
        /// Fully-resolved values passed into the step before execution.
        public var inputs: [Swift.String:Swift.String]?
        /// The flag which can be used to help decide whether the failure of current step leads to the Automation failure.
        public var isCritical: Swift.Bool
        /// The flag which can be used to end automation no matter whether the step succeeds or fails.
        public var isEnd: Swift.Bool
        /// The maximum number of tries to run the action of the step. The default value is 1.
        public var maxAttempts: Swift.Int
        /// The next step after the step succeeds.
        public var nextStep: Swift.String?
        /// The action to take if the step fails. The default value is Abort.
        public var onFailure: Swift.String?
        /// Returned values from the execution of the step.
        public var outputs: [Swift.String:[Swift.String]]?
        /// A user-specified list of parameters to override when running a step.
        public var overriddenParameters: [Swift.String:[Swift.String]]?
        /// A message associated with the response code for an execution.
        public var response: Swift.String?
        /// The response code returned by the execution of the step.
        public var responseCode: Swift.String?
        /// The unique ID of a step execution.
        public var stepExecutionId: Swift.String?
        /// The name of this execution step.
        public var stepName: Swift.String?
        /// The execution status for this step.
        public var stepStatus: SsmClientTypes.AutomationExecutionStatus?
        /// The combination of Amazon Web Services Regions and Amazon Web Services accounts targeted by the current Automation execution.
        public var targetLocation: SsmClientTypes.TargetLocation?
        /// The targets for the step execution.
        public var targets: [SsmClientTypes.Target]?
        /// The timeout seconds of the step.
        public var timeoutSeconds: Swift.Int
        /// Strategies used when step fails, we support Continue and Abort. Abort will fail the automation when the step fails. Continue will ignore the failure of current step and allow automation to run the next step. With conditional branching, we add step:stepName to support the automation to go to another specific step.
        public var validNextSteps: [Swift.String]?

        public init (
            action: Swift.String? = nil,
            executionEndTime: ClientRuntime.Date? = nil,
            executionStartTime: ClientRuntime.Date? = nil,
            failureDetails: SsmClientTypes.FailureDetails? = nil,
            failureMessage: Swift.String? = nil,
            inputs: [Swift.String:Swift.String]? = nil,
            isCritical: Swift.Bool = false,
            isEnd: Swift.Bool = false,
            maxAttempts: Swift.Int = 0,
            nextStep: Swift.String? = nil,
            onFailure: Swift.String? = nil,
            outputs: [Swift.String:[Swift.String]]? = nil,
            overriddenParameters: [Swift.String:[Swift.String]]? = nil,
            response: Swift.String? = nil,
            responseCode: Swift.String? = nil,
            stepExecutionId: Swift.String? = nil,
            stepName: Swift.String? = nil,
            stepStatus: SsmClientTypes.AutomationExecutionStatus? = nil,
            targetLocation: SsmClientTypes.TargetLocation? = nil,
            targets: [SsmClientTypes.Target]? = nil,
            timeoutSeconds: Swift.Int = 0,
            validNextSteps: [Swift.String]? = nil
        )
        {
            self.action = action
            self.executionEndTime = executionEndTime
            self.executionStartTime = executionStartTime
            self.failureDetails = failureDetails
            self.failureMessage = failureMessage
            self.inputs = inputs
            self.isCritical = isCritical
            self.isEnd = isEnd
            self.maxAttempts = maxAttempts
            self.nextStep = nextStep
            self.onFailure = onFailure
            self.outputs = outputs
            self.overriddenParameters = overriddenParameters
            self.response = response
            self.responseCode = responseCode
            self.stepExecutionId = stepExecutionId
            self.stepName = stepName
            self.stepStatus = stepStatus
            self.targetLocation = targetLocation
            self.targets = targets
            self.timeoutSeconds = timeoutSeconds
            self.validNextSteps = validNextSteps
        }
    }

}

extension SsmClientTypes.StepExecutionFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stepexecutionfiltervaluelist0 in values {
                try valuesContainer.encode(stepexecutionfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.StepExecutionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.StepExecutionFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StepExecutionFilter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// A filter to limit the amount of step execution information returned by the call.
    public struct StepExecutionFilter: Swift.Equatable {
        /// One or more keys to limit the results. Valid filter keys include the following: StepName, Action, StepExecutionId, StepExecutionStatus, StartTimeBefore, StartTimeAfter.
        /// This member is required.
        public var key: SsmClientTypes.StepExecutionFilterKey?
        /// The values of the filter key.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.StepExecutionFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum StepExecutionFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case action
        case startTimeAfter
        case startTimeBefore
        case stepExecutionId
        case stepExecutionStatus
        case stepName
        case sdkUnknown(Swift.String)

        public static var allCases: [StepExecutionFilterKey] {
            return [
                .action,
                .startTimeAfter,
                .startTimeBefore,
                .stepExecutionId,
                .stepExecutionStatus,
                .stepName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .action: return "Action"
            case .startTimeAfter: return "StartTimeAfter"
            case .startTimeBefore: return "StartTimeBefore"
            case .stepExecutionId: return "StepExecutionId"
            case .stepExecutionStatus: return "StepExecutionStatus"
            case .stepName: return "StepName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepExecutionFilterKey(rawValue: rawValue) ?? StepExecutionFilterKey.sdkUnknown(rawValue)
        }
    }
}

public struct StopAutomationExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopAutomationExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopAutomationExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopAutomationExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopAutomationExecutionOutputError>
}

extension StopAutomationExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopAutomationExecutionInput(automationExecutionId: \(Swift.String(describing: automationExecutionId)), type: \(Swift.String(describing: type)))"}
}

extension StopAutomationExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct StopAutomationExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopAutomationExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopAutomationExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopAutomationExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopAutomationExecutionOutputError>
}

public struct StopAutomationExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopAutomationExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopAutomationExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopAutomationExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopAutomationExecutionOutputError>
}

public struct StopAutomationExecutionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopAutomationExecutionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopAutomationExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopAutomationExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopAutomationExecutionOutputError>
}

public struct StopAutomationExecutionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopAutomationExecutionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopAutomationExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopAutomationExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopAutomationExecutionOutputError>
}

public struct StopAutomationExecutionInput: Swift.Equatable {
    /// The execution ID of the Automation to stop.
    /// This member is required.
    public var automationExecutionId: Swift.String?
    /// The stop request type. Valid types include the following: Cancel and Complete. The default type is Cancel.
    public var type: SsmClientTypes.StopType?

    public init (
        automationExecutionId: Swift.String? = nil,
        type: SsmClientTypes.StopType? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
        self.type = type
    }
}

struct StopAutomationExecutionInputBody: Swift.Equatable {
    public let automationExecutionId: Swift.String?
    public let type: SsmClientTypes.StopType?
}

extension StopAutomationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.StopType.self, forKey: .type)
        type = typeDecoded
    }
}

extension StopAutomationExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopAutomationExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFound" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationStatusUpdateException" : self = .invalidAutomationStatusUpdateException(try InvalidAutomationStatusUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopAutomationExecutionOutputError: Swift.Error, Swift.Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case internalServerError(InternalServerError)
    case invalidAutomationStatusUpdateException(InvalidAutomationStatusUpdateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopAutomationExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopAutomationExecutionOutputResponse()"}
}

extension StopAutomationExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopAutomationExecutionOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopAutomationExecutionOutputResponseBody: Swift.Equatable {
}

extension StopAutomationExecutionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SsmClientTypes {
    public enum StopType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancel
        case complete
        case sdkUnknown(Swift.String)

        public static var allCases: [StopType] {
            return [
                .cancel,
                .complete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "Cancel"
            case .complete: return "Complete"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StopType(rawValue: rawValue) ?? StopType.sdkUnknown(rawValue)
        }
    }
}

extension SubTypeCountLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubTypeCountLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension SubTypeCountLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubTypeCountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The sub-type count exceeded the limit for the inventory type.
public struct SubTypeCountLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubTypeCountLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubTypeCountLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SsmClientTypes {
    /// Metadata that you assign to your Amazon Web Services resources. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment. In Amazon Web Services Systems Manager, you can apply tags to Systems Manager documents (SSM documents), managed nodes, maintenance windows, parameters, patch baselines, OpsItems, and OpsMetadata.
    public struct Tag: Swift.Equatable {
        /// The name of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes.Target: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for targetvalues0 in values {
                try valuesContainer.encode(targetvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.Target: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Target(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SsmClientTypes {
    /// An array of search criteria that targets managed nodes using a key-value pair that you specify. One or more targets must be specified for maintenance window Run Command-type tasks. Depending on the task, targets are optional for other maintenance window task types (Automation, Lambda, and Step Functions). For more information about running tasks that don't specify targets, see [Registering maintenance window tasks without targets](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) in the Amazon Web Services Systems Manager User Guide. Supported formats include the following.
    ///
    /// * Key=InstanceIds,Values=,,
    ///
    /// * Key=tag:,Values=,
    ///
    /// * Key=tag-key,Values=,
    ///
    /// * Run Command and Maintenance window targets only: Key=resource-groups:Name,Values=
    ///
    /// * Maintenance window targets only: Key=resource-groups:ResourceTypeFilters,Values=,
    ///
    /// * Automation targets only: Key=ResourceGroup;Values=
    ///
    ///
    /// For example:
    ///
    /// * Key=InstanceIds,Values=i-02573cafcfEXAMPLE,i-0471e04240EXAMPLE,i-07782c72faEXAMPLE
    ///
    /// * Key=tag:CostCenter,Values=CostCenter1,CostCenter2,CostCenter3
    ///
    /// * Key=tag-key,Values=Name,Instance-Type,CostCenter
    ///
    /// * Run Command and Maintenance window targets only: Key=resource-groups:Name,Values=ProductionResourceGroup This example demonstrates how to target all resources in the resource group ProductionResourceGroup in your maintenance window.
    ///
    /// * Maintenance window targets only: Key=resource-groups:ResourceTypeFilters,Values=AWS::EC2::INSTANCE,AWS::EC2::VPC This example demonstrates how to target only Amazon Elastic Compute Cloud (Amazon EC2) instances and VPCs in your maintenance window.
    ///
    /// * Automation targets only: Key=ResourceGroup,Values=MyResourceGroup
    ///
    /// * State Manager association targets only: Key=InstanceIds,Values=* This example demonstrates how to target all managed instances in the Amazon Web Services Region where the association was created.
    ///
    ///
    /// For more information about how to send commands that target managed nodes using Key,Value parameters, see [Targeting multiple instances](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-targeting) in the Amazon Web Services Systems Manager User Guide.
    public struct Target: Swift.Equatable {
        /// User-defined criteria for sending commands that target managed nodes that meet the criteria.
        public var key: Swift.String?
        /// User-defined criteria that maps to Key. For example, if you specified tag:ServerRole, you could specify value:WebServer to run a command on instances that include EC2 tags of ServerRole,WebServer. Depending on the type of target, the maximum number of values for a key might be lower than the global maximum of 50.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension TargetInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetInUseException(message: \(Swift.String(describing: message)))"}
}

extension TargetInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TargetInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You specified the Safe option for the DeregisterTargetFromMaintenanceWindow operation, but the target is still referenced in a task.
public struct TargetInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TargetInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TargetInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.TargetLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case executionRoleName = "ExecutionRoleName"
        case regions = "Regions"
        case targetLocationMaxConcurrency = "TargetLocationMaxConcurrency"
        case targetLocationMaxErrors = "TargetLocationMaxErrors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for accounts0 in accounts {
                try accountsContainer.encode(accounts0)
            }
        }
        if let executionRoleName = executionRoleName {
            try encodeContainer.encode(executionRoleName, forKey: .executionRoleName)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regions0 in regions {
                try regionsContainer.encode(regions0)
            }
        }
        if let targetLocationMaxConcurrency = targetLocationMaxConcurrency {
            try encodeContainer.encode(targetLocationMaxConcurrency, forKey: .targetLocationMaxConcurrency)
        }
        if let targetLocationMaxErrors = targetLocationMaxErrors {
            try encodeContainer.encode(targetLocationMaxErrors, forKey: .targetLocationMaxErrors)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accounts)
        var accountsDecoded0:[Swift.String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Swift.String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let targetLocationMaxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetLocationMaxConcurrency)
        targetLocationMaxConcurrency = targetLocationMaxConcurrencyDecoded
        let targetLocationMaxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetLocationMaxErrors)
        targetLocationMaxErrors = targetLocationMaxErrorsDecoded
        let executionRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleName)
        executionRoleName = executionRoleNameDecoded
    }
}

extension SsmClientTypes.TargetLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetLocation(accounts: \(Swift.String(describing: accounts)), executionRoleName: \(Swift.String(describing: executionRoleName)), regions: \(Swift.String(describing: regions)), targetLocationMaxConcurrency: \(Swift.String(describing: targetLocationMaxConcurrency)), targetLocationMaxErrors: \(Swift.String(describing: targetLocationMaxErrors)))"}
}

extension SsmClientTypes {
    /// The combination of Amazon Web Services Regions and Amazon Web Services accounts targeted by the current Automation execution.
    public struct TargetLocation: Swift.Equatable {
        /// The Amazon Web Services accounts targeted by the current Automation execution.
        public var accounts: [Swift.String]?
        /// The Automation execution role used by the currently running Automation. If not specified, the default value is AWS-SystemsManager-AutomationExecutionRole.
        public var executionRoleName: Swift.String?
        /// The Amazon Web Services Regions targeted by the current Automation execution.
        public var regions: [Swift.String]?
        /// The maximum number of Amazon Web Services Regions and Amazon Web Services accounts allowed to run the Automation concurrently.
        public var targetLocationMaxConcurrency: Swift.String?
        /// The maximum number of errors allowed before the system stops queueing additional Automation executions for the currently running Automation.
        public var targetLocationMaxErrors: Swift.String?

        public init (
            accounts: [Swift.String]? = nil,
            executionRoleName: Swift.String? = nil,
            regions: [Swift.String]? = nil,
            targetLocationMaxConcurrency: Swift.String? = nil,
            targetLocationMaxErrors: Swift.String? = nil
        )
        {
            self.accounts = accounts
            self.executionRoleName = executionRoleName
            self.regions = regions
            self.targetLocationMaxConcurrency = targetLocationMaxConcurrency
            self.targetLocationMaxErrors = targetLocationMaxErrors
        }
    }

}

extension TargetNotConnected: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetNotConnected(message: \(Swift.String(describing: message)))"}
}

extension TargetNotConnected {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TargetNotConnectedBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified target managed node for the session isn't fully configured for use with Session Manager. For more information, see [Getting started with Session Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-getting-started.html) in the Amazon Web Services Systems Manager User Guide. This error is also returned if you attempt to start a session on a managed node that is located in a different account or Region
public struct TargetNotConnected: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TargetNotConnectedBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TargetNotConnectedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TerminateSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TerminateSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TerminateSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TerminateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TerminateSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TerminateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TerminateSessionOutputError>
}

extension TerminateSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateSessionInput(sessionId: \(Swift.String(describing: sessionId)))"}
}

extension TerminateSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

public struct TerminateSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TerminateSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TerminateSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TerminateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TerminateSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TerminateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TerminateSessionOutputError>
}

public struct TerminateSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TerminateSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TerminateSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TerminateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TerminateSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TerminateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TerminateSessionOutputError>
}

public struct TerminateSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TerminateSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TerminateSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TerminateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TerminateSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<TerminateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TerminateSessionOutputError>
}

public struct TerminateSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TerminateSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TerminateSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TerminateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TerminateSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<TerminateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TerminateSessionOutputError>
}

public struct TerminateSessionInput: Swift.Equatable {
    /// The ID of the session to terminate.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct TerminateSessionInputBody: Swift.Equatable {
    public let sessionId: Swift.String?
}

extension TerminateSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TerminateSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateSessionOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateSessionOutputResponse(sessionId: \(Swift.String(describing: sessionId)))"}
}

extension TerminateSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TerminateSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sessionId = output.sessionId
        } else {
            self.sessionId = nil
        }
    }
}

public struct TerminateSessionOutputResponse: Swift.Equatable {
    /// The ID of the session that has been terminated.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct TerminateSessionOutputResponseBody: Swift.Equatable {
    public let sessionId: Swift.String?
}

extension TerminateSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TooManyTagsError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsError()"}
}

extension TooManyTagsError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Targets parameter includes too many tags. Remove one or more tags and try the command again.
public struct TooManyTagsError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension TooManyUpdates: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyUpdates(message: \(Swift.String(describing: message)))"}
}

extension TooManyUpdates {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyUpdatesBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are concurrent updates for a resource that supports one update at a time.
public struct TooManyUpdates: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyUpdatesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyUpdatesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TotalSizeLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TotalSizeLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension TotalSizeLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TotalSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The size of inventory data has exceeded the total size limit for the resource.
public struct TotalSizeLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TotalSizeLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TotalSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UnlabelParameterVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlabelParameterVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnlabelParameterVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnlabelParameterVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnlabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlabelParameterVersionOutputError>
}

extension UnlabelParameterVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnlabelParameterVersionInput(labels: \(Swift.String(describing: labels)), name: \(Swift.String(describing: name)), parameterVersion: \(Swift.String(describing: parameterVersion)))"}
}

extension UnlabelParameterVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for parameterlabellist0 in labels {
                try labelsContainer.encode(parameterlabellist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if parameterVersion != 0 {
            try encodeContainer.encode(parameterVersion, forKey: .parameterVersion)
        }
    }
}

public struct UnlabelParameterVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlabelParameterVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnlabelParameterVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnlabelParameterVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnlabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlabelParameterVersionOutputError>
}

public struct UnlabelParameterVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlabelParameterVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnlabelParameterVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnlabelParameterVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnlabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlabelParameterVersionOutputError>
}

public struct UnlabelParameterVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlabelParameterVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UnlabelParameterVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UnlabelParameterVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UnlabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlabelParameterVersionOutputError>
}

public struct UnlabelParameterVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlabelParameterVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UnlabelParameterVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UnlabelParameterVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UnlabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlabelParameterVersionOutputError>
}

public struct UnlabelParameterVersionInput: Swift.Equatable {
    /// One or more labels to delete from the specified parameter version.
    /// This member is required.
    public var labels: [Swift.String]?
    /// The name of the parameter from which you want to delete one or more labels.
    /// This member is required.
    public var name: Swift.String?
    /// The specific version of the parameter which you want to delete one or more labels from. If it isn't present, the call will fail.
    /// This member is required.
    public var parameterVersion: Swift.Int

    public init (
        labels: [Swift.String]? = nil,
        name: Swift.String? = nil,
        parameterVersion: Swift.Int = 0
    )
    {
        self.labels = labels
        self.name = name
        self.parameterVersion = parameterVersion
    }
}

struct UnlabelParameterVersionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let parameterVersion: Swift.Int
    public let labels: [Swift.String]?
}

extension UnlabelParameterVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parameterVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .parameterVersion)
        parameterVersion = parameterVersionDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension UnlabelParameterVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnlabelParameterVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionNotFound" : self = .parameterVersionNotFound(try ParameterVersionNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnlabelParameterVersionOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case parameterNotFound(ParameterNotFound)
    case parameterVersionNotFound(ParameterVersionNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnlabelParameterVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnlabelParameterVersionOutputResponse(invalidLabels: \(Swift.String(describing: invalidLabels)), removedLabels: \(Swift.String(describing: removedLabels)))"}
}

extension UnlabelParameterVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnlabelParameterVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invalidLabels = output.invalidLabels
            self.removedLabels = output.removedLabels
        } else {
            self.invalidLabels = nil
            self.removedLabels = nil
        }
    }
}

public struct UnlabelParameterVersionOutputResponse: Swift.Equatable {
    /// The labels that aren't attached to the given parameter version.
    public var invalidLabels: [Swift.String]?
    /// A list of all labels deleted from the parameter.
    public var removedLabels: [Swift.String]?

    public init (
        invalidLabels: [Swift.String]? = nil,
        removedLabels: [Swift.String]? = nil
    )
    {
        self.invalidLabels = invalidLabels
        self.removedLabels = removedLabels
    }
}

struct UnlabelParameterVersionOutputResponseBody: Swift.Equatable {
    public let removedLabels: [Swift.String]?
    public let invalidLabels: [Swift.String]?
}

extension UnlabelParameterVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidLabels = "InvalidLabels"
        case removedLabels = "RemovedLabels"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let removedLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removedLabels)
        var removedLabelsDecoded0:[Swift.String]? = nil
        if let removedLabelsContainer = removedLabelsContainer {
            removedLabelsDecoded0 = [Swift.String]()
            for string0 in removedLabelsContainer {
                if let string0 = string0 {
                    removedLabelsDecoded0?.append(string0)
                }
            }
        }
        removedLabels = removedLabelsDecoded0
        let invalidLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidLabels)
        var invalidLabelsDecoded0:[Swift.String]? = nil
        if let invalidLabelsContainer = invalidLabelsContainer {
            invalidLabelsDecoded0 = [Swift.String]()
            for string0 in invalidLabelsContainer {
                if let string0 = string0 {
                    invalidLabelsDecoded0?.append(string0)
                }
            }
        }
        invalidLabels = invalidLabelsDecoded0
    }
}

extension UnsupportedCalendarException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedCalendarException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedCalendarException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedCalendarExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The calendar entry contained in the specified SSM document isn't supported.
public struct UnsupportedCalendarException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedCalendarExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedCalendarExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedFeatureRequiredException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedFeatureRequiredException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedFeatureRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedFeatureRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Patching for applications released by Microsoft is only available on EC2 instances and advanced instances. To patch applications released by Microsoft on on-premises servers and VMs, you must enable advanced instances. For more information, see [Enabling the advanced-instances tier](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-managedinstances-advanced.html) in the Amazon Web Services Systems Manager User Guide.
public struct UnsupportedFeatureRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedFeatureRequiredExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedFeatureRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedInventoryItemContextException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedInventoryItemContextException(message: \(Swift.String(describing: message)), typeName: \(Swift.String(describing: typeName)))"}
}

extension UnsupportedInventoryItemContextException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedInventoryItemContextExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Context attribute that you specified for the InventoryItem isn't allowed for this inventory type. You can only use the Context attribute with inventory types like AWS:ComplianceItem.
public struct UnsupportedInventoryItemContextException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var typeName: Swift.String?

    public init (
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct UnsupportedInventoryItemContextExceptionBody: Swift.Equatable {
    public let typeName: Swift.String?
    public let message: Swift.String?
}

extension UnsupportedInventoryItemContextExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedInventorySchemaVersionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedInventorySchemaVersionException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedInventorySchemaVersionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedInventorySchemaVersionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Inventory item type schema version has to match supported versions in the service. Check output of GetInventorySchema to see the available schema version for each type.
public struct UnsupportedInventorySchemaVersionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedInventorySchemaVersionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedInventorySchemaVersionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperatingSystem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedOperatingSystem(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedOperatingSystem {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedOperatingSystemBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operating systems you specified isn't supported, or the operation isn't supported for the operating system.
public struct UnsupportedOperatingSystem: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperatingSystemBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedOperatingSystemBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedParameterType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedParameterType(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedParameterType {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedParameterTypeBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter type isn't supported.
public struct UnsupportedParameterType: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedParameterTypeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedParameterTypeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedPlatformType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedPlatformType(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedPlatformType {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedPlatformTypeBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The document doesn't support the platform type of the given managed node ID(s). For example, you sent an document for a Windows managed node to a Linux node.
public struct UnsupportedPlatformType: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedPlatformTypeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedPlatformTypeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateAssociationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssociationOutputError>
}

extension UpdateAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssociationInput(applyOnlyAtCronInterval: \(Swift.String(describing: applyOnlyAtCronInterval)), associationId: \(Swift.String(describing: associationId)), associationName: \(Swift.String(describing: associationName)), associationVersion: \(Swift.String(describing: associationVersion)), automationTargetParameterName: \(Swift.String(describing: automationTargetParameterName)), calendarNames: \(Swift.String(describing: calendarNames)), complianceSeverity: \(Swift.String(describing: complianceSeverity)), documentVersion: \(Swift.String(describing: documentVersion)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), outputLocation: \(Swift.String(describing: outputLocation)), parameters: \(Swift.String(describing: parameters)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), syncCompliance: \(Swift.String(describing: syncCompliance)), targetLocations: \(Swift.String(describing: targetLocations)), targets: \(Swift.String(describing: targets)))"}
}

extension UpdateAssociationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct UpdateAssociationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssociationOutputError>
}

public struct UpdateAssociationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssociationOutputError>
}

public struct UpdateAssociationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssociationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssociationOutputError>
}

public struct UpdateAssociationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssociationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssociationOutputError>
}

public struct UpdateAssociationInput: Swift.Equatable {
    /// By default, when you update an association, the system runs it immediately after it is updated and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you update it. This parameter isn't supported for rate expressions. Also, if you specified this option when you created the association, you can reset it. To do so, specify the no-apply-only-at-cron-interval parameter when you update the association from the command line. This parameter forces the association to run immediately after updating it and according to the interval specified.
    public var applyOnlyAtCronInterval: Swift.Bool
    /// The ID of the association you want to update.
    /// This member is required.
    public var associationId: Swift.String?
    /// The name of the association that you want to update.
    public var associationName: Swift.String?
    /// This parameter is provided for concurrency control purposes. You must specify the latest association version in the service. If you want to ensure that this request succeeds, either specify $LATEST, or omit this parameter.
    public var associationVersion: Swift.String?
    /// Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
    public var automationTargetParameterName: Swift.String?
    /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents you want to gate your associations under. The associations only run when that change calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
    public var calendarNames: [Swift.String]?
    /// The severity level to assign to the association.
    public var complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
    /// The document version you want update for the association.
    public var documentVersion: Swift.String?
    /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
    public var maxConcurrency: Swift.String?
    /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
    public var maxErrors: Swift.String?
    /// The name of the SSM Command document or Automation runbook that contains the configuration information for the managed node. You can specify Amazon Web Services-predefined documents, documents you created, or a document that is shared with you from another account. For Systems Manager document (SSM document) that are shared with you from other Amazon Web Services accounts, you must specify the complete SSM document ARN, in the following format: arn:aws:ssm:region:account-id:document/document-name  For example: arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document For Amazon Web Services-predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, AWS-ApplyPatchBaseline or My-Document.
    public var name: Swift.String?
    /// An S3 bucket where you want to store the results of this request.
    public var outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
    /// The parameters you want to update for the association. If you create a parameter using Parameter Store, a capability of Amazon Web Services Systems Manager, you can reference the parameter using {{ssm:parameter-name}}.
    public var parameters: [Swift.String:[Swift.String]]?
    /// The cron expression used to schedule the association that you want to update.
    public var scheduleExpression: Swift.String?
    /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
    public var syncCompliance: SsmClientTypes.AssociationSyncCompliance?
    /// A location is a combination of Amazon Web Services Regions and Amazon Web Services accounts where you want to run the association. Use this action to update an association in multiple Regions and multiple accounts.
    public var targetLocations: [SsmClientTypes.TargetLocation]?
    /// The targets of the association.
    public var targets: [SsmClientTypes.Target]?

    public init (
        applyOnlyAtCronInterval: Swift.Bool = false,
        associationId: Swift.String? = nil,
        associationName: Swift.String? = nil,
        associationVersion: Swift.String? = nil,
        automationTargetParameterName: Swift.String? = nil,
        calendarNames: [Swift.String]? = nil,
        complianceSeverity: SsmClientTypes.AssociationComplianceSeverity? = nil,
        documentVersion: Swift.String? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        outputLocation: SsmClientTypes.InstanceAssociationOutputLocation? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        scheduleExpression: Swift.String? = nil,
        syncCompliance: SsmClientTypes.AssociationSyncCompliance? = nil,
        targetLocations: [SsmClientTypes.TargetLocation]? = nil,
        targets: [SsmClientTypes.Target]? = nil
    )
    {
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationId = associationId
        self.associationName = associationName
        self.associationVersion = associationVersion
        self.automationTargetParameterName = automationTargetParameterName
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.documentVersion = documentVersion
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.syncCompliance = syncCompliance
        self.targetLocations = targetLocations
        self.targets = targets
    }
}

struct UpdateAssociationInputBody: Swift.Equatable {
    public let associationId: Swift.String?
    public let parameters: [Swift.String:[Swift.String]]?
    public let documentVersion: Swift.String?
    public let scheduleExpression: Swift.String?
    public let outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
    public let name: Swift.String?
    public let targets: [SsmClientTypes.Target]?
    public let associationName: Swift.String?
    public let associationVersion: Swift.String?
    public let automationTargetParameterName: Swift.String?
    public let maxErrors: Swift.String?
    public let maxConcurrency: Swift.String?
    public let complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
    public let syncCompliance: SsmClientTypes.AssociationSyncCompliance?
    public let applyOnlyAtCronInterval: Swift.Bool
    public let calendarNames: [Swift.String]?
    public let targetLocations: [SsmClientTypes.TargetLocation]?
}

extension UpdateAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension UpdateAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociationVersionLimitExceeded" : self = .associationVersionLimitExceeded(try AssociationVersionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAssociationVersion" : self = .invalidAssociationVersion(try InvalidAssociationVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputLocation" : self = .invalidOutputLocation(try InvalidOutputLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchedule" : self = .invalidSchedule(try InvalidSchedule(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUpdate" : self = .invalidUpdate(try InvalidUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssociationOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case associationVersionLimitExceeded(AssociationVersionLimitExceeded)
    case internalServerError(InternalServerError)
    case invalidAssociationVersion(InvalidAssociationVersion)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidOutputLocation(InvalidOutputLocation)
    case invalidParameters(InvalidParameters)
    case invalidSchedule(InvalidSchedule)
    case invalidTarget(InvalidTarget)
    case invalidUpdate(InvalidUpdate)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssociationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssociationOutputResponse(associationDescription: \(Swift.String(describing: associationDescription)))"}
}

extension UpdateAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct UpdateAssociationOutputResponse: Swift.Equatable {
    /// The description of the association that was updated.
    public var associationDescription: SsmClientTypes.AssociationDescription?

    public init (
        associationDescription: SsmClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct UpdateAssociationOutputResponseBody: Swift.Equatable {
    public let associationDescription: SsmClientTypes.AssociationDescription?
}

extension UpdateAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

public struct UpdateAssociationStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssociationStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssociationStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssociationStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssociationStatusOutputError>
}

extension UpdateAssociationStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssociationStatusInput(associationStatus: \(Swift.String(describing: associationStatus)), instanceId: \(Swift.String(describing: instanceId)), name: \(Swift.String(describing: name)))"}
}

extension UpdateAssociationStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus = "AssociationStatus"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus, forKey: .associationStatus)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAssociationStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssociationStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssociationStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssociationStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssociationStatusOutputError>
}

public struct UpdateAssociationStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssociationStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssociationStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssociationStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssociationStatusOutputError>
}

public struct UpdateAssociationStatusInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssociationStatusInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAssociationStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAssociationStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssociationStatusOutputError>
}

public struct UpdateAssociationStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssociationStatusInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAssociationStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAssociationStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssociationStatusOutputError>
}

public struct UpdateAssociationStatusInput: Swift.Equatable {
    /// The association status.
    /// This member is required.
    public var associationStatus: SsmClientTypes.AssociationStatus?
    /// The managed node ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the SSM document.
    /// This member is required.
    public var name: Swift.String?

    public init (
        associationStatus: SsmClientTypes.AssociationStatus? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.associationStatus = associationStatus
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateAssociationStatusInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let instanceId: Swift.String?
    public let associationStatus: SsmClientTypes.AssociationStatus?
}

extension UpdateAssociationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus = "AssociationStatus"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
    }
}

extension UpdateAssociationStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssociationStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatusUnchanged" : self = .statusUnchanged(try StatusUnchanged(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssociationStatusOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidInstanceId(InvalidInstanceId)
    case statusUnchanged(StatusUnchanged)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssociationStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssociationStatusOutputResponse(associationDescription: \(Swift.String(describing: associationDescription)))"}
}

extension UpdateAssociationStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAssociationStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct UpdateAssociationStatusOutputResponse: Swift.Equatable {
    /// Information about the association.
    public var associationDescription: SsmClientTypes.AssociationDescription?

    public init (
        associationDescription: SsmClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct UpdateAssociationStatusOutputResponseBody: Swift.Equatable {
    public let associationDescription: SsmClientTypes.AssociationDescription?
}

extension UpdateAssociationStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

public struct UpdateDocumentDefaultVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentDefaultVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDocumentDefaultVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDocumentDefaultVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentDefaultVersionOutputError>
}

extension UpdateDocumentDefaultVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDocumentDefaultVersionInput(documentVersion: \(Swift.String(describing: documentVersion)), name: \(Swift.String(describing: name)))"}
}

extension UpdateDocumentDefaultVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateDocumentDefaultVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentDefaultVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDocumentDefaultVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDocumentDefaultVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentDefaultVersionOutputError>
}

public struct UpdateDocumentDefaultVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentDefaultVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDocumentDefaultVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDocumentDefaultVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentDefaultVersionOutputError>
}

public struct UpdateDocumentDefaultVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentDefaultVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDocumentDefaultVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDocumentDefaultVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentDefaultVersionOutputError>
}

public struct UpdateDocumentDefaultVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentDefaultVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDocumentDefaultVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDocumentDefaultVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentDefaultVersionOutputError>
}

public struct UpdateDocumentDefaultVersionInput: Swift.Equatable {
    /// The version of a custom document that you want to set as the default version.
    /// This member is required.
    public var documentVersion: Swift.String?
    /// The name of a custom document that you want to set as the default version.
    /// This member is required.
    public var name: Swift.String?

    public init (
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.name = name
    }
}

struct UpdateDocumentDefaultVersionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let documentVersion: Swift.String?
}

extension UpdateDocumentDefaultVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
    }
}

extension UpdateDocumentDefaultVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentDefaultVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentSchemaVersion" : self = .invalidDocumentSchemaVersion(try InvalidDocumentSchemaVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentDefaultVersionOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentSchemaVersion(InvalidDocumentSchemaVersion)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentDefaultVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDocumentDefaultVersionOutputResponse(description: \(Swift.String(describing: description)))"}
}

extension UpdateDocumentDefaultVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDocumentDefaultVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct UpdateDocumentDefaultVersionOutputResponse: Swift.Equatable {
    /// The description of a custom document that you want to set as the default version.
    public var description: SsmClientTypes.DocumentDefaultVersionDescription?

    public init (
        description: SsmClientTypes.DocumentDefaultVersionDescription? = nil
    )
    {
        self.description = description
    }
}

struct UpdateDocumentDefaultVersionOutputResponseBody: Swift.Equatable {
    public let description: SsmClientTypes.DocumentDefaultVersionDescription?
}

extension UpdateDocumentDefaultVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentDefaultVersionDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct UpdateDocumentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentOutputError>
}

extension UpdateDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDocumentInput(attachments: \(Swift.String(describing: attachments)), content: \(Swift.String(describing: content)), displayName: \(Swift.String(describing: displayName)), documentFormat: \(Swift.String(describing: documentFormat)), documentVersion: \(Swift.String(describing: documentVersion)), name: \(Swift.String(describing: name)), targetType: \(Swift.String(describing: targetType)), versionName: \(Swift.String(describing: versionName)))"}
}

extension UpdateDocumentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachmentssourcelist0 in attachments {
                try attachmentsContainer.encode(attachmentssourcelist0)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

public struct UpdateDocumentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentOutputError>
}

public struct UpdateDocumentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDocumentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDocumentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentOutputError>
}

public struct UpdateDocumentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDocumentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDocumentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentOutputError>
}

public struct UpdateDocumentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDocumentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDocumentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentOutputError>
}

public struct UpdateDocumentInput: Swift.Equatable {
    /// A list of key-value pairs that describe attachments to a version of a document.
    public var attachments: [SsmClientTypes.AttachmentsSource]?
    /// A valid JSON or YAML string.
    /// This member is required.
    public var content: Swift.String?
    /// The friendly name of the SSM document that you want to update. This value can differ for each version of the document. If you don't specify a value for this parameter in your request, the existing value is applied to the new document version.
    public var displayName: Swift.String?
    /// Specify the document format for the new document version. Systems Manager supports JSON and YAML documents. JSON is the default format.
    public var documentFormat: SsmClientTypes.DocumentFormat?
    /// The version of the document that you want to update. Currently, Systems Manager supports updating only the latest version of the document. You can specify the version number of the latest version or use the $LATEST variable.
    public var documentVersion: Swift.String?
    /// The name of the SSM document that you want to update.
    /// This member is required.
    public var name: Swift.String?
    /// Specify a new target type for the document.
    public var targetType: Swift.String?
    /// An optional field specifying the version of the artifact you are updating with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init (
        attachments: [SsmClientTypes.AttachmentsSource]? = nil,
        content: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentFormat: SsmClientTypes.DocumentFormat? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        targetType: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.content = content
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentVersion = documentVersion
        self.name = name
        self.targetType = targetType
        self.versionName = versionName
    }
}

struct UpdateDocumentInputBody: Swift.Equatable {
    public let content: Swift.String?
    public let attachments: [SsmClientTypes.AttachmentsSource]?
    public let name: Swift.String?
    public let displayName: Swift.String?
    public let versionName: Swift.String?
    public let documentVersion: Swift.String?
    public let documentFormat: SsmClientTypes.DocumentFormat?
    public let targetType: Swift.String?
}

extension UpdateDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([SsmClientTypes.AttachmentsSource?].self, forKey: .attachments)
        var attachmentsDecoded0:[SsmClientTypes.AttachmentsSource]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [SsmClientTypes.AttachmentsSource]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

public struct UpdateDocumentMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDocumentMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDocumentMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentMetadataOutputError>
}

extension UpdateDocumentMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDocumentMetadataInput(documentReviews: \(Swift.String(describing: documentReviews)), documentVersion: \(Swift.String(describing: documentVersion)), name: \(Swift.String(describing: name)))"}
}

extension UpdateDocumentMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentReviews = "DocumentReviews"
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentReviews = documentReviews {
            try encodeContainer.encode(documentReviews, forKey: .documentReviews)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateDocumentMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDocumentMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDocumentMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentMetadataOutputError>
}

public struct UpdateDocumentMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDocumentMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDocumentMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentMetadataOutputError>
}

public struct UpdateDocumentMetadataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentMetadataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDocumentMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDocumentMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentMetadataOutputError>
}

public struct UpdateDocumentMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDocumentMetadataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDocumentMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDocumentMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDocumentMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDocumentMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDocumentMetadataOutputError>
}

public struct UpdateDocumentMetadataInput: Swift.Equatable {
    /// The change template review details to update.
    /// This member is required.
    public var documentReviews: SsmClientTypes.DocumentReviews?
    /// The version of a change template in which to update approval metadata.
    public var documentVersion: Swift.String?
    /// The name of the change template for which a version's metadata is to be updated.
    /// This member is required.
    public var name: Swift.String?

    public init (
        documentReviews: SsmClientTypes.DocumentReviews? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.documentReviews = documentReviews
        self.documentVersion = documentVersion
        self.name = name
    }
}

struct UpdateDocumentMetadataInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let documentVersion: Swift.String?
    public let documentReviews: SsmClientTypes.DocumentReviews?
}

extension UpdateDocumentMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentReviews = "DocumentReviews"
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentReviewsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentReviews.self, forKey: .documentReviews)
        documentReviews = documentReviewsDecoded
    }
}

extension UpdateDocumentMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDocumentMetadataOutputResponse()"}
}

extension UpdateDocumentMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDocumentMetadataOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDocumentMetadataOutputResponseBody: Swift.Equatable {
}

extension UpdateDocumentMetadataOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UpdateDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DocumentVersionLimitExceeded" : self = .documentVersionLimitExceeded(try DocumentVersionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateDocumentContent" : self = .duplicateDocumentContent(try DuplicateDocumentContent(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateDocumentVersionName" : self = .duplicateDocumentVersionName(try DuplicateDocumentVersionName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentContent" : self = .invalidDocumentContent(try InvalidDocumentContent(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentSchemaVersion" : self = .invalidDocumentSchemaVersion(try InvalidDocumentSchemaVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxDocumentSizeExceeded" : self = .maxDocumentSizeExceeded(try MaxDocumentSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentOutputError: Swift.Error, Swift.Equatable {
    case documentVersionLimitExceeded(DocumentVersionLimitExceeded)
    case duplicateDocumentContent(DuplicateDocumentContent)
    case duplicateDocumentVersionName(DuplicateDocumentVersionName)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentContent(InvalidDocumentContent)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case invalidDocumentSchemaVersion(InvalidDocumentSchemaVersion)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case maxDocumentSizeExceeded(MaxDocumentSizeExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDocumentOutputResponse(documentDescription: \(Swift.String(describing: documentDescription)))"}
}

extension UpdateDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documentDescription = output.documentDescription
        } else {
            self.documentDescription = nil
        }
    }
}

public struct UpdateDocumentOutputResponse: Swift.Equatable {
    /// A description of the document that was updated.
    public var documentDescription: SsmClientTypes.DocumentDescription?

    public init (
        documentDescription: SsmClientTypes.DocumentDescription? = nil
    )
    {
        self.documentDescription = documentDescription
    }
}

struct UpdateDocumentOutputResponseBody: Swift.Equatable {
    public let documentDescription: SsmClientTypes.DocumentDescription?
}

extension UpdateDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentDescription = "DocumentDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentDescription.self, forKey: .documentDescription)
        documentDescription = documentDescriptionDecoded
    }
}

public struct UpdateMaintenanceWindowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowOutputError>
}

extension UpdateMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowInput(allowUnassociatedTargets: \(Swift.String(describing: allowUnassociatedTargets)), cutoff: \(Swift.String(describing: cutoff)), description: \(Swift.String(describing: description)), duration: \(Swift.String(describing: duration)), enabled: \(Swift.String(describing: enabled)), endDate: \(Swift.String(describing: endDate)), name: \(Swift.String(describing: name)), replace: \(Swift.String(describing: replace)), schedule: \(Swift.String(describing: schedule)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleTimezone: \(Swift.String(describing: scheduleTimezone)), startDate: \(Swift.String(describing: startDate)), windowId: \(Swift.String(describing: windowId)))"}
}

extension UpdateMaintenanceWindowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case replace = "Replace"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowUnassociatedTargets != false {
            try encodeContainer.encode(allowUnassociatedTargets, forKey: .allowUnassociatedTargets)
        }
        if cutoff != 0 {
            try encodeContainer.encode(cutoff, forKey: .cutoff)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleTimezone = scheduleTimezone {
            try encodeContainer.encode(scheduleTimezone, forKey: .scheduleTimezone)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct UpdateMaintenanceWindowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowOutputError>
}

public struct UpdateMaintenanceWindowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowOutputError>
}

public struct UpdateMaintenanceWindowInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowOutputError>
}

public struct UpdateMaintenanceWindowInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateMaintenanceWindowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMaintenanceWindowInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowOutputError>
}

public struct UpdateMaintenanceWindowInput: Swift.Equatable {
    /// Whether targets must be registered with the maintenance window before tasks can be defined for those targets.
    public var allowUnassociatedTargets: Swift.Bool
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    public var cutoff: Swift.Int
    /// An optional description for the update request.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    public var duration: Swift.Int
    /// Whether the maintenance window is enabled.
    public var enabled: Swift.Bool
    /// The date and time, in ISO-8601 Extended format, for when you want the maintenance window to become inactive. EndDate allows you to set a date and time in the future when the maintenance window will no longer run.
    public var endDate: Swift.String?
    /// The name of the maintenance window.
    public var name: Swift.String?
    /// If True, then all fields that are required by the [CreateMaintenanceWindow] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    public var schedule: Swift.String?
    /// The number of days to wait after the date and time specified by a cron expression before running the maintenance window. For example, the following cron expression schedules a maintenance window to run the third Tuesday of every month at 11:30 PM. cron(30 23 ? * TUE#3 *) If the schedule offset is 2, the maintenance window won't run until two days later.
    public var scheduleOffset: Swift.Int
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var startDate: Swift.String?
    /// The ID of the maintenance window to update.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        allowUnassociatedTargets: Swift.Bool = false,
        cutoff: Swift.Int = 0,
        description: Swift.String? = nil,
        duration: Swift.Int = 0,
        enabled: Swift.Bool = false,
        endDate: Swift.String? = nil,
        name: Swift.String? = nil,
        replace: Swift.Bool = false,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int = 0,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.name = name
        self.replace = replace
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

struct UpdateMaintenanceWindowInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let startDate: Swift.String?
    public let endDate: Swift.String?
    public let schedule: Swift.String?
    public let scheduleTimezone: Swift.String?
    public let scheduleOffset: Swift.Int
    public let duration: Swift.Int
    public let cutoff: Swift.Int
    public let allowUnassociatedTargets: Swift.Bool
    public let enabled: Swift.Bool
    public let replace: Swift.Bool
}

extension UpdateMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case replace = "Replace"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Swift.Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let replaceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension UpdateMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceWindowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowOutputResponse(allowUnassociatedTargets: \(Swift.String(describing: allowUnassociatedTargets)), cutoff: \(Swift.String(describing: cutoff)), description: \(Swift.String(describing: description)), duration: \(Swift.String(describing: duration)), enabled: \(Swift.String(describing: enabled)), endDate: \(Swift.String(describing: endDate)), name: \(Swift.String(describing: name)), schedule: \(Swift.String(describing: schedule)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleTimezone: \(Swift.String(describing: scheduleTimezone)), startDate: \(Swift.String(describing: startDate)), windowId: \(Swift.String(describing: windowId)))"}
}

extension UpdateMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowUnassociatedTargets = output.allowUnassociatedTargets
            self.cutoff = output.cutoff
            self.description = output.description
            self.duration = output.duration
            self.enabled = output.enabled
            self.endDate = output.endDate
            self.name = output.name
            self.schedule = output.schedule
            self.scheduleOffset = output.scheduleOffset
            self.scheduleTimezone = output.scheduleTimezone
            self.startDate = output.startDate
            self.windowId = output.windowId
        } else {
            self.allowUnassociatedTargets = false
            self.cutoff = 0
            self.description = nil
            self.duration = 0
            self.enabled = false
            self.endDate = nil
            self.name = nil
            self.schedule = nil
            self.scheduleOffset = 0
            self.scheduleTimezone = nil
            self.startDate = nil
            self.windowId = nil
        }
    }
}

public struct UpdateMaintenanceWindowOutputResponse: Swift.Equatable {
    /// Whether targets must be registered with the maintenance window before tasks can be defined for those targets.
    public var allowUnassociatedTargets: Swift.Bool
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    public var cutoff: Swift.Int
    /// An optional description of the update.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    public var duration: Swift.Int
    /// Whether the maintenance window is enabled.
    public var enabled: Swift.Bool
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive. The maintenance window won't run after this specified time.
    public var endDate: Swift.String?
    /// The name of the maintenance window.
    public var name: Swift.String?
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    public var schedule: Swift.String?
    /// The number of days to wait to run a maintenance window after the scheduled cron expression date and time.
    public var scheduleOffset: Swift.Int
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active. The maintenance window won't run before this specified time.
    public var startDate: Swift.String?
    /// The ID of the created maintenance window.
    public var windowId: Swift.String?

    public init (
        allowUnassociatedTargets: Swift.Bool = false,
        cutoff: Swift.Int = 0,
        description: Swift.String? = nil,
        duration: Swift.Int = 0,
        enabled: Swift.Bool = false,
        endDate: Swift.String? = nil,
        name: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int = 0,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.name = name
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

struct UpdateMaintenanceWindowOutputResponseBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let startDate: Swift.String?
    public let endDate: Swift.String?
    public let schedule: Swift.String?
    public let scheduleTimezone: Swift.String?
    public let scheduleOffset: Swift.Int
    public let duration: Swift.Int
    public let cutoff: Swift.Int
    public let allowUnassociatedTargets: Swift.Bool
    public let enabled: Swift.Bool
}

extension UpdateMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Swift.Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

public struct UpdateMaintenanceWindowTargetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowTargetOutputError>
}

extension UpdateMaintenanceWindowTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowTargetInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), ownerInformation: \(Swift.String(describing: ownerInformation)), replace: \(Swift.String(describing: replace)), targets: \(Swift.String(describing: targets)), windowId: \(Swift.String(describing: windowId)), windowTargetId: \(Swift.String(describing: windowTargetId)))"}
}

extension UpdateMaintenanceWindowTargetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case replace = "Replace"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }
}

public struct UpdateMaintenanceWindowTargetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowTargetOutputError>
}

public struct UpdateMaintenanceWindowTargetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowTargetOutputError>
}

public struct UpdateMaintenanceWindowTargetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowTargetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateMaintenanceWindowTargetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMaintenanceWindowTargetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowTargetOutputError>
}

public struct UpdateMaintenanceWindowTargetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowTargetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateMaintenanceWindowTargetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMaintenanceWindowTargetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowTargetOutputError>
}

public struct UpdateMaintenanceWindowTargetInput: Swift.Equatable {
    /// An optional description for the update.
    public var description: Swift.String?
    /// A name for the update.
    public var name: Swift.String?
    /// User-provided value that will be included in any Amazon CloudWatch Events events raised while running tasks for these targets in this maintenance window.
    public var ownerInformation: Swift.String?
    /// If True, then all fields that are required by the [RegisterTargetWithMaintenanceWindow] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool
    /// The targets to add or replace.
    public var targets: [SsmClientTypes.Target]?
    /// The maintenance window ID with which to modify the target.
    /// This member is required.
    public var windowId: Swift.String?
    /// The target ID to modify.
    /// This member is required.
    public var windowTargetId: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        replace: Swift.Bool = false,
        targets: [SsmClientTypes.Target]? = nil,
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.replace = replace
        self.targets = targets
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct UpdateMaintenanceWindowTargetInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let windowTargetId: Swift.String?
    public let targets: [SsmClientTypes.Target]?
    public let ownerInformation: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let replace: Swift.Bool
}

extension UpdateMaintenanceWindowTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case replace = "Replace"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let replaceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension UpdateMaintenanceWindowTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceWindowTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceWindowTargetOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceWindowTargetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowTargetOutputResponse(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), ownerInformation: \(Swift.String(describing: ownerInformation)), targets: \(Swift.String(describing: targets)), windowId: \(Swift.String(describing: windowId)), windowTargetId: \(Swift.String(describing: windowTargetId)))"}
}

extension UpdateMaintenanceWindowTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMaintenanceWindowTargetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.name = output.name
            self.ownerInformation = output.ownerInformation
            self.targets = output.targets
            self.windowId = output.windowId
            self.windowTargetId = output.windowTargetId
        } else {
            self.description = nil
            self.name = nil
            self.ownerInformation = nil
            self.targets = nil
            self.windowId = nil
            self.windowTargetId = nil
        }
    }
}

public struct UpdateMaintenanceWindowTargetOutputResponse: Swift.Equatable {
    /// The updated description.
    public var description: Swift.String?
    /// The updated name.
    public var name: Swift.String?
    /// The updated owner.
    public var ownerInformation: Swift.String?
    /// The updated targets.
    public var targets: [SsmClientTypes.Target]?
    /// The maintenance window ID specified in the update request.
    public var windowId: Swift.String?
    /// The target ID specified in the update request.
    public var windowTargetId: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.targets = targets
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct UpdateMaintenanceWindowTargetOutputResponseBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let windowTargetId: Swift.String?
    public let targets: [SsmClientTypes.Target]?
    public let ownerInformation: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
}

extension UpdateMaintenanceWindowTargetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct UpdateMaintenanceWindowTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowTaskOutputError>
}

extension UpdateMaintenanceWindowTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowTaskInput(cutoffBehavior: \(Swift.String(describing: cutoffBehavior)), description: \(Swift.String(describing: description)), loggingInfo: \(Swift.String(describing: loggingInfo)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), replace: \(Swift.String(describing: replace)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), taskArn: \(Swift.String(describing: taskArn)), taskInvocationParameters: \(Swift.String(describing: taskInvocationParameters)), taskParameters: \(Swift.String(describing: taskParameters)), windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)))"}
}

extension UpdateMaintenanceWindowTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case replace = "Replace"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cutoffBehavior = cutoffBehavior {
            try encodeContainer.encode(cutoffBehavior.rawValue, forKey: .cutoffBehavior)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskInvocationParameters = taskInvocationParameters {
            try encodeContainer.encode(taskInvocationParameters, forKey: .taskInvocationParameters)
        }
        if let taskParameters = taskParameters {
            var taskParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskParameters)
            for (dictKey0, maintenancewindowtaskparameters0) in taskParameters {
                try taskParametersContainer.encode(maintenancewindowtaskparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }
}

public struct UpdateMaintenanceWindowTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowTaskOutputError>
}

public struct UpdateMaintenanceWindowTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceWindowTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowTaskOutputError>
}

public struct UpdateMaintenanceWindowTaskInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowTaskInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateMaintenanceWindowTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMaintenanceWindowTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowTaskOutputError>
}

public struct UpdateMaintenanceWindowTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceWindowTaskInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateMaintenanceWindowTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMaintenanceWindowTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceWindowTaskOutputError>
}

public struct UpdateMaintenanceWindowTaskInput: Swift.Equatable {
    /// Indicates whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
    ///
    /// * CONTINUE_TASK: When the cutoff time is reached, any tasks that are running continue. The default value.
    ///
    /// * CANCEL_TASK:
    ///
    /// * For Automation, Lambda, Step Functions tasks: When the cutoff time is reached, any task invocations that are already running continue, but no new task invocations are started.
    ///
    /// * For Run Command tasks: When the cutoff time is reached, the system sends a [CancelCommand] operation that attempts to cancel the command associated with the task. However, there is no guarantee that the command will be terminated and the underlying process stopped.
    ///
    ///
    /// The status for tasks that are not completed is TIMED_OUT.
    public var cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// The new task description to specify.
    public var description: Swift.String?
    /// The new logging location in Amazon S3 to specify. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SsmClientTypes.LoggingInfo?
    /// The new MaxConcurrency value you want to specify. MaxConcurrency is the number of targets that are allowed to run this task in parallel. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.
    public var maxConcurrency: Swift.String?
    /// The new MaxErrors value to specify. MaxErrors is the maximum number of errors that are allowed before the task stops being scheduled. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.
    public var maxErrors: Swift.String?
    /// The new task name to specify.
    public var name: Swift.String?
    /// The new task priority to specify. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.
    public var priority: Swift.Int
    /// If True, then all fields that are required by the [RegisterTaskWithMaintenanceWindow] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool
    /// The Amazon Resource Name (ARN) of the IAM service role for Amazon Web Services Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses your account's service-linked role. If no service-linked role for Systems Manager exists in your account, it is created when you run RegisterTaskWithMaintenanceWindow. For more information, see the following topics in the in the Amazon Web Services Systems Manager User Guide:
    ///
    /// * [Using service-linked roles for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions)
    ///
    /// * [Should I use a service-linked role or a custom service role to run maintenance window tasks? ](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role)
    public var serviceRoleArn: Swift.String?
    /// The targets (either managed nodes or tags) to modify. Managed nodes are specified using the format Key=instanceids,Values=instanceID_1,instanceID_2. Tags are specified using the format  Key=tag_name,Values=tag_value. One or more targets must be specified for maintenance window Run Command-type tasks. Depending on the task, targets are optional for other maintenance window task types (Automation, Lambda, and Step Functions). For more information about running tasks that don't specify targets, see [Registering maintenance window tasks without targets](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) in the Amazon Web Services Systems Manager User Guide.
    public var targets: [SsmClientTypes.Target]?
    /// The task ARN to modify.
    public var taskArn: Swift.String?
    /// The parameters that the task should use during execution. Populate only the fields that match the task type. All other fields should be empty. When you update a maintenance window task that has options specified in TaskInvocationParameters, you must provide again all the TaskInvocationParameters values that you want to retain. The values you don't specify again are removed. For example, suppose that when you registered a Run Command task, you specified TaskInvocationParameters values for Comment, NotificationConfig, and OutputS3BucketName. If you update the maintenance window task and specify only a different OutputS3BucketName value, the values for Comment and NotificationConfig are removed.
    public var taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The parameters to modify. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. The map has the following format: Key: string, between 1 and 255 characters Value: an array of strings, each string is between 1 and 255 characters
    public var taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The maintenance window ID that contains the task to modify.
    /// This member is required.
    public var windowId: Swift.String?
    /// The task ID to modify.
    /// This member is required.
    public var windowTaskId: Swift.String?

    public init (
        cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SsmClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int = 0,
        replace: Swift.Bool = false,
        serviceRoleArn: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.replace = replace
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct UpdateMaintenanceWindowTaskInputBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let windowTaskId: Swift.String?
    public let targets: [SsmClientTypes.Target]?
    public let taskArn: Swift.String?
    public let serviceRoleArn: Swift.String?
    public let taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    public let taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    public let priority: Swift.Int
    public let maxConcurrency: Swift.String?
    public let maxErrors: Swift.String?
    public let loggingInfo: SsmClientTypes.LoggingInfo?
    public let name: Swift.String?
    public let description: Swift.String?
    public let replace: Swift.Bool
    public let cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
}

extension UpdateMaintenanceWindowTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case replace = "Replace"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let replaceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
        let cutoffBehaviorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskCutoffBehavior.self, forKey: .cutoffBehavior)
        cutoffBehavior = cutoffBehaviorDecoded
    }
}

extension UpdateMaintenanceWindowTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceWindowTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceWindowTaskOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceWindowTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowTaskOutputResponse(cutoffBehavior: \(Swift.String(describing: cutoffBehavior)), description: \(Swift.String(describing: description)), loggingInfo: \(Swift.String(describing: loggingInfo)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), taskArn: \(Swift.String(describing: taskArn)), taskInvocationParameters: \(Swift.String(describing: taskInvocationParameters)), taskParameters: \(Swift.String(describing: taskParameters)), windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)))"}
}

extension UpdateMaintenanceWindowTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMaintenanceWindowTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cutoffBehavior = output.cutoffBehavior
            self.description = output.description
            self.loggingInfo = output.loggingInfo
            self.maxConcurrency = output.maxConcurrency
            self.maxErrors = output.maxErrors
            self.name = output.name
            self.priority = output.priority
            self.serviceRoleArn = output.serviceRoleArn
            self.targets = output.targets
            self.taskArn = output.taskArn
            self.taskInvocationParameters = output.taskInvocationParameters
            self.taskParameters = output.taskParameters
            self.windowId = output.windowId
            self.windowTaskId = output.windowTaskId
        } else {
            self.cutoffBehavior = nil
            self.description = nil
            self.loggingInfo = nil
            self.maxConcurrency = nil
            self.maxErrors = nil
            self.name = nil
            self.priority = 0
            self.serviceRoleArn = nil
            self.targets = nil
            self.taskArn = nil
            self.taskInvocationParameters = nil
            self.taskParameters = nil
            self.windowId = nil
            self.windowTaskId = nil
        }
    }
}

public struct UpdateMaintenanceWindowTaskOutputResponse: Swift.Equatable {
    /// The specification for whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
    public var cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// The updated task description.
    public var description: Swift.String?
    /// The updated logging information in Amazon S3. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SsmClientTypes.LoggingInfo?
    /// The updated MaxConcurrency value.
    public var maxConcurrency: Swift.String?
    /// The updated MaxErrors value.
    public var maxErrors: Swift.String?
    /// The updated task name.
    public var name: Swift.String?
    /// The updated priority value.
    public var priority: Swift.Int
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
    public var serviceRoleArn: Swift.String?
    /// The updated target values.
    public var targets: [SsmClientTypes.Target]?
    /// The updated task ARN value.
    public var taskArn: Swift.String?
    /// The updated parameter values.
    public var taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The updated parameter values. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The ID of the maintenance window that was updated.
    public var windowId: Swift.String?
    /// The task ID of the maintenance window that was updated.
    public var windowTaskId: Swift.String?

    public init (
        cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SsmClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRoleArn: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct UpdateMaintenanceWindowTaskOutputResponseBody: Swift.Equatable {
    public let windowId: Swift.String?
    public let windowTaskId: Swift.String?
    public let targets: [SsmClientTypes.Target]?
    public let taskArn: Swift.String?
    public let serviceRoleArn: Swift.String?
    public let taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    public let taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    public let priority: Swift.Int
    public let maxConcurrency: Swift.String?
    public let maxErrors: Swift.String?
    public let loggingInfo: SsmClientTypes.LoggingInfo?
    public let name: Swift.String?
    public let description: Swift.String?
    public let cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
}

extension UpdateMaintenanceWindowTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cutoffBehaviorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskCutoffBehavior.self, forKey: .cutoffBehavior)
        cutoffBehavior = cutoffBehaviorDecoded
    }
}

public struct UpdateManagedInstanceRoleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateManagedInstanceRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateManagedInstanceRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateManagedInstanceRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateManagedInstanceRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateManagedInstanceRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateManagedInstanceRoleOutputError>
}

extension UpdateManagedInstanceRoleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateManagedInstanceRoleInput(iamRole: \(Swift.String(describing: iamRole)), instanceId: \(Swift.String(describing: instanceId)))"}
}

extension UpdateManagedInstanceRoleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRole = "IamRole"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct UpdateManagedInstanceRoleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateManagedInstanceRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateManagedInstanceRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateManagedInstanceRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateManagedInstanceRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateManagedInstanceRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateManagedInstanceRoleOutputError>
}

public struct UpdateManagedInstanceRoleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateManagedInstanceRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateManagedInstanceRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateManagedInstanceRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateManagedInstanceRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateManagedInstanceRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateManagedInstanceRoleOutputError>
}

public struct UpdateManagedInstanceRoleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateManagedInstanceRoleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateManagedInstanceRoleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateManagedInstanceRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateManagedInstanceRoleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateManagedInstanceRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateManagedInstanceRoleOutputError>
}

public struct UpdateManagedInstanceRoleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateManagedInstanceRoleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateManagedInstanceRoleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateManagedInstanceRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateManagedInstanceRoleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateManagedInstanceRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateManagedInstanceRoleOutputError>
}

public struct UpdateManagedInstanceRoleInput: Swift.Equatable {
    /// The IAM role you want to assign or change.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The ID of the managed node where you want to update the role.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        iamRole: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.iamRole = iamRole
        self.instanceId = instanceId
    }
}

struct UpdateManagedInstanceRoleInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let iamRole: Swift.String?
}

extension UpdateManagedInstanceRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRole = "IamRole"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
    }
}

extension UpdateManagedInstanceRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateManagedInstanceRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateManagedInstanceRoleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateManagedInstanceRoleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateManagedInstanceRoleOutputResponse()"}
}

extension UpdateManagedInstanceRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateManagedInstanceRoleOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateManagedInstanceRoleOutputResponseBody: Swift.Equatable {
}

extension UpdateManagedInstanceRoleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateOpsItemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOpsItemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOpsItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOpsItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOpsItemOutputError>
}

extension UpdateOpsItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOpsItemInput(actualEndTime: \(Swift.String(describing: actualEndTime)), actualStartTime: \(Swift.String(describing: actualStartTime)), category: \(Swift.String(describing: category)), description: \(Swift.String(describing: description)), notifications: \(Swift.String(describing: notifications)), operationalData: \(Swift.String(describing: operationalData)), operationalDataToDelete: \(Swift.String(describing: operationalDataToDelete)), opsItemId: \(Swift.String(describing: opsItemId)), plannedEndTime: \(Swift.String(describing: plannedEndTime)), plannedStartTime: \(Swift.String(describing: plannedStartTime)), priority: \(Swift.String(describing: priority)), relatedOpsItems: \(Swift.String(describing: relatedOpsItems)), severity: \(Swift.String(describing: severity)), status: \(Swift.String(describing: status)), title: \(Swift.String(describing: title)))"}
}

extension UpdateOpsItemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case operationalDataToDelete = "OperationalDataToDelete"
        case opsItemId = "OpsItemId"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for opsitemnotifications0 in notifications {
                try notificationsContainer.encode(opsitemnotifications0)
            }
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let operationalDataToDelete = operationalDataToDelete {
            var operationalDataToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operationalDataToDelete)
            for opsitemopsdatakeyslist0 in operationalDataToDelete {
                try operationalDataToDeleteContainer.encode(opsitemopsdatakeyslist0)
            }
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let relatedOpsItems = relatedOpsItems {
            var relatedOpsItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedOpsItems)
            for relatedopsitems0 in relatedOpsItems {
                try relatedOpsItemsContainer.encode(relatedopsitems0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

public struct UpdateOpsItemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOpsItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOpsItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOpsItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOpsItemOutputError>
}

public struct UpdateOpsItemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOpsItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOpsItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOpsItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOpsItemOutputError>
}

public struct UpdateOpsItemInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOpsItemInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateOpsItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateOpsItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOpsItemOutputError>
}

public struct UpdateOpsItemInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOpsItemInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateOpsItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateOpsItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOpsItemOutputError>
}

public struct UpdateOpsItemInput: Swift.Equatable {
    /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualEndTime: ClientRuntime.Date?
    /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualStartTime: ClientRuntime.Date?
    /// Specify a new category for an OpsItem.
    public var category: Swift.String?
    /// Update the information about the OpsItem. Provide enough information so that users reading this OpsItem for the first time understand the issue.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this OpsItem is edited or changed.
    public var notifications: [SsmClientTypes.OpsItemNotification]?
    /// Add new keys or edit existing key-value pairs of the OperationalData map in the OpsItem object. Operational data is custom data that provides useful reference details about the OpsItem. For example, you can specify log files, error strings, license keys, troubleshooting tips, or other relevant data. You enter operational data as key-value pairs. The key has a maximum length of 128 characters. The value has a maximum size of 20 KB. Operational data keys can't begin with the following: amazon, aws, amzn, ssm, /amazon, /aws, /amzn, /ssm. You can choose to make the data searchable by other users in the account or you can restrict search access. Searchable data means that all users with access to the OpsItem Overview page (as provided by the [DescribeOpsItems] API operation) can view and search on the specified data. Operational data that isn't searchable is only viewable by users who have access to the OpsItem (as provided by the [GetOpsItem] API operation). Use the /aws/resources key in OperationalData to specify a related resource in the request. Use the /aws/automations key in OperationalData to associate an Automation runbook with the OpsItem. To view Amazon Web Services CLI example commands that use these keys, see [Creating OpsItems manually](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems) in the Amazon Web Services Systems Manager User Guide.
    public var operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
    /// Keys that you want to remove from the OperationalData map.
    public var operationalDataToDelete: [Swift.String]?
    /// The ID of the OpsItem.
    /// This member is required.
    public var opsItemId: Swift.String?
    /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedEndTime: ClientRuntime.Date?
    /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedStartTime: ClientRuntime.Date?
    /// The importance of this OpsItem in relation to other OpsItems in the system.
    public var priority: Swift.Int?
    /// One or more OpsItems that share something in common with the current OpsItems. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
    public var relatedOpsItems: [SsmClientTypes.RelatedOpsItem]?
    /// Specify a new severity for an OpsItem.
    public var severity: Swift.String?
    /// The OpsItem status. Status can be Open, In Progress, or Resolved. For more information, see [Editing OpsItem details](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems.html#OpsCenter-working-with-OpsItems-editing-details) in the Amazon Web Services Systems Manager User Guide.
    public var status: SsmClientTypes.OpsItemStatus?
    /// A short heading that describes the nature of the OpsItem and the impacted resource.
    public var title: Swift.String?

    public init (
        actualEndTime: ClientRuntime.Date? = nil,
        actualStartTime: ClientRuntime.Date? = nil,
        category: Swift.String? = nil,
        description: Swift.String? = nil,
        notifications: [SsmClientTypes.OpsItemNotification]? = nil,
        operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil,
        operationalDataToDelete: [Swift.String]? = nil,
        opsItemId: Swift.String? = nil,
        plannedEndTime: ClientRuntime.Date? = nil,
        plannedStartTime: ClientRuntime.Date? = nil,
        priority: Swift.Int? = nil,
        relatedOpsItems: [SsmClientTypes.RelatedOpsItem]? = nil,
        severity: Swift.String? = nil,
        status: SsmClientTypes.OpsItemStatus? = nil,
        title: Swift.String? = nil
    )
    {
        self.actualEndTime = actualEndTime
        self.actualStartTime = actualStartTime
        self.category = category
        self.description = description
        self.notifications = notifications
        self.operationalData = operationalData
        self.operationalDataToDelete = operationalDataToDelete
        self.opsItemId = opsItemId
        self.plannedEndTime = plannedEndTime
        self.plannedStartTime = plannedStartTime
        self.priority = priority
        self.relatedOpsItems = relatedOpsItems
        self.severity = severity
        self.status = status
        self.title = title
    }
}

struct UpdateOpsItemInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
    public let operationalDataToDelete: [Swift.String]?
    public let notifications: [SsmClientTypes.OpsItemNotification]?
    public let priority: Swift.Int?
    public let relatedOpsItems: [SsmClientTypes.RelatedOpsItem]?
    public let status: SsmClientTypes.OpsItemStatus?
    public let opsItemId: Swift.String?
    public let title: Swift.String?
    public let category: Swift.String?
    public let severity: Swift.String?
    public let actualStartTime: ClientRuntime.Date?
    public let actualEndTime: ClientRuntime.Date?
    public let plannedStartTime: ClientRuntime.Date?
    public let plannedEndTime: ClientRuntime.Date?
}

extension UpdateOpsItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case operationalDataToDelete = "OperationalDataToDelete"
        case opsItemId = "OpsItemId"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [Swift.String:SsmClientTypes.OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let operationalDataToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .operationalDataToDelete)
        var operationalDataToDeleteDecoded0:[Swift.String]? = nil
        if let operationalDataToDeleteContainer = operationalDataToDeleteContainer {
            operationalDataToDeleteDecoded0 = [Swift.String]()
            for string0 in operationalDataToDeleteContainer {
                if let string0 = string0 {
                    operationalDataToDeleteDecoded0?.append(string0)
                }
            }
        }
        operationalDataToDelete = operationalDataToDeleteDecoded0
        let notificationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[SsmClientTypes.OpsItemNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [SsmClientTypes.OpsItemNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let relatedOpsItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.RelatedOpsItem?].self, forKey: .relatedOpsItems)
        var relatedOpsItemsDecoded0:[SsmClientTypes.RelatedOpsItem]? = nil
        if let relatedOpsItemsContainer = relatedOpsItemsContainer {
            relatedOpsItemsDecoded0 = [SsmClientTypes.RelatedOpsItem]()
            for structure0 in relatedOpsItemsContainer {
                if let structure0 = structure0 {
                    relatedOpsItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedOpsItems = relatedOpsItemsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemStatus.self, forKey: .status)
        status = statusDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension UpdateOpsItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOpsItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemAlreadyExistsException" : self = .opsItemAlreadyExistsException(try OpsItemAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOpsItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemAlreadyExistsException(OpsItemAlreadyExistsException)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOpsItemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOpsItemOutputResponse()"}
}

extension UpdateOpsItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOpsItemOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateOpsItemOutputResponseBody: Swift.Equatable {
}

extension UpdateOpsItemOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateOpsMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOpsMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOpsMetadataOutputError>
}

extension UpdateOpsMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOpsMetadataInput(keysToDelete: \(Swift.String(describing: keysToDelete)), metadataToUpdate: \(Swift.String(describing: metadataToUpdate)), opsMetadataArn: \(Swift.String(describing: opsMetadataArn)))"}
}

extension UpdateOpsMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keysToDelete = "KeysToDelete"
        case metadataToUpdate = "MetadataToUpdate"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keysToDelete = keysToDelete {
            var keysToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keysToDelete)
            for metadatakeystodeletelist0 in keysToDelete {
                try keysToDeleteContainer.encode(metadatakeystodeletelist0)
            }
        }
        if let metadataToUpdate = metadataToUpdate {
            var metadataToUpdateContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadataToUpdate)
            for (dictKey0, metadatamap0) in metadataToUpdate {
                try metadataToUpdateContainer.encode(metadatamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
    }
}

public struct UpdateOpsMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOpsMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOpsMetadataOutputError>
}

public struct UpdateOpsMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOpsMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOpsMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOpsMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOpsMetadataOutputError>
}

public struct UpdateOpsMetadataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOpsMetadataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateOpsMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateOpsMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOpsMetadataOutputError>
}

public struct UpdateOpsMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOpsMetadataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateOpsMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateOpsMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOpsMetadataOutputError>
}

public struct UpdateOpsMetadataInput: Swift.Equatable {
    /// The metadata keys to delete from the OpsMetadata object.
    public var keysToDelete: [Swift.String]?
    /// Metadata to add to an OpsMetadata object.
    public var metadataToUpdate: [Swift.String:SsmClientTypes.MetadataValue]?
    /// The Amazon Resoure Name (ARN) of the OpsMetadata Object to update.
    /// This member is required.
    public var opsMetadataArn: Swift.String?

    public init (
        keysToDelete: [Swift.String]? = nil,
        metadataToUpdate: [Swift.String:SsmClientTypes.MetadataValue]? = nil,
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.keysToDelete = keysToDelete
        self.metadataToUpdate = metadataToUpdate
        self.opsMetadataArn = opsMetadataArn
    }
}

struct UpdateOpsMetadataInputBody: Swift.Equatable {
    public let opsMetadataArn: Swift.String?
    public let metadataToUpdate: [Swift.String:SsmClientTypes.MetadataValue]?
    public let keysToDelete: [Swift.String]?
}

extension UpdateOpsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keysToDelete = "KeysToDelete"
        case metadataToUpdate = "MetadataToUpdate"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
        let metadataToUpdateContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MetadataValue?].self, forKey: .metadataToUpdate)
        var metadataToUpdateDecoded0: [Swift.String:SsmClientTypes.MetadataValue]? = nil
        if let metadataToUpdateContainer = metadataToUpdateContainer {
            metadataToUpdateDecoded0 = [Swift.String:SsmClientTypes.MetadataValue]()
            for (key0, metadatavalue0) in metadataToUpdateContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataToUpdateDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadataToUpdate = metadataToUpdateDecoded0
        let keysToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keysToDelete)
        var keysToDeleteDecoded0:[Swift.String]? = nil
        if let keysToDeleteContainer = keysToDeleteContainer {
            keysToDeleteDecoded0 = [Swift.String]()
            for string0 in keysToDeleteContainer {
                if let string0 = string0 {
                    keysToDeleteDecoded0?.append(string0)
                }
            }
        }
        keysToDelete = keysToDeleteDecoded0
    }
}

extension UpdateOpsMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOpsMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataKeyLimitExceededException" : self = .opsMetadataKeyLimitExceededException(try OpsMetadataKeyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataNotFoundException" : self = .opsMetadataNotFoundException(try OpsMetadataNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataTooManyUpdatesException" : self = .opsMetadataTooManyUpdatesException(try OpsMetadataTooManyUpdatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOpsMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataKeyLimitExceededException(OpsMetadataKeyLimitExceededException)
    case opsMetadataNotFoundException(OpsMetadataNotFoundException)
    case opsMetadataTooManyUpdatesException(OpsMetadataTooManyUpdatesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOpsMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOpsMetadataOutputResponse(opsMetadataArn: \(Swift.String(describing: opsMetadataArn)))"}
}

extension UpdateOpsMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.opsMetadataArn = output.opsMetadataArn
        } else {
            self.opsMetadataArn = nil
        }
    }
}

public struct UpdateOpsMetadataOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the OpsMetadata Object that was updated.
    public var opsMetadataArn: Swift.String?

    public init (
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

struct UpdateOpsMetadataOutputResponseBody: Swift.Equatable {
    public let opsMetadataArn: Swift.String?
}

extension UpdateOpsMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
    }
}

public struct UpdatePatchBaselineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePatchBaselineOutputError>
}

extension UpdatePatchBaselineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePatchBaselineInput(approvalRules: \(Swift.String(describing: approvalRules)), approvedPatches: \(Swift.String(describing: approvedPatches)), approvedPatchesComplianceLevel: \(Swift.String(describing: approvedPatchesComplianceLevel)), approvedPatchesEnableNonSecurity: \(Swift.String(describing: approvedPatchesEnableNonSecurity)), baselineId: \(Swift.String(describing: baselineId)), description: \(Swift.String(describing: description)), globalFilters: \(Swift.String(describing: globalFilters)), name: \(Swift.String(describing: name)), rejectedPatches: \(Swift.String(describing: rejectedPatches)), rejectedPatchesAction: \(Swift.String(describing: rejectedPatchesAction)), replace: \(Swift.String(describing: replace)), sources: \(Swift.String(describing: sources)))"}
}

extension UpdatePatchBaselineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case replace = "Replace"
        case sources = "Sources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalFilters = globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
    }
}

public struct UpdatePatchBaselineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePatchBaselineOutputError>
}

public struct UpdatePatchBaselineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePatchBaselineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePatchBaselineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePatchBaselineOutputError>
}

public struct UpdatePatchBaselineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePatchBaselineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdatePatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePatchBaselineOutputError>
}

public struct UpdatePatchBaselineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePatchBaselineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdatePatchBaselineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePatchBaselineInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePatchBaselineOutputError>
}

public struct UpdatePatchBaselineInput: Swift.Equatable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SsmClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var approvedPatches: [Swift.String]?
    /// Assigns a new compliance severity level to an existing patch baseline.
    public var approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool
    /// The ID of the patch baseline to update.
    /// This member is required.
    public var baselineId: Swift.String?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to include patches in the baseline.
    public var globalFilters: SsmClientTypes.PatchFilterGroup?
    /// The name of the patch baseline.
    public var name: Swift.String?
    /// A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var rejectedPatches: [Swift.String]?
    /// The action for Patch Manager to take on patches included in the RejectedPackages list.
    ///
    /// * ALLOW_AS_DEPENDENCY : A package in the Rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as InstalledOther. This is the default action if no option is specified.
    ///
    /// * BLOCK : Packages in the RejectedPatches list, and packages that include them as dependencies, aren't installed under any circumstances. If a package was installed before it was added to the Rejected patches list, it is considered non-compliant with the patch baseline, and its status is reported as InstalledRejected.
    public var rejectedPatchesAction: SsmClientTypes.PatchAction?
    /// If True, then all fields that are required by the [CreatePatchBaseline] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SsmClientTypes.PatchSource]?

    public init (
        approvalRules: SsmClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool = false,
        baselineId: Swift.String? = nil,
        description: Swift.String? = nil,
        globalFilters: SsmClientTypes.PatchFilterGroup? = nil,
        name: Swift.String? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SsmClientTypes.PatchAction? = nil,
        replace: Swift.Bool = false,
        sources: [SsmClientTypes.PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.description = description
        self.globalFilters = globalFilters
        self.name = name
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.replace = replace
        self.sources = sources
    }
}

struct UpdatePatchBaselineInputBody: Swift.Equatable {
    public let baselineId: Swift.String?
    public let name: Swift.String?
    public let globalFilters: SsmClientTypes.PatchFilterGroup?
    public let approvalRules: SsmClientTypes.PatchRuleGroup?
    public let approvedPatches: [Swift.String]?
    public let approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    public let approvedPatchesEnableNonSecurity: Swift.Bool
    public let rejectedPatches: [Swift.String]?
    public let rejectedPatchesAction: SsmClientTypes.PatchAction?
    public let description: Swift.String?
    public let sources: [SsmClientTypes.PatchSource]?
    public let replace: Swift.Bool
}

extension UpdatePatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case replace = "Replace"
        case sources = "Sources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let replaceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension UpdatePatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePatchBaselineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePatchBaselineOutputResponse(approvalRules: \(Swift.String(describing: approvalRules)), approvedPatches: \(Swift.String(describing: approvedPatches)), approvedPatchesComplianceLevel: \(Swift.String(describing: approvedPatchesComplianceLevel)), approvedPatchesEnableNonSecurity: \(Swift.String(describing: approvedPatchesEnableNonSecurity)), baselineId: \(Swift.String(describing: baselineId)), createdDate: \(Swift.String(describing: createdDate)), description: \(Swift.String(describing: description)), globalFilters: \(Swift.String(describing: globalFilters)), modifiedDate: \(Swift.String(describing: modifiedDate)), name: \(Swift.String(describing: name)), operatingSystem: \(Swift.String(describing: operatingSystem)), rejectedPatches: \(Swift.String(describing: rejectedPatches)), rejectedPatchesAction: \(Swift.String(describing: rejectedPatchesAction)), sources: \(Swift.String(describing: sources)))"}
}

extension UpdatePatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRules = output.approvalRules
            self.approvedPatches = output.approvedPatches
            self.approvedPatchesComplianceLevel = output.approvedPatchesComplianceLevel
            self.approvedPatchesEnableNonSecurity = output.approvedPatchesEnableNonSecurity
            self.baselineId = output.baselineId
            self.createdDate = output.createdDate
            self.description = output.description
            self.globalFilters = output.globalFilters
            self.modifiedDate = output.modifiedDate
            self.name = output.name
            self.operatingSystem = output.operatingSystem
            self.rejectedPatches = output.rejectedPatches
            self.rejectedPatchesAction = output.rejectedPatchesAction
            self.sources = output.sources
        } else {
            self.approvalRules = nil
            self.approvedPatches = nil
            self.approvedPatchesComplianceLevel = nil
            self.approvedPatchesEnableNonSecurity = false
            self.baselineId = nil
            self.createdDate = nil
            self.description = nil
            self.globalFilters = nil
            self.modifiedDate = nil
            self.name = nil
            self.operatingSystem = nil
            self.rejectedPatches = nil
            self.rejectedPatchesAction = nil
            self.sources = nil
        }
    }
}

public struct UpdatePatchBaselineOutputResponse: Swift.Equatable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SsmClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline.
    public var approvedPatches: [Swift.String]?
    /// The compliance severity level assigned to the patch baseline after the update completed.
    public var approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool
    /// The ID of the deleted patch baseline.
    public var baselineId: Swift.String?
    /// The date when the patch baseline was created.
    public var createdDate: ClientRuntime.Date?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to exclude patches from the baseline.
    public var globalFilters: SsmClientTypes.PatchFilterGroup?
    /// The date when the patch baseline was last modified.
    public var modifiedDate: ClientRuntime.Date?
    /// The name of the patch baseline.
    public var name: Swift.String?
    /// The operating system rule used by the updated patch baseline.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// A list of explicitly rejected patches for the baseline.
    public var rejectedPatches: [Swift.String]?
    /// The action specified to take on patches included in the RejectedPatches list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.
    public var rejectedPatchesAction: SsmClientTypes.PatchAction?
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SsmClientTypes.PatchSource]?

    public init (
        approvalRules: SsmClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool = false,
        baselineId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        globalFilters: SsmClientTypes.PatchFilterGroup? = nil,
        modifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SsmClientTypes.PatchAction? = nil,
        sources: [SsmClientTypes.PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.createdDate = createdDate
        self.description = description
        self.globalFilters = globalFilters
        self.modifiedDate = modifiedDate
        self.name = name
        self.operatingSystem = operatingSystem
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
    }
}

struct UpdatePatchBaselineOutputResponseBody: Swift.Equatable {
    public let baselineId: Swift.String?
    public let name: Swift.String?
    public let operatingSystem: SsmClientTypes.OperatingSystem?
    public let globalFilters: SsmClientTypes.PatchFilterGroup?
    public let approvalRules: SsmClientTypes.PatchRuleGroup?
    public let approvedPatches: [Swift.String]?
    public let approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    public let approvedPatchesEnableNonSecurity: Swift.Bool
    public let rejectedPatches: [Swift.String]?
    public let rejectedPatchesAction: SsmClientTypes.PatchAction?
    public let createdDate: ClientRuntime.Date?
    public let modifiedDate: ClientRuntime.Date?
    public let description: Swift.String?
    public let sources: [SsmClientTypes.PatchSource]?
}

extension UpdatePatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case createdDate = "CreatedDate"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case modifiedDate = "ModifiedDate"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

public struct UpdateResourceDataSyncInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceDataSyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceDataSyncOutputError>
}

extension UpdateResourceDataSyncInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceDataSyncInput(syncName: \(Swift.String(describing: syncName)), syncSource: \(Swift.String(describing: syncSource)), syncType: \(Swift.String(describing: syncType)))"}
}

extension UpdateResourceDataSyncInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncSource = syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

public struct UpdateResourceDataSyncInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceDataSyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceDataSyncOutputError>
}

public struct UpdateResourceDataSyncInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceDataSyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceDataSyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceDataSyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceDataSyncOutputError>
}

public struct UpdateResourceDataSyncInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceDataSyncInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateResourceDataSyncInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateResourceDataSyncInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceDataSyncOutputError>
}

public struct UpdateResourceDataSyncInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceDataSyncInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateResourceDataSyncInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateResourceDataSyncInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceDataSyncOutputError>
}

public struct UpdateResourceDataSyncInput: Swift.Equatable {
    /// The name of the resource data sync you want to update.
    /// This member is required.
    public var syncName: Swift.String?
    /// Specify information about the data sources to synchronize.
    /// This member is required.
    public var syncSource: SsmClientTypes.ResourceDataSyncSource?
    /// The type of resource data sync. The supported SyncType is SyncFromSource.
    /// This member is required.
    public var syncType: Swift.String?

    public init (
        syncName: Swift.String? = nil,
        syncSource: SsmClientTypes.ResourceDataSyncSource? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.syncName = syncName
        self.syncSource = syncSource
        self.syncType = syncType
    }
}

struct UpdateResourceDataSyncInputBody: Swift.Equatable {
    public let syncName: Swift.String?
    public let syncType: Swift.String?
    public let syncSource: SsmClientTypes.ResourceDataSyncSource?
}

extension UpdateResourceDataSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncSource.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
    }
}

extension UpdateResourceDataSyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceDataSyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncConflictException" : self = .resourceDataSyncConflictException(try ResourceDataSyncConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfiguration" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncNotFound" : self = .resourceDataSyncNotFoundException(try ResourceDataSyncNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceDataSyncOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceDataSyncConflictException(ResourceDataSyncConflictException)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case resourceDataSyncNotFoundException(ResourceDataSyncNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceDataSyncOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceDataSyncOutputResponse()"}
}

extension UpdateResourceDataSyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceDataSyncOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateResourceDataSyncOutputResponseBody: Swift.Equatable {
}

extension UpdateResourceDataSyncOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateServiceSettingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceSettingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceSettingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceSettingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceSettingOutputError>
}

extension UpdateServiceSettingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceSettingInput(settingId: \(Swift.String(describing: settingId)), settingValue: \(Swift.String(describing: settingValue)))"}
}

extension UpdateServiceSettingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
        case settingValue = "SettingValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
        if let settingValue = settingValue {
            try encodeContainer.encode(settingValue, forKey: .settingValue)
        }
    }
}

public struct UpdateServiceSettingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceSettingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceSettingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceSettingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceSettingOutputError>
}

public struct UpdateServiceSettingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceSettingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceSettingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceSettingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceSettingOutputError>
}

public struct UpdateServiceSettingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceSettingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceSettingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceSettingInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceSettingOutputError>
}

public struct UpdateServiceSettingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceSettingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceSettingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceSettingInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceSettingOutputError>
}

/// The request body of the UpdateServiceSetting API operation.
public struct UpdateServiceSettingInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service setting to reset. For example, arn:aws:ssm:us-east-1:111122223333:servicesetting/ssm/parameter-store/high-throughput-enabled. The setting ID can be one of the following.
    ///
    /// * /ssm/automation/customer-script-log-destination
    ///
    /// * /ssm/automation/customer-script-log-group-name
    ///
    /// * /ssm/documents/console/public-sharing-permission
    ///
    /// * /ssm/parameter-store/default-parameter-tier
    ///
    /// * /ssm/parameter-store/high-throughput-enabled
    ///
    /// * /ssm/managed-instance/activation-tier
    /// This member is required.
    public var settingId: Swift.String?
    /// The new value to specify for the service setting. The following list specifies the available values for each setting.
    ///
    /// * /ssm/parameter-store/default-parameter-tier: Standard, Advanced, Intelligent-Tiering
    ///
    /// * /ssm/parameter-store/high-throughput-enabled: true or false
    ///
    /// * /ssm/managed-instance/activation-tier: true or false
    ///
    /// * /ssm/automation/customer-script-log-destination: CloudWatch
    ///
    /// * /ssm/automation/customer-script-log-group-name: the name of an Amazon CloudWatch Logs log group
    ///
    /// * /ssm/documents/console/public-sharing-permission: Enable or Disable
    ///
    /// * /ssm/managed-instance/activation-tier: standard or advanced
    /// This member is required.
    public var settingValue: Swift.String?

    public init (
        settingId: Swift.String? = nil,
        settingValue: Swift.String? = nil
    )
    {
        self.settingId = settingId
        self.settingValue = settingValue
    }
}

struct UpdateServiceSettingInputBody: Swift.Equatable {
    public let settingId: Swift.String?
    public let settingValue: Swift.String?
}

extension UpdateServiceSettingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
        case settingValue = "SettingValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingId)
        settingId = settingIdDecoded
        let settingValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingValue)
        settingValue = settingValueDecoded
    }
}

extension UpdateServiceSettingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceSettingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceSettingNotFound" : self = .serviceSettingNotFound(try ServiceSettingNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceSettingOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case serviceSettingNotFound(ServiceSettingNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceSettingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceSettingOutputResponse()"}
}

extension UpdateServiceSettingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The result body of the UpdateServiceSetting API operation.
public struct UpdateServiceSettingOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateServiceSettingOutputResponseBody: Swift.Equatable {
}

extension UpdateServiceSettingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}
