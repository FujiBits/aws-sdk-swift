// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSdkIdentityClientTypes {
    public enum AllowMessages: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowMessages] {
            return [
                .all,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowMessages(rawValue: rawValue) ?? AllowMessages.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkIdentityClientTypes.AppInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSdkIdentityClientTypes.AppInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstance(appInstanceArn: \(Swift.String(describing: appInstanceArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// The details of an AppInstance, an instance of an Amazon Chime SDK messaging application.
    public struct AppInstance: Swift.Equatable {
        /// The ARN of the messaging instance.
        public var appInstanceArn: Swift.String?
        /// The time at which an AppInstance was created. In epoch milliseconds.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time an AppInstance was last updated. In epoch milliseconds.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata of an AppInstance.
        public var metadata: Swift.String?
        /// The name of an AppInstance.
        public var name: Swift.String?

        public init (
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceAdmin: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin = "Admin"
        case appInstanceArn = "AppInstanceArn"
        case createdTimestamp = "CreatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = admin {
            try encodeContainer.encode(admin, forKey: .admin)
        }
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.Identity.self, forKey: .admin)
        admin = adminDecoded
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension ChimeSdkIdentityClientTypes.AppInstanceAdmin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceAdmin(admin: \(Swift.String(describing: admin)), appInstanceArn: \(Swift.String(describing: appInstanceArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// The details of an AppInstanceAdmin.
    public struct AppInstanceAdmin: Swift.Equatable {
        /// The AppInstanceAdmin data.
        public var admin: ChimeSdkIdentityClientTypes.Identity?
        /// The ARN of the AppInstance for which the user is an administrator.
        public var appInstanceArn: Swift.String?
        /// The time at which an administrator was created.
        public var createdTimestamp: ClientRuntime.Date?

        public init (
            admin: ChimeSdkIdentityClientTypes.Identity? = nil,
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.admin = admin
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceAdminSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin = "Admin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = admin {
            try encodeContainer.encode(admin, forKey: .admin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.Identity.self, forKey: .admin)
        admin = adminDecoded
    }
}

extension ChimeSdkIdentityClientTypes.AppInstanceAdminSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceAdminSummary(admin: \(Swift.String(describing: admin)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// Summary of the details of an AppInstanceAdmin.
    public struct AppInstanceAdminSummary: Swift.Equatable {
        /// The details of the AppInstanceAdmin.
        public var admin: ChimeSdkIdentityClientTypes.Identity?

        public init (
            admin: ChimeSdkIdentityClientTypes.Identity? = nil
        )
        {
            self.admin = admin
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelRetentionSettings = "ChannelRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelRetentionSettings = channelRetentionSettings {
            try encodeContainer.encode(channelRetentionSettings, forKey: .channelRetentionSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ChannelRetentionSettings.self, forKey: .channelRetentionSettings)
        channelRetentionSettings = channelRetentionSettingsDecoded
    }
}

extension ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceRetentionSettings(channelRetentionSettings: \(Swift.String(describing: channelRetentionSettings)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// The details of the data-retention settings for an AppInstance.
    public struct AppInstanceRetentionSettings: Swift.Equatable {
        /// The length of time in days to retain the messages in a channel.
        public var channelRetentionSettings: ChimeSdkIdentityClientTypes.ChannelRetentionSettings?

        public init (
            channelRetentionSettings: ChimeSdkIdentityClientTypes.ChannelRetentionSettings? = nil
        )
        {
            self.channelRetentionSettings = channelRetentionSettings
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSdkIdentityClientTypes.AppInstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceSummary(appInstanceArn: \(Swift.String(describing: appInstanceArn)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// Summary of the data for an AppInstance.
    public struct AppInstanceSummary: Swift.Equatable {
        /// The AppInstance ARN.
        public var appInstanceArn: Swift.String?
        /// The metadata of the AppInstance.
        public var metadata: Swift.String?
        /// The name of the AppInstance.
        public var name: Swift.String?

        public init (
            appInstanceArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceUser: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserArn = appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeSdkIdentityClientTypes.AppInstanceUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUser(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// The details of an AppInstanceUser.
    public struct AppInstanceUser: Swift.Equatable {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The time at which the AppInstanceUser was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which the AppInstanceUser was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of the AppInstanceUser.
        public var name: Swift.String?

        public init (
            appInstanceUserArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case appInstanceUserArn = "AppInstanceUserArn"
        case createdTimestamp = "CreatedTimestamp"
        case endpointAttributes = "EndpointAttributes"
        case endpointId = "EndpointId"
        case endpointState = "EndpointState"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let appInstanceUserArn = appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let endpointAttributes = endpointAttributes {
            try encodeContainer.encode(endpointAttributes, forKey: .endpointAttributes)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let endpointState = endpointState {
            try encodeContainer.encode(endpointState, forKey: .endpointState)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType.self, forKey: .type)
        type = typeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let endpointAttributesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointAttributes.self, forKey: .endpointAttributes)
        endpointAttributes = endpointAttributesDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
        let endpointStateDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointState.self, forKey: .endpointState)
        endpointState = endpointStateDecoded
    }
}

extension ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserEndpoint(allowMessages: \(Swift.String(describing: allowMessages)), appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), endpointAttributes: \(Swift.String(describing: endpointAttributes)), endpointId: \(Swift.String(describing: endpointId)), endpointState: \(Swift.String(describing: endpointState)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), name: \(Swift.String(describing: name)), resourceArn: \(Swift.String(describing: resourceArn)), type: \(Swift.String(describing: type)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// An endpoint under an Amazon Chime AppInstanceUser that receives messages for a user. For push notifications, the endpoint is a mobile device used to receive mobile push notifications for a user.
    public struct AppInstanceUserEndpoint: Swift.Equatable {
        /// Boolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint will receive all messages. NONE indicates the endpoint will receive no messages.
        public var allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The time at which an AppInstanceUserEndpoint was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The attributes of an Endpoint.
        public var endpointAttributes: ChimeSdkIdentityClientTypes.EndpointAttributes?
        /// The unique identifier of the AppInstanceUserEndpoint.
        public var endpointId: Swift.String?
        /// A read-only field that represents the state of an AppInstanceUserEndpoint. Supported values:
        ///
        /// * ACTIVE: The AppInstanceUserEndpoint is active and able to receive messages. When ACTIVE, the EndpointStatusReason remains empty.
        ///
        /// * INACTIVE: The AppInstanceUserEndpoint is inactive and can't receive message. When INACTIVE, the corresponding reason will be conveyed through EndpointStatusReason.
        ///
        /// * INVALID_DEVICE_TOKEN indicates that an AppInstanceUserEndpoint is INACTIVE due to invalid device token
        ///
        /// * INVALID_PINPOINT_ARN indicates that an AppInstanceUserEndpoint is INACTIVE due to an invalid pinpoint ARN that was input through the ResourceArn field.
        public var endpointState: ChimeSdkIdentityClientTypes.EndpointState?
        /// The time at which an AppInstanceUserEndpoint was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The name of the AppInstanceUserEndpoint.
        public var name: Swift.String?
        /// The ARN of the resource to which the endpoint belongs.
        public var resourceArn: Swift.String?
        /// The type of the AppInstanceUserEndpoint.
        public var type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType?

        public init (
            allowMessages: ChimeSdkIdentityClientTypes.AllowMessages? = nil,
            appInstanceUserArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endpointAttributes: ChimeSdkIdentityClientTypes.EndpointAttributes? = nil,
            endpointId: Swift.String? = nil,
            endpointState: ChimeSdkIdentityClientTypes.EndpointState? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType? = nil
        )
        {
            self.allowMessages = allowMessages
            self.appInstanceUserArn = appInstanceUserArn
            self.createdTimestamp = createdTimestamp
            self.endpointAttributes = endpointAttributes
            self.endpointId = endpointId
            self.endpointState = endpointState
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.resourceArn = resourceArn
            self.type = type
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case appInstanceUserArn = "AppInstanceUserArn"
        case endpointId = "EndpointId"
        case endpointState = "EndpointState"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let appInstanceUserArn = appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let endpointState = endpointState {
            try encodeContainer.encode(endpointState, forKey: .endpointState)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType.self, forKey: .type)
        type = typeDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
        let endpointStateDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointState.self, forKey: .endpointState)
        endpointState = endpointStateDecoded
    }
}

extension ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserEndpointSummary(allowMessages: \(Swift.String(describing: allowMessages)), appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), endpointId: \(Swift.String(describing: endpointId)), endpointState: \(Swift.String(describing: endpointState)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// Summary of the details of an AppInstanceUserEndpoint.
    public struct AppInstanceUserEndpointSummary: Swift.Equatable {
        /// BBoolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint will receive all messages. NONE indicates the endpoint will receive no messages.
        public var allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The unique identifier of the AppInstanceUserEndpoint.
        public var endpointId: Swift.String?
        /// A read-only field that represent the state of an AppInstanceUserEndpoint.
        public var endpointState: ChimeSdkIdentityClientTypes.EndpointState?
        /// The name of the AppInstanceUserEndpoint.
        public var name: Swift.String?
        /// The type of the AppInstanceUserEndpoint.
        public var type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType?

        public init (
            allowMessages: ChimeSdkIdentityClientTypes.AllowMessages? = nil,
            appInstanceUserArn: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            endpointState: ChimeSdkIdentityClientTypes.EndpointState? = nil,
            name: Swift.String? = nil,
            type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType? = nil
        )
        {
            self.allowMessages = allowMessages
            self.appInstanceUserArn = appInstanceUserArn
            self.endpointId = endpointId
            self.endpointState = endpointState
            self.name = name
            self.type = type
        }
    }

}

extension ChimeSdkIdentityClientTypes {
    public enum AppInstanceUserEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apns
        case apnsSandbox
        case gcm
        case sdkUnknown(Swift.String)

        public static var allCases: [AppInstanceUserEndpointType] {
            return [
                .apns,
                .apnsSandbox,
                .gcm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apns: return "APNS"
            case .apnsSandbox: return "APNS_SANDBOX"
            case .gcm: return "GCM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppInstanceUserEndpointType(rawValue: rawValue) ?? AppInstanceUserEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkIdentityClientTypes.AppInstanceUserSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserArn = appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSdkIdentityClientTypes.AppInstanceUserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserSummary(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// Summary of the details of an AppInstanceUser.
    public struct AppInstanceUserSummary: Swift.Equatable {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of an AppInstanceUser.
        public var name: Swift.String?

        public init (
            appInstanceUserArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let code: ChimeSdkIdentityClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSdkIdentityClientTypes.ChannelRetentionSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension ChimeSdkIdentityClientTypes.ChannelRetentionSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelRetentionSettings(retentionDays: \(Swift.String(describing: retentionDays)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// The details of the retention settings for a channel.
    public struct ChannelRetentionSettings: Swift.Equatable {
        /// The time in days to retain the messages in a channel.
        public var retentionDays: Swift.Int?

        public init (
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let code: ChimeSdkIdentityClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAppInstanceAdminInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceAdminInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceAdminOutputError>
}

extension CreateAppInstanceAdminInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceAdminInput(appInstanceAdminArn: \(Swift.String(describing: appInstanceAdminArn)), appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension CreateAppInstanceAdminInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdminArn = "AppInstanceAdminArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceAdminArn = appInstanceAdminArn {
            try encodeContainer.encode(appInstanceAdminArn, forKey: .appInstanceAdminArn)
        }
    }
}

public struct CreateAppInstanceAdminInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceAdminInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceAdminOutputError>
}

public struct CreateAppInstanceAdminInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceAdminInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceAdminOutputError>
}

public struct CreateAppInstanceAdminInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceAdminInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceAdminOutputError>
}

public struct CreateAppInstanceAdminInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceAdminInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceAdminOutputError>
}

public struct CreateAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the administrator of the current AppInstance.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceAdminInputBody: Swift.Equatable {
    public let appInstanceAdminArn: Swift.String?
}

extension CreateAppInstanceAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdminArn = "AppInstanceAdminArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceAdminArn)
        appInstanceAdminArn = appInstanceAdminArnDecoded
    }
}

extension CreateAppInstanceAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppInstanceAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppInstanceAdminOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppInstanceAdminOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceAdminOutputResponse(appInstanceAdmin: \(Swift.String(describing: appInstanceAdmin)), appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension CreateAppInstanceAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppInstanceAdminOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmin = output.appInstanceAdmin
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceAdmin = nil
            self.appInstanceArn = nil
        }
    }
}

public struct CreateAppInstanceAdminOutputResponse: Swift.Equatable {
    /// The name and ARN of the admin for the AppInstance.
    public var appInstanceAdmin: ChimeSdkIdentityClientTypes.Identity?
    /// The ARN of the of the admin for the AppInstance.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdmin: ChimeSdkIdentityClientTypes.Identity? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceAdminOutputResponseBody: Swift.Equatable {
    public let appInstanceAdmin: ChimeSdkIdentityClientTypes.Identity?
    public let appInstanceArn: Swift.String?
}

extension CreateAppInstanceAdminOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmin = "AppInstanceAdmin"
        case appInstanceArn = "AppInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.Identity.self, forKey: .appInstanceAdmin)
        appInstanceAdmin = appInstanceAdminDecoded
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

public struct CreateAppInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceOutputError>
}

extension CreateAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAppInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateAppInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceOutputError>
}

public struct CreateAppInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceOutputError>
}

public struct CreateAppInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceOutputError>
}

public struct CreateAppInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/app-instances"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceOutputError>
}

public struct CreateAppInstanceInput: Swift.Equatable {
    /// The ClientRequestToken of the AppInstance.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The metadata of the AppInstance. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The name of the AppInstance.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstanceUser.
    public var tags: [ChimeSdkIdentityClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeSdkIdentityClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let metadata: Swift.String?
    public let clientRequestToken: Swift.String?
    public let tags: [ChimeSdkIdentityClientTypes.Tag]?
}

extension CreateAppInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceOutputResponse(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension CreateAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceArn = nil
        }
    }
}

public struct CreateAppInstanceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceOutputResponseBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
}

extension CreateAppInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

public struct CreateAppInstanceUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceUserOutputError>
}

extension CreateAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceUserInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceUserId: \(Swift.String(describing: appInstanceUserId)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUserId = "AppInstanceUserId"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let appInstanceUserId = appInstanceUserId {
            try encodeContainer.encode(appInstanceUserId, forKey: .appInstanceUserId)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceUserOutputError>
}

public struct CreateAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceUserOutputError>
}

public struct CreateAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceUserOutputError>
}

public struct CreateAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/app-instance-users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceUserOutputError>
}

public struct CreateAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstance request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The user ID of the AppInstance.
    /// This member is required.
    public var appInstanceUserId: Swift.String?
    /// The token assigned to the user requesting an AppInstance.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The request's metadata. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The user's name.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstanceUser.
    public var tags: [ChimeSdkIdentityClientTypes.Tag]?

    public init (
        appInstanceArn: Swift.String? = nil,
        appInstanceUserId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeSdkIdentityClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUserId = appInstanceUserId
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceUserInputBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
    public let appInstanceUserId: Swift.String?
    public let name: Swift.String?
    public let metadata: Swift.String?
    public let clientRequestToken: Swift.String?
    public let tags: [ChimeSdkIdentityClientTypes.Tag]?
}

extension CreateAppInstanceUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUserId = "AppInstanceUserId"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserId)
        appInstanceUserId = appInstanceUserIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceUserOutputResponse(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)))"}
}

extension CreateAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
        } else {
            self.appInstanceUserArn = nil
        }
    }
}

public struct CreateAppInstanceUserOutputResponse: Swift.Equatable {
    /// The user's ARN.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct CreateAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let appInstanceUserArn: Swift.String?
}

extension CreateAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
    }
}

extension DeleteAppInstanceAdminInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceAdminInput(appInstanceAdminArn: \(Swift.String(describing: appInstanceAdminArn)), appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension DeleteAppInstanceAdminInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAppInstanceAdminInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceAdminInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceAdminOutputError>
}

public struct DeleteAppInstanceAdminInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceAdminInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceAdminOutputError>
}

public struct DeleteAppInstanceAdminInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceAdminInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceAdminOutputError>
}

public struct DeleteAppInstanceAdminInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceAdminInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        guard let appInstanceAdminArn = input.appInstanceAdminArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceAdminArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceAdminOutputError>
}

public struct DeleteAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the AppInstance's administrator.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceAdminInputBody: Swift.Equatable {
}

extension DeleteAppInstanceAdminInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppInstanceAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppInstanceAdminOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppInstanceAdminOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceAdminOutputResponse()"}
}

extension DeleteAppInstanceAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppInstanceAdminOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAppInstanceAdminOutputResponseBody: Swift.Equatable {
}

extension DeleteAppInstanceAdminOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension DeleteAppInstanceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAppInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceOutputError>
}

public struct DeleteAppInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceOutputError>
}

public struct DeleteAppInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceOutputError>
}

public struct DeleteAppInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceOutputError>
}

public struct DeleteAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceInputBody: Swift.Equatable {
}

extension DeleteAppInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceOutputResponse()"}
}

extension DeleteAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAppInstanceOutputResponseBody: Swift.Equatable {
}

extension DeleteAppInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)))"}
}

extension DeleteAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceUserOutputError>
}

public struct DeleteAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceUserOutputError>
}

public struct DeleteAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceUserOutputError>
}

public struct DeleteAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceUserOutputError>
}

public struct DeleteAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user request being deleted.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct DeleteAppInstanceUserInputBody: Swift.Equatable {
}

extension DeleteAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceUserOutputResponse()"}
}

extension DeleteAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppInstanceUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAppInstanceUserOutputResponseBody: Swift.Equatable {
}

extension DeleteAppInstanceUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterAppInstanceUserEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterAppInstanceUserEndpointInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), endpointId: \(Swift.String(describing: endpointId)))"}
}

extension DeregisterAppInstanceUserEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeregisterAppInstanceUserEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterAppInstanceUserEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterAppInstanceUserEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterAppInstanceUserEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterAppInstanceUserEndpointOutputError>
}

public struct DeregisterAppInstanceUserEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterAppInstanceUserEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterAppInstanceUserEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterAppInstanceUserEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterAppInstanceUserEndpointOutputError>
}

public struct DeregisterAppInstanceUserEndpointInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterAppInstanceUserEndpointInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeregisterAppInstanceUserEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterAppInstanceUserEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterAppInstanceUserEndpointOutputError>
}

public struct DeregisterAppInstanceUserEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterAppInstanceUserEndpointInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeregisterAppInstanceUserEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        guard let endpointId = input.endpointId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("endpointId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterAppInstanceUserEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterAppInstanceUserEndpointOutputError>
}

public struct DeregisterAppInstanceUserEndpointInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    /// This member is required.
    public var endpointId: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct DeregisterAppInstanceUserEndpointInputBody: Swift.Equatable {
}

extension DeregisterAppInstanceUserEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterAppInstanceUserEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterAppInstanceUserEndpointOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterAppInstanceUserEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterAppInstanceUserEndpointOutputResponse()"}
}

extension DeregisterAppInstanceUserEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterAppInstanceUserEndpointOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterAppInstanceUserEndpointOutputResponseBody: Swift.Equatable {
}

extension DeregisterAppInstanceUserEndpointOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceAdminInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceAdminInput(appInstanceAdminArn: \(Swift.String(describing: appInstanceAdminArn)), appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension DescribeAppInstanceAdminInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAppInstanceAdminInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceAdminInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceAdminOutputError>
}

public struct DescribeAppInstanceAdminInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceAdminInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceAdminOutputError>
}

public struct DescribeAppInstanceAdminInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceAdminInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceAdminOutputError>
}

public struct DescribeAppInstanceAdminInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceAdminInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        guard let appInstanceAdminArn = input.appInstanceAdminArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceAdminArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceAdminOutputError>
}

public struct DescribeAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the AppInstanceAdmin.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct DescribeAppInstanceAdminInputBody: Swift.Equatable {
}

extension DescribeAppInstanceAdminInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceAdminOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceAdminOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceAdminOutputResponse(appInstanceAdmin: \(Swift.String(describing: appInstanceAdmin)))"}
}

extension DescribeAppInstanceAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceAdminOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmin = output.appInstanceAdmin
        } else {
            self.appInstanceAdmin = nil
        }
    }
}

public struct DescribeAppInstanceAdminOutputResponse: Swift.Equatable {
    /// The ARN and name of the AppInstanceUser, the ARN of the AppInstance, and the created and last-updated timestamps. All timestamps use epoch milliseconds.
    public var appInstanceAdmin: ChimeSdkIdentityClientTypes.AppInstanceAdmin?

    public init (
        appInstanceAdmin: ChimeSdkIdentityClientTypes.AppInstanceAdmin? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
    }
}

struct DescribeAppInstanceAdminOutputResponseBody: Swift.Equatable {
    public let appInstanceAdmin: ChimeSdkIdentityClientTypes.AppInstanceAdmin?
}

extension DescribeAppInstanceAdminOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmin = "AppInstanceAdmin"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceAdmin.self, forKey: .appInstanceAdmin)
        appInstanceAdmin = appInstanceAdminDecoded
    }
}

extension DescribeAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension DescribeAppInstanceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAppInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceOutputError>
}

public struct DescribeAppInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceOutputError>
}

public struct DescribeAppInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceOutputError>
}

public struct DescribeAppInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceOutputError>
}

public struct DescribeAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DescribeAppInstanceInputBody: Swift.Equatable {
}

extension DescribeAppInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceOutputResponse(appInstance: \(Swift.String(describing: appInstance)))"}
}

extension DescribeAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstance = output.appInstance
        } else {
            self.appInstance = nil
        }
    }
}

public struct DescribeAppInstanceOutputResponse: Swift.Equatable {
    /// The ARN, metadata, created and last-updated timestamps, and the name of the AppInstance. All timestamps use epoch milliseconds.
    public var appInstance: ChimeSdkIdentityClientTypes.AppInstance?

    public init (
        appInstance: ChimeSdkIdentityClientTypes.AppInstance? = nil
    )
    {
        self.appInstance = appInstance
    }
}

struct DescribeAppInstanceOutputResponseBody: Swift.Equatable {
    public let appInstance: ChimeSdkIdentityClientTypes.AppInstance?
}

extension DescribeAppInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstance = "AppInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstance.self, forKey: .appInstance)
        appInstance = appInstanceDecoded
    }
}

extension DescribeAppInstanceUserEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceUserEndpointInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), endpointId: \(Swift.String(describing: endpointId)))"}
}

extension DescribeAppInstanceUserEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAppInstanceUserEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceUserEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceUserEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserEndpointOutputError>
}

public struct DescribeAppInstanceUserEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceUserEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceUserEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserEndpointOutputError>
}

public struct DescribeAppInstanceUserEndpointInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserEndpointInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceUserEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceUserEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserEndpointOutputError>
}

public struct DescribeAppInstanceUserEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserEndpointInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceUserEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        guard let endpointId = input.endpointId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("endpointId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceUserEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserEndpointOutputError>
}

public struct DescribeAppInstanceUserEndpointInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    /// This member is required.
    public var endpointId: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct DescribeAppInstanceUserEndpointInputBody: Swift.Equatable {
}

extension DescribeAppInstanceUserEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceUserEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceUserEndpointOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceUserEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceUserEndpointOutputResponse(appInstanceUserEndpoint: \(Swift.String(describing: appInstanceUserEndpoint)))"}
}

extension DescribeAppInstanceUserEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceUserEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserEndpoint = output.appInstanceUserEndpoint
        } else {
            self.appInstanceUserEndpoint = nil
        }
    }
}

public struct DescribeAppInstanceUserEndpointOutputResponse: Swift.Equatable {
    /// The full details of an AppInstanceUserEndpoint: the AppInstanceUserArn, ID, name, type, resource ARN, attributes, allow messages, state, and created and last updated timestamps. All timestamps use epoch milliseconds.
    public var appInstanceUserEndpoint: ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint?

    public init (
        appInstanceUserEndpoint: ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint? = nil
    )
    {
        self.appInstanceUserEndpoint = appInstanceUserEndpoint
    }
}

struct DescribeAppInstanceUserEndpointOutputResponseBody: Swift.Equatable {
    public let appInstanceUserEndpoint: ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint?
}

extension DescribeAppInstanceUserEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserEndpoint = "AppInstanceUserEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserEndpointDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint.self, forKey: .appInstanceUserEndpoint)
        appInstanceUserEndpoint = appInstanceUserEndpointDecoded
    }
}

extension DescribeAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)))"}
}

extension DescribeAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserOutputError>
}

public struct DescribeAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserOutputError>
}

public struct DescribeAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserOutputError>
}

public struct DescribeAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserOutputError>
}

public struct DescribeAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct DescribeAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceUserOutputResponse(appInstanceUser: \(Swift.String(describing: appInstanceUser)))"}
}

extension DescribeAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUser = output.appInstanceUser
        } else {
            self.appInstanceUser = nil
        }
    }
}

public struct DescribeAppInstanceUserOutputResponse: Swift.Equatable {
    /// The name of the AppInstanceUser.
    public var appInstanceUser: ChimeSdkIdentityClientTypes.AppInstanceUser?

    public init (
        appInstanceUser: ChimeSdkIdentityClientTypes.AppInstanceUser? = nil
    )
    {
        self.appInstanceUser = appInstanceUser
    }
}

struct DescribeAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let appInstanceUser: ChimeSdkIdentityClientTypes.AppInstanceUser?
}

extension DescribeAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUser = "AppInstanceUser"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceUser.self, forKey: .appInstanceUser)
        appInstanceUser = appInstanceUserDecoded
    }
}

extension ChimeSdkIdentityClientTypes.EndpointAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceToken = "DeviceToken"
        case voipDeviceToken = "VoipDeviceToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceToken = deviceToken {
            try encodeContainer.encode(deviceToken, forKey: .deviceToken)
        }
        if let voipDeviceToken = voipDeviceToken {
            try encodeContainer.encode(voipDeviceToken, forKey: .voipDeviceToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceToken)
        deviceToken = deviceTokenDecoded
        let voipDeviceTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voipDeviceToken)
        voipDeviceToken = voipDeviceTokenDecoded
    }
}

extension ChimeSdkIdentityClientTypes.EndpointAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointAttributes(deviceToken: \(Swift.String(describing: deviceToken)), voipDeviceToken: \(Swift.String(describing: voipDeviceToken)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// The attributes of an Endpoint.
    public struct EndpointAttributes: Swift.Equatable {
        /// The device token for the GCM, APNS, and APNS_SANDBOX endpoint types.
        /// This member is required.
        public var deviceToken: Swift.String?
        /// The VOIP device token for the APNS and APNS_SANDBOX endpoint types.
        public var voipDeviceToken: Swift.String?

        public init (
            deviceToken: Swift.String? = nil,
            voipDeviceToken: Swift.String? = nil
        )
        {
            self.deviceToken = deviceToken
            self.voipDeviceToken = voipDeviceToken
        }
    }

}

extension ChimeSdkIdentityClientTypes.EndpointState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason.rawValue, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension ChimeSdkIdentityClientTypes.EndpointState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointState(status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// A read-only field that represents the state of an AppInstanceUserEndpoint. Supported values:
    ///
    /// * ACTIVE: The AppInstanceUserEndpoint is active and able to receive messages. When ACTIVE, the EndpointStatusReason remains empty.
    ///
    /// * INACTIVE: The AppInstanceUserEndpoint is inactive and can't receive message. When INACTIVE, the corresponding reason will be conveyed through EndpointStatusReason.
    ///
    /// * INVALID_DEVICE_TOKEN indicates that an AppInstanceUserEndpoint is INACTIVE due to invalid device token
    ///
    /// * INVALID_PINPOINT_ARN indicates that an AppInstanceUserEndpoint is INACTIVE due to an invalid pinpoint ARN that was input through the ResourceArn field.
    public struct EndpointState: Swift.Equatable {
        /// Enum that indicates the Status of an AppInstanceUserEndpoint.
        /// This member is required.
        public var status: ChimeSdkIdentityClientTypes.EndpointStatus?
        /// The reason for the EndpointStatus.
        public var statusReason: ChimeSdkIdentityClientTypes.EndpointStatusReason?

        public init (
            status: ChimeSdkIdentityClientTypes.EndpointStatus? = nil,
            statusReason: ChimeSdkIdentityClientTypes.EndpointStatusReason? = nil
        )
        {
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension ChimeSdkIdentityClientTypes {
    public enum EndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkIdentityClientTypes {
    public enum EndpointStatusReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidDeviceToken
        case invalidPinpointArn
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatusReason] {
            return [
                .invalidDeviceToken,
                .invalidPinpointArn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidDeviceToken: return "INVALID_DEVICE_TOKEN"
            case .invalidPinpointArn: return "INVALID_PINPOINT_ARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatusReason(rawValue: rawValue) ?? EndpointStatusReason.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkIdentityClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForbiddenException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    public let code: ChimeSdkIdentityClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetAppInstanceRetentionSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAppInstanceRetentionSettingsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension GetAppInstanceRetentionSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAppInstanceRetentionSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceRetentionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAppInstanceRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAppInstanceRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceRetentionSettingsOutputError>
}

public struct GetAppInstanceRetentionSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceRetentionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAppInstanceRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAppInstanceRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceRetentionSettingsOutputError>
}

public struct GetAppInstanceRetentionSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceRetentionSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAppInstanceRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAppInstanceRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceRetentionSettingsOutputError>
}

public struct GetAppInstanceRetentionSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceRetentionSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAppInstanceRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAppInstanceRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceRetentionSettingsOutputError>
}

public struct GetAppInstanceRetentionSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct GetAppInstanceRetentionSettingsInputBody: Swift.Equatable {
}

extension GetAppInstanceRetentionSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAppInstanceRetentionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppInstanceRetentionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppInstanceRetentionSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppInstanceRetentionSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAppInstanceRetentionSettingsOutputResponse(appInstanceRetentionSettings: \(Swift.String(describing: appInstanceRetentionSettings)), initiateDeletionTimestamp: \(Swift.String(describing: initiateDeletionTimestamp)))"}
}

extension GetAppInstanceRetentionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAppInstanceRetentionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceRetentionSettings = output.appInstanceRetentionSettings
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
        } else {
            self.appInstanceRetentionSettings = nil
            self.initiateDeletionTimestamp = nil
        }
    }
}

public struct GetAppInstanceRetentionSettingsOutputResponse: Swift.Equatable {
    /// The retention settings for the AppInstance.
    public var appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?
    /// The timestamp representing the time at which the specified items are retained, in Epoch Seconds.
    public var initiateDeletionTimestamp: ClientRuntime.Date?

    public init (
        appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

struct GetAppInstanceRetentionSettingsOutputResponseBody: Swift.Equatable {
    public let appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?
    public let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension GetAppInstanceRetentionSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

extension ChimeSdkIdentityClientTypes.Identity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ChimeSdkIdentityClientTypes.Identity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Identity(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// The details of a user.
    public struct Identity: Swift.Equatable {
        /// The ARN in an Identity.
        public var arn: Swift.String?
        /// The name in an Identity.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ListAppInstanceAdminsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceAdminsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstanceAdminsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAppInstanceAdminsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceAdminsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstanceAdminsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstanceAdminsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceAdminsOutputError>
}

public struct ListAppInstanceAdminsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceAdminsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstanceAdminsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstanceAdminsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceAdminsOutputError>
}

public struct ListAppInstanceAdminsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceAdminsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppInstanceAdminsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstanceAdminsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceAdminsOutputError>
}

public struct ListAppInstanceAdminsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceAdminsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppInstanceAdminsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstanceAdminsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceAdminsOutputError>
}

public struct ListAppInstanceAdminsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of administrators that you want to return.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceAdminsInputBody: Swift.Equatable {
}

extension ListAppInstanceAdminsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceAdminsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstanceAdminsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstanceAdminsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstanceAdminsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceAdminsOutputResponse(appInstanceAdmins: \(Swift.String(describing: appInstanceAdmins)), appInstanceArn: \(Swift.String(describing: appInstanceArn)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstanceAdminsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstanceAdminsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmins = output.appInstanceAdmins
            self.appInstanceArn = output.appInstanceArn
            self.nextToken = output.nextToken
        } else {
            self.appInstanceAdmins = nil
            self.appInstanceArn = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceAdminsOutputResponse: Swift.Equatable {
    /// The information for each administrator.
    public var appInstanceAdmins: [ChimeSdkIdentityClientTypes.AppInstanceAdminSummary]?
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceAdmins: [ChimeSdkIdentityClientTypes.AppInstanceAdminSummary]? = nil,
        appInstanceArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceAdmins = appInstanceAdmins
        self.appInstanceArn = appInstanceArn
        self.nextToken = nextToken
    }
}

struct ListAppInstanceAdminsOutputResponseBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
    public let appInstanceAdmins: [ChimeSdkIdentityClientTypes.AppInstanceAdminSummary]?
    public let nextToken: Swift.String?
}

extension ListAppInstanceAdminsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmins = "AppInstanceAdmins"
        case appInstanceArn = "AppInstanceArn"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceAdminsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.AppInstanceAdminSummary?].self, forKey: .appInstanceAdmins)
        var appInstanceAdminsDecoded0:[ChimeSdkIdentityClientTypes.AppInstanceAdminSummary]? = nil
        if let appInstanceAdminsContainer = appInstanceAdminsContainer {
            appInstanceAdminsDecoded0 = [ChimeSdkIdentityClientTypes.AppInstanceAdminSummary]()
            for structure0 in appInstanceAdminsContainer {
                if let structure0 = structure0 {
                    appInstanceAdminsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceAdmins = appInstanceAdminsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppInstanceUserEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUserEndpointsInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstanceUserEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAppInstanceUserEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUserEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstanceUserEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUserEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstanceUserEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUserEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUserEndpointsOutputError>
}

public struct ListAppInstanceUserEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUserEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstanceUserEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUserEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstanceUserEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUserEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUserEndpointsOutputError>
}

public struct ListAppInstanceUserEndpointsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUserEndpointsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppInstanceUserEndpointsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUserEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstanceUserEndpointsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUserEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUserEndpointsOutputError>
}

public struct ListAppInstanceUserEndpointsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUserEndpointsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppInstanceUserEndpointsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUserEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstanceUserEndpointsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUserEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUserEndpointsOutputError>
}

public struct ListAppInstanceUserEndpointsInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The maximum number of endpoints that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested endpoints are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUserEndpointsInputBody: Swift.Equatable {
}

extension ListAppInstanceUserEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceUserEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstanceUserEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstanceUserEndpointsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstanceUserEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUserEndpointsOutputResponse(appInstanceUserEndpoints: \(Swift.String(describing: appInstanceUserEndpoints)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstanceUserEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstanceUserEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserEndpoints = output.appInstanceUserEndpoints
            self.nextToken = output.nextToken
        } else {
            self.appInstanceUserEndpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceUserEndpointsOutputResponse: Swift.Equatable {
    /// The information for each requested AppInstanceUserEndpoint.
    public var appInstanceUserEndpoints: [ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary]?
    /// The token passed by previous API calls until all requested endpoints are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceUserEndpoints: [ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserEndpoints = appInstanceUserEndpoints
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUserEndpointsOutputResponseBody: Swift.Equatable {
    public let appInstanceUserEndpoints: [ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary]?
    public let nextToken: Swift.String?
}

extension ListAppInstanceUserEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserEndpoints = "AppInstanceUserEndpoints"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserEndpointsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary?].self, forKey: .appInstanceUserEndpoints)
        var appInstanceUserEndpointsDecoded0:[ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary]? = nil
        if let appInstanceUserEndpointsContainer = appInstanceUserEndpointsContainer {
            appInstanceUserEndpointsDecoded0 = [ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary]()
            for structure0 in appInstanceUserEndpointsContainer {
                if let structure0 = structure0 {
                    appInstanceUserEndpointsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceUserEndpoints = appInstanceUserEndpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppInstanceUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUsersInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstanceUsersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAppInstanceUsersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstanceUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstanceUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUsersOutputError>
}

public struct ListAppInstanceUsersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstanceUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let appInstanceArn = input.operationInput.appInstanceArn {
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstanceUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUsersOutputError>
}

public struct ListAppInstanceUsersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUsersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppInstanceUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstanceUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUsersOutputError>
}

public struct ListAppInstanceUsersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUsersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppInstanceUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/app-instance-users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstanceUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUsersOutputError>
}

public struct ListAppInstanceUsersInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of requests that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUsersInputBody: Swift.Equatable {
}

extension ListAppInstanceUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstanceUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstanceUsersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstanceUsersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUsersOutputResponse(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceUsers: \(Swift.String(describing: appInstanceUsers)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstanceUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstanceUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
            self.appInstanceUsers = output.appInstanceUsers
            self.nextToken = output.nextToken
        } else {
            self.appInstanceArn = nil
            self.appInstanceUsers = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceUsersOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The information for each requested AppInstanceUser.
    public var appInstanceUsers: [ChimeSdkIdentityClientTypes.AppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        appInstanceUsers: [ChimeSdkIdentityClientTypes.AppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUsers = appInstanceUsers
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUsersOutputResponseBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
    public let appInstanceUsers: [ChimeSdkIdentityClientTypes.AppInstanceUserSummary]?
    public let nextToken: Swift.String?
}

extension ListAppInstanceUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUsers = "AppInstanceUsers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceUsersContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.AppInstanceUserSummary?].self, forKey: .appInstanceUsers)
        var appInstanceUsersDecoded0:[ChimeSdkIdentityClientTypes.AppInstanceUserSummary]? = nil
        if let appInstanceUsersContainer = appInstanceUsersContainer {
            appInstanceUsersDecoded0 = [ChimeSdkIdentityClientTypes.AppInstanceUserSummary]()
            for structure0 in appInstanceUsersContainer {
                if let structure0 = structure0 {
                    appInstanceUsersDecoded0?.append(structure0)
                }
            }
        }
        appInstanceUsers = appInstanceUsersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstancesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstancesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAppInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstancesOutputError>
}

public struct ListAppInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstancesOutputError>
}

public struct ListAppInstancesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstancesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstancesOutputError>
}

public struct ListAppInstancesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstancesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/app-instances"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstancesOutputError>
}

public struct ListAppInstancesInput: Swift.Equatable {
    /// The maximum number of AppInstances that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API requests until you reach the maximum number of AppInstances.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstancesInputBody: Swift.Equatable {
}

extension ListAppInstancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstancesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstancesOutputResponse(appInstances: \(Swift.String(describing: appInstances)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstances = output.appInstances
            self.nextToken = output.nextToken
        } else {
            self.appInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstancesOutputResponse: Swift.Equatable {
    /// The information for each AppInstance.
    public var appInstances: [ChimeSdkIdentityClientTypes.AppInstanceSummary]?
    /// The token passed by previous API requests until the maximum number of AppInstances is reached.
    public var nextToken: Swift.String?

    public init (
        appInstances: [ChimeSdkIdentityClientTypes.AppInstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstances = appInstances
        self.nextToken = nextToken
    }
}

struct ListAppInstancesOutputResponseBody: Swift.Equatable {
    public let appInstances: [ChimeSdkIdentityClientTypes.AppInstanceSummary]?
    public let nextToken: Swift.String?
}

extension ListAppInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstances = "AppInstances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstancesContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.AppInstanceSummary?].self, forKey: .appInstances)
        var appInstancesDecoded0:[ChimeSdkIdentityClientTypes.AppInstanceSummary]? = nil
        if let appInstancesContainer = appInstancesContainer {
            appInstancesDecoded0 = [ChimeSdkIdentityClientTypes.AppInstanceSummary]()
            for structure0 in appInstancesContainer {
                if let structure0 = structure0 {
                    appInstancesDecoded0?.append(structure0)
                }
            }
        }
        appInstances = appInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceARN = input.operationInput.resourceARN {
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            input.builder.withQueryItem(resourceARNQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tag key-value pairs.
    public var tags: [ChimeSdkIdentityClientTypes.Tag]?

    public init (
        tags: [ChimeSdkIdentityClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [ChimeSdkIdentityClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct PutAppInstanceRetentionSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceRetentionSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceRetentionSettingsOutputError>
}

extension PutAppInstanceRetentionSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAppInstanceRetentionSettingsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceRetentionSettings: \(Swift.String(describing: appInstanceRetentionSettings)))"}
}

extension PutAppInstanceRetentionSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceRetentionSettings = appInstanceRetentionSettings {
            try encodeContainer.encode(appInstanceRetentionSettings, forKey: .appInstanceRetentionSettings)
        }
    }
}

public struct PutAppInstanceRetentionSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceRetentionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceRetentionSettingsOutputError>
}

public struct PutAppInstanceRetentionSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceRetentionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceRetentionSettingsOutputError>
}

public struct PutAppInstanceRetentionSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceRetentionSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutAppInstanceRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutAppInstanceRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceRetentionSettingsOutputError>
}

public struct PutAppInstanceRetentionSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceRetentionSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutAppInstanceRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutAppInstanceRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceRetentionSettingsOutputError>
}

public struct PutAppInstanceRetentionSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The time in days to retain data. Data type: number.
    /// This member is required.
    public var appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?

    public init (
        appInstanceArn: Swift.String? = nil,
        appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
    }
}

struct PutAppInstanceRetentionSettingsInputBody: Swift.Equatable {
    public let appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?
}

extension PutAppInstanceRetentionSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
    }
}

extension PutAppInstanceRetentionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAppInstanceRetentionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAppInstanceRetentionSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAppInstanceRetentionSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAppInstanceRetentionSettingsOutputResponse(appInstanceRetentionSettings: \(Swift.String(describing: appInstanceRetentionSettings)), initiateDeletionTimestamp: \(Swift.String(describing: initiateDeletionTimestamp)))"}
}

extension PutAppInstanceRetentionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutAppInstanceRetentionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceRetentionSettings = output.appInstanceRetentionSettings
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
        } else {
            self.appInstanceRetentionSettings = nil
            self.initiateDeletionTimestamp = nil
        }
    }
}

public struct PutAppInstanceRetentionSettingsOutputResponse: Swift.Equatable {
    /// The time in days to retain data. Data type: number.
    public var appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?
    /// The time at which the API deletes data.
    public var initiateDeletionTimestamp: ClientRuntime.Date?

    public init (
        appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

struct PutAppInstanceRetentionSettingsOutputResponseBody: Swift.Equatable {
    public let appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?
    public let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension PutAppInstanceRetentionSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

public struct RegisterAppInstanceUserEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterAppInstanceUserEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterAppInstanceUserEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterAppInstanceUserEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterAppInstanceUserEndpointOutputError>
}

extension RegisterAppInstanceUserEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterAppInstanceUserEndpointInput(allowMessages: \(Swift.String(describing: allowMessages)), appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), endpointAttributes: \(Swift.String(describing: endpointAttributes)), name: \(Swift.String(describing: name)), resourceArn: \(Swift.String(describing: resourceArn)), type: \(Swift.String(describing: type)))"}
}

extension RegisterAppInstanceUserEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case clientRequestToken = "ClientRequestToken"
        case endpointAttributes = "EndpointAttributes"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let endpointAttributes = endpointAttributes {
            try encodeContainer.encode(endpointAttributes, forKey: .endpointAttributes)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct RegisterAppInstanceUserEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterAppInstanceUserEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterAppInstanceUserEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterAppInstanceUserEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterAppInstanceUserEndpointOutputError>
}

public struct RegisterAppInstanceUserEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterAppInstanceUserEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterAppInstanceUserEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterAppInstanceUserEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterAppInstanceUserEndpointOutputError>
}

public struct RegisterAppInstanceUserEndpointInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterAppInstanceUserEndpointInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RegisterAppInstanceUserEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterAppInstanceUserEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterAppInstanceUserEndpointOutputError>
}

public struct RegisterAppInstanceUserEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterAppInstanceUserEndpointInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RegisterAppInstanceUserEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterAppInstanceUserEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterAppInstanceUserEndpointOutputError>
}

public struct RegisterAppInstanceUserEndpointInput: Swift.Equatable {
    /// Boolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint receives all messages. NONE indicates the endpoint receives no messages.
    public var allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The idempotency token for each client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The attributes of an Endpoint.
    /// This member is required.
    public var endpointAttributes: ChimeSdkIdentityClientTypes.EndpointAttributes?
    /// The name of the AppInstanceUserEndpoint.
    public var name: Swift.String?
    /// The ARN of the resource to which the endpoint belongs.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The type of the AppInstanceUserEndpoint. Supported types:
    ///
    /// * APNS: The mobile notification service for an Apple device.
    ///
    /// * APNS_SANDBOX: The sandbox environment of the mobile notification service for an Apple device.
    ///
    /// * GCM: The mobile notification service for an Android device.
    ///
    ///
    /// Populate the ResourceArn value of each type as PinpointAppArn.
    /// This member is required.
    public var type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType?

    public init (
        allowMessages: ChimeSdkIdentityClientTypes.AllowMessages? = nil,
        appInstanceUserArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        endpointAttributes: ChimeSdkIdentityClientTypes.EndpointAttributes? = nil,
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType? = nil
    )
    {
        self.allowMessages = allowMessages
        self.appInstanceUserArn = appInstanceUserArn
        self.clientRequestToken = clientRequestToken
        self.endpointAttributes = endpointAttributes
        self.name = name
        self.resourceArn = resourceArn
        self.type = type
    }
}

struct RegisterAppInstanceUserEndpointInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType?
    public let resourceArn: Swift.String?
    public let endpointAttributes: ChimeSdkIdentityClientTypes.EndpointAttributes?
    public let clientRequestToken: Swift.String?
    public let allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
}

extension RegisterAppInstanceUserEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case clientRequestToken = "ClientRequestToken"
        case endpointAttributes = "EndpointAttributes"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType.self, forKey: .type)
        type = typeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let endpointAttributesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointAttributes.self, forKey: .endpointAttributes)
        endpointAttributes = endpointAttributesDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
    }
}

extension RegisterAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterAppInstanceUserEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterAppInstanceUserEndpointOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterAppInstanceUserEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterAppInstanceUserEndpointOutputResponse(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), endpointId: \(Swift.String(describing: endpointId)))"}
}

extension RegisterAppInstanceUserEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterAppInstanceUserEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
            self.endpointId = output.endpointId
        } else {
            self.appInstanceUserArn = nil
            self.endpointId = nil
        }
    }
}

public struct RegisterAppInstanceUserEndpointOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    public var endpointId: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct RegisterAppInstanceUserEndpointOutputResponseBody: Swift.Equatable {
    public let appInstanceUserArn: Swift.String?
    public let endpointId: Swift.String?
}

extension RegisterAppInstanceUserEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case endpointId = "EndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension ResourceLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceLimitExceededException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    public let code: ChimeSdkIdentityClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceFailureException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    public let code: ChimeSdkIdentityClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let code: ChimeSdkIdentityClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSdkIdentityClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSdkIdentityClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ChimeSdkIdentityClientTypes {
    /// A tag object containing a key-value pair.
    public struct Tag: Swift.Equatable {
        /// The key in a tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value in a tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeSdkIdentityClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ChimeSdkIdentityClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [ChimeSdkIdentityClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottledClientException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottledClientException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ThrottledClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    public let code: ChimeSdkIdentityClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedClientException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedClientException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    public let code: ChimeSdkIdentityClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAppInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceOutputError>
}

extension UpdateAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension UpdateAppInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAppInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceOutputError>
}

public struct UpdateAppInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceOutputError>
}

public struct UpdateAppInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceOutputError>
}

public struct UpdateAppInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceOutputError>
}

public struct UpdateAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The metadata that you want to change.
    /// This member is required.
    public var metadata: Swift.String?
    /// The name that you want to change.
    /// This member is required.
    public var name: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let metadata: Swift.String?
}

extension UpdateAppInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceOutputResponse(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension UpdateAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAppInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceArn = nil
        }
    }
}

public struct UpdateAppInstanceOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct UpdateAppInstanceOutputResponseBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
}

extension UpdateAppInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

public struct UpdateAppInstanceUserEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceUserEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceUserEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserEndpointOutputError>
}

extension UpdateAppInstanceUserEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceUserEndpointInput(allowMessages: \(Swift.String(describing: allowMessages)), appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), endpointId: \(Swift.String(describing: endpointId)), name: \(Swift.String(describing: name)))"}
}

extension UpdateAppInstanceUserEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAppInstanceUserEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceUserEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceUserEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserEndpointOutputError>
}

public struct UpdateAppInstanceUserEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceUserEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceUserEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserEndpointOutputError>
}

public struct UpdateAppInstanceUserEndpointInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserEndpointInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInstanceUserEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInstanceUserEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserEndpointOutputError>
}

public struct UpdateAppInstanceUserEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserEndpointInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInstanceUserEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        guard let endpointId = input.endpointId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("endpointId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInstanceUserEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserEndpointOutputError>
}

public struct UpdateAppInstanceUserEndpointInput: Swift.Equatable {
    /// Boolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint will receive all messages. NONE indicates the endpoint will receive no messages.
    public var allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    /// This member is required.
    public var endpointId: Swift.String?
    /// The name of the AppInstanceUserEndpoint.
    public var name: Swift.String?

    public init (
        allowMessages: ChimeSdkIdentityClientTypes.AllowMessages? = nil,
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.allowMessages = allowMessages
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
        self.name = name
    }
}

struct UpdateAppInstanceUserEndpointInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
}

extension UpdateAppInstanceUserEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
    }
}

extension UpdateAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppInstanceUserEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppInstanceUserEndpointOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppInstanceUserEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceUserEndpointOutputResponse(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), endpointId: \(Swift.String(describing: endpointId)))"}
}

extension UpdateAppInstanceUserEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAppInstanceUserEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
            self.endpointId = output.endpointId
        } else {
            self.appInstanceUserArn = nil
            self.endpointId = nil
        }
    }
}

public struct UpdateAppInstanceUserEndpointOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    public var endpointId: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct UpdateAppInstanceUserEndpointOutputResponseBody: Swift.Equatable {
    public let appInstanceUserArn: Swift.String?
    public let endpointId: Swift.String?
}

extension UpdateAppInstanceUserEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case endpointId = "EndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

public struct UpdateAppInstanceUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserOutputError>
}

extension UpdateAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension UpdateAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserOutputError>
}

public struct UpdateAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserOutputError>
}

public struct UpdateAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserOutputError>
}

public struct UpdateAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserOutputError>
}

public struct UpdateAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The metadata of the AppInstanceUser.
    /// This member is required.
    public var metadata: Swift.String?
    /// The name of the AppInstanceUser.
    /// This member is required.
    public var name: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceUserInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let metadata: Swift.String?
}

extension UpdateAppInstanceUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceUserOutputResponse(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)))"}
}

extension UpdateAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
        } else {
            self.appInstanceUserArn = nil
        }
    }
}

public struct UpdateAppInstanceUserOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct UpdateAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let appInstanceUserArn: Swift.String?
}

extension UpdateAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
    }
}
