// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform the action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The update or deletion of a resource caused an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource.
    /// This member is required.
    public var resourceType: LookoutVisionClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: LookoutVisionClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: LookoutVisionClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetInput(clientToken: \(Swift.String(describing: clientToken)), datasetSource: \(Swift.String(describing: datasetSource)), datasetType: \(Swift.String(describing: datasetType)), projectName: \(Swift.String(describing: projectName)))"}
}

extension CreateDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetSource = "DatasetSource"
        case datasetType = "DatasetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetSource = datasetSource {
            try encodeContainer.encode(datasetSource, forKey: .datasetSource)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to CreateDataset
    ///       completes only once.  You choose the value to pass. For example, An issue,
    ///       such as an network outage, might prevent you from getting a response from CreateDataset.
    ///       In this case, safely retry your call
    ///        to CreateDataset by using the same ClientToken parameter value. An error occurs
    ///        if the other input parameters are not the same as in the first request. Using a different
    ///        value for ClientToken is considered a new call to CreateDataset. An idempotency
    ///        token is active for 8 hours.
    ///
    public var clientToken: Swift.String?
    /// The location of the manifest file that Amazon Lookout for Vision uses to create the dataset.
    ///          If you don't specify DatasetSource, an empty dataset is created and the operation
    ///       synchronously returns. Later, you can add JSON Lines by calling UpdateDatasetEntries.
    ///
    ///          If you specify a value for DataSource, the manifest at the S3 location
    ///      is validated and used to create the dataset. The call to CreateDataset is asynchronous
    ///      and might take a while to complete. To find out the current status, Check the value of Status
    ///      returned in a call to DescribeDataset.
    public let datasetSource: LookoutVisionClientTypes.DatasetSource?
    /// The type of the dataset. Specify train for a training dataset.
    ///       Specify test for a test dataset.
    /// This member is required.
    public let datasetType: Swift.String?
    /// The name of the project in which you want to create a dataset.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        datasetSource: LookoutVisionClientTypes.DatasetSource? = nil,
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetSource = datasetSource
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    public let datasetType: Swift.String?
    public let datasetSource: LookoutVisionClientTypes.DatasetSource?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetSource = "DatasetSource"
        case datasetType = "DatasetType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let datasetSourceDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetSource.self, forKey: .datasetSource)
        datasetSource = datasetSourceDecoded
    }
}

extension CreateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetOutputResponse(datasetMetadata: \(Swift.String(describing: datasetMetadata)))"}
}

extension CreateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetMetadata = output.datasetMetadata
        } else {
            self.datasetMetadata = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Swift.Equatable {
    /// Information about the dataset.
    public let datasetMetadata: LookoutVisionClientTypes.DatasetMetadata?

    public init (
        datasetMetadata: LookoutVisionClientTypes.DatasetMetadata? = nil
    )
    {
        self.datasetMetadata = datasetMetadata
    }
}

struct CreateDatasetOutputResponseBody: Swift.Equatable {
    public let datasetMetadata: LookoutVisionClientTypes.DatasetMetadata?
}

extension CreateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetMetadata = "DatasetMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetMetadataDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetMetadata.self, forKey: .datasetMetadata)
        datasetMetadata = datasetMetadataDecoded
    }
}

public struct CreateModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateModelOutputError>
}

extension CreateModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateModelInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), outputConfig: \(Swift.String(describing: outputConfig)), projectName: \(Swift.String(describing: projectName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case outputConfig = "OutputConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let outputConfig = outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateModelOutputError>
}

public struct CreateModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateModelOutputError>
}

public struct CreateModelInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to CreateModel
    ///       completes only once.  You choose the value to pass. For example, An issue,
    ///       such as an network outage, might prevent you from getting a response from CreateModel.
    ///       In this case, safely retry your call
    ///        to CreateModel by using the same ClientToken parameter value. An error occurs
    ///        if the other input parameters are not the same as in the first request. Using a different
    ///        value for ClientToken is considered a new call to CreateModel. An idempotency
    ///        token is active for 8 hours.
    public var clientToken: Swift.String?
    /// A description for the version of the model.
    public let description: Swift.String?
    /// The identifier for your AWS Key Management Service (AWS KMS) customer master key (CMK).
    ///          The key is used to encrypt training and test images copied into the service for model training. Your
    ///          source images are unaffected.
    ///          If this parameter is not specified, the copied images are encrypted by a key that AWS owns and manages.
    public let kmsKeyId: Swift.String?
    /// The location where Amazon Lookout for Vision saves the training results.
    /// This member is required.
    public let outputConfig: LookoutVisionClientTypes.OutputConfig?
    /// The name of the project in which you want to create a model version.
    /// This member is required.
    public let projectName: Swift.String?
    /// A set of tags (key-value pairs) that you want to attach to the model.
    public let tags: [LookoutVisionClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        outputConfig: LookoutVisionClientTypes.OutputConfig? = nil,
        projectName: Swift.String? = nil,
        tags: [LookoutVisionClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.outputConfig = outputConfig
        self.projectName = projectName
        self.tags = tags
    }
}

struct CreateModelInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let outputConfig: LookoutVisionClientTypes.OutputConfig?
    public let kmsKeyId: Swift.String?
    public let tags: [LookoutVisionClientTypes.Tag]?
}

extension CreateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case outputConfig = "OutputConfig"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.OutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LookoutVisionClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LookoutVisionClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateModelOutputResponse(modelMetadata: \(Swift.String(describing: modelMetadata)))"}
}

extension CreateModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelMetadata = output.modelMetadata
        } else {
            self.modelMetadata = nil
        }
    }
}

public struct CreateModelOutputResponse: Swift.Equatable {
    /// The response from a call to CreateModel.
    public let modelMetadata: LookoutVisionClientTypes.ModelMetadata?

    public init (
        modelMetadata: LookoutVisionClientTypes.ModelMetadata? = nil
    )
    {
        self.modelMetadata = modelMetadata
    }
}

struct CreateModelOutputResponseBody: Swift.Equatable {
    public let modelMetadata: LookoutVisionClientTypes.ModelMetadata?
}

extension CreateModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelMetadata = "ModelMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelMetadataDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelMetadata.self, forKey: .modelMetadata)
        modelMetadata = modelMetadataDecoded
    }
}

public struct CreateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(clientToken: \(Swift.String(describing: clientToken)), projectName: \(Swift.String(describing: projectName)))"}
}

extension CreateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectName = "ProjectName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to CreateProject
    ///       completes only once.  You choose the value to pass. For example, An issue,
    ///       such as an network outage, might prevent you from getting a response from CreateProject.
    ///       In this case, safely retry your call
    ///        to CreateProject by using the same ClientToken parameter value. An error occurs
    ///        if the other input parameters are not the same as in the first request. Using a different
    ///        value for ClientToken is considered a new call to CreateProject. An idempotency
    ///        token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The name for the project.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectName = projectName
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    public let projectName: Swift.String?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectName = "ProjectName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectOutputResponse(projectMetadata: \(Swift.String(describing: projectMetadata)))"}
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectMetadata = output.projectMetadata
        } else {
            self.projectMetadata = nil
        }
    }
}

public struct CreateProjectOutputResponse: Swift.Equatable {
    /// Information about the project.
    public let projectMetadata: LookoutVisionClientTypes.ProjectMetadata?

    public init (
        projectMetadata: LookoutVisionClientTypes.ProjectMetadata? = nil
    )
    {
        self.projectMetadata = projectMetadata
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    public let projectMetadata: LookoutVisionClientTypes.ProjectMetadata?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectMetadata = "ProjectMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectMetadataDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ProjectMetadata.self, forKey: .projectMetadata)
        projectMetadata = projectMetadataDecoded
    }
}

extension LookoutVisionClientTypes.DatasetDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case datasetType = "DatasetType"
        case imageStats = "ImageStats"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case projectName = "ProjectName"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let imageStats = imageStats {
            try encodeContainer.encode(imageStats, forKey: .imageStats)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let imageStatsDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetImageStats.self, forKey: .imageStats)
        imageStats = imageStatsDecoded
    }
}

extension LookoutVisionClientTypes.DatasetDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetDescription(creationTimestamp: \(Swift.String(describing: creationTimestamp)), datasetType: \(Swift.String(describing: datasetType)), imageStats: \(Swift.String(describing: imageStats)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), projectName: \(Swift.String(describing: projectName)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension LookoutVisionClientTypes {
    /// The description for a dataset. For more information, see DescribeDataset.
    public struct DatasetDescription: Swift.Equatable {
        /// The Unix timestamp for the time and date that the dataset was created.
        public let creationTimestamp: ClientRuntime.Date?
        /// The type of the dataset. The value train represents a training dataset or single dataset project.
        ///       The value test represents a test dataset.
        public let datasetType: Swift.String?
        ///
        public let imageStats: LookoutVisionClientTypes.DatasetImageStats?
        /// The Unix timestamp for the date and time that the dataset was last updated.
        public let lastUpdatedTimestamp: ClientRuntime.Date?
        /// The name of the project that contains the dataset.
        public let projectName: Swift.String?
        /// The status of the dataset.
        public let status: LookoutVisionClientTypes.DatasetStatus?
        /// The status message for the dataset.
        public let statusMessage: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            datasetType: Swift.String? = nil,
            imageStats: LookoutVisionClientTypes.DatasetImageStats? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            projectName: Swift.String? = nil,
            status: LookoutVisionClientTypes.DatasetStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.datasetType = datasetType
            self.imageStats = imageStats
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LookoutVisionClientTypes.DatasetGroundTruthManifest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Object = "S3Object"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Object = s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.InputS3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
    }
}

extension LookoutVisionClientTypes.DatasetGroundTruthManifest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetGroundTruthManifest(s3Object: \(Swift.String(describing: s3Object)))"}
}

extension LookoutVisionClientTypes {
    /// Location information about a manifest file. You can use a manifest file to
    ///       create a dataset.
    public struct DatasetGroundTruthManifest: Swift.Equatable {
        /// The S3 bucket location for the manifest file.
        public let s3Object: LookoutVisionClientTypes.InputS3Object?

        public init (
            s3Object: LookoutVisionClientTypes.InputS3Object? = nil
        )
        {
            self.s3Object = s3Object
        }
    }

}

extension LookoutVisionClientTypes.DatasetImageStats: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomaly = "Anomaly"
        case labeled = "Labeled"
        case normal = "Normal"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomaly = anomaly {
            try encodeContainer.encode(anomaly, forKey: .anomaly)
        }
        if let labeled = labeled {
            try encodeContainer.encode(labeled, forKey: .labeled)
        }
        if let normal = normal {
            try encodeContainer.encode(normal, forKey: .normal)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total)
        total = totalDecoded
        let labeledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .labeled)
        labeled = labeledDecoded
        let normalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .normal)
        normal = normalDecoded
        let anomalyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .anomaly)
        anomaly = anomalyDecoded
    }
}

extension LookoutVisionClientTypes.DatasetImageStats: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetImageStats(anomaly: \(Swift.String(describing: anomaly)), labeled: \(Swift.String(describing: labeled)), normal: \(Swift.String(describing: normal)), total: \(Swift.String(describing: total)))"}
}

extension LookoutVisionClientTypes {
    /// Statistics about the images in a dataset.
    public struct DatasetImageStats: Swift.Equatable {
        /// the total number of images labeled as an anomaly.
        public let anomaly: Swift.Int?
        /// The total number of labeled images.
        public let labeled: Swift.Int?
        /// The total number of images labeled as normal.
        public let normal: Swift.Int?
        /// The total number of images in the dataset.
        public let total: Swift.Int?

        public init (
            anomaly: Swift.Int? = nil,
            labeled: Swift.Int? = nil,
            normal: Swift.Int? = nil,
            total: Swift.Int? = nil
        )
        {
            self.anomaly = anomaly
            self.labeled = labeled
            self.normal = normal
            self.total = total
        }
    }

}

extension LookoutVisionClientTypes.DatasetMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case datasetType = "DatasetType"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension LookoutVisionClientTypes.DatasetMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetMetadata(creationTimestamp: \(Swift.String(describing: creationTimestamp)), datasetType: \(Swift.String(describing: datasetType)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension LookoutVisionClientTypes {
    /// Sumary information for an Amazon Lookout for Vision dataset.
    public struct DatasetMetadata: Swift.Equatable {
        /// The Unix timestamp for the date and time that the dataset was created.
        public let creationTimestamp: ClientRuntime.Date?
        /// The type of the dataset.
        public let datasetType: Swift.String?
        /// The status for the dataset.
        public let status: LookoutVisionClientTypes.DatasetStatus?
        /// The status message for the dataset.
        public let statusMessage: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            datasetType: Swift.String? = nil,
            status: LookoutVisionClientTypes.DatasetStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.datasetType = datasetType
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LookoutVisionClientTypes.DatasetSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundTruthManifest = "GroundTruthManifest"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundTruthManifest = groundTruthManifest {
            try encodeContainer.encode(groundTruthManifest, forKey: .groundTruthManifest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groundTruthManifestDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetGroundTruthManifest.self, forKey: .groundTruthManifest)
        groundTruthManifest = groundTruthManifestDecoded
    }
}

extension LookoutVisionClientTypes.DatasetSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetSource(groundTruthManifest: \(Swift.String(describing: groundTruthManifest)))"}
}

extension LookoutVisionClientTypes {
    /// Information about the location of a manifest file that Amazon Lookout for Vision uses to to create a dataset.
    public struct DatasetSource: Swift.Equatable {
        /// Location information for the manifest file.
        public let groundTruthManifest: LookoutVisionClientTypes.DatasetGroundTruthManifest?

        public init (
            groundTruthManifest: LookoutVisionClientTypes.DatasetGroundTruthManifest? = nil
        )
        {
            self.groundTruthManifest = groundTruthManifest
        }
    }

}

extension LookoutVisionClientTypes {
    public enum DatasetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case deleteComplete
        case deleteFailed
        case deleteInProgress
        case updateComplete
        case updateFailedRollbackComplete
        case updateFailedRollbackInProgress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetStatus] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress,
                .deleteComplete,
                .deleteFailed,
                .deleteInProgress,
                .updateComplete,
                .updateFailedRollbackComplete,
                .updateFailedRollbackInProgress,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteComplete: return "DELETE_COMPLETE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateComplete: return "UPDATE_COMPLETE"
            case .updateFailedRollbackComplete: return "UPDATE_FAILED_ROLLBACK_COMPLETE"
            case .updateFailedRollbackInProgress: return "UPDATE_FAILED_ROLLBACK_IN_PROGRESS"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetStatus(rawValue: rawValue) ?? DatasetStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetInput(clientToken: \(Swift.String(describing: clientToken)), datasetType: \(Swift.String(describing: datasetType)), projectName: \(Swift.String(describing: projectName)))"}
}

extension DeleteDatasetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to DeleteDataset
    ///       completes only once.  You choose the value to pass. For example, An issue,
    ///       such as an network outage, might prevent you from getting a response from DeleteDataset.
    ///       In this case, safely retry your call
    ///        to DeleteDataset by using the same ClientToken parameter value. An error occurs
    ///        if the other input parameters are not the same as in the first request. Using a different
    ///        value for ClientToken is considered a new call to DeleteDataset. An idempotency
    ///        token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The type of the dataset to delete. Specify train to delete the training dataset.
    ///       Specify test to delete the test dataset. To delete the dataset in a single dataset project,
    ///          specify train.
    /// This member is required.
    public let datasetType: Swift.String?
    /// The name of the project that contains the dataset that you want to delete.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
}

extension DeleteDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetOutputResponse()"}
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDatasetOutputResponseBody: Swift.Equatable {
}

extension DeleteDatasetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteModelInput(clientToken: \(Swift.String(describing: clientToken)), modelVersion: \(Swift.String(describing: modelVersion)), projectName: \(Swift.String(describing: projectName)))"}
}

extension DeleteModelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteModelOutputError>
}

public struct DeleteModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteModelOutputError>
}

public struct DeleteModelInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to DeleteModel
    ///       completes only once.  You choose the value to pass. For example, An issue,
    ///       such as an network outage, might prevent you from getting a response from DeleteModel.
    ///       In this case, safely retry your call
    ///        to DeleteModel by using the same ClientToken parameter value. An error occurs
    ///        if the other input parameters are not the same as in the first request. Using a different
    ///        value for ClientToken is considered a new call to DeleteModel. An idempotency
    ///        token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The version of the model that you want to delete.
    /// This member is required.
    public let modelVersion: Swift.String?
    /// The name of the project that contains the model that you want to delete.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct DeleteModelInputBody: Swift.Equatable {
}

extension DeleteModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteModelOutputResponse(modelArn: \(Swift.String(describing: modelArn)))"}
}

extension DeleteModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelArn = output.modelArn
        } else {
            self.modelArn = nil
        }
    }
}

public struct DeleteModelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the model that was deleted.
    public let modelArn: Swift.String?

    public init (
        modelArn: Swift.String? = nil
    )
    {
        self.modelArn = modelArn
    }
}

struct DeleteModelOutputResponseBody: Swift.Equatable {
    public let modelArn: Swift.String?
}

extension DeleteModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelArn = "ModelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
    }
}

extension DeleteProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectInput(clientToken: \(Swift.String(describing: clientToken)), projectName: \(Swift.String(describing: projectName)))"}
}

extension DeleteProjectInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to DeleteProject
    ///          completes only once.  You choose the value to pass. For example, An issue,
    ///          such as an network outage, might prevent you from getting a response from DeleteProject.
    ///          In this case, safely retry your call
    ///          to DeleteProject by using the same ClientToken parameter value. An error occurs
    ///          if the other input parameters are not the same as in the first request. Using a different
    ///          value for ClientToken is considered a new call to DeleteProject. An idempotency
    ///          token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The name of the project to delete.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectName = projectName
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectOutputResponse(projectArn: \(Swift.String(describing: projectArn)))"}
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectArn = output.projectArn
        } else {
            self.projectArn = nil
        }
    }
}

public struct DeleteProjectOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project that was deleted.
    public let projectArn: Swift.String?

    public init (
        projectArn: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

struct DeleteProjectOutputResponseBody: Swift.Equatable {
    public let projectArn: Swift.String?
}

extension DeleteProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn = "ProjectArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension DescribeDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetInput(datasetType: \(Swift.String(describing: datasetType)), projectName: \(Swift.String(describing: projectName)))"}
}

extension DescribeDatasetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// The type of the dataset to describe. Specify train to describe the
    ///       training dataset. Specify test to describe the test dataset.
    ///       If you have a single dataset project, specify train
    ///
    /// This member is required.
    public let datasetType: Swift.String?
    /// The name of the project that contains the dataset that you want to describe.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
}

extension DescribeDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetOutputResponse(datasetDescription: \(Swift.String(describing: datasetDescription)))"}
}

extension DescribeDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetDescription = output.datasetDescription
        } else {
            self.datasetDescription = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Swift.Equatable {
    /// The description of the requested dataset.
    public let datasetDescription: LookoutVisionClientTypes.DatasetDescription?

    public init (
        datasetDescription: LookoutVisionClientTypes.DatasetDescription? = nil
    )
    {
        self.datasetDescription = datasetDescription
    }
}

struct DescribeDatasetOutputResponseBody: Swift.Equatable {
    public let datasetDescription: LookoutVisionClientTypes.DatasetDescription?
}

extension DescribeDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetDescription = "DatasetDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetDescription.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
    }
}

extension DescribeModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeModelInput(modelVersion: \(Swift.String(describing: modelVersion)), projectName: \(Swift.String(describing: projectName)))"}
}

extension DescribeModelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeModelOutputError>
}

public struct DescribeModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeModelOutputError>
}

public struct DescribeModelInput: Swift.Equatable {
    /// The version of the model that you want to describe.
    /// This member is required.
    public let modelVersion: Swift.String?
    /// The project that contains the version of a model that you want to describe.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct DescribeModelInputBody: Swift.Equatable {
}

extension DescribeModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeModelOutputResponse(modelDescription: \(Swift.String(describing: modelDescription)))"}
}

extension DescribeModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelDescription = output.modelDescription
        } else {
            self.modelDescription = nil
        }
    }
}

public struct DescribeModelOutputResponse: Swift.Equatable {
    /// Contains the description of the model.
    public let modelDescription: LookoutVisionClientTypes.ModelDescription?

    public init (
        modelDescription: LookoutVisionClientTypes.ModelDescription? = nil
    )
    {
        self.modelDescription = modelDescription
    }
}

struct DescribeModelOutputResponseBody: Swift.Equatable {
    public let modelDescription: LookoutVisionClientTypes.ModelDescription?
}

extension DescribeModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelDescription = "ModelDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDescriptionDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelDescription.self, forKey: .modelDescription)
        modelDescription = modelDescriptionDecoded
    }
}

extension DescribeProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectInput(projectName: \(Swift.String(describing: projectName)))"}
}

extension DescribeProjectInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The name of the project that you want to describe.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectOutputResponse(projectDescription: \(Swift.String(describing: projectDescription)))"}
}

extension DescribeProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectDescription = output.projectDescription
        } else {
            self.projectDescription = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Swift.Equatable {
    /// The description of the project.
    public let projectDescription: LookoutVisionClientTypes.ProjectDescription?

    public init (
        projectDescription: LookoutVisionClientTypes.ProjectDescription? = nil
    )
    {
        self.projectDescription = projectDescription
    }
}

struct DescribeProjectOutputResponseBody: Swift.Equatable {
    public let projectDescription: LookoutVisionClientTypes.ProjectDescription?
}

extension DescribeProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectDescription = "ProjectDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ProjectDescription.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
    }
}

public struct DetectAnomaliesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectAnomaliesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectAnomaliesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectAnomaliesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.stream(bodydata)
            input.builder.withBody(bodybody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectAnomaliesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectAnomaliesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectAnomaliesOutputError>
}

extension DetectAnomaliesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectAnomaliesInput(body: \(Swift.String(describing: body)), contentType: \(Swift.String(describing: contentType)), modelVersion: \(Swift.String(describing: modelVersion)), projectName: \(Swift.String(describing: projectName)))"}
}

extension DetectAnomaliesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.toBytes().toData(), forKey: .body)
        }
    }
}

public struct DetectAnomaliesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectAnomaliesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectAnomaliesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectAnomaliesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: Swift.String(contentType))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectAnomaliesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectAnomaliesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectAnomaliesOutputError>
}

public struct DetectAnomaliesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectAnomaliesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectAnomaliesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetectAnomaliesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectAnomaliesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectAnomaliesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetectAnomaliesOutputError>
}

public struct DetectAnomaliesInput: Swift.Equatable {
    /// The unencrypted image bytes that you want to analyze.
    /// This member is required.
    public let body: ClientRuntime.ByteStream?
    /// The type of the image passed in Body.
    ///          Valid values are image/png (PNG format images) and image/jpeg (JPG format images).
    /// This member is required.
    public let contentType: Swift.String?
    /// The version of the model that you want to use.
    /// This member is required.
    public let modelVersion: Swift.String?
    /// The name of the project that contains the model version that you want to use.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        body: ClientRuntime.ByteStream? = nil,
        contentType: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct DetectAnomaliesInputBody: Swift.Equatable {
    public let body: ClientRuntime.ByteStream?
}

extension DetectAnomaliesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
    }
}

extension DetectAnomaliesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectAnomaliesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectAnomaliesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectAnomaliesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectAnomaliesOutputResponse(detectAnomalyResult: \(Swift.String(describing: detectAnomalyResult)))"}
}

extension DetectAnomaliesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetectAnomaliesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectAnomalyResult = output.detectAnomalyResult
        } else {
            self.detectAnomalyResult = nil
        }
    }
}

public struct DetectAnomaliesOutputResponse: Swift.Equatable {
    /// The results of the DetectAnomalies operation.
    public let detectAnomalyResult: LookoutVisionClientTypes.DetectAnomalyResult?

    public init (
        detectAnomalyResult: LookoutVisionClientTypes.DetectAnomalyResult? = nil
    )
    {
        self.detectAnomalyResult = detectAnomalyResult
    }
}

struct DetectAnomaliesOutputResponseBody: Swift.Equatable {
    public let detectAnomalyResult: LookoutVisionClientTypes.DetectAnomalyResult?
}

extension DetectAnomaliesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectAnomalyResult = "DetectAnomalyResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectAnomalyResultDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DetectAnomalyResult.self, forKey: .detectAnomalyResult)
        detectAnomalyResult = detectAnomalyResultDecoded
    }
}

extension LookoutVisionClientTypes.DetectAnomalyResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidence = "Confidence"
        case isAnomalous = "IsAnomalous"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidence = confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if isAnomalous != false {
            try encodeContainer.encode(isAnomalous, forKey: .isAnomalous)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ImageSource.self, forKey: .source)
        source = sourceDecoded
        let isAnomalousDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isAnomalous)
        isAnomalous = isAnomalousDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .confidence)
        confidence = confidenceDecoded
    }
}

extension LookoutVisionClientTypes.DetectAnomalyResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectAnomalyResult(confidence: \(Swift.String(describing: confidence)), isAnomalous: \(Swift.String(describing: isAnomalous)), source: \(Swift.String(describing: source)))"}
}

extension LookoutVisionClientTypes {
    /// The prediction results from a call to DetectAnomalies.
    public struct DetectAnomalyResult: Swift.Equatable {
        /// The confidence that Amazon Lookout for Vision has in the accuracy of the prediction.
        public let confidence: Swift.Float?
        /// True if the image contains an anomaly, otherwise false.
        public let isAnomalous: Swift.Bool
        /// The source of the image that was analyzed. direct means that the
        ///       images was supplied from the local computer. No other values are supported.
        public let source: LookoutVisionClientTypes.ImageSource?

        public init (
            confidence: Swift.Float? = nil,
            isAnomalous: Swift.Bool = false,
            source: LookoutVisionClientTypes.ImageSource? = nil
        )
        {
            self.confidence = confidence
            self.isAnomalous = isAnomalous
            self.source = source
        }
    }

}

extension LookoutVisionClientTypes.ImageSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension LookoutVisionClientTypes.ImageSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageSource(type: \(Swift.String(describing: type)))"}
}

extension LookoutVisionClientTypes {
    /// The source for an image.
    public struct ImageSource: Swift.Equatable {
        /// The type of the image.
        public let type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension LookoutVisionClientTypes.InputS3Object: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension LookoutVisionClientTypes.InputS3Object: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputS3Object(bucket: \(Swift.String(describing: bucket)), key: \(Swift.String(describing: key)), versionId: \(Swift.String(describing: versionId)))"}
}

extension LookoutVisionClientTypes {
    /// Amazon S3 Location information for an input manifest file.
    public struct InputS3Object: Swift.Equatable {
        /// The Amazon S3 bucket that contains the manifest.
        /// This member is required.
        public let bucket: Swift.String?
        /// The name and location of the manifest file withiin the bucket.
        /// This member is required.
        public let key: Swift.String?
        /// The version ID of the bucket.
        public let versionId: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Lookout for Vision experienced a service issue. Try your call again.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The period of time, in seconds, before the operation can be retried.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDatasetEntriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetEntriesInput(afterCreationDate: \(Swift.String(describing: afterCreationDate)), anomalyClass: \(Swift.String(describing: anomalyClass)), beforeCreationDate: \(Swift.String(describing: beforeCreationDate)), datasetType: \(Swift.String(describing: datasetType)), labeled: \(Swift.String(describing: labeled)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectName: \(Swift.String(describing: projectName)), sourceRefContains: \(Swift.String(describing: sourceRefContains)))"}
}

extension ListDatasetEntriesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDatasetEntriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetEntriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetEntriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetEntriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetEntriesOutputError>
}

public struct ListDatasetEntriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetEntriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetEntriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sourceRefContains = input.operationInput.sourceRefContains {
            let sourceRefContainsQueryItem = ClientRuntime.URLQueryItem(name: "sourceRefContains".urlPercentEncoding(), value: Swift.String(sourceRefContains).urlPercentEncoding())
            input.builder.withQueryItem(sourceRefContainsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let labeled = input.operationInput.labeled {
            let labeledQueryItem = ClientRuntime.URLQueryItem(name: "labeled".urlPercentEncoding(), value: Swift.String(labeled).urlPercentEncoding())
            input.builder.withQueryItem(labeledQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let beforeCreationDate = input.operationInput.beforeCreationDate {
            let beforeCreationDateQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(beforeCreationDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(beforeCreationDateQueryItem)
        }
        if let afterCreationDate = input.operationInput.afterCreationDate {
            let afterCreationDateQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(afterCreationDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(afterCreationDateQueryItem)
        }
        if let anomalyClass = input.operationInput.anomalyClass {
            let anomalyClassQueryItem = ClientRuntime.URLQueryItem(name: "anomalyClass".urlPercentEncoding(), value: Swift.String(anomalyClass).urlPercentEncoding())
            input.builder.withQueryItem(anomalyClassQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetEntriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetEntriesOutputError>
}

public struct ListDatasetEntriesInput: Swift.Equatable {
    /// Only includes entries after the specified date in the response. For example, 2020-06-23T00:00:00.
    public let afterCreationDate: ClientRuntime.Date?
    /// Specify normal to include only normal images. Specify anomaly to only include
    ///          anomalous entries. If you don't specify a value, Amazon Lookout for Vision returns normal and anomalous images.
    public let anomalyClass: Swift.String?
    /// Only includes entries before the specified date in the response. For example, 2020-06-23T00:00:00.
    public let beforeCreationDate: ClientRuntime.Date?
    /// The type of the dataset that you want to list.  Specify train to list
    ///          the training dataset. Specify test to list the test dataset. If you have a single dataset
    ///       project, specify train.
    /// This member is required.
    public let datasetType: Swift.String?
    /// Specify true to include labeled entries, otherwise specify false. If you
    ///       don't specify a value, Lookout for Vision returns all entries.
    public let labeled: Swift.Bool?
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100.
    ///          If you specify a value greater than 100, a ValidationException
    ///          error occurs. The default value is 100.
    public let maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve),
    ///          Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to
    ///          retrieve the next set of dataset entries.
    public let nextToken: Swift.String?
    /// The name of the project that contains the dataset that you want to list.
    /// This member is required.
    public let projectName: Swift.String?
    /// Perform a "contains" search on the  values of the source-ref key within the dataset.
    ///          For example a value of "IMG_17"  returns all JSON Lines where the source-ref key value matches *IMG_17*.
    public let sourceRefContains: Swift.String?

    public init (
        afterCreationDate: ClientRuntime.Date? = nil,
        anomalyClass: Swift.String? = nil,
        beforeCreationDate: ClientRuntime.Date? = nil,
        datasetType: Swift.String? = nil,
        labeled: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sourceRefContains: Swift.String? = nil
    )
    {
        self.afterCreationDate = afterCreationDate
        self.anomalyClass = anomalyClass
        self.beforeCreationDate = beforeCreationDate
        self.datasetType = datasetType
        self.labeled = labeled
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.sourceRefContains = sourceRefContains
    }
}

struct ListDatasetEntriesInputBody: Swift.Equatable {
}

extension ListDatasetEntriesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDatasetEntriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetEntriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetEntriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetEntriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetEntriesOutputResponse(datasetEntries: \(Swift.String(describing: datasetEntries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetEntriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetEntriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetEntries = output.datasetEntries
            self.nextToken = output.nextToken
        } else {
            self.datasetEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetEntriesOutputResponse: Swift.Equatable {
    /// A list of the entries (JSON Lines) within the dataset.
    public let datasetEntries: [Swift.String]?
    /// If the response is truncated, Amazon Lookout for Vision returns this token
    ///          that you can use in the subsequent request to retrieve the next set ofdataset entries.
    public let nextToken: Swift.String?

    public init (
        datasetEntries: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetEntries = datasetEntries
        self.nextToken = nextToken
    }
}

struct ListDatasetEntriesOutputResponseBody: Swift.Equatable {
    public let datasetEntries: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListDatasetEntriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetEntries = "DatasetEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetEntriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetEntries)
        var datasetEntriesDecoded0:[Swift.String]? = nil
        if let datasetEntriesContainer = datasetEntriesContainer {
            datasetEntriesDecoded0 = [Swift.String]()
            for string0 in datasetEntriesContainer {
                if let string0 = string0 {
                    datasetEntriesDecoded0?.append(string0)
                }
            }
        }
        datasetEntries = datasetEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListModelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListModelsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectName: \(Swift.String(describing: projectName)))"}
}

extension ListModelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListModelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListModelsOutputError>
}

public struct ListModelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListModelsOutputError>
}

public struct ListModelsInput: Swift.Equatable {
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100.
    ///          If you specify a value greater than 100, a ValidationException
    ///          error occurs. The default value is 100.
    public let maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve),
    ///          Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to
    ///          retrieve the next set of models.
    public let nextToken: Swift.String?
    /// The name of the project that contains the model versions that you want to list.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

struct ListModelsInputBody: Swift.Equatable {
}

extension ListModelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListModelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListModelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListModelsOutputResponse(models: \(Swift.String(describing: models)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.models = output.models
            self.nextToken = output.nextToken
        } else {
            self.models = nil
            self.nextToken = nil
        }
    }
}

public struct ListModelsOutputResponse: Swift.Equatable {
    /// A list of model versions in the specified project.
    public let models: [LookoutVisionClientTypes.ModelMetadata]?
    /// If the response is truncated, Amazon Lookout for Vision returns this token
    ///          that you can use in the subsequent request to retrieve the next set of models.
    public let nextToken: Swift.String?

    public init (
        models: [LookoutVisionClientTypes.ModelMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.models = models
        self.nextToken = nextToken
    }
}

struct ListModelsOutputResponseBody: Swift.Equatable {
    public let models: [LookoutVisionClientTypes.ModelMetadata]?
    public let nextToken: Swift.String?
}

extension ListModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case models = "Models"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.ModelMetadata?].self, forKey: .models)
        var modelsDecoded0:[LookoutVisionClientTypes.ModelMetadata]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [LookoutVisionClientTypes.ModelMetadata]()
            for structure0 in modelsContainer {
                if let structure0 = structure0 {
                    modelsDecoded0?.append(structure0)
                }
            }
        }
        models = modelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListProjectsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProjectsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100.
    ///          If you specify a value greater than 100, a ValidationException
    ///          error occurs. The default value is 100.
    public let maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve),
    ///          Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to
    ///          retrieve the next set of projects.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), projects: \(Swift.String(describing: projects)))"}
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Swift.Equatable {
    /// If the response is truncated, Amazon Lookout for Vision returns this token
    ///          that you can use in the subsequent request to retrieve the next set of projects.
    public let nextToken: Swift.String?
    /// A list of projects in your AWS account.
    public let projects: [LookoutVisionClientTypes.ProjectMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [LookoutVisionClientTypes.ProjectMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    public let projects: [LookoutVisionClientTypes.ProjectMetadata]?
    public let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case projects = "Projects"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.ProjectMetadata?].self, forKey: .projects)
        var projectsDecoded0:[LookoutVisionClientTypes.ProjectMetadata]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [LookoutVisionClientTypes.ProjectMetadata]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the model for which you want to list tags.
    /// This member is required.
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A map of tag keys and values attached to the specified model.
    public let tags: [LookoutVisionClientTypes.Tag]?

    public init (
        tags: [LookoutVisionClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [LookoutVisionClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LookoutVisionClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LookoutVisionClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutVisionClientTypes.ModelDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case description = "Description"
        case evaluationEndTimestamp = "EvaluationEndTimestamp"
        case evaluationManifest = "EvaluationManifest"
        case evaluationResult = "EvaluationResult"
        case kmsKeyId = "KmsKeyId"
        case modelArn = "ModelArn"
        case modelVersion = "ModelVersion"
        case outputConfig = "OutputConfig"
        case performance = "Performance"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let evaluationEndTimestamp = evaluationEndTimestamp {
            try encodeContainer.encode(evaluationEndTimestamp.timeIntervalSince1970, forKey: .evaluationEndTimestamp)
        }
        if let evaluationManifest = evaluationManifest {
            try encodeContainer.encode(evaluationManifest, forKey: .evaluationManifest)
        }
        if let evaluationResult = evaluationResult {
            try encodeContainer.encode(evaluationResult, forKey: .evaluationResult)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let modelArn = modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let outputConfig = outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
        if let performance = performance {
            try encodeContainer.encode(performance, forKey: .performance)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let performanceDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelPerformance.self, forKey: .performance)
        performance = performanceDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.OutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let evaluationManifestDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.OutputS3Object.self, forKey: .evaluationManifest)
        evaluationManifest = evaluationManifestDecoded
        let evaluationResultDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.OutputS3Object.self, forKey: .evaluationResult)
        evaluationResult = evaluationResultDecoded
        let evaluationEndTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .evaluationEndTimestamp)
        evaluationEndTimestamp = evaluationEndTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension LookoutVisionClientTypes.ModelDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelDescription(creationTimestamp: \(Swift.String(describing: creationTimestamp)), description: \(Swift.String(describing: description)), evaluationEndTimestamp: \(Swift.String(describing: evaluationEndTimestamp)), evaluationManifest: \(Swift.String(describing: evaluationManifest)), evaluationResult: \(Swift.String(describing: evaluationResult)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), modelArn: \(Swift.String(describing: modelArn)), modelVersion: \(Swift.String(describing: modelVersion)), outputConfig: \(Swift.String(describing: outputConfig)), performance: \(Swift.String(describing: performance)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension LookoutVisionClientTypes {
    /// Describes an Amazon Lookout for Vision model.
    public struct ModelDescription: Swift.Equatable {
        /// The unix timestamp for the date and time that the model was created.
        public let creationTimestamp: ClientRuntime.Date?
        /// The description for the model.
        public let description: Swift.String?
        /// The unix timestamp for the date and time that the evaluation ended.
        public let evaluationEndTimestamp: ClientRuntime.Date?
        /// The S3 location where Amazon Lookout for Vision saves the manifest file
        ///          that was used to test the trained model and generate the performance scores.
        public let evaluationManifest: LookoutVisionClientTypes.OutputS3Object?
        /// The S3 location where Amazon Lookout for Vision saves the performance metrics.
        public let evaluationResult: LookoutVisionClientTypes.OutputS3Object?
        /// The identifer for the AWS Key Management Service (AWS KMS) key that was used to encrypt the model
        ///          during training.
        public let kmsKeyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: Swift.String?
        /// The version of the model
        public let modelVersion: Swift.String?
        /// The S3 location where Amazon Lookout for Vision saves model training files.
        public let outputConfig: LookoutVisionClientTypes.OutputConfig?
        /// Performance metrics for the model. Created during training.
        public let performance: LookoutVisionClientTypes.ModelPerformance?
        /// The status of the model.
        public let status: LookoutVisionClientTypes.ModelStatus?
        /// The status message for the model.
        public let statusMessage: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            evaluationEndTimestamp: ClientRuntime.Date? = nil,
            evaluationManifest: LookoutVisionClientTypes.OutputS3Object? = nil,
            evaluationResult: LookoutVisionClientTypes.OutputS3Object? = nil,
            kmsKeyId: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            outputConfig: LookoutVisionClientTypes.OutputConfig? = nil,
            performance: LookoutVisionClientTypes.ModelPerformance? = nil,
            status: LookoutVisionClientTypes.ModelStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.evaluationEndTimestamp = evaluationEndTimestamp
            self.evaluationManifest = evaluationManifest
            self.evaluationResult = evaluationResult
            self.kmsKeyId = kmsKeyId
            self.modelArn = modelArn
            self.modelVersion = modelVersion
            self.outputConfig = outputConfig
            self.performance = performance
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LookoutVisionClientTypes {
    public enum ModelHostingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hosted
        case hostingFailed
        case startingHosting
        case stoppingHosting
        case systemUpdating
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelHostingStatus] {
            return [
                .hosted,
                .hostingFailed,
                .startingHosting,
                .stoppingHosting,
                .systemUpdating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hosted: return "HOSTED"
            case .hostingFailed: return "HOSTING_FAILED"
            case .startingHosting: return "STARTING_HOSTING"
            case .stoppingHosting: return "STOPPING_HOSTING"
            case .systemUpdating: return "SYSTEM_UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelHostingStatus(rawValue: rawValue) ?? ModelHostingStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutVisionClientTypes.ModelMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case description = "Description"
        case modelArn = "ModelArn"
        case modelVersion = "ModelVersion"
        case performance = "Performance"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelArn = modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let performance = performance {
            try encodeContainer.encode(performance, forKey: .performance)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let performanceDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelPerformance.self, forKey: .performance)
        performance = performanceDecoded
    }
}

extension LookoutVisionClientTypes.ModelMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelMetadata(creationTimestamp: \(Swift.String(describing: creationTimestamp)), description: \(Swift.String(describing: description)), modelArn: \(Swift.String(describing: modelArn)), modelVersion: \(Swift.String(describing: modelVersion)), performance: \(Swift.String(describing: performance)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension LookoutVisionClientTypes {
    /// Describes an Amazon Lookout for Vision model.
    public struct ModelMetadata: Swift.Equatable {
        /// The unix timestamp for the date and time that the model was created.
        public let creationTimestamp: ClientRuntime.Date?
        /// The description for the model.
        public let description: Swift.String?
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: Swift.String?
        /// The version of the model.
        public let modelVersion: Swift.String?
        /// Performance metrics for the model. Not available until training has successfully completed.
        public let performance: LookoutVisionClientTypes.ModelPerformance?
        /// The status of the model.
        public let status: LookoutVisionClientTypes.ModelStatus?
        /// The status message for the model.
        public let statusMessage: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            performance: LookoutVisionClientTypes.ModelPerformance? = nil,
            status: LookoutVisionClientTypes.ModelStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.modelArn = modelArn
            self.modelVersion = modelVersion
            self.performance = performance
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LookoutVisionClientTypes.ModelPerformance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case f1Score = "F1Score"
        case precision = "Precision"
        case recall = "Recall"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let f1Score = f1Score {
            try encodeContainer.encode(f1Score, forKey: .f1Score)
        }
        if let precision = precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let recall = recall {
            try encodeContainer.encode(recall, forKey: .recall)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let f1ScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .f1Score)
        f1Score = f1ScoreDecoded
        let recallDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .recall)
        recall = recallDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .precision)
        precision = precisionDecoded
    }
}

extension LookoutVisionClientTypes.ModelPerformance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelPerformance(f1Score: \(Swift.String(describing: f1Score)), precision: \(Swift.String(describing: precision)), recall: \(Swift.String(describing: recall)))"}
}

extension LookoutVisionClientTypes {
    /// Information about the evaluation performance of a trained model.
    public struct ModelPerformance: Swift.Equatable {
        /// The overall F1 score metric for the trained model.
        public let f1Score: Swift.Float?
        /// The overall precision metric value for the trained model.
        public let precision: Swift.Float?
        /// The overall recall metric value for the trained model.
        public let recall: Swift.Float?

        public init (
            f1Score: Swift.Float? = nil,
            precision: Swift.Float? = nil,
            recall: Swift.Float? = nil
        )
        {
            self.f1Score = f1Score
            self.precision = precision
            self.recall = recall
        }
    }

}

extension LookoutVisionClientTypes {
    public enum ModelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case hosted
        case hostingFailed
        case startingHosting
        case stoppingHosting
        case systemUpdating
        case trained
        case training
        case trainingFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelStatus] {
            return [
                .deleting,
                .hosted,
                .hostingFailed,
                .startingHosting,
                .stoppingHosting,
                .systemUpdating,
                .trained,
                .training,
                .trainingFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .hosted: return "HOSTED"
            case .hostingFailed: return "HOSTING_FAILED"
            case .startingHosting: return "STARTING_HOSTING"
            case .stoppingHosting: return "STOPPING_HOSTING"
            case .systemUpdating: return "SYSTEM_UPDATING"
            case .trained: return "TRAINED"
            case .training: return "TRAINING"
            case .trainingFailed: return "TRAINING_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelStatus(rawValue: rawValue) ?? ModelStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutVisionClientTypes.OutputConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location = "S3Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension LookoutVisionClientTypes.OutputConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputConfig(s3Location: \(Swift.String(describing: s3Location)))"}
}

extension LookoutVisionClientTypes {
    /// The S3 location where Amazon Lookout for Vision saves model training files.
    public struct OutputConfig: Swift.Equatable {
        /// The S3 location for the output.
        /// This member is required.
        public let s3Location: LookoutVisionClientTypes.S3Location?

        public init (
            s3Location: LookoutVisionClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension LookoutVisionClientTypes.OutputS3Object: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension LookoutVisionClientTypes.OutputS3Object: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputS3Object(bucket: \(Swift.String(describing: bucket)), key: \(Swift.String(describing: key)))"}
}

extension LookoutVisionClientTypes {
    /// The S3 location where Amazon Lookout for Vision saves training output.
    public struct OutputS3Object: Swift.Equatable {
        /// The bucket that contains the training output.
        /// This member is required.
        public let bucket: Swift.String?
        /// The location of the training output in the bucket.
        /// This member is required.
        public let key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension LookoutVisionClientTypes.ProjectDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case datasets = "Datasets"
        case projectArn = "ProjectArn"
        case projectName = "ProjectName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let datasets = datasets {
            var datasetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasets)
            for datasetmetadatalist0 in datasets {
                try datasetsContainer.encode(datasetmetadatalist0)
            }
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let datasetsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.DatasetMetadata?].self, forKey: .datasets)
        var datasetsDecoded0:[LookoutVisionClientTypes.DatasetMetadata]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [LookoutVisionClientTypes.DatasetMetadata]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
    }
}

extension LookoutVisionClientTypes.ProjectDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectDescription(creationTimestamp: \(Swift.String(describing: creationTimestamp)), datasets: \(Swift.String(describing: datasets)), projectArn: \(Swift.String(describing: projectArn)), projectName: \(Swift.String(describing: projectName)))"}
}

extension LookoutVisionClientTypes {
    /// Describe an Amazon Lookout for Vision project. For more information, see DescribeProject.
    public struct ProjectDescription: Swift.Equatable {
        /// The unix timestamp for the date and time that the project was created.
        public let creationTimestamp: ClientRuntime.Date?
        /// A list of datasets in the project.
        public let datasets: [LookoutVisionClientTypes.DatasetMetadata]?
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: Swift.String?
        /// The name of the project.
        public let projectName: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            datasets: [LookoutVisionClientTypes.DatasetMetadata]? = nil,
            projectArn: Swift.String? = nil,
            projectName: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.datasets = datasets
            self.projectArn = projectArn
            self.projectName = projectName
        }
    }

}

extension LookoutVisionClientTypes.ProjectMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case projectArn = "ProjectArn"
        case projectName = "ProjectName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
    }
}

extension LookoutVisionClientTypes.ProjectMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectMetadata(creationTimestamp: \(Swift.String(describing: creationTimestamp)), projectArn: \(Swift.String(describing: projectArn)), projectName: \(Swift.String(describing: projectName)))"}
}

extension LookoutVisionClientTypes {
    /// Metadata about an Amazon Lookout for Vision project.
    public struct ProjectMetadata: Swift.Equatable {
        /// The unix timestamp for the date and time that the project was created.
        public let creationTimestamp: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: Swift.String?
        /// The name of the project.
        public let projectName: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            projectArn: Swift.String? = nil,
            projectName: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.projectArn = projectArn
            self.projectName = projectName
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource.
    /// This member is required.
    public var resourceType: LookoutVisionClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: LookoutVisionClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: LookoutVisionClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension LookoutVisionClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dataset
        case model
        case project
        case trial
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .dataset,
                .model,
                .project,
                .trial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dataset: return "DATASET"
            case .model: return "MODEL"
            case .project: return "PROJECT"
            case .trial: return "TRIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension LookoutVisionClientTypes.S3Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension LookoutVisionClientTypes.S3Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Location(bucket: \(Swift.String(describing: bucket)), prefix: \(Swift.String(describing: prefix)))"}
}

extension LookoutVisionClientTypes {
    /// Information about the location training output.
    public struct S3Location: Swift.Equatable {
        /// The S3 bucket that contains the training output.
        /// This member is required.
        public let bucket: Swift.String?
        /// The path of the folder, within the S3 bucket, that contains the training output.
        public let prefix: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            prefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.prefix = prefix
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A service quota was exceeded the allowed limit. For more information, see
///         Limits in Amazon Lookout for Vision in the Amazon Lookout for Vision Developer Guide.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The quota code.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: LookoutVisionClientTypes.ResourceType?
    /// The service code.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: LookoutVisionClientTypes.ResourceType? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: LookoutVisionClientTypes.ResourceType?
    public let quotaCode: Swift.String?
    public let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

public struct StartModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartModelOutputError>
}

extension StartModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartModelInput(clientToken: \(Swift.String(describing: clientToken)), minInferenceUnits: \(Swift.String(describing: minInferenceUnits)), modelVersion: \(Swift.String(describing: modelVersion)), projectName: \(Swift.String(describing: projectName)))"}
}

extension StartModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minInferenceUnits = "MinInferenceUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let minInferenceUnits = minInferenceUnits {
            try encodeContainer.encode(minInferenceUnits, forKey: .minInferenceUnits)
        }
    }
}

public struct StartModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartModelOutputError>
}

public struct StartModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartModelOutputError>
}

public struct StartModelInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to StartModel
    ///          completes only once.  You choose the value to pass. For example, An issue,
    ///          such as an network outage, might prevent you from getting a response from StartModel.
    ///          In this case, safely retry your call
    ///          to StartModel by using the same ClientToken parameter value. An error occurs
    ///          if the other input parameters are not the same as in the first request. Using a different
    ///          value for ClientToken is considered a new call to StartModel. An idempotency
    ///          token is active for 8 hours.
    ///
    public var clientToken: Swift.String?
    /// The minimum number of inference units to use. A single
    ///          inference unit represents 1 hour of processing and can support up to 5 Transaction Pers Second (TPS).
    ///          Use a higher number to increase the TPS throughput of your model. You are charged for the number
    ///          of inference units that you use.
    ///
    /// This member is required.
    public let minInferenceUnits: Swift.Int?
    /// The version of the model that you want to start.
    /// This member is required.
    public let modelVersion: Swift.String?
    /// The name of the project that contains the model that you want to start.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        minInferenceUnits: Swift.Int? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.minInferenceUnits = minInferenceUnits
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct StartModelInputBody: Swift.Equatable {
    public let minInferenceUnits: Swift.Int?
}

extension StartModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minInferenceUnits = "MinInferenceUnits"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minInferenceUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minInferenceUnits)
        minInferenceUnits = minInferenceUnitsDecoded
    }
}

extension StartModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartModelOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension StartModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct StartModelOutputResponse: Swift.Equatable {
    /// The current running status of the model.
    public let status: LookoutVisionClientTypes.ModelHostingStatus?

    public init (
        status: LookoutVisionClientTypes.ModelHostingStatus? = nil
    )
    {
        self.status = status
    }
}

struct StartModelOutputResponseBody: Swift.Equatable {
    public let status: LookoutVisionClientTypes.ModelHostingStatus?
}

extension StartModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelHostingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension StopModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopModelInput(clientToken: \(Swift.String(describing: clientToken)), modelVersion: \(Swift.String(describing: modelVersion)), projectName: \(Swift.String(describing: projectName)))"}
}

extension StopModelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StopModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopModelOutputError>
}

public struct StopModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopModelOutputError>
}

public struct StopModelInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to StopModel
    ///          completes only once.  You choose the value to pass. For example, An issue,
    ///          such as an network outage, might prevent you from getting a response from StopModel.
    ///          In this case, safely retry your call
    ///          to StopModel by using the same ClientToken parameter value. An error occurs
    ///          if the other input parameters are not the same as in the first request. Using a different
    ///          value for ClientToken is considered a new call to StopModel. An idempotency
    ///          token is active for 8 hours.
    ///
    ///
    ///
    public var clientToken: Swift.String?
    /// The version of the model that you want to stop.
    /// This member is required.
    public let modelVersion: Swift.String?
    /// The name of the project that contains the model that you want to stop.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct StopModelInputBody: Swift.Equatable {
}

extension StopModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopModelOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension StopModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct StopModelOutputResponse: Swift.Equatable {
    /// The status of the model.
    public let status: LookoutVisionClientTypes.ModelHostingStatus?

    public init (
        status: LookoutVisionClientTypes.ModelHostingStatus? = nil
    )
    {
        self.status = status
    }
}

struct StopModelOutputResponseBody: Swift.Equatable {
    public let status: LookoutVisionClientTypes.ModelHostingStatus?
}

extension StopModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelHostingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension LookoutVisionClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LookoutVisionClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension LookoutVisionClientTypes {
    /// A key and value pair that is attached to the specified Amazon Lookout for Vision model.
    public struct Tag: Swift.Equatable {
        /// The key of the tag that is attached to the specified model.
        /// This member is required.
        public let key: Swift.String?
        /// The value of the tag that is attached to the specified model.
        /// This member is required.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the model to assign the tags.
    /// This member is required.
    public let resourceArn: Swift.String?
    /// The key-value tags to assign to the model.
    /// This member is required.
    public let tags: [LookoutVisionClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [LookoutVisionClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [LookoutVisionClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LookoutVisionClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LookoutVisionClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Lookout for Vision is temporarily unable to process the request. Try your call again.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The quota code.
    public var quotaCode: Swift.String?
    /// The period of time, in seconds, before the operation can be retried.
    public var retryAfterSeconds: Swift.Int
    /// The service code.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let quotaCode: Swift.String?
    public let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the model from which you want to remove tags.
    /// This member is required.
    public let resourceArn: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDatasetEntriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetEntriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetEntriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetEntriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetEntriesOutputError>
}

extension UpdateDatasetEntriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatasetEntriesInput(changes: \(Swift.String(describing: changes)), clientToken: \(Swift.String(describing: clientToken)), datasetType: \(Swift.String(describing: datasetType)), projectName: \(Swift.String(describing: projectName)))"}
}

extension UpdateDatasetEntriesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changes = "Changes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changes = changes {
            try encodeContainer.encode(changes.base64EncodedString(), forKey: .changes)
        }
    }
}

public struct UpdateDatasetEntriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetEntriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetEntriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetEntriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetEntriesOutputError>
}

public struct UpdateDatasetEntriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetEntriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetEntriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetEntriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetEntriesOutputError>
}

public struct UpdateDatasetEntriesInput: Swift.Equatable {
    /// The entries to add to the dataset.
    /// This member is required.
    public let changes: ClientRuntime.Data?
    /// ClientToken is an idempotency token that ensures a call to UpdateDatasetEntries
    ///          completes only once.  You choose the value to pass. For example, An issue,
    ///          such as an network outage, might prevent you from getting a response from UpdateDatasetEntries.
    ///          In this case, safely retry your call
    ///          to UpdateDatasetEntries by using the same ClientToken parameter value. An error occurs
    ///          if the other input parameters are not the same as in the first request. Using a different
    ///          value for ClientToken is considered a new call to UpdateDatasetEntries. An idempotency
    ///          token is active for 8 hours.
    ///
    public var clientToken: Swift.String?
    /// The type of the dataset that you want to update. Specify train to update
    ///       the training dataset. Specify test to update the test dataset. If you
    ///        have a single dataset project, specify train.
    /// This member is required.
    public let datasetType: Swift.String?
    /// The name of the project that contains the dataset that you want to update.
    /// This member is required.
    public let projectName: Swift.String?

    public init (
        changes: ClientRuntime.Data? = nil,
        clientToken: Swift.String? = nil,
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.changes = changes
        self.clientToken = clientToken
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct UpdateDatasetEntriesInputBody: Swift.Equatable {
    public let changes: ClientRuntime.Data?
}

extension UpdateDatasetEntriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changes = "Changes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .changes)
        changes = changesDecoded
    }
}

extension UpdateDatasetEntriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetEntriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatasetEntriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetEntriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatasetEntriesOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension UpdateDatasetEntriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDatasetEntriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct UpdateDatasetEntriesOutputResponse: Swift.Equatable {
    /// The status of the dataset update.
    public let status: LookoutVisionClientTypes.DatasetStatus?

    public init (
        status: LookoutVisionClientTypes.DatasetStatus? = nil
    )
    {
        self.status = status
    }
}

struct UpdateDatasetEntriesOutputResponseBody: Swift.Equatable {
    public let status: LookoutVisionClientTypes.DatasetStatus?
}

extension UpdateDatasetEntriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An input validation error occured. For example, invalid characters in a project name,
///       or if a pagination token is invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
