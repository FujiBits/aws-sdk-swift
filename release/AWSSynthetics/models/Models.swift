// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SyntheticsClientTypes.BaseScreenshot: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ignoreCoordinates = "IgnoreCoordinates"
        case screenshotName = "ScreenshotName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ignoreCoordinates = ignoreCoordinates {
            var ignoreCoordinatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ignoreCoordinates)
            for basescreenshotignorecoordinates0 in ignoreCoordinates {
                try ignoreCoordinatesContainer.encode(basescreenshotignorecoordinates0)
            }
        }
        if let screenshotName = screenshotName {
            try encodeContainer.encode(screenshotName, forKey: .screenshotName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let screenshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenshotName)
        screenshotName = screenshotNameDecoded
        let ignoreCoordinatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ignoreCoordinates)
        var ignoreCoordinatesDecoded0:[Swift.String]? = nil
        if let ignoreCoordinatesContainer = ignoreCoordinatesContainer {
            ignoreCoordinatesDecoded0 = [Swift.String]()
            for string0 in ignoreCoordinatesContainer {
                if let string0 = string0 {
                    ignoreCoordinatesDecoded0?.append(string0)
                }
            }
        }
        ignoreCoordinates = ignoreCoordinatesDecoded0
    }
}

extension SyntheticsClientTypes.BaseScreenshot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BaseScreenshot(ignoreCoordinates: \(Swift.String(describing: ignoreCoordinates)), screenshotName: \(Swift.String(describing: screenshotName)))"}
}

extension SyntheticsClientTypes {
    /// A structure representing a screenshot that is used as a baseline during visual monitoring comparisons made by the canary.
    public struct BaseScreenshot: Swift.Equatable {
        /// Coordinates that define the part of a screen to ignore during screenshot comparisons. To obtain the coordinates to use here, use the
        ///          CloudWatch Logs console to draw the boundaries on the screen. For more information, see {LINK}
        public let ignoreCoordinates: [Swift.String]?
        /// The name of the screenshot. This is generated the first time the canary is run after the UpdateCanary operation that
        ///       specified for this canary to perform visual monitoring.
        /// This member is required.
        public let screenshotName: Swift.String?

        public init (
            ignoreCoordinates: [Swift.String]? = nil,
            screenshotName: Swift.String? = nil
        )
        {
            self.ignoreCoordinates = ignoreCoordinates
            self.screenshotName = screenshotName
        }
    }

}

extension SyntheticsClientTypes.Canary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactS3Location = "ArtifactS3Location"
        case code = "Code"
        case engineArn = "EngineArn"
        case executionRoleArn = "ExecutionRoleArn"
        case failureRetentionPeriodInDays = "FailureRetentionPeriodInDays"
        case id = "Id"
        case name = "Name"
        case runConfig = "RunConfig"
        case runtimeVersion = "RuntimeVersion"
        case schedule = "Schedule"
        case status = "Status"
        case successRetentionPeriodInDays = "SuccessRetentionPeriodInDays"
        case tags = "Tags"
        case timeline = "Timeline"
        case visualReference = "VisualReference"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactS3Location = artifactS3Location {
            try encodeContainer.encode(artifactS3Location, forKey: .artifactS3Location)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let engineArn = engineArn {
            try encodeContainer.encode(engineArn, forKey: .engineArn)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureRetentionPeriodInDays = failureRetentionPeriodInDays {
            try encodeContainer.encode(failureRetentionPeriodInDays, forKey: .failureRetentionPeriodInDays)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runConfig = runConfig {
            try encodeContainer.encode(runConfig, forKey: .runConfig)
        }
        if let runtimeVersion = runtimeVersion {
            try encodeContainer.encode(runtimeVersion, forKey: .runtimeVersion)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let successRetentionPeriodInDays = successRetentionPeriodInDays {
            try encodeContainer.encode(successRetentionPeriodInDays, forKey: .successRetentionPeriodInDays)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeline = timeline {
            try encodeContainer.encode(timeline, forKey: .timeline)
        }
        if let visualReference = visualReference {
            try encodeContainer.encode(visualReference, forKey: .visualReference)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryCodeOutput.self, forKey: .code)
        code = codeDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryScheduleOutput.self, forKey: .schedule)
        schedule = scheduleDecoded
        let runConfigDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryRunConfigOutput.self, forKey: .runConfig)
        runConfig = runConfigDecoded
        let successRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .successRetentionPeriodInDays)
        successRetentionPeriodInDays = successRetentionPeriodInDaysDecoded
        let failureRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureRetentionPeriodInDays)
        failureRetentionPeriodInDays = failureRetentionPeriodInDaysDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryStatus.self, forKey: .status)
        status = statusDecoded
        let timelineDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryTimeline.self, forKey: .timeline)
        timeline = timelineDecoded
        let artifactS3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactS3Location)
        artifactS3Location = artifactS3LocationDecoded
        let engineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineArn)
        engineArn = engineArnDecoded
        let runtimeVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeVersion)
        runtimeVersion = runtimeVersionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.VpcConfigOutput.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let visualReferenceDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.VisualReferenceOutput.self, forKey: .visualReference)
        visualReference = visualReferenceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SyntheticsClientTypes.Canary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Canary(artifactS3Location: \(Swift.String(describing: artifactS3Location)), code: \(Swift.String(describing: code)), engineArn: \(Swift.String(describing: engineArn)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), failureRetentionPeriodInDays: \(Swift.String(describing: failureRetentionPeriodInDays)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), runConfig: \(Swift.String(describing: runConfig)), runtimeVersion: \(Swift.String(describing: runtimeVersion)), schedule: \(Swift.String(describing: schedule)), status: \(Swift.String(describing: status)), successRetentionPeriodInDays: \(Swift.String(describing: successRetentionPeriodInDays)), tags: \(Swift.String(describing: tags)), timeline: \(Swift.String(describing: timeline)), visualReference: \(Swift.String(describing: visualReference)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension SyntheticsClientTypes {
    /// This structure contains all information about one canary in your account.
    public struct Canary: Swift.Equatable {
        /// The location in Amazon S3 where Synthetics stores artifacts from the runs of this
        ///          canary. Artifacts include the log file, screenshots, and HAR files.
        public let artifactS3Location: Swift.String?
        /// This structure contains information about the canary's Lambda handler and
        ///       where its code is stored by CloudWatch Synthetics.
        public let code: SyntheticsClientTypes.CanaryCodeOutput?
        /// The ARN of the Lambda function that is used as your canary's engine. For more information
        ///          about Lambda ARN format, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-api-permissions-ref.html">Resources and Conditions for Lambda Actions.
        public let engineArn: Swift.String?
        /// The ARN of the IAM role used to run the canary. This role must include lambda.amazonaws.com as a principal in the trust
        ///          policy.
        public let executionRoleArn: Swift.String?
        /// The number of days to retain data about failed runs of this canary.
        public let failureRetentionPeriodInDays: Swift.Int?
        /// The unique ID of this canary.
        public let id: Swift.String?
        /// The name of the canary.
        public let name: Swift.String?
        /// A structure that contains information about a canary run.
        public let runConfig: SyntheticsClientTypes.CanaryRunConfigOutput?
        /// Specifies the runtime version to use for the canary. For more information about
        ///          runtime versions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library.html">
        ///             Canary Runtime Versions.
        public let runtimeVersion: Swift.String?
        /// A structure that contains information about how often the canary is to run, and when
        ///          these runs are to stop.
        public let schedule: SyntheticsClientTypes.CanaryScheduleOutput?
        /// A structure that contains information about the canary's status.
        public let status: SyntheticsClientTypes.CanaryStatus?
        /// The number of days to retain data about successful runs of this canary.
        public let successRetentionPeriodInDays: Swift.Int?
        /// The list of key-value pairs that are associated with the canary.
        public let tags: [Swift.String:Swift.String]?
        /// A structure that contains information about when the canary was created, modified, and
        ///          most recently run.
        public let timeline: SyntheticsClientTypes.CanaryTimeline?
        /// If this canary performs visual monitoring by comparing screenshots, this structure contains the ID of the canary run to use as the baseline for screenshots, and the coordinates
        ///       of any parts of the screen to ignore during the visual monitoring comparison.
        public let visualReference: SyntheticsClientTypes.VisualReferenceOutput?
        /// If this canary is to test an endpoint in a VPC, this structure contains
        ///          information about the subnets and security groups of the VPC endpoint.
        ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_VPC.html">
        ///             Running a Canary in a VPC.
        public let vpcConfig: SyntheticsClientTypes.VpcConfigOutput?

        public init (
            artifactS3Location: Swift.String? = nil,
            code: SyntheticsClientTypes.CanaryCodeOutput? = nil,
            engineArn: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            failureRetentionPeriodInDays: Swift.Int? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            runConfig: SyntheticsClientTypes.CanaryRunConfigOutput? = nil,
            runtimeVersion: Swift.String? = nil,
            schedule: SyntheticsClientTypes.CanaryScheduleOutput? = nil,
            status: SyntheticsClientTypes.CanaryStatus? = nil,
            successRetentionPeriodInDays: Swift.Int? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            timeline: SyntheticsClientTypes.CanaryTimeline? = nil,
            visualReference: SyntheticsClientTypes.VisualReferenceOutput? = nil,
            vpcConfig: SyntheticsClientTypes.VpcConfigOutput? = nil
        )
        {
            self.artifactS3Location = artifactS3Location
            self.code = code
            self.engineArn = engineArn
            self.executionRoleArn = executionRoleArn
            self.failureRetentionPeriodInDays = failureRetentionPeriodInDays
            self.id = id
            self.name = name
            self.runConfig = runConfig
            self.runtimeVersion = runtimeVersion
            self.schedule = schedule
            self.status = status
            self.successRetentionPeriodInDays = successRetentionPeriodInDays
            self.tags = tags
            self.timeline = timeline
            self.visualReference = visualReference
            self.vpcConfig = vpcConfig
        }
    }

}

extension SyntheticsClientTypes.CanaryCodeInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case handler = "Handler"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3Version = "S3Version"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3Version = s3Version {
            try encodeContainer.encode(s3Version, forKey: .s3Version)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3VersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Version)
        s3Version = s3VersionDecoded
        let zipFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
    }
}

extension SyntheticsClientTypes.CanaryCodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryCodeInput(handler: \(Swift.String(describing: handler)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3Version: \(Swift.String(describing: s3Version)), zipFile: \(Swift.String(describing: zipFile)))"}
}

extension SyntheticsClientTypes {
    /// Use this structure to input your script code for the canary. This structure contains the
    ///          Lambda handler with the location where the canary should start running the script. If the
    ///          script is stored in an S3 bucket, the bucket name, key, and version are also included. If
    ///          the script was passed into the canary directly, the script code is contained in the value
    ///          of Zipfile.
    public struct CanaryCodeInput: Swift.Equatable {
        /// The entry point to use for the source code when running the canary. This value must end
        ///          with the string .handler. The string is limited to 29 characters or fewer.
        /// This member is required.
        public let handler: Swift.String?
        /// If your canary script is located in S3, specify the bucket name here. Do not include s3:// as the
        ///          start of the bucket name.
        public let s3Bucket: Swift.String?
        /// The S3 key of your script. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingObjects.html">Working with Amazon S3 Objects.
        public let s3Key: Swift.String?
        /// The S3 version ID of your script.
        public let s3Version: Swift.String?
        /// If you input your canary script directly into the canary instead of referring to an S3
        ///          location, the value of this parameter is the base64-encoded contents of the .zip file that
        ///          contains the script. It must be smaller than 256 Kb.
        public let zipFile: ClientRuntime.Data?

        public init (
            handler: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3Version: Swift.String? = nil,
            zipFile: ClientRuntime.Data? = nil
        )
        {
            self.handler = handler
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3Version = s3Version
            self.zipFile = zipFile
        }
    }

}

extension SyntheticsClientTypes.CanaryCodeOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case handler = "Handler"
        case sourceLocationArn = "SourceLocationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let sourceLocationArn = sourceLocationArn {
            try encodeContainer.encode(sourceLocationArn, forKey: .sourceLocationArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceLocationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationArn)
        sourceLocationArn = sourceLocationArnDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
    }
}

extension SyntheticsClientTypes.CanaryCodeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryCodeOutput(handler: \(Swift.String(describing: handler)), sourceLocationArn: \(Swift.String(describing: sourceLocationArn)))"}
}

extension SyntheticsClientTypes {
    /// This structure contains information about the canary's Lambda handler and
    ///       where its code is stored by CloudWatch Synthetics.
    public struct CanaryCodeOutput: Swift.Equatable {
        /// The entry point to use for the source code when running the canary.
        public let handler: Swift.String?
        /// The ARN of the Lambda layer where Synthetics stores the canary script code.
        public let sourceLocationArn: Swift.String?

        public init (
            handler: Swift.String? = nil,
            sourceLocationArn: Swift.String? = nil
        )
        {
            self.handler = handler
            self.sourceLocationArn = sourceLocationArn
        }
    }

}

extension SyntheticsClientTypes.CanaryLastRun: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canaryName = "CanaryName"
        case lastRun = "LastRun"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canaryName = canaryName {
            try encodeContainer.encode(canaryName, forKey: .canaryName)
        }
        if let lastRun = lastRun {
            try encodeContainer.encode(lastRun, forKey: .lastRun)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canaryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .canaryName)
        canaryName = canaryNameDecoded
        let lastRunDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryRun.self, forKey: .lastRun)
        lastRun = lastRunDecoded
    }
}

extension SyntheticsClientTypes.CanaryLastRun: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryLastRun(canaryName: \(Swift.String(describing: canaryName)), lastRun: \(Swift.String(describing: lastRun)))"}
}

extension SyntheticsClientTypes {
    /// This structure contains information about the most recent run of a single canary.
    public struct CanaryLastRun: Swift.Equatable {
        /// The name of the canary.
        public let canaryName: Swift.String?
        /// The results from this canary's most recent run.
        public let lastRun: SyntheticsClientTypes.CanaryRun?

        public init (
            canaryName: Swift.String? = nil,
            lastRun: SyntheticsClientTypes.CanaryRun? = nil
        )
        {
            self.canaryName = canaryName
            self.lastRun = lastRun
        }
    }

}

extension SyntheticsClientTypes.CanaryRun: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactS3Location = "ArtifactS3Location"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case timeline = "Timeline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactS3Location = artifactS3Location {
            try encodeContainer.encode(artifactS3Location, forKey: .artifactS3Location)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timeline = timeline {
            try encodeContainer.encode(timeline, forKey: .timeline)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryRunStatus.self, forKey: .status)
        status = statusDecoded
        let timelineDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryRunTimeline.self, forKey: .timeline)
        timeline = timelineDecoded
        let artifactS3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactS3Location)
        artifactS3Location = artifactS3LocationDecoded
    }
}

extension SyntheticsClientTypes.CanaryRun: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryRun(artifactS3Location: \(Swift.String(describing: artifactS3Location)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), timeline: \(Swift.String(describing: timeline)))"}
}

extension SyntheticsClientTypes {
    /// This structure contains the details about one run of one canary.
    public struct CanaryRun: Swift.Equatable {
        /// The location where the canary stored artifacts from the run. Artifacts include
        ///          the log file, screenshots, and HAR files.
        public let artifactS3Location: Swift.String?
        /// A unique ID that identifies this canary run.
        public let id: Swift.String?
        /// The name of the canary.
        public let name: Swift.String?
        /// The status of this run.
        public let status: SyntheticsClientTypes.CanaryRunStatus?
        /// A structure that contains the start and end times of this run.
        public let timeline: SyntheticsClientTypes.CanaryRunTimeline?

        public init (
            artifactS3Location: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: SyntheticsClientTypes.CanaryRunStatus? = nil,
            timeline: SyntheticsClientTypes.CanaryRunTimeline? = nil
        )
        {
            self.artifactS3Location = artifactS3Location
            self.id = id
            self.name = name
            self.status = status
            self.timeline = timeline
        }
    }

}

extension SyntheticsClientTypes.CanaryRunConfigInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeTracing = "ActiveTracing"
        case environmentVariables = "EnvironmentVariables"
        case memoryInMB = "MemoryInMB"
        case timeoutInSeconds = "TimeoutInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeTracing = activeTracing {
            try encodeContainer.encode(activeTracing, forKey: .activeTracing)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariablesmap0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariablesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let memoryInMB = memoryInMB {
            try encodeContainer.encode(memoryInMB, forKey: .memoryInMB)
        }
        if let timeoutInSeconds = timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let memoryInMBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memoryInMB)
        memoryInMB = memoryInMBDecoded
        let activeTracingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activeTracing)
        activeTracing = activeTracingDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in environmentVariablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    environmentVariablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
    }
}

extension SyntheticsClientTypes.CanaryRunConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryRunConfigInput(activeTracing: \(Swift.String(describing: activeTracing)), environmentVariables: \(Swift.String(describing: environmentVariables)), memoryInMB: \(Swift.String(describing: memoryInMB)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)))"}
}

extension SyntheticsClientTypes {
    /// A structure that contains input information for a canary run.
    public struct CanaryRunConfigInput: Swift.Equatable {
        /// Specifies whether this canary is to use active X-Ray tracing when it runs. Active tracing
        ///          enables
        ///          this canary run to be displayed in the ServiceLens and X-Ray service maps even if the canary does
        ///          not hit an endpoint that has X-Ray tracing enabled. Using X-Ray tracing incurs charges.
        ///       For more information, see  <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_tracing.html">
        ///          Canaries and X-Ray tracing.
        ///          You can enable active tracing only for canaries that use version syn-nodejs-2.0
        ///       or later for their canary runtime.
        public let activeTracing: Swift.Bool?
        /// Specifies the keys and values to use for any environment variables
        ///       used in the canary script. Use the following format:
        ///          { "key1" : "value1", "key2" : "value2", ...}
        ///          Keys must start with a letter and be at least two characters. The total size
        ///          of your environment variables cannot exceed 4 KB. You can't specify any Lambda
        ///          reserved environment variables as the keys for your environment variables. For
        ///          more information about reserved keys, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime">
        ///             Runtime environment variables.
        public let environmentVariables: [Swift.String:Swift.String]?
        /// The maximum amount of memory available to the canary while it is running, in MB. This value must be a multiple of 64.
        public let memoryInMB: Swift.Int?
        /// How long the canary is allowed to run before it must stop. You can't set this time to be longer
        ///          than the frequency of the runs of this canary.
        ///          If you omit this field, the
        ///          frequency of the canary is used as this value, up to a maximum of 14 minutes.
        public let timeoutInSeconds: Swift.Int?

        public init (
            activeTracing: Swift.Bool? = nil,
            environmentVariables: [Swift.String:Swift.String]? = nil,
            memoryInMB: Swift.Int? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.activeTracing = activeTracing
            self.environmentVariables = environmentVariables
            self.memoryInMB = memoryInMB
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension SyntheticsClientTypes.CanaryRunConfigOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeTracing = "ActiveTracing"
        case memoryInMB = "MemoryInMB"
        case timeoutInSeconds = "TimeoutInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeTracing = activeTracing {
            try encodeContainer.encode(activeTracing, forKey: .activeTracing)
        }
        if let memoryInMB = memoryInMB {
            try encodeContainer.encode(memoryInMB, forKey: .memoryInMB)
        }
        if let timeoutInSeconds = timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let memoryInMBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memoryInMB)
        memoryInMB = memoryInMBDecoded
        let activeTracingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activeTracing)
        activeTracing = activeTracingDecoded
    }
}

extension SyntheticsClientTypes.CanaryRunConfigOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryRunConfigOutput(activeTracing: \(Swift.String(describing: activeTracing)), memoryInMB: \(Swift.String(describing: memoryInMB)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)))"}
}

extension SyntheticsClientTypes {
    /// A structure that contains information about a canary run.
    public struct CanaryRunConfigOutput: Swift.Equatable {
        /// Displays whether this canary run used active X-Ray tracing.
        public let activeTracing: Swift.Bool?
        /// The maximum amount of memory available to the canary while it is running, in MB. This value
        ///          must be a multiple of 64.
        public let memoryInMB: Swift.Int?
        /// How long the canary is allowed to run before it must stop.
        public let timeoutInSeconds: Swift.Int?

        public init (
            activeTracing: Swift.Bool? = nil,
            memoryInMB: Swift.Int? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.activeTracing = activeTracing
            self.memoryInMB = memoryInMB
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension SyntheticsClientTypes {
    public enum CanaryRunState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case passed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [CanaryRunState] {
            return [
                .failed,
                .passed,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .passed: return "PASSED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CanaryRunState(rawValue: rawValue) ?? CanaryRunState.sdkUnknown(rawValue)
        }
    }
}

extension SyntheticsClientTypes {
    public enum CanaryRunStateReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canaryFailure
        case executionFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [CanaryRunStateReasonCode] {
            return [
                .canaryFailure,
                .executionFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canaryFailure: return "CANARY_FAILURE"
            case .executionFailure: return "EXECUTION_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CanaryRunStateReasonCode(rawValue: rawValue) ?? CanaryRunStateReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension SyntheticsClientTypes.CanaryRunStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let stateReasonCode = stateReasonCode {
            try encodeContainer.encode(stateReasonCode.rawValue, forKey: .stateReasonCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryRunState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryRunStateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
    }
}

extension SyntheticsClientTypes.CanaryRunStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryRunStatus(state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)), stateReasonCode: \(Swift.String(describing: stateReasonCode)))"}
}

extension SyntheticsClientTypes {
    /// This structure contains the status information about a canary run.
    public struct CanaryRunStatus: Swift.Equatable {
        /// The current state of the run.
        public let state: SyntheticsClientTypes.CanaryRunState?
        /// If run of the canary failed, this field contains the reason for the error.
        public let stateReason: Swift.String?
        /// If this value is CANARY_FAILURE, an exception occurred in the
        ///          canary code. If this value is EXECUTION_FAILURE, an exception occurred in
        ///          CloudWatch Synthetics.
        public let stateReasonCode: SyntheticsClientTypes.CanaryRunStateReasonCode?

        public init (
            state: SyntheticsClientTypes.CanaryRunState? = nil,
            stateReason: Swift.String? = nil,
            stateReasonCode: SyntheticsClientTypes.CanaryRunStateReasonCode? = nil
        )
        {
            self.state = state
            self.stateReason = stateReason
            self.stateReasonCode = stateReasonCode
        }
    }

}

extension SyntheticsClientTypes.CanaryRunTimeline: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completed = "Completed"
        case started = "Started"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completed = completed {
            try encodeContainer.encode(completed.timeIntervalSince1970, forKey: .completed)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .started)
        started = startedDecoded
        let completedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completed)
        completed = completedDecoded
    }
}

extension SyntheticsClientTypes.CanaryRunTimeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryRunTimeline(completed: \(Swift.String(describing: completed)), started: \(Swift.String(describing: started)))"}
}

extension SyntheticsClientTypes {
    /// This structure contains the start and end times of a single canary run.
    public struct CanaryRunTimeline: Swift.Equatable {
        /// The end time of the run.
        public let completed: ClientRuntime.Date?
        /// The start time of the run.
        public let started: ClientRuntime.Date?

        public init (
            completed: ClientRuntime.Date? = nil,
            started: ClientRuntime.Date? = nil
        )
        {
            self.completed = completed
            self.started = started
        }
    }

}

extension SyntheticsClientTypes.CanaryScheduleInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInSeconds = "DurationInSeconds"
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInSeconds = durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
    }
}

extension SyntheticsClientTypes.CanaryScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryScheduleInput(durationInSeconds: \(Swift.String(describing: durationInSeconds)), expression: \(Swift.String(describing: expression)))"}
}

extension SyntheticsClientTypes {
    /// This structure specifies how often a canary is to make runs and the date and time
    ///          when it should stop making runs.
    public struct CanaryScheduleInput: Swift.Equatable {
        /// How long, in seconds, for the canary to continue making regular runs according to
        ///          the schedule in the Expression value. If you specify 0, the canary continues
        ///          making runs until you stop it. If you omit this field, the default of 0 is used.
        public let durationInSeconds: Swift.Int?
        /// A rate expression or a cron expression that defines how often the canary is to run.
        ///          For a rate expression, The syntax is
        ///                rate(number unit). unit
        ///          can be minute, minutes, or hour.
        ///          For example, rate(1 minute) runs the canary once a minute, rate(10 minutes) runs it once every
        ///       10 minutes, and rate(1 hour) runs it once every hour. You can
        ///          specify a frequency between rate(1 minute) and rate(1 hour).
        ///          Specifying rate(0 minute) or rate(0 hour) is a special value
        ///          that causes the
        ///          canary to run only once when it is started.
        ///          Use cron(expression) to specify a cron
        ///          expression. You can't schedule a canary to wait for more than a year before running. For information about the syntax for cron expressions, see
        ///          <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_cron.html">
        ///             Scheduling canary runs using cron.
        /// This member is required.
        public let expression: Swift.String?

        public init (
            durationInSeconds: Swift.Int? = nil,
            expression: Swift.String? = nil
        )
        {
            self.durationInSeconds = durationInSeconds
            self.expression = expression
        }
    }

}

extension SyntheticsClientTypes.CanaryScheduleOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInSeconds = "DurationInSeconds"
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInSeconds = durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
    }
}

extension SyntheticsClientTypes.CanaryScheduleOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryScheduleOutput(durationInSeconds: \(Swift.String(describing: durationInSeconds)), expression: \(Swift.String(describing: expression)))"}
}

extension SyntheticsClientTypes {
    /// How long, in seconds, for the canary to continue making regular runs according to the schedule in the
    ///          Expression value.
    public struct CanaryScheduleOutput: Swift.Equatable {
        /// How long, in seconds, for the canary to continue making regular runs after it
        ///          was created. The runs are performed according to the schedule in the
        ///          Expression value.
        public let durationInSeconds: Swift.Int?
        /// A rate expression or a cron expression that defines how often the canary is to run.
        ///          For a rate expression, The syntax is
        ///          rate(number unit). unit
        ///          can be minute, minutes, or hour.
        ///          For example, rate(1 minute) runs the canary once a minute, rate(10 minutes) runs it once every
        ///          10 minutes, and rate(1 hour) runs it once every hour. You can
        ///          specify a frequency between rate(1 minute) and rate(1 hour).
        ///          Specifying rate(0 minute) or rate(0 hour) is a special value
        ///          that causes the
        ///          canary to run only once when it is started.
        ///          Use cron(expression) to specify a cron
        ///          expression. For information about the syntax for cron expressions, see
        ///          <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_cron.html">
        ///             Scheduling canary runs using cron.
        public let expression: Swift.String?

        public init (
            durationInSeconds: Swift.Int? = nil,
            expression: Swift.String? = nil
        )
        {
            self.durationInSeconds = durationInSeconds
            self.expression = expression
        }
    }

}

extension SyntheticsClientTypes {
    public enum CanaryState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case error
        case ready
        case running
        case starting
        case stopped
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CanaryState] {
            return [
                .creating,
                .deleting,
                .error,
                .ready,
                .running,
                .starting,
                .stopped,
                .stopping,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .ready: return "READY"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CanaryState(rawValue: rawValue) ?? CanaryState.sdkUnknown(rawValue)
        }
    }
}

extension SyntheticsClientTypes {
    public enum CanaryStateReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidPermissions
        case sdkUnknown(Swift.String)

        public static var allCases: [CanaryStateReasonCode] {
            return [
                .invalidPermissions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidPermissions: return "INVALID_PERMISSIONS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CanaryStateReasonCode(rawValue: rawValue) ?? CanaryStateReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension SyntheticsClientTypes.CanaryStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let stateReasonCode = stateReasonCode {
            try encodeContainer.encode(stateReasonCode.rawValue, forKey: .stateReasonCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryStateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
    }
}

extension SyntheticsClientTypes.CanaryStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryStatus(state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)), stateReasonCode: \(Swift.String(describing: stateReasonCode)))"}
}

extension SyntheticsClientTypes {
    /// A structure that contains the current state of the canary.
    public struct CanaryStatus: Swift.Equatable {
        /// The current state of the canary.
        public let state: SyntheticsClientTypes.CanaryState?
        /// If the canary has insufficient permissions to run, this field provides more details.
        public let stateReason: Swift.String?
        /// If the canary cannot run or has failed, this field displays the reason.
        public let stateReasonCode: SyntheticsClientTypes.CanaryStateReasonCode?

        public init (
            state: SyntheticsClientTypes.CanaryState? = nil,
            stateReason: Swift.String? = nil,
            stateReasonCode: SyntheticsClientTypes.CanaryStateReasonCode? = nil
        )
        {
            self.state = state
            self.stateReason = stateReason
            self.stateReasonCode = stateReasonCode
        }
    }

}

extension SyntheticsClientTypes.CanaryTimeline: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case lastModified = "LastModified"
        case lastStarted = "LastStarted"
        case lastStopped = "LastStopped"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let lastStarted = lastStarted {
            try encodeContainer.encode(lastStarted.timeIntervalSince1970, forKey: .lastStarted)
        }
        if let lastStopped = lastStopped {
            try encodeContainer.encode(lastStopped.timeIntervalSince1970, forKey: .lastStopped)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastStartedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStarted)
        lastStarted = lastStartedDecoded
        let lastStoppedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStopped)
        lastStopped = lastStoppedDecoded
    }
}

extension SyntheticsClientTypes.CanaryTimeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CanaryTimeline(created: \(Swift.String(describing: created)), lastModified: \(Swift.String(describing: lastModified)), lastStarted: \(Swift.String(describing: lastStarted)), lastStopped: \(Swift.String(describing: lastStopped)))"}
}

extension SyntheticsClientTypes {
    /// This structure contains information about when the canary was created and modified.
    public struct CanaryTimeline: Swift.Equatable {
        /// The date and time the canary was created.
        public let created: ClientRuntime.Date?
        /// The date and time the canary was most recently modified.
        public let lastModified: ClientRuntime.Date?
        /// The date and time that the canary's most recent run started.
        public let lastStarted: ClientRuntime.Date?
        /// The date and time that the canary's most recent run ended.
        public let lastStopped: ClientRuntime.Date?

        public init (
            created: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil,
            lastStarted: ClientRuntime.Date? = nil,
            lastStopped: ClientRuntime.Date? = nil
        )
        {
            self.created = created
            self.lastModified = lastModified
            self.lastStarted = lastStarted
            self.lastStopped = lastStopped
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A conflicting operation is already in progress.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateCanaryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCanaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCanaryOutputError>
}

extension CreateCanaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCanaryInput(artifactS3Location: \(Swift.String(describing: artifactS3Location)), code: \(Swift.String(describing: code)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), failureRetentionPeriodInDays: \(Swift.String(describing: failureRetentionPeriodInDays)), name: \(Swift.String(describing: name)), runConfig: \(Swift.String(describing: runConfig)), runtimeVersion: \(Swift.String(describing: runtimeVersion)), schedule: \(Swift.String(describing: schedule)), successRetentionPeriodInDays: \(Swift.String(describing: successRetentionPeriodInDays)), tags: \(Swift.String(describing: tags)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension CreateCanaryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactS3Location = "ArtifactS3Location"
        case code = "Code"
        case executionRoleArn = "ExecutionRoleArn"
        case failureRetentionPeriodInDays = "FailureRetentionPeriodInDays"
        case name = "Name"
        case runConfig = "RunConfig"
        case runtimeVersion = "RuntimeVersion"
        case schedule = "Schedule"
        case successRetentionPeriodInDays = "SuccessRetentionPeriodInDays"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactS3Location = artifactS3Location {
            try encodeContainer.encode(artifactS3Location, forKey: .artifactS3Location)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureRetentionPeriodInDays = failureRetentionPeriodInDays {
            try encodeContainer.encode(failureRetentionPeriodInDays, forKey: .failureRetentionPeriodInDays)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runConfig = runConfig {
            try encodeContainer.encode(runConfig, forKey: .runConfig)
        }
        if let runtimeVersion = runtimeVersion {
            try encodeContainer.encode(runtimeVersion, forKey: .runtimeVersion)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let successRetentionPeriodInDays = successRetentionPeriodInDays {
            try encodeContainer.encode(successRetentionPeriodInDays, forKey: .successRetentionPeriodInDays)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateCanaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCanaryOutputError>
}

public struct CreateCanaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCanaryOutputError>
}

public struct CreateCanaryInput: Swift.Equatable {
    /// The location in Amazon S3 where Synthetics stores artifacts from the test runs of this
    ///          canary. Artifacts include the log file, screenshots, and HAR files.  The name of the
    ///          S3 bucket can't include a period (.).
    /// This member is required.
    public let artifactS3Location: Swift.String?
    /// A structure that includes the entry point from which the canary should start
    ///          running your script. If the script is stored in
    ///          an S3 bucket, the bucket name, key, and version are also included.
    ///
    /// This member is required.
    public let code: SyntheticsClientTypes.CanaryCodeInput?
    /// The ARN of the IAM role to be used to run the canary. This role must already exist,
    ///          and must include lambda.amazonaws.com as a principal in the trust
    ///          policy. The role must also have the following permissions:
    ///
    ///
    ///
    ///                   s3:PutObject
    ///
    ///
    ///
    ///
    ///                   s3:GetBucketLocation
    ///
    ///
    ///
    ///
    ///                   s3:ListAllMyBuckets
    ///
    ///
    ///
    ///
    ///                   cloudwatch:PutMetricData
    ///
    ///
    ///
    ///
    ///                   logs:CreateLogGroup
    ///
    ///
    ///
    ///
    ///                   logs:CreateLogStream
    ///
    ///
    ///
    ///
    ///                   logs:PutLogEvents
    ///
    ///
    ///
    /// This member is required.
    public let executionRoleArn: Swift.String?
    /// The number of days to retain data about failed runs of this canary. If you omit
    ///          this field, the default of 31 days is used. The valid range is 1 to 455 days.
    public let failureRetentionPeriodInDays: Swift.Int?
    /// The name for this canary. Be sure to give it a descriptive name
    ///          that distinguishes it from other canaries in your account.
    ///          Do not include secrets or proprietary information in your canary names. The canary name
    ///          makes up part of the canary ARN, and the ARN is included in outbound calls over the
    ///          internet. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/servicelens_canaries_security.html">Security
    ///             Considerations for Synthetics Canaries.
    /// This member is required.
    public let name: Swift.String?
    /// A structure that contains the configuration for individual canary runs,
    ///          such as timeout value.
    public let runConfig: SyntheticsClientTypes.CanaryRunConfigInput?
    /// Specifies the runtime version to use for the canary. For a list of valid
    ///          runtime versions and more information about
    ///          runtime versions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library.html">
    ///             Canary Runtime Versions.
    /// This member is required.
    public let runtimeVersion: Swift.String?
    /// A structure that contains information about how often the canary is to run and when
    ///          these test runs are to stop.
    /// This member is required.
    public let schedule: SyntheticsClientTypes.CanaryScheduleInput?
    /// The number of days to retain data about successful runs of this canary. If you omit
    ///          this field, the default of 31 days is used. The valid range is 1 to 455 days.
    public let successRetentionPeriodInDays: Swift.Int?
    /// A list of key-value pairs to associate with the canary.
    ///          You can associate as many as 50 tags with a canary.
    ///          Tags can help you organize and categorize your
    ///          resources. You can also use them to scope user permissions, by
    ///          granting a user permission to access or change only the resources that have
    ///          certain tag values.
    public let tags: [Swift.String:Swift.String]?
    /// If this canary is to test an endpoint in a VPC, this structure contains
    ///       information about the subnet and security groups of the VPC endpoint.
    ///       For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_VPC.html">
    ///          Running a Canary in a VPC.
    public let vpcConfig: SyntheticsClientTypes.VpcConfigInput?

    public init (
        artifactS3Location: Swift.String? = nil,
        code: SyntheticsClientTypes.CanaryCodeInput? = nil,
        executionRoleArn: Swift.String? = nil,
        failureRetentionPeriodInDays: Swift.Int? = nil,
        name: Swift.String? = nil,
        runConfig: SyntheticsClientTypes.CanaryRunConfigInput? = nil,
        runtimeVersion: Swift.String? = nil,
        schedule: SyntheticsClientTypes.CanaryScheduleInput? = nil,
        successRetentionPeriodInDays: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: SyntheticsClientTypes.VpcConfigInput? = nil
    )
    {
        self.artifactS3Location = artifactS3Location
        self.code = code
        self.executionRoleArn = executionRoleArn
        self.failureRetentionPeriodInDays = failureRetentionPeriodInDays
        self.name = name
        self.runConfig = runConfig
        self.runtimeVersion = runtimeVersion
        self.schedule = schedule
        self.successRetentionPeriodInDays = successRetentionPeriodInDays
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateCanaryInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let code: SyntheticsClientTypes.CanaryCodeInput?
    public let artifactS3Location: Swift.String?
    public let executionRoleArn: Swift.String?
    public let schedule: SyntheticsClientTypes.CanaryScheduleInput?
    public let runConfig: SyntheticsClientTypes.CanaryRunConfigInput?
    public let successRetentionPeriodInDays: Swift.Int?
    public let failureRetentionPeriodInDays: Swift.Int?
    public let runtimeVersion: Swift.String?
    public let vpcConfig: SyntheticsClientTypes.VpcConfigInput?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateCanaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactS3Location = "ArtifactS3Location"
        case code = "Code"
        case executionRoleArn = "ExecutionRoleArn"
        case failureRetentionPeriodInDays = "FailureRetentionPeriodInDays"
        case name = "Name"
        case runConfig = "RunConfig"
        case runtimeVersion = "RuntimeVersion"
        case schedule = "Schedule"
        case successRetentionPeriodInDays = "SuccessRetentionPeriodInDays"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryCodeInput.self, forKey: .code)
        code = codeDecoded
        let artifactS3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactS3Location)
        artifactS3Location = artifactS3LocationDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryScheduleInput.self, forKey: .schedule)
        schedule = scheduleDecoded
        let runConfigDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryRunConfigInput.self, forKey: .runConfig)
        runConfig = runConfigDecoded
        let successRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .successRetentionPeriodInDays)
        successRetentionPeriodInDays = successRetentionPeriodInDaysDecoded
        let failureRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureRetentionPeriodInDays)
        failureRetentionPeriodInDays = failureRetentionPeriodInDaysDecoded
        let runtimeVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeVersion)
        runtimeVersion = runtimeVersionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.VpcConfigInput.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCanaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCanaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCanaryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCanaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCanaryOutputResponse(canary: \(Swift.String(describing: canary)))"}
}

extension CreateCanaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCanaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.canary = output.canary
        } else {
            self.canary = nil
        }
    }
}

public struct CreateCanaryOutputResponse: Swift.Equatable {
    /// The full details about the canary you have created.
    public let canary: SyntheticsClientTypes.Canary?

    public init (
        canary: SyntheticsClientTypes.Canary? = nil
    )
    {
        self.canary = canary
    }
}

struct CreateCanaryOutputResponseBody: Swift.Equatable {
    public let canary: SyntheticsClientTypes.Canary?
}

extension CreateCanaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canary = "Canary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canaryDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.Canary.self, forKey: .canary)
        canary = canaryDecoded
    }
}

extension DeleteCanaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCanaryInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteCanaryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCanaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCanaryOutputError>
}

public struct DeleteCanaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCanaryOutputError>
}

public struct DeleteCanaryInput: Swift.Equatable {
    /// The name of the canary that you want to delete. To find the names of your canaries, use <a href="https://docs.aws.amazon.com/AmazonSynthetics/latest/APIReference/API_DescribeCanaries.html">DescribeCanaries.
    /// This member is required.
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteCanaryInputBody: Swift.Equatable {
}

extension DeleteCanaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCanaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCanaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCanaryOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCanaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCanaryOutputResponse()"}
}

extension DeleteCanaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCanaryOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCanaryOutputResponseBody: Swift.Equatable {
}

extension DeleteCanaryOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeCanariesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCanariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCanariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCanariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCanariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCanariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCanariesOutputError>
}

extension DescribeCanariesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCanariesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCanariesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeCanariesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCanariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCanariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCanariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCanariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCanariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCanariesOutputError>
}

public struct DescribeCanariesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCanariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCanariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCanariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCanariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCanariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCanariesOutputError>
}

public struct DescribeCanariesInput: Swift.Equatable {
    /// Specify this parameter to limit how many canaries are returned each time you use
    ///       the DescribeCanaries operation. If you omit this parameter, the default of 100 is used.
    public let maxResults: Swift.Int?
    /// A token that indicates that there is more data
    ///          available. You can use this token in a subsequent operation to retrieve the next
    ///          set of results.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeCanariesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeCanariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public struct DescribeCanariesLastRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCanariesLastRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCanariesLastRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCanariesLastRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCanariesLastRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCanariesLastRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCanariesLastRunOutputError>
}

extension DescribeCanariesLastRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCanariesLastRunInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCanariesLastRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeCanariesLastRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCanariesLastRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCanariesLastRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCanariesLastRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCanariesLastRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCanariesLastRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCanariesLastRunOutputError>
}

public struct DescribeCanariesLastRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCanariesLastRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCanariesLastRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCanariesLastRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCanariesLastRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCanariesLastRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCanariesLastRunOutputError>
}

public struct DescribeCanariesLastRunInput: Swift.Equatable {
    /// Specify this parameter to limit how many runs are returned each time you use
    ///          the DescribeLastRun operation. If you omit this parameter, the default of 100 is used.
    public let maxResults: Swift.Int?
    /// A token that indicates that there is more data
    ///          available. You can use this token in a subsequent DescribeCanaries operation to retrieve the next
    ///          set of results.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeCanariesLastRunInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeCanariesLastRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeCanariesLastRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCanariesLastRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCanariesLastRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCanariesLastRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCanariesLastRunOutputResponse(canariesLastRun: \(Swift.String(describing: canariesLastRun)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCanariesLastRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCanariesLastRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.canariesLastRun = output.canariesLastRun
            self.nextToken = output.nextToken
        } else {
            self.canariesLastRun = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeCanariesLastRunOutputResponse: Swift.Equatable {
    /// An array that contains the information from the most recent run of each
    ///          canary.
    public let canariesLastRun: [SyntheticsClientTypes.CanaryLastRun]?
    /// A token that indicates that there is more data
    ///          available. You can use this token in a subsequent DescribeCanariesLastRun operation to retrieve the next
    ///          set of results.
    public let nextToken: Swift.String?

    public init (
        canariesLastRun: [SyntheticsClientTypes.CanaryLastRun]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.canariesLastRun = canariesLastRun
        self.nextToken = nextToken
    }
}

struct DescribeCanariesLastRunOutputResponseBody: Swift.Equatable {
    public let canariesLastRun: [SyntheticsClientTypes.CanaryLastRun]?
    public let nextToken: Swift.String?
}

extension DescribeCanariesLastRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canariesLastRun = "CanariesLastRun"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canariesLastRunContainer = try containerValues.decodeIfPresent([SyntheticsClientTypes.CanaryLastRun?].self, forKey: .canariesLastRun)
        var canariesLastRunDecoded0:[SyntheticsClientTypes.CanaryLastRun]? = nil
        if let canariesLastRunContainer = canariesLastRunContainer {
            canariesLastRunDecoded0 = [SyntheticsClientTypes.CanaryLastRun]()
            for structure0 in canariesLastRunContainer {
                if let structure0 = structure0 {
                    canariesLastRunDecoded0?.append(structure0)
                }
            }
        }
        canariesLastRun = canariesLastRunDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeCanariesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCanariesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCanariesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCanariesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCanariesOutputResponse(canaries: \(Swift.String(describing: canaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCanariesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCanariesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.canaries = output.canaries
            self.nextToken = output.nextToken
        } else {
            self.canaries = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeCanariesOutputResponse: Swift.Equatable {
    /// Returns an array. Each item in the array contains the full information about
    ///          one canary.
    public let canaries: [SyntheticsClientTypes.Canary]?
    /// A token that indicates that there is more data
    ///          available. You can use this token in a subsequent DescribeCanaries operation to retrieve the next
    ///          set of results.
    public let nextToken: Swift.String?

    public init (
        canaries: [SyntheticsClientTypes.Canary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.canaries = canaries
        self.nextToken = nextToken
    }
}

struct DescribeCanariesOutputResponseBody: Swift.Equatable {
    public let canaries: [SyntheticsClientTypes.Canary]?
    public let nextToken: Swift.String?
}

extension DescribeCanariesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canaries = "Canaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canariesContainer = try containerValues.decodeIfPresent([SyntheticsClientTypes.Canary?].self, forKey: .canaries)
        var canariesDecoded0:[SyntheticsClientTypes.Canary]? = nil
        if let canariesContainer = canariesContainer {
            canariesDecoded0 = [SyntheticsClientTypes.Canary]()
            for structure0 in canariesContainer {
                if let structure0 = structure0 {
                    canariesDecoded0?.append(structure0)
                }
            }
        }
        canaries = canariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeRuntimeVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRuntimeVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRuntimeVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRuntimeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRuntimeVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRuntimeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRuntimeVersionsOutputError>
}

extension DescribeRuntimeVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRuntimeVersionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeRuntimeVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeRuntimeVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRuntimeVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRuntimeVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRuntimeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRuntimeVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRuntimeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRuntimeVersionsOutputError>
}

public struct DescribeRuntimeVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRuntimeVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRuntimeVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRuntimeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRuntimeVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRuntimeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRuntimeVersionsOutputError>
}

public struct DescribeRuntimeVersionsInput: Swift.Equatable {
    /// Specify this parameter to limit how many runs are returned each time you use
    ///          the DescribeRuntimeVersions operation. If you omit this parameter, the default of 100 is used.
    public let maxResults: Swift.Int?
    /// A token that indicates that there is more data
    ///          available. You can use this token in a subsequent DescribeRuntimeVersions operation to retrieve the next
    ///          set of results.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeRuntimeVersionsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeRuntimeVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRuntimeVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRuntimeVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRuntimeVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRuntimeVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRuntimeVersionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), runtimeVersions: \(Swift.String(describing: runtimeVersions)))"}
}

extension DescribeRuntimeVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRuntimeVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.runtimeVersions = output.runtimeVersions
        } else {
            self.nextToken = nil
            self.runtimeVersions = nil
        }
    }
}

public struct DescribeRuntimeVersionsOutputResponse: Swift.Equatable {
    /// A token that indicates that there is more data
    ///          available. You can use this token in a subsequent DescribeRuntimeVersions operation to retrieve the next
    ///          set of results.
    public let nextToken: Swift.String?
    /// An array of objects that display the details about each Synthetics canary runtime
    ///          version.
    public let runtimeVersions: [SyntheticsClientTypes.RuntimeVersion]?

    public init (
        nextToken: Swift.String? = nil,
        runtimeVersions: [SyntheticsClientTypes.RuntimeVersion]? = nil
    )
    {
        self.nextToken = nextToken
        self.runtimeVersions = runtimeVersions
    }
}

struct DescribeRuntimeVersionsOutputResponseBody: Swift.Equatable {
    public let runtimeVersions: [SyntheticsClientTypes.RuntimeVersion]?
    public let nextToken: Swift.String?
}

extension DescribeRuntimeVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case runtimeVersions = "RuntimeVersions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeVersionsContainer = try containerValues.decodeIfPresent([SyntheticsClientTypes.RuntimeVersion?].self, forKey: .runtimeVersions)
        var runtimeVersionsDecoded0:[SyntheticsClientTypes.RuntimeVersion]? = nil
        if let runtimeVersionsContainer = runtimeVersionsContainer {
            runtimeVersionsDecoded0 = [SyntheticsClientTypes.RuntimeVersion]()
            for structure0 in runtimeVersionsContainer {
                if let structure0 = structure0 {
                    runtimeVersionsDecoded0?.append(structure0)
                }
            }
        }
        runtimeVersions = runtimeVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCanaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCanaryInput(name: \(Swift.String(describing: name)))"}
}

extension GetCanaryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCanaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCanaryOutputError>
}

public struct GetCanaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCanaryOutputError>
}

public struct GetCanaryInput: Swift.Equatable {
    /// The name of the canary that you want details for.
    /// This member is required.
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetCanaryInputBody: Swift.Equatable {
}

extension GetCanaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCanaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCanaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCanaryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCanaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCanaryOutputResponse(canary: \(Swift.String(describing: canary)))"}
}

extension GetCanaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCanaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.canary = output.canary
        } else {
            self.canary = nil
        }
    }
}

public struct GetCanaryOutputResponse: Swift.Equatable {
    /// A strucure that contains the full information about the canary.
    public let canary: SyntheticsClientTypes.Canary?

    public init (
        canary: SyntheticsClientTypes.Canary? = nil
    )
    {
        self.canary = canary
    }
}

struct GetCanaryOutputResponseBody: Swift.Equatable {
    public let canary: SyntheticsClientTypes.Canary?
}

extension GetCanaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canary = "Canary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canaryDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.Canary.self, forKey: .canary)
        canary = canaryDecoded
    }
}

public struct GetCanaryRunsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCanaryRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCanaryRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCanaryRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCanaryRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCanaryRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCanaryRunsOutputError>
}

extension GetCanaryRunsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCanaryRunsInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetCanaryRunsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetCanaryRunsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCanaryRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCanaryRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCanaryRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCanaryRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCanaryRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCanaryRunsOutputError>
}

public struct GetCanaryRunsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCanaryRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCanaryRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCanaryRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCanaryRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCanaryRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCanaryRunsOutputError>
}

public struct GetCanaryRunsInput: Swift.Equatable {
    /// Specify this parameter to limit how many runs are returned each time you use
    ///          the GetCanaryRuns operation. If you omit this parameter, the default of 100 is used.
    public let maxResults: Swift.Int?
    /// The name of the canary that you want to see runs for.
    /// This member is required.
    public let name: Swift.String?
    /// A token that indicates that there is more data
    ///          available. You can use this token in a subsequent GetCanaryRuns operation to retrieve the next
    ///          set of results.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetCanaryRunsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetCanaryRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCanaryRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCanaryRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCanaryRunsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCanaryRunsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCanaryRunsOutputResponse(canaryRuns: \(Swift.String(describing: canaryRuns)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetCanaryRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCanaryRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.canaryRuns = output.canaryRuns
            self.nextToken = output.nextToken
        } else {
            self.canaryRuns = nil
            self.nextToken = nil
        }
    }
}

public struct GetCanaryRunsOutputResponse: Swift.Equatable {
    /// An array of structures. Each structure contains the details of one of the
    ///          retrieved canary runs.
    public let canaryRuns: [SyntheticsClientTypes.CanaryRun]?
    /// A token that indicates that there is more data
    ///          available. You can use this token in a subsequent GetCanaryRuns
    ///          operation to retrieve the next
    ///          set of results.
    public let nextToken: Swift.String?

    public init (
        canaryRuns: [SyntheticsClientTypes.CanaryRun]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.canaryRuns = canaryRuns
        self.nextToken = nextToken
    }
}

struct GetCanaryRunsOutputResponseBody: Swift.Equatable {
    public let canaryRuns: [SyntheticsClientTypes.CanaryRun]?
    public let nextToken: Swift.String?
}

extension GetCanaryRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canaryRuns = "CanaryRuns"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canaryRunsContainer = try containerValues.decodeIfPresent([SyntheticsClientTypes.CanaryRun?].self, forKey: .canaryRuns)
        var canaryRunsDecoded0:[SyntheticsClientTypes.CanaryRun]? = nil
        if let canaryRunsContainer = canaryRunsContainer {
            canaryRunsDecoded0 = [SyntheticsClientTypes.CanaryRun]()
            for structure0 in canaryRunsContainer {
                if let structure0 = structure0 {
                    canaryRunsDecoded0?.append(structure0)
                }
            }
        }
        canaryRuns = canaryRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unknown internal error occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the canary that you want to view tags for.
    ///          The ARN format of a canary is
    ///                arn:aws:synthetics:Region:account-id:canary:canary-name
    ///             .
    /// This member is required.
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tag keys and values associated with the canary that you specified.
    public let tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the specified resources was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SyntheticsClientTypes.RuntimeVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deprecationDate = "DeprecationDate"
        case description = "Description"
        case releaseDate = "ReleaseDate"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deprecationDate = deprecationDate {
            try encodeContainer.encode(deprecationDate.timeIntervalSince1970, forKey: .deprecationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let releaseDate = releaseDate {
            try encodeContainer.encode(releaseDate.timeIntervalSince1970, forKey: .releaseDate)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let releaseDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let deprecationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deprecationDate)
        deprecationDate = deprecationDateDecoded
    }
}

extension SyntheticsClientTypes.RuntimeVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuntimeVersion(deprecationDate: \(Swift.String(describing: deprecationDate)), description: \(Swift.String(describing: description)), releaseDate: \(Swift.String(describing: releaseDate)), versionName: \(Swift.String(describing: versionName)))"}
}

extension SyntheticsClientTypes {
    /// This structure contains information about one canary runtime version. For more information about
    ///          runtime versions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library.html">
    ///             Canary Runtime Versions.
    public struct RuntimeVersion: Swift.Equatable {
        /// If this runtime version is deprecated, this value is the date of deprecation.
        public let deprecationDate: ClientRuntime.Date?
        /// A description of the runtime version, created by Amazon.
        public let description: Swift.String?
        /// The date that the runtime version was released.
        public let releaseDate: ClientRuntime.Date?
        /// The name of the runtime version. For a list of valid runtime versions,
        ///          see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library.html">
        ///             Canary Runtime Versions.
        public let versionName: Swift.String?

        public init (
            deprecationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            releaseDate: ClientRuntime.Date? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.deprecationDate = deprecationDate
            self.description = description
            self.releaseDate = releaseDate
            self.versionName = versionName
        }
    }

}

extension StartCanaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartCanaryInput(name: \(Swift.String(describing: name)))"}
}

extension StartCanaryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StartCanaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartCanaryOutputError>
}

public struct StartCanaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartCanaryOutputError>
}

public struct StartCanaryInput: Swift.Equatable {
    /// The name of the canary that you want to run. To find
    ///          canary names, use <a href="https://docs.aws.amazon.com/AmazonSynthetics/latest/APIReference/API_DescribeCanaries.html">DescribeCanaries.
    /// This member is required.
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StartCanaryInputBody: Swift.Equatable {
}

extension StartCanaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartCanaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCanaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartCanaryOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCanaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartCanaryOutputResponse()"}
}

extension StartCanaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartCanaryOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartCanaryOutputResponseBody: Swift.Equatable {
}

extension StartCanaryOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopCanaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopCanaryInput(name: \(Swift.String(describing: name)))"}
}

extension StopCanaryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StopCanaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopCanaryOutputError>
}

public struct StopCanaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopCanaryOutputError>
}

public struct StopCanaryInput: Swift.Equatable {
    /// The name of the canary that you want to stop. To find the names of your
    ///          canaries, use <a href="https://docs.aws.amazon.com/AmazonSynthetics/latest/APIReference/API_DescribeCanaries.html">DescribeCanaries.
    /// This member is required.
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopCanaryInputBody: Swift.Equatable {
}

extension StopCanaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopCanaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopCanaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopCanaryOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopCanaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopCanaryOutputResponse()"}
}

extension StopCanaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopCanaryOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopCanaryOutputResponseBody: Swift.Equatable {
}

extension StopCanaryOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the canary that you're adding tags to.
    ///          The ARN format of a canary is
    ///                arn:aws:synthetics:Region:account-id:canary:canary-name
    ///             .
    /// This member is required.
    public let resourceArn: Swift.String?
    /// The list of key-value pairs to associate with the canary.
    /// This member is required.
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the canary that you're removing tags from.
    ///          The ARN format of a canary is
    ///                arn:aws:synthetics:Region:account-id:canary:canary-name
    ///             .
    /// This member is required.
    public let resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateCanaryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCanaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCanaryOutputError>
}

extension UpdateCanaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCanaryInput(code: \(Swift.String(describing: code)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), failureRetentionPeriodInDays: \(Swift.String(describing: failureRetentionPeriodInDays)), name: \(Swift.String(describing: name)), runConfig: \(Swift.String(describing: runConfig)), runtimeVersion: \(Swift.String(describing: runtimeVersion)), schedule: \(Swift.String(describing: schedule)), successRetentionPeriodInDays: \(Swift.String(describing: successRetentionPeriodInDays)), visualReference: \(Swift.String(describing: visualReference)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension UpdateCanaryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case executionRoleArn = "ExecutionRoleArn"
        case failureRetentionPeriodInDays = "FailureRetentionPeriodInDays"
        case runConfig = "RunConfig"
        case runtimeVersion = "RuntimeVersion"
        case schedule = "Schedule"
        case successRetentionPeriodInDays = "SuccessRetentionPeriodInDays"
        case visualReference = "VisualReference"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureRetentionPeriodInDays = failureRetentionPeriodInDays {
            try encodeContainer.encode(failureRetentionPeriodInDays, forKey: .failureRetentionPeriodInDays)
        }
        if let runConfig = runConfig {
            try encodeContainer.encode(runConfig, forKey: .runConfig)
        }
        if let runtimeVersion = runtimeVersion {
            try encodeContainer.encode(runtimeVersion, forKey: .runtimeVersion)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let successRetentionPeriodInDays = successRetentionPeriodInDays {
            try encodeContainer.encode(successRetentionPeriodInDays, forKey: .successRetentionPeriodInDays)
        }
        if let visualReference = visualReference {
            try encodeContainer.encode(visualReference, forKey: .visualReference)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct UpdateCanaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCanaryOutputError>
}

public struct UpdateCanaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCanaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCanaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCanaryOutputError>
}

public struct UpdateCanaryInput: Swift.Equatable {
    /// A structure that includes the entry point from which the canary should start
    ///          running your script. If the script is stored in
    ///          an S3 bucket, the bucket name, key, and version are also included.
    ///
    public let code: SyntheticsClientTypes.CanaryCodeInput?
    /// The ARN of the IAM role to be used to run the canary. This role must already exist,
    ///          and must include lambda.amazonaws.com as a principal in the trust
    ///          policy. The role must also have the following permissions:
    ///
    ///
    ///
    ///                   s3:PutObject
    ///
    ///
    ///
    ///
    ///                   s3:GetBucketLocation
    ///
    ///
    ///
    ///
    ///                   s3:ListAllMyBuckets
    ///
    ///
    ///
    ///
    ///                   cloudwatch:PutMetricData
    ///
    ///
    ///
    ///
    ///                   logs:CreateLogGroup
    ///
    ///
    ///
    ///
    ///                   logs:CreateLogStream
    ///
    ///
    ///
    ///
    ///                   logs:CreateLogStream
    ///
    ///
    ///
    public let executionRoleArn: Swift.String?
    /// The number of days to retain data about failed runs of this canary.
    public let failureRetentionPeriodInDays: Swift.Int?
    /// The name of the canary that you want to update. To find the names of your
    ///          canaries, use <a href="https://docs.aws.amazon.com/AmazonSynthetics/latest/APIReference/API_DescribeCanaries.html">DescribeCanaries.
    ///          You cannot change the name of a canary that has already been created.
    /// This member is required.
    public let name: Swift.String?
    /// A structure that contains the timeout value that is used for each individual run of the
    ///          canary.
    public let runConfig: SyntheticsClientTypes.CanaryRunConfigInput?
    /// Specifies the runtime version to use for the canary.
    ///          For a list of valid runtime versions and for more information about
    ///          runtime versions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library.html">
    ///             Canary Runtime Versions.
    public let runtimeVersion: Swift.String?
    /// A structure that contains information about how often the canary is to run, and when
    ///          these runs are to stop.
    public let schedule: SyntheticsClientTypes.CanaryScheduleInput?
    /// The number of days to retain data about successful runs of this canary.
    public let successRetentionPeriodInDays: Swift.Int?
    /// Defines the screenshots to use as the baseline for comparisons during visual monitoring comparisons during future runs of this canary. If you omit this
    ///       parameter, no changes are made to any baseline screenshots that the canary might be using already.
    ///          Visual monitoring is supported only on canaries running the syn-puppeteer-node-3.2
    ///          runtime or later. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Library_SyntheticsLogger_VisualTesting.html">
    ///             Visual monitoring and <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Blueprints_VisualTesting.html">
    ///                Visual monitoring blueprint
    ///
    public let visualReference: SyntheticsClientTypes.VisualReferenceInput?
    /// If this canary is to test an endpoint in a VPC, this structure contains
    ///          information about the subnet and security groups of the VPC endpoint.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_VPC.html">
    ///             Running a Canary in a VPC.
    public let vpcConfig: SyntheticsClientTypes.VpcConfigInput?

    public init (
        code: SyntheticsClientTypes.CanaryCodeInput? = nil,
        executionRoleArn: Swift.String? = nil,
        failureRetentionPeriodInDays: Swift.Int? = nil,
        name: Swift.String? = nil,
        runConfig: SyntheticsClientTypes.CanaryRunConfigInput? = nil,
        runtimeVersion: Swift.String? = nil,
        schedule: SyntheticsClientTypes.CanaryScheduleInput? = nil,
        successRetentionPeriodInDays: Swift.Int? = nil,
        visualReference: SyntheticsClientTypes.VisualReferenceInput? = nil,
        vpcConfig: SyntheticsClientTypes.VpcConfigInput? = nil
    )
    {
        self.code = code
        self.executionRoleArn = executionRoleArn
        self.failureRetentionPeriodInDays = failureRetentionPeriodInDays
        self.name = name
        self.runConfig = runConfig
        self.runtimeVersion = runtimeVersion
        self.schedule = schedule
        self.successRetentionPeriodInDays = successRetentionPeriodInDays
        self.visualReference = visualReference
        self.vpcConfig = vpcConfig
    }
}

struct UpdateCanaryInputBody: Swift.Equatable {
    public let code: SyntheticsClientTypes.CanaryCodeInput?
    public let executionRoleArn: Swift.String?
    public let runtimeVersion: Swift.String?
    public let schedule: SyntheticsClientTypes.CanaryScheduleInput?
    public let runConfig: SyntheticsClientTypes.CanaryRunConfigInput?
    public let successRetentionPeriodInDays: Swift.Int?
    public let failureRetentionPeriodInDays: Swift.Int?
    public let vpcConfig: SyntheticsClientTypes.VpcConfigInput?
    public let visualReference: SyntheticsClientTypes.VisualReferenceInput?
}

extension UpdateCanaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case executionRoleArn = "ExecutionRoleArn"
        case failureRetentionPeriodInDays = "FailureRetentionPeriodInDays"
        case runConfig = "RunConfig"
        case runtimeVersion = "RuntimeVersion"
        case schedule = "Schedule"
        case successRetentionPeriodInDays = "SuccessRetentionPeriodInDays"
        case visualReference = "VisualReference"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryCodeInput.self, forKey: .code)
        code = codeDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let runtimeVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeVersion)
        runtimeVersion = runtimeVersionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryScheduleInput.self, forKey: .schedule)
        schedule = scheduleDecoded
        let runConfigDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.CanaryRunConfigInput.self, forKey: .runConfig)
        runConfig = runConfigDecoded
        let successRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .successRetentionPeriodInDays)
        successRetentionPeriodInDays = successRetentionPeriodInDaysDecoded
        let failureRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureRetentionPeriodInDays)
        failureRetentionPeriodInDays = failureRetentionPeriodInDaysDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.VpcConfigInput.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let visualReferenceDecoded = try containerValues.decodeIfPresent(SyntheticsClientTypes.VisualReferenceInput.self, forKey: .visualReference)
        visualReference = visualReferenceDecoded
    }
}

extension UpdateCanaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCanaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCanaryOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCanaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCanaryOutputResponse()"}
}

extension UpdateCanaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCanaryOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateCanaryOutputResponseBody: Swift.Equatable {
}

extension UpdateCanaryOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parameter could not be validated.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SyntheticsClientTypes.VisualReferenceInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCanaryRunId = "BaseCanaryRunId"
        case baseScreenshots = "BaseScreenshots"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseCanaryRunId = baseCanaryRunId {
            try encodeContainer.encode(baseCanaryRunId, forKey: .baseCanaryRunId)
        }
        if let baseScreenshots = baseScreenshots {
            var baseScreenshotsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .baseScreenshots)
            for basescreenshots0 in baseScreenshots {
                try baseScreenshotsContainer.encode(basescreenshots0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseScreenshotsContainer = try containerValues.decodeIfPresent([SyntheticsClientTypes.BaseScreenshot?].self, forKey: .baseScreenshots)
        var baseScreenshotsDecoded0:[SyntheticsClientTypes.BaseScreenshot]? = nil
        if let baseScreenshotsContainer = baseScreenshotsContainer {
            baseScreenshotsDecoded0 = [SyntheticsClientTypes.BaseScreenshot]()
            for structure0 in baseScreenshotsContainer {
                if let structure0 = structure0 {
                    baseScreenshotsDecoded0?.append(structure0)
                }
            }
        }
        baseScreenshots = baseScreenshotsDecoded0
        let baseCanaryRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCanaryRunId)
        baseCanaryRunId = baseCanaryRunIdDecoded
    }
}

extension SyntheticsClientTypes.VisualReferenceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VisualReferenceInput(baseCanaryRunId: \(Swift.String(describing: baseCanaryRunId)), baseScreenshots: \(Swift.String(describing: baseScreenshots)))"}
}

extension SyntheticsClientTypes {
    /// An object that specifies what screenshots to use as a baseline for visual monitoring by this canary, and optionally the parts of the screenshots to ignore during the visual monitoring comparison.
    ///
    ///          Visual monitoring is supported only on canaries running the syn-puppeteer-node-3.2
    ///          runtime or later. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Library_SyntheticsLogger_VisualTesting.html">
    ///             Visual monitoring and <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Blueprints_VisualTesting.html">
    ///                Visual monitoring blueprint
    ///
    public struct VisualReferenceInput: Swift.Equatable {
        /// Specifies which canary run to use the screenshots from as the baseline for future visual monitoring with this canary. Valid values are
        ///          nextrun to use the screenshots from the next run after this update is made, lastrun to use the screenshots from the most recent run
        ///          before this update was made, or the value of Id in the <a href="https://docs.aws.amazon.com/AmazonSynthetics/latest/APIReference/API_CanaryRun.html">
        ///             CanaryRun from any past run of this canary.
        /// This member is required.
        public let baseCanaryRunId: Swift.String?
        /// An array of screenshots that will be used as the baseline for visual monitoring in future runs of this canary. If there is a screenshot that you don't want to be used for
        ///       visual monitoring, remove it from this array.
        public let baseScreenshots: [SyntheticsClientTypes.BaseScreenshot]?

        public init (
            baseCanaryRunId: Swift.String? = nil,
            baseScreenshots: [SyntheticsClientTypes.BaseScreenshot]? = nil
        )
        {
            self.baseCanaryRunId = baseCanaryRunId
            self.baseScreenshots = baseScreenshots
        }
    }

}

extension SyntheticsClientTypes.VisualReferenceOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCanaryRunId = "BaseCanaryRunId"
        case baseScreenshots = "BaseScreenshots"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseCanaryRunId = baseCanaryRunId {
            try encodeContainer.encode(baseCanaryRunId, forKey: .baseCanaryRunId)
        }
        if let baseScreenshots = baseScreenshots {
            var baseScreenshotsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .baseScreenshots)
            for basescreenshots0 in baseScreenshots {
                try baseScreenshotsContainer.encode(basescreenshots0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseScreenshotsContainer = try containerValues.decodeIfPresent([SyntheticsClientTypes.BaseScreenshot?].self, forKey: .baseScreenshots)
        var baseScreenshotsDecoded0:[SyntheticsClientTypes.BaseScreenshot]? = nil
        if let baseScreenshotsContainer = baseScreenshotsContainer {
            baseScreenshotsDecoded0 = [SyntheticsClientTypes.BaseScreenshot]()
            for structure0 in baseScreenshotsContainer {
                if let structure0 = structure0 {
                    baseScreenshotsDecoded0?.append(structure0)
                }
            }
        }
        baseScreenshots = baseScreenshotsDecoded0
        let baseCanaryRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCanaryRunId)
        baseCanaryRunId = baseCanaryRunIdDecoded
    }
}

extension SyntheticsClientTypes.VisualReferenceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VisualReferenceOutput(baseCanaryRunId: \(Swift.String(describing: baseCanaryRunId)), baseScreenshots: \(Swift.String(describing: baseScreenshots)))"}
}

extension SyntheticsClientTypes {
    /// If this canary performs visual monitoring by comparing screenshots, this structure contains the ID of the canary run that is used as the baseline for screenshots, and the coordinates
    ///          of any parts of those screenshots that are ignored during visual monitoring comparison.
    ///          Visual monitoring is supported only on canaries running the syn-puppeteer-node-3.2 runtime or later.
    public struct VisualReferenceOutput: Swift.Equatable {
        /// The ID of the canary run that produced the screenshots that are used as the baseline for visual monitoring comparisons during future runs of this canary.
        public let baseCanaryRunId: Swift.String?
        /// An array of screenshots that are used as the baseline for comparisons during visual monitoring.
        public let baseScreenshots: [SyntheticsClientTypes.BaseScreenshot]?

        public init (
            baseCanaryRunId: Swift.String? = nil,
            baseScreenshots: [SyntheticsClientTypes.BaseScreenshot]? = nil
        )
        {
            self.baseCanaryRunId = baseCanaryRunId
            self.baseScreenshots = baseScreenshots
        }
    }

}

extension SyntheticsClientTypes.VpcConfigInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension SyntheticsClientTypes.VpcConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcConfigInput(securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension SyntheticsClientTypes {
    /// If this canary is to test an endpoint in a VPC, this structure contains
    ///          information about the subnets and security groups of the VPC endpoint.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_VPC.html">
    ///             Running a Canary in a VPC.
    public struct VpcConfigInput: Swift.Equatable {
        /// The IDs of the security groups for this canary.
        public let securityGroupIds: [Swift.String]?
        /// The IDs of the subnets where this canary is to run.
        public let subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension SyntheticsClientTypes.VpcConfigOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension SyntheticsClientTypes.VpcConfigOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcConfigOutput(securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension SyntheticsClientTypes {
    /// If this canary is to test an endpoint in a VPC, this structure contains
    ///          information about the subnets and security groups of the VPC endpoint.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_VPC.html">
    ///             Running a Canary in a VPC.
    public struct VpcConfigOutput: Swift.Equatable {
        /// The IDs of the security groups for this canary.
        public let securityGroupIds: [Swift.String]?
        /// The IDs of the subnets where this canary is to run.
        public let subnetIds: [Swift.String]?
        /// The IDs of the VPC where this canary is to run.
        public let vpcId: Swift.String?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}
