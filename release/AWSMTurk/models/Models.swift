// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptQualificationRequestInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptQualificationRequestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptQualificationRequestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptQualificationRequestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptQualificationRequestOutputError>
}

extension AcceptQualificationRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptQualificationRequestInput(integerValue: \(Swift.String(describing: integerValue)), qualificationRequestId: \(Swift.String(describing: qualificationRequestId)))"}
}

extension AcceptQualificationRequestInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integerValue = "IntegerValue"
        case qualificationRequestId = "QualificationRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let qualificationRequestId = qualificationRequestId {
            try encodeContainer.encode(qualificationRequestId, forKey: .qualificationRequestId)
        }
    }
}

public struct AcceptQualificationRequestInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptQualificationRequestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptQualificationRequestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptQualificationRequestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptQualificationRequestOutputError>
}

public struct AcceptQualificationRequestInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptQualificationRequestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptQualificationRequestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptQualificationRequestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptQualificationRequestOutputError>
}

public struct AcceptQualificationRequestInput: Swift.Equatable {
    ///
    ///             The value of the Qualification. You can omit this value if you are using the
    ///             presence or absence of the Qualification as the basis for a HIT requirement.
    ///
    public let integerValue: Swift.Int?
    /// The ID of the Qualification request, as returned by the GetQualificationRequests operation.
    /// This member is required.
    public let qualificationRequestId: Swift.String?

    public init (
        integerValue: Swift.Int? = nil,
        qualificationRequestId: Swift.String? = nil
    )
    {
        self.integerValue = integerValue
        self.qualificationRequestId = qualificationRequestId
    }
}

struct AcceptQualificationRequestInputBody: Swift.Equatable {
    public let qualificationRequestId: Swift.String?
    public let integerValue: Swift.Int?
}

extension AcceptQualificationRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integerValue = "IntegerValue"
        case qualificationRequestId = "QualificationRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationRequestId)
        qualificationRequestId = qualificationRequestIdDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
    }
}

extension AcceptQualificationRequestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptQualificationRequestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptQualificationRequestOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptQualificationRequestOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptQualificationRequestOutputResponse()"}
}

extension AcceptQualificationRequestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AcceptQualificationRequestOutputResponse: Swift.Equatable {

    public init() {}
}

struct AcceptQualificationRequestOutputResponseBody: Swift.Equatable {
}

extension AcceptQualificationRequestOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct ApproveAssignmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApproveAssignmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApproveAssignmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApproveAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApproveAssignmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApproveAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApproveAssignmentOutputError>
}

extension ApproveAssignmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApproveAssignmentInput(assignmentId: \(Swift.String(describing: assignmentId)), overrideRejection: \(Swift.String(describing: overrideRejection)), requesterFeedback: \(Swift.String(describing: requesterFeedback)))"}
}

extension ApproveAssignmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case overrideRejection = "OverrideRejection"
        case requesterFeedback = "RequesterFeedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let overrideRejection = overrideRejection {
            try encodeContainer.encode(overrideRejection, forKey: .overrideRejection)
        }
        if let requesterFeedback = requesterFeedback {
            try encodeContainer.encode(requesterFeedback, forKey: .requesterFeedback)
        }
    }
}

public struct ApproveAssignmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApproveAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApproveAssignmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApproveAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApproveAssignmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApproveAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApproveAssignmentOutputError>
}

public struct ApproveAssignmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApproveAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApproveAssignmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApproveAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApproveAssignmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApproveAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApproveAssignmentOutputError>
}

public struct ApproveAssignmentInput: Swift.Equatable {
    ///
    ///             The ID of the assignment. The assignment must correspond to a HIT created by the Requester.
    ///
    /// This member is required.
    public let assignmentId: Swift.String?
    ///
    ///             A flag indicating that an assignment should be approved even if it was previously rejected. Defaults to False.
    ///
    public let overrideRejection: Swift.Bool?
    ///
    ///             A message for the Worker, which the Worker can see in the Status section of the web site.
    ///
    public let requesterFeedback: Swift.String?

    public init (
        assignmentId: Swift.String? = nil,
        overrideRejection: Swift.Bool? = nil,
        requesterFeedback: Swift.String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.overrideRejection = overrideRejection
        self.requesterFeedback = requesterFeedback
    }
}

struct ApproveAssignmentInputBody: Swift.Equatable {
    public let assignmentId: Swift.String?
    public let requesterFeedback: Swift.String?
    public let overrideRejection: Swift.Bool?
}

extension ApproveAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case overrideRejection = "OverrideRejection"
        case requesterFeedback = "RequesterFeedback"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let requesterFeedbackDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requesterFeedback)
        requesterFeedback = requesterFeedbackDecoded
        let overrideRejectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overrideRejection)
        overrideRejection = overrideRejectionDecoded
    }
}

extension ApproveAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApproveAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApproveAssignmentOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApproveAssignmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApproveAssignmentOutputResponse()"}
}

extension ApproveAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ApproveAssignmentOutputResponse: Swift.Equatable {

    public init() {}
}

struct ApproveAssignmentOutputResponseBody: Swift.Equatable {
}

extension ApproveAssignmentOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MTurkClientTypes.Assignment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptTime = "AcceptTime"
        case answer = "Answer"
        case approvalTime = "ApprovalTime"
        case assignmentId = "AssignmentId"
        case assignmentStatus = "AssignmentStatus"
        case autoApprovalTime = "AutoApprovalTime"
        case deadline = "Deadline"
        case hITId = "HITId"
        case rejectionTime = "RejectionTime"
        case requesterFeedback = "RequesterFeedback"
        case submitTime = "SubmitTime"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptTime = acceptTime {
            try encodeContainer.encode(acceptTime.timeIntervalSince1970, forKey: .acceptTime)
        }
        if let answer = answer {
            try encodeContainer.encode(answer, forKey: .answer)
        }
        if let approvalTime = approvalTime {
            try encodeContainer.encode(approvalTime.timeIntervalSince1970, forKey: .approvalTime)
        }
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let autoApprovalTime = autoApprovalTime {
            try encodeContainer.encode(autoApprovalTime.timeIntervalSince1970, forKey: .autoApprovalTime)
        }
        if let deadline = deadline {
            try encodeContainer.encode(deadline.timeIntervalSince1970, forKey: .deadline)
        }
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let rejectionTime = rejectionTime {
            try encodeContainer.encode(rejectionTime.timeIntervalSince1970, forKey: .rejectionTime)
        }
        if let requesterFeedback = requesterFeedback {
            try encodeContainer.encode(requesterFeedback, forKey: .requesterFeedback)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let autoApprovalTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .autoApprovalTime)
        autoApprovalTime = autoApprovalTimeDecoded
        let acceptTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .acceptTime)
        acceptTime = acceptTimeDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let approvalTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .approvalTime)
        approvalTime = approvalTimeDecoded
        let rejectionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .rejectionTime)
        rejectionTime = rejectionTimeDecoded
        let deadlineDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deadline)
        deadline = deadlineDecoded
        let answerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .answer)
        answer = answerDecoded
        let requesterFeedbackDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requesterFeedback)
        requesterFeedback = requesterFeedbackDecoded
    }
}

extension MTurkClientTypes.Assignment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Assignment(acceptTime: \(Swift.String(describing: acceptTime)), answer: \(Swift.String(describing: answer)), approvalTime: \(Swift.String(describing: approvalTime)), assignmentId: \(Swift.String(describing: assignmentId)), assignmentStatus: \(Swift.String(describing: assignmentStatus)), autoApprovalTime: \(Swift.String(describing: autoApprovalTime)), deadline: \(Swift.String(describing: deadline)), hITId: \(Swift.String(describing: hITId)), rejectionTime: \(Swift.String(describing: rejectionTime)), requesterFeedback: \(Swift.String(describing: requesterFeedback)), submitTime: \(Swift.String(describing: submitTime)), workerId: \(Swift.String(describing: workerId)))"}
}

extension MTurkClientTypes {
    ///  The Assignment data structure represents a single assignment
    ///             of a HIT to a Worker. The assignment tracks the Worker's efforts to
    ///             complete the HIT, and contains the results for later retrieval.
    ///
    public struct Assignment: Swift.Equatable {
        ///  The date and time the Worker accepted the assignment.
        public let acceptTime: ClientRuntime.Date?
        ///  The Worker's answers submitted for the HIT contained in a
        ///             QuestionFormAnswers document, if the Worker provides an answer. If
        ///             the Worker does not provide any answers, Answer may contain a
        ///             QuestionFormAnswers document, or Answer may be empty.
        public let answer: Swift.String?
        ///  If the Worker has submitted results and the Requester has
        ///             approved the results, ApprovalTime is the date and time the Requester
        ///             approved the results. This value is omitted from the assignment if
        ///             the Requester has not yet approved the results.
        public let approvalTime: ClientRuntime.Date?
        ///  A unique identifier for the assignment.
        public let assignmentId: Swift.String?
        ///  The status of the assignment.
        public let assignmentStatus: MTurkClientTypes.AssignmentStatus?
        ///  If results have been submitted, AutoApprovalTime is the date
        ///             and time the results of the assignment results are considered
        ///             Approved automatically if they have not already been explicitly
        ///             approved or rejected by the Requester. This value is derived from the
        ///             auto-approval delay specified by the Requester in the HIT. This value
        ///             is omitted from the assignment if the Worker has not yet submitted
        ///             results.
        public let autoApprovalTime: ClientRuntime.Date?
        ///  The date and time of the deadline for the assignment. This
        ///             value is derived from the deadline specification for the HIT and the
        ///             date and time the Worker accepted the HIT.
        public let deadline: ClientRuntime.Date?
        ///  The ID of the HIT.
        public let hITId: Swift.String?
        ///  If the Worker has submitted results and the Requester has
        ///             rejected the results, RejectionTime is the date and time the
        ///             Requester rejected the results.
        public let rejectionTime: ClientRuntime.Date?
        ///  The feedback string included with the call to the
        ///             ApproveAssignment operation or the RejectAssignment operation, if the
        ///             Requester approved or rejected the assignment and specified feedback.
        public let requesterFeedback: Swift.String?
        ///  If the Worker has submitted results, SubmitTime is the date
        ///             and time the assignment was submitted. This value is omitted from the
        ///             assignment if the Worker has not yet submitted results.
        public let submitTime: ClientRuntime.Date?
        ///  The ID of the Worker who accepted the HIT.
        public let workerId: Swift.String?

        public init (
            acceptTime: ClientRuntime.Date? = nil,
            answer: Swift.String? = nil,
            approvalTime: ClientRuntime.Date? = nil,
            assignmentId: Swift.String? = nil,
            assignmentStatus: MTurkClientTypes.AssignmentStatus? = nil,
            autoApprovalTime: ClientRuntime.Date? = nil,
            deadline: ClientRuntime.Date? = nil,
            hITId: Swift.String? = nil,
            rejectionTime: ClientRuntime.Date? = nil,
            requesterFeedback: Swift.String? = nil,
            submitTime: ClientRuntime.Date? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.acceptTime = acceptTime
            self.answer = answer
            self.approvalTime = approvalTime
            self.assignmentId = assignmentId
            self.assignmentStatus = assignmentStatus
            self.autoApprovalTime = autoApprovalTime
            self.deadline = deadline
            self.hITId = hITId
            self.rejectionTime = rejectionTime
            self.requesterFeedback = requesterFeedback
            self.submitTime = submitTime
            self.workerId = workerId
        }
    }

}

extension MTurkClientTypes {
    public enum AssignmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case rejected
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignmentStatus] {
            return [
                .approved,
                .rejected,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "Approved"
            case .rejected: return "Rejected"
            case .submitted: return "Submitted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssignmentStatus(rawValue: rawValue) ?? AssignmentStatus.sdkUnknown(rawValue)
        }
    }
}

public struct AssociateQualificationWithWorkerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateQualificationWithWorkerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateQualificationWithWorkerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateQualificationWithWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateQualificationWithWorkerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateQualificationWithWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateQualificationWithWorkerOutputError>
}

extension AssociateQualificationWithWorkerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateQualificationWithWorkerInput(integerValue: \(Swift.String(describing: integerValue)), qualificationTypeId: \(Swift.String(describing: qualificationTypeId)), sendNotification: \(Swift.String(describing: sendNotification)), workerId: \(Swift.String(describing: workerId)))"}
}

extension AssociateQualificationWithWorkerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integerValue = "IntegerValue"
        case qualificationTypeId = "QualificationTypeId"
        case sendNotification = "SendNotification"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let sendNotification = sendNotification {
            try encodeContainer.encode(sendNotification, forKey: .sendNotification)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct AssociateQualificationWithWorkerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateQualificationWithWorkerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateQualificationWithWorkerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateQualificationWithWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateQualificationWithWorkerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateQualificationWithWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateQualificationWithWorkerOutputError>
}

public struct AssociateQualificationWithWorkerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateQualificationWithWorkerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateQualificationWithWorkerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateQualificationWithWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateQualificationWithWorkerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateQualificationWithWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateQualificationWithWorkerOutputError>
}

public struct AssociateQualificationWithWorkerInput: Swift.Equatable {
    /// The value of the Qualification to assign.
    public let integerValue: Swift.Int?
    /// The ID of the Qualification type to use for the assigned Qualification.
    /// This member is required.
    public let qualificationTypeId: Swift.String?
    ///
    ///             Specifies whether to send a notification email message to the Worker
    ///             saying that the qualification was assigned to the Worker.
    ///             Note: this is true by default.
    ///
    public let sendNotification: Swift.Bool?
    ///
    ///             The ID of the Worker to whom the Qualification is being assigned.
    ///             Worker IDs are included with submitted HIT assignments and Qualification requests.
    ///
    /// This member is required.
    public let workerId: Swift.String?

    public init (
        integerValue: Swift.Int? = nil,
        qualificationTypeId: Swift.String? = nil,
        sendNotification: Swift.Bool? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.integerValue = integerValue
        self.qualificationTypeId = qualificationTypeId
        self.sendNotification = sendNotification
        self.workerId = workerId
    }
}

struct AssociateQualificationWithWorkerInputBody: Swift.Equatable {
    public let qualificationTypeId: Swift.String?
    public let workerId: Swift.String?
    public let integerValue: Swift.Int?
    public let sendNotification: Swift.Bool?
}

extension AssociateQualificationWithWorkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integerValue = "IntegerValue"
        case qualificationTypeId = "QualificationTypeId"
        case sendNotification = "SendNotification"
        case workerId = "WorkerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let sendNotificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sendNotification)
        sendNotification = sendNotificationDecoded
    }
}

extension AssociateQualificationWithWorkerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateQualificationWithWorkerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateQualificationWithWorkerOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateQualificationWithWorkerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateQualificationWithWorkerOutputResponse()"}
}

extension AssociateQualificationWithWorkerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateQualificationWithWorkerOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateQualificationWithWorkerOutputResponseBody: Swift.Equatable {
}

extension AssociateQualificationWithWorkerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MTurkClientTypes.BonusPayment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case bonusAmount = "BonusAmount"
        case grantTime = "GrantTime"
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let bonusAmount = bonusAmount {
            try encodeContainer.encode(bonusAmount, forKey: .bonusAmount)
        }
        if let grantTime = grantTime {
            try encodeContainer.encode(grantTime.timeIntervalSince1970, forKey: .grantTime)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let bonusAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bonusAmount)
        bonusAmount = bonusAmountDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let grantTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .grantTime)
        grantTime = grantTimeDecoded
    }
}

extension MTurkClientTypes.BonusPayment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BonusPayment(assignmentId: \(Swift.String(describing: assignmentId)), bonusAmount: \(Swift.String(describing: bonusAmount)), grantTime: \(Swift.String(describing: grantTime)), reason: \(Swift.String(describing: reason)), workerId: \(Swift.String(describing: workerId)))"}
}

extension MTurkClientTypes {
    /// An object representing a Bonus payment paid to a Worker.
    public struct BonusPayment: Swift.Equatable {
        /// The ID of the assignment associated with this bonus payment.
        public let assignmentId: Swift.String?
        /// A string representing a currency amount.
        public let bonusAmount: Swift.String?
        /// The date and time of when the bonus was granted.
        public let grantTime: ClientRuntime.Date?
        /// The Reason text given when the bonus was granted, if any.
        public let reason: Swift.String?
        /// The ID of the Worker to whom the bonus was paid.
        public let workerId: Swift.String?

        public init (
            assignmentId: Swift.String? = nil,
            bonusAmount: Swift.String? = nil,
            grantTime: ClientRuntime.Date? = nil,
            reason: Swift.String? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.assignmentId = assignmentId
            self.bonusAmount = bonusAmount
            self.grantTime = grantTime
            self.reason = reason
            self.workerId = workerId
        }
    }

}

extension MTurkClientTypes {
    public enum Comparator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doesnotexist
        case equalto
        case exists
        case greaterthan
        case greaterthanorequalto
        case `in`
        case lessthan
        case lessthanorequalto
        case notequalto
        case notin
        case sdkUnknown(Swift.String)

        public static var allCases: [Comparator] {
            return [
                .doesnotexist,
                .equalto,
                .exists,
                .greaterthan,
                .greaterthanorequalto,
                .in,
                .lessthan,
                .lessthanorequalto,
                .notequalto,
                .notin,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doesnotexist: return "DoesNotExist"
            case .equalto: return "EqualTo"
            case .exists: return "Exists"
            case .greaterthan: return "GreaterThan"
            case .greaterthanorequalto: return "GreaterThanOrEqualTo"
            case .in: return "In"
            case .lessthan: return "LessThan"
            case .lessthanorequalto: return "LessThanOrEqualTo"
            case .notequalto: return "NotEqualTo"
            case .notin: return "NotIn"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Comparator(rawValue: rawValue) ?? Comparator.sdkUnknown(rawValue)
        }
    }
}

public struct CreateAdditionalAssignmentsForHITInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAdditionalAssignmentsForHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAdditionalAssignmentsForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAdditionalAssignmentsForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAdditionalAssignmentsForHITOutputError>
}

extension CreateAdditionalAssignmentsForHITInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAdditionalAssignmentsForHITInput(hITId: \(Swift.String(describing: hITId)), numberOfAdditionalAssignments: \(Swift.String(describing: numberOfAdditionalAssignments)), uniqueRequestToken: \(Swift.String(describing: uniqueRequestToken)))"}
}

extension CreateAdditionalAssignmentsForHITInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
        case numberOfAdditionalAssignments = "NumberOfAdditionalAssignments"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let numberOfAdditionalAssignments = numberOfAdditionalAssignments {
            try encodeContainer.encode(numberOfAdditionalAssignments, forKey: .numberOfAdditionalAssignments)
        }
        if let uniqueRequestToken = uniqueRequestToken {
            try encodeContainer.encode(uniqueRequestToken, forKey: .uniqueRequestToken)
        }
    }
}

public struct CreateAdditionalAssignmentsForHITInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAdditionalAssignmentsForHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAdditionalAssignmentsForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAdditionalAssignmentsForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAdditionalAssignmentsForHITOutputError>
}

public struct CreateAdditionalAssignmentsForHITInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAdditionalAssignmentsForHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAdditionalAssignmentsForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAdditionalAssignmentsForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAdditionalAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAdditionalAssignmentsForHITOutputError>
}

public struct CreateAdditionalAssignmentsForHITInput: Swift.Equatable {
    /// The ID of the HIT to extend.
    /// This member is required.
    public let hITId: Swift.String?
    /// The number of additional assignments to request for this HIT.
    /// This member is required.
    public let numberOfAdditionalAssignments: Swift.Int?
    ///
    ///             A unique identifier for this request, which allows you to retry the call on error
    ///             without extending the HIT multiple times.
    ///             This is useful in cases such as network timeouts where it is unclear whether or not
    ///             the call succeeded on the server. If the extend HIT already exists in the system
    ///             from a previous call using the same UniqueRequestToken,
    ///             subsequent calls will return an error with a message containing the request ID.
    ///
    public let uniqueRequestToken: Swift.String?

    public init (
        hITId: Swift.String? = nil,
        numberOfAdditionalAssignments: Swift.Int? = nil,
        uniqueRequestToken: Swift.String? = nil
    )
    {
        self.hITId = hITId
        self.numberOfAdditionalAssignments = numberOfAdditionalAssignments
        self.uniqueRequestToken = uniqueRequestToken
    }
}

struct CreateAdditionalAssignmentsForHITInputBody: Swift.Equatable {
    public let hITId: Swift.String?
    public let numberOfAdditionalAssignments: Swift.Int?
    public let uniqueRequestToken: Swift.String?
}

extension CreateAdditionalAssignmentsForHITInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
        case numberOfAdditionalAssignments = "NumberOfAdditionalAssignments"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let numberOfAdditionalAssignmentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAdditionalAssignments)
        numberOfAdditionalAssignments = numberOfAdditionalAssignmentsDecoded
        let uniqueRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uniqueRequestToken)
        uniqueRequestToken = uniqueRequestTokenDecoded
    }
}

extension CreateAdditionalAssignmentsForHITOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAdditionalAssignmentsForHITOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAdditionalAssignmentsForHITOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAdditionalAssignmentsForHITOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAdditionalAssignmentsForHITOutputResponse()"}
}

extension CreateAdditionalAssignmentsForHITOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateAdditionalAssignmentsForHITOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateAdditionalAssignmentsForHITOutputResponseBody: Swift.Equatable {
}

extension CreateAdditionalAssignmentsForHITOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateHITInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHITOutputError>
}

extension CreateHITInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHITInput(assignmentDurationInSeconds: \(Swift.String(describing: assignmentDurationInSeconds)), assignmentReviewPolicy: \(Swift.String(describing: assignmentReviewPolicy)), autoApprovalDelayInSeconds: \(Swift.String(describing: autoApprovalDelayInSeconds)), description: \(Swift.String(describing: description)), hITLayoutId: \(Swift.String(describing: hITLayoutId)), hITLayoutParameters: \(Swift.String(describing: hITLayoutParameters)), hITReviewPolicy: \(Swift.String(describing: hITReviewPolicy)), keywords: \(Swift.String(describing: keywords)), lifetimeInSeconds: \(Swift.String(describing: lifetimeInSeconds)), maxAssignments: \(Swift.String(describing: maxAssignments)), qualificationRequirements: \(Swift.String(describing: qualificationRequirements)), question: \(Swift.String(describing: question)), requesterAnnotation: \(Swift.String(describing: requesterAnnotation)), reward: \(Swift.String(describing: reward)), title: \(Swift.String(describing: title)), uniqueRequestToken: \(Swift.String(describing: uniqueRequestToken)))"}
}

extension CreateHITInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentDurationInSeconds = "AssignmentDurationInSeconds"
        case assignmentReviewPolicy = "AssignmentReviewPolicy"
        case autoApprovalDelayInSeconds = "AutoApprovalDelayInSeconds"
        case description = "Description"
        case hITLayoutId = "HITLayoutId"
        case hITLayoutParameters = "HITLayoutParameters"
        case hITReviewPolicy = "HITReviewPolicy"
        case keywords = "Keywords"
        case lifetimeInSeconds = "LifetimeInSeconds"
        case maxAssignments = "MaxAssignments"
        case qualificationRequirements = "QualificationRequirements"
        case question = "Question"
        case requesterAnnotation = "RequesterAnnotation"
        case reward = "Reward"
        case title = "Title"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentDurationInSeconds = assignmentDurationInSeconds {
            try encodeContainer.encode(assignmentDurationInSeconds, forKey: .assignmentDurationInSeconds)
        }
        if let assignmentReviewPolicy = assignmentReviewPolicy {
            try encodeContainer.encode(assignmentReviewPolicy, forKey: .assignmentReviewPolicy)
        }
        if let autoApprovalDelayInSeconds = autoApprovalDelayInSeconds {
            try encodeContainer.encode(autoApprovalDelayInSeconds, forKey: .autoApprovalDelayInSeconds)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hITLayoutId = hITLayoutId {
            try encodeContainer.encode(hITLayoutId, forKey: .hITLayoutId)
        }
        if let hITLayoutParameters = hITLayoutParameters {
            var hITLayoutParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hITLayoutParameters)
            for hitlayoutparameterlist0 in hITLayoutParameters {
                try hITLayoutParametersContainer.encode(hitlayoutparameterlist0)
            }
        }
        if let hITReviewPolicy = hITReviewPolicy {
            try encodeContainer.encode(hITReviewPolicy, forKey: .hITReviewPolicy)
        }
        if let keywords = keywords {
            try encodeContainer.encode(keywords, forKey: .keywords)
        }
        if let lifetimeInSeconds = lifetimeInSeconds {
            try encodeContainer.encode(lifetimeInSeconds, forKey: .lifetimeInSeconds)
        }
        if let maxAssignments = maxAssignments {
            try encodeContainer.encode(maxAssignments, forKey: .maxAssignments)
        }
        if let qualificationRequirements = qualificationRequirements {
            var qualificationRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .qualificationRequirements)
            for qualificationrequirementlist0 in qualificationRequirements {
                try qualificationRequirementsContainer.encode(qualificationrequirementlist0)
            }
        }
        if let question = question {
            try encodeContainer.encode(question, forKey: .question)
        }
        if let requesterAnnotation = requesterAnnotation {
            try encodeContainer.encode(requesterAnnotation, forKey: .requesterAnnotation)
        }
        if let reward = reward {
            try encodeContainer.encode(reward, forKey: .reward)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let uniqueRequestToken = uniqueRequestToken {
            try encodeContainer.encode(uniqueRequestToken, forKey: .uniqueRequestToken)
        }
    }
}

public struct CreateHITInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHITOutputError>
}

public struct CreateHITInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHITOutputError>
}

public struct CreateHITInput: Swift.Equatable {
    ///
    ///             The amount of time, in seconds, that a Worker has to complete the HIT after accepting it.
    ///             If a Worker does not complete the assignment within the specified duration,
    ///             the assignment is considered abandoned. If the HIT is still active
    ///             (that is, its lifetime has not elapsed), the assignment becomes available
    ///             for other users to find and accept.
    ///
    /// This member is required.
    public let assignmentDurationInSeconds: Swift.Int?
    ///
    ///             The Assignment-level Review Policy applies to the assignments under the HIT.
    ///             You can specify for Mechanical Turk to take various actions based on the policy.
    ///
    public let assignmentReviewPolicy: MTurkClientTypes.ReviewPolicy?
    ///
    ///             The number of seconds after an assignment for the HIT has been submitted,
    ///             after which the assignment is considered Approved automatically
    ///             unless the Requester explicitly rejects it.
    ///
    public let autoApprovalDelayInSeconds: Swift.Int?
    ///
    ///             A general description of the HIT. A description includes detailed information about the kind of task
    ///             the HIT contains. On the Amazon Mechanical Turk web site, the HIT description appears in the expanded
    ///             view of search results, and in the HIT and assignment screens. A good description gives the user enough
    ///             information to evaluate the HIT before accepting it.
    ///
    /// This member is required.
    public let description: Swift.String?
    ///
    ///             The HITLayoutId allows you to use a pre-existing HIT design with placeholder values
    ///             and create an additional HIT by providing those values as HITLayoutParameters.
    ///
    ///
    ///             Constraints: Either a Question parameter or a HITLayoutId parameter must be provided.
    ///
    public let hITLayoutId: Swift.String?
    ///
    ///             If the HITLayoutId is provided, any placeholder values must be filled in with values
    ///             using the HITLayoutParameter structure. For more information, see HITLayout.
    ///
    public let hITLayoutParameters: [MTurkClientTypes.HITLayoutParameter]?
    ///
    ///             The HIT-level Review Policy applies to the HIT.
    ///             You can specify for Mechanical Turk to take various actions based on the policy.
    ///
    public let hITReviewPolicy: MTurkClientTypes.ReviewPolicy?
    ///
    ///             One or more words or phrases that describe the HIT, separated by commas.
    ///             These words are used in searches to find HITs.
    ///
    public let keywords: Swift.String?
    ///
    ///             An amount of time, in seconds, after which the HIT is no longer available for users to accept.
    ///             After the lifetime of the HIT elapses, the HIT no longer appears in HIT searches,
    ///             even if not all of the assignments for the HIT have been accepted.
    ///
    /// This member is required.
    public let lifetimeInSeconds: Swift.Int?
    ///
    ///             The number of times the HIT can be accepted and completed before the HIT becomes unavailable.
    ///
    public let maxAssignments: Swift.Int?
    ///
    ///             Conditions that a Worker's Qualifications must meet in order
    ///             to accept the HIT. A HIT can have between zero and ten
    ///             Qualification requirements. All requirements must be met in
    ///             order for a Worker to accept the HIT. Additionally, other
    ///             actions can be restricted using the ActionsGuarded
    ///             field on each QualificationRequirement structure.
    ///
    public let qualificationRequirements: [MTurkClientTypes.QualificationRequirement]?
    ///
    ///             The data the person completing the HIT uses to produce the results.
    ///
    ///
    ///             Constraints: Must be a QuestionForm data structure, an ExternalQuestion data structure,
    ///             or an HTMLQuestion data structure. The XML question data must not be larger than
    ///             64 kilobytes (65,535 bytes) in size, including whitespace.
    ///
    ///         Either a Question parameter or a HITLayoutId parameter must be provided.
    public let question: Swift.String?
    ///
    ///             An arbitrary data field.
    ///             The RequesterAnnotation parameter lets your application attach arbitrary data
    ///             to the HIT for tracking purposes.
    ///             For example, this parameter could be an identifier internal to the Requester's application
    ///             that corresponds with the HIT.
    ///
    ///
    ///             The RequesterAnnotation parameter for a HIT is only visible to the Requester who created the HIT.
    ///             It is not shown to the Worker, or any other Requester.
    ///
    ///
    ///             The RequesterAnnotation parameter may be different for each HIT you submit.
    ///             It does not affect how your HITs are grouped.
    ///
    public let requesterAnnotation: Swift.String?
    ///
    ///             The amount of money the Requester will pay a Worker for successfully completing the HIT.
    ///
    /// This member is required.
    public let reward: Swift.String?
    ///
    ///             The title of the HIT. A title should be short and descriptive about the kind of task the HIT contains.
    ///             On the Amazon Mechanical Turk web site, the HIT title appears in search results,
    ///             and everywhere the HIT is mentioned.
    ///
    /// This member is required.
    public let title: Swift.String?
    ///
    ///             A unique identifier for this request which allows you to retry the call
    ///             on error without creating duplicate HITs.
    ///             This is useful in cases such as network timeouts where it is unclear whether or not
    ///             the call succeeded on the server.
    ///             If the HIT already exists in the system from a previous call using the same UniqueRequestToken,
    ///             subsequent calls will return a AWS.MechanicalTurk.HitAlreadyExists error
    ///             with a message containing the HITId.
    ///
    ///
    ///
    ///                 Note: It is your responsibility to ensure uniqueness of the token.
    ///                 The unique token expires after 24 hours. Subsequent calls using the same
    ///                 UniqueRequestToken made after the 24 hour limit could create duplicate HITs.
    ///
    ///
    public let uniqueRequestToken: Swift.String?

    public init (
        assignmentDurationInSeconds: Swift.Int? = nil,
        assignmentReviewPolicy: MTurkClientTypes.ReviewPolicy? = nil,
        autoApprovalDelayInSeconds: Swift.Int? = nil,
        description: Swift.String? = nil,
        hITLayoutId: Swift.String? = nil,
        hITLayoutParameters: [MTurkClientTypes.HITLayoutParameter]? = nil,
        hITReviewPolicy: MTurkClientTypes.ReviewPolicy? = nil,
        keywords: Swift.String? = nil,
        lifetimeInSeconds: Swift.Int? = nil,
        maxAssignments: Swift.Int? = nil,
        qualificationRequirements: [MTurkClientTypes.QualificationRequirement]? = nil,
        question: Swift.String? = nil,
        requesterAnnotation: Swift.String? = nil,
        reward: Swift.String? = nil,
        title: Swift.String? = nil,
        uniqueRequestToken: Swift.String? = nil
    )
    {
        self.assignmentDurationInSeconds = assignmentDurationInSeconds
        self.assignmentReviewPolicy = assignmentReviewPolicy
        self.autoApprovalDelayInSeconds = autoApprovalDelayInSeconds
        self.description = description
        self.hITLayoutId = hITLayoutId
        self.hITLayoutParameters = hITLayoutParameters
        self.hITReviewPolicy = hITReviewPolicy
        self.keywords = keywords
        self.lifetimeInSeconds = lifetimeInSeconds
        self.maxAssignments = maxAssignments
        self.qualificationRequirements = qualificationRequirements
        self.question = question
        self.requesterAnnotation = requesterAnnotation
        self.reward = reward
        self.title = title
        self.uniqueRequestToken = uniqueRequestToken
    }
}

struct CreateHITInputBody: Swift.Equatable {
    public let maxAssignments: Swift.Int?
    public let autoApprovalDelayInSeconds: Swift.Int?
    public let lifetimeInSeconds: Swift.Int?
    public let assignmentDurationInSeconds: Swift.Int?
    public let reward: Swift.String?
    public let title: Swift.String?
    public let keywords: Swift.String?
    public let description: Swift.String?
    public let question: Swift.String?
    public let requesterAnnotation: Swift.String?
    public let qualificationRequirements: [MTurkClientTypes.QualificationRequirement]?
    public let uniqueRequestToken: Swift.String?
    public let assignmentReviewPolicy: MTurkClientTypes.ReviewPolicy?
    public let hITReviewPolicy: MTurkClientTypes.ReviewPolicy?
    public let hITLayoutId: Swift.String?
    public let hITLayoutParameters: [MTurkClientTypes.HITLayoutParameter]?
}

extension CreateHITInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentDurationInSeconds = "AssignmentDurationInSeconds"
        case assignmentReviewPolicy = "AssignmentReviewPolicy"
        case autoApprovalDelayInSeconds = "AutoApprovalDelayInSeconds"
        case description = "Description"
        case hITLayoutId = "HITLayoutId"
        case hITLayoutParameters = "HITLayoutParameters"
        case hITReviewPolicy = "HITReviewPolicy"
        case keywords = "Keywords"
        case lifetimeInSeconds = "LifetimeInSeconds"
        case maxAssignments = "MaxAssignments"
        case qualificationRequirements = "QualificationRequirements"
        case question = "Question"
        case requesterAnnotation = "RequesterAnnotation"
        case reward = "Reward"
        case title = "Title"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxAssignmentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAssignments)
        maxAssignments = maxAssignmentsDecoded
        let autoApprovalDelayInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .autoApprovalDelayInSeconds)
        autoApprovalDelayInSeconds = autoApprovalDelayInSecondsDecoded
        let lifetimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lifetimeInSeconds)
        lifetimeInSeconds = lifetimeInSecondsDecoded
        let assignmentDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assignmentDurationInSeconds)
        assignmentDurationInSeconds = assignmentDurationInSecondsDecoded
        let rewardDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reward)
        reward = rewardDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let keywordsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywords)
        keywords = keywordsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let questionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .question)
        question = questionDecoded
        let requesterAnnotationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requesterAnnotation)
        requesterAnnotation = requesterAnnotationDecoded
        let qualificationRequirementsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.QualificationRequirement?].self, forKey: .qualificationRequirements)
        var qualificationRequirementsDecoded0:[MTurkClientTypes.QualificationRequirement]? = nil
        if let qualificationRequirementsContainer = qualificationRequirementsContainer {
            qualificationRequirementsDecoded0 = [MTurkClientTypes.QualificationRequirement]()
            for structure0 in qualificationRequirementsContainer {
                if let structure0 = structure0 {
                    qualificationRequirementsDecoded0?.append(structure0)
                }
            }
        }
        qualificationRequirements = qualificationRequirementsDecoded0
        let uniqueRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uniqueRequestToken)
        uniqueRequestToken = uniqueRequestTokenDecoded
        let assignmentReviewPolicyDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.ReviewPolicy.self, forKey: .assignmentReviewPolicy)
        assignmentReviewPolicy = assignmentReviewPolicyDecoded
        let hITReviewPolicyDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.ReviewPolicy.self, forKey: .hITReviewPolicy)
        hITReviewPolicy = hITReviewPolicyDecoded
        let hITLayoutIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITLayoutId)
        hITLayoutId = hITLayoutIdDecoded
        let hITLayoutParametersContainer = try containerValues.decodeIfPresent([MTurkClientTypes.HITLayoutParameter?].self, forKey: .hITLayoutParameters)
        var hITLayoutParametersDecoded0:[MTurkClientTypes.HITLayoutParameter]? = nil
        if let hITLayoutParametersContainer = hITLayoutParametersContainer {
            hITLayoutParametersDecoded0 = [MTurkClientTypes.HITLayoutParameter]()
            for structure0 in hITLayoutParametersContainer {
                if let structure0 = structure0 {
                    hITLayoutParametersDecoded0?.append(structure0)
                }
            }
        }
        hITLayoutParameters = hITLayoutParametersDecoded0
    }
}

extension CreateHITOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHITOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHITOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHITOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHITOutputResponse(hIT: \(Swift.String(describing: hIT)))"}
}

extension CreateHITOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHITOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hIT = output.hIT
        } else {
            self.hIT = nil
        }
    }
}

public struct CreateHITOutputResponse: Swift.Equatable {
    ///  Contains the newly created HIT data. For a description of
    ///             the HIT data structure as it appears in responses, see the HIT Data
    ///             Structure documentation.
    ///
    public let hIT: MTurkClientTypes.HIT?

    public init (
        hIT: MTurkClientTypes.HIT? = nil
    )
    {
        self.hIT = hIT
    }
}

struct CreateHITOutputResponseBody: Swift.Equatable {
    public let hIT: MTurkClientTypes.HIT?
}

extension CreateHITOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hIT = "HIT"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.HIT.self, forKey: .hIT)
        hIT = hITDecoded
    }
}

public struct CreateHITTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHITTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHITTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHITTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHITTypeOutputError>
}

extension CreateHITTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHITTypeInput(assignmentDurationInSeconds: \(Swift.String(describing: assignmentDurationInSeconds)), autoApprovalDelayInSeconds: \(Swift.String(describing: autoApprovalDelayInSeconds)), description: \(Swift.String(describing: description)), keywords: \(Swift.String(describing: keywords)), qualificationRequirements: \(Swift.String(describing: qualificationRequirements)), reward: \(Swift.String(describing: reward)), title: \(Swift.String(describing: title)))"}
}

extension CreateHITTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentDurationInSeconds = "AssignmentDurationInSeconds"
        case autoApprovalDelayInSeconds = "AutoApprovalDelayInSeconds"
        case description = "Description"
        case keywords = "Keywords"
        case qualificationRequirements = "QualificationRequirements"
        case reward = "Reward"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentDurationInSeconds = assignmentDurationInSeconds {
            try encodeContainer.encode(assignmentDurationInSeconds, forKey: .assignmentDurationInSeconds)
        }
        if let autoApprovalDelayInSeconds = autoApprovalDelayInSeconds {
            try encodeContainer.encode(autoApprovalDelayInSeconds, forKey: .autoApprovalDelayInSeconds)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keywords = keywords {
            try encodeContainer.encode(keywords, forKey: .keywords)
        }
        if let qualificationRequirements = qualificationRequirements {
            var qualificationRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .qualificationRequirements)
            for qualificationrequirementlist0 in qualificationRequirements {
                try qualificationRequirementsContainer.encode(qualificationrequirementlist0)
            }
        }
        if let reward = reward {
            try encodeContainer.encode(reward, forKey: .reward)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

public struct CreateHITTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHITTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHITTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHITTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHITTypeOutputError>
}

public struct CreateHITTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHITTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHITTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHITTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHITTypeOutputError>
}

public struct CreateHITTypeInput: Swift.Equatable {
    ///
    ///             The amount of time, in seconds, that a Worker has to complete the HIT after accepting it.
    ///             If a Worker does not complete the assignment within the specified duration,
    ///             the assignment is considered abandoned. If the HIT is still active
    ///             (that is, its lifetime has not elapsed), the assignment becomes available
    ///             for other users to find and accept.
    ///
    /// This member is required.
    public let assignmentDurationInSeconds: Swift.Int?
    ///
    ///             The number of seconds after an assignment for the HIT has been submitted,
    ///             after which the assignment is considered Approved automatically
    ///             unless the Requester explicitly rejects it.
    ///
    public let autoApprovalDelayInSeconds: Swift.Int?
    ///
    ///             A general description of the HIT. A description includes detailed information about the kind of task
    ///             the HIT contains. On the Amazon Mechanical Turk web site, the HIT description appears in the expanded
    ///             view of search results, and in the HIT and assignment screens. A good description gives the user enough
    ///             information to evaluate the HIT before accepting it.
    ///
    /// This member is required.
    public let description: Swift.String?
    ///
    ///             One or more words or phrases that describe the HIT, separated by commas.
    ///             These words are used in searches to find HITs.
    ///
    public let keywords: Swift.String?
    ///
    ///             Conditions that a Worker's Qualifications must meet in order
    ///             to accept the HIT. A HIT can have between zero and ten
    ///             Qualification requirements. All requirements must be met in
    ///             order for a Worker to accept the HIT. Additionally, other
    ///             actions can be restricted using the ActionsGuarded
    ///             field on each QualificationRequirement structure.
    ///
    public let qualificationRequirements: [MTurkClientTypes.QualificationRequirement]?
    ///
    ///             The amount of money the Requester will pay a Worker for successfully completing the HIT.
    ///
    /// This member is required.
    public let reward: Swift.String?
    ///
    ///             The title of the HIT. A title should be short and descriptive about the kind of task the HIT contains.
    ///             On the Amazon Mechanical Turk web site, the HIT title appears in search results,
    ///             and everywhere the HIT is mentioned.
    ///
    /// This member is required.
    public let title: Swift.String?

    public init (
        assignmentDurationInSeconds: Swift.Int? = nil,
        autoApprovalDelayInSeconds: Swift.Int? = nil,
        description: Swift.String? = nil,
        keywords: Swift.String? = nil,
        qualificationRequirements: [MTurkClientTypes.QualificationRequirement]? = nil,
        reward: Swift.String? = nil,
        title: Swift.String? = nil
    )
    {
        self.assignmentDurationInSeconds = assignmentDurationInSeconds
        self.autoApprovalDelayInSeconds = autoApprovalDelayInSeconds
        self.description = description
        self.keywords = keywords
        self.qualificationRequirements = qualificationRequirements
        self.reward = reward
        self.title = title
    }
}

struct CreateHITTypeInputBody: Swift.Equatable {
    public let autoApprovalDelayInSeconds: Swift.Int?
    public let assignmentDurationInSeconds: Swift.Int?
    public let reward: Swift.String?
    public let title: Swift.String?
    public let keywords: Swift.String?
    public let description: Swift.String?
    public let qualificationRequirements: [MTurkClientTypes.QualificationRequirement]?
}

extension CreateHITTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentDurationInSeconds = "AssignmentDurationInSeconds"
        case autoApprovalDelayInSeconds = "AutoApprovalDelayInSeconds"
        case description = "Description"
        case keywords = "Keywords"
        case qualificationRequirements = "QualificationRequirements"
        case reward = "Reward"
        case title = "Title"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoApprovalDelayInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .autoApprovalDelayInSeconds)
        autoApprovalDelayInSeconds = autoApprovalDelayInSecondsDecoded
        let assignmentDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assignmentDurationInSeconds)
        assignmentDurationInSeconds = assignmentDurationInSecondsDecoded
        let rewardDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reward)
        reward = rewardDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let keywordsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywords)
        keywords = keywordsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let qualificationRequirementsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.QualificationRequirement?].self, forKey: .qualificationRequirements)
        var qualificationRequirementsDecoded0:[MTurkClientTypes.QualificationRequirement]? = nil
        if let qualificationRequirementsContainer = qualificationRequirementsContainer {
            qualificationRequirementsDecoded0 = [MTurkClientTypes.QualificationRequirement]()
            for structure0 in qualificationRequirementsContainer {
                if let structure0 = structure0 {
                    qualificationRequirementsDecoded0?.append(structure0)
                }
            }
        }
        qualificationRequirements = qualificationRequirementsDecoded0
    }
}

extension CreateHITTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHITTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHITTypeOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHITTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHITTypeOutputResponse(hITTypeId: \(Swift.String(describing: hITTypeId)))"}
}

extension CreateHITTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHITTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hITTypeId = output.hITTypeId
        } else {
            self.hITTypeId = nil
        }
    }
}

public struct CreateHITTypeOutputResponse: Swift.Equatable {
    ///  The ID of the newly registered HIT type.
    public let hITTypeId: Swift.String?

    public init (
        hITTypeId: Swift.String? = nil
    )
    {
        self.hITTypeId = hITTypeId
    }
}

struct CreateHITTypeOutputResponseBody: Swift.Equatable {
    public let hITTypeId: Swift.String?
}

extension CreateHITTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITTypeId = "HITTypeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
    }
}

public struct CreateHITWithHITTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHITWithHITTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHITWithHITTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHITWithHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHITWithHITTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHITWithHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHITWithHITTypeOutputError>
}

extension CreateHITWithHITTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHITWithHITTypeInput(assignmentReviewPolicy: \(Swift.String(describing: assignmentReviewPolicy)), hITLayoutId: \(Swift.String(describing: hITLayoutId)), hITLayoutParameters: \(Swift.String(describing: hITLayoutParameters)), hITReviewPolicy: \(Swift.String(describing: hITReviewPolicy)), hITTypeId: \(Swift.String(describing: hITTypeId)), lifetimeInSeconds: \(Swift.String(describing: lifetimeInSeconds)), maxAssignments: \(Swift.String(describing: maxAssignments)), question: \(Swift.String(describing: question)), requesterAnnotation: \(Swift.String(describing: requesterAnnotation)), uniqueRequestToken: \(Swift.String(describing: uniqueRequestToken)))"}
}

extension CreateHITWithHITTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentReviewPolicy = "AssignmentReviewPolicy"
        case hITLayoutId = "HITLayoutId"
        case hITLayoutParameters = "HITLayoutParameters"
        case hITReviewPolicy = "HITReviewPolicy"
        case hITTypeId = "HITTypeId"
        case lifetimeInSeconds = "LifetimeInSeconds"
        case maxAssignments = "MaxAssignments"
        case question = "Question"
        case requesterAnnotation = "RequesterAnnotation"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentReviewPolicy = assignmentReviewPolicy {
            try encodeContainer.encode(assignmentReviewPolicy, forKey: .assignmentReviewPolicy)
        }
        if let hITLayoutId = hITLayoutId {
            try encodeContainer.encode(hITLayoutId, forKey: .hITLayoutId)
        }
        if let hITLayoutParameters = hITLayoutParameters {
            var hITLayoutParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hITLayoutParameters)
            for hitlayoutparameterlist0 in hITLayoutParameters {
                try hITLayoutParametersContainer.encode(hitlayoutparameterlist0)
            }
        }
        if let hITReviewPolicy = hITReviewPolicy {
            try encodeContainer.encode(hITReviewPolicy, forKey: .hITReviewPolicy)
        }
        if let hITTypeId = hITTypeId {
            try encodeContainer.encode(hITTypeId, forKey: .hITTypeId)
        }
        if let lifetimeInSeconds = lifetimeInSeconds {
            try encodeContainer.encode(lifetimeInSeconds, forKey: .lifetimeInSeconds)
        }
        if let maxAssignments = maxAssignments {
            try encodeContainer.encode(maxAssignments, forKey: .maxAssignments)
        }
        if let question = question {
            try encodeContainer.encode(question, forKey: .question)
        }
        if let requesterAnnotation = requesterAnnotation {
            try encodeContainer.encode(requesterAnnotation, forKey: .requesterAnnotation)
        }
        if let uniqueRequestToken = uniqueRequestToken {
            try encodeContainer.encode(uniqueRequestToken, forKey: .uniqueRequestToken)
        }
    }
}

public struct CreateHITWithHITTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHITWithHITTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHITWithHITTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHITWithHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHITWithHITTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHITWithHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHITWithHITTypeOutputError>
}

public struct CreateHITWithHITTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHITWithHITTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHITWithHITTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHITWithHITTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHITWithHITTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHITWithHITTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHITWithHITTypeOutputError>
}

public struct CreateHITWithHITTypeInput: Swift.Equatable {
    ///
    ///             The Assignment-level Review Policy applies to the assignments under the HIT.
    ///             You can specify for Mechanical Turk to take various actions based on the policy.
    ///
    public let assignmentReviewPolicy: MTurkClientTypes.ReviewPolicy?
    ///
    ///             The HITLayoutId allows you to use a pre-existing HIT design with placeholder values
    ///             and create an additional HIT by providing those values as HITLayoutParameters.
    ///
    ///
    ///             Constraints: Either a Question parameter or a HITLayoutId parameter must be provided.
    ///
    public let hITLayoutId: Swift.String?
    ///
    ///             If the HITLayoutId is provided, any placeholder values must be filled in with values
    ///             using the HITLayoutParameter structure. For more information, see HITLayout.
    ///
    public let hITLayoutParameters: [MTurkClientTypes.HITLayoutParameter]?
    ///
    ///             The HIT-level Review Policy applies to the HIT.
    ///             You can specify for Mechanical Turk to take various actions based on the policy.
    ///
    public let hITReviewPolicy: MTurkClientTypes.ReviewPolicy?
    /// The HIT type ID you want to create this HIT with.
    /// This member is required.
    public let hITTypeId: Swift.String?
    ///
    ///             An amount of time, in seconds, after which the HIT is no longer available for users to accept.
    ///             After the lifetime of the HIT elapses, the HIT no longer appears in HIT searches,
    ///             even if not all of the assignments for the HIT have been accepted.
    ///
    /// This member is required.
    public let lifetimeInSeconds: Swift.Int?
    ///
    ///             The number of times the HIT can be accepted and completed before the HIT becomes unavailable.
    ///
    public let maxAssignments: Swift.Int?
    ///
    ///             The data the person completing the HIT uses to produce the results.
    ///
    ///
    ///             Constraints: Must be a QuestionForm data structure, an ExternalQuestion data structure,
    ///             or an HTMLQuestion data structure. The XML question data must not be larger than
    ///             64 kilobytes (65,535 bytes) in size, including whitespace.
    ///
    ///         Either a Question parameter or a HITLayoutId parameter must be provided.
    public let question: Swift.String?
    ///
    ///             An arbitrary data field.
    ///             The RequesterAnnotation parameter lets your application attach arbitrary data
    ///             to the HIT for tracking purposes.
    ///             For example, this parameter could be an identifier internal to the Requester's application
    ///             that corresponds with the HIT.
    ///
    ///
    ///             The RequesterAnnotation parameter for a HIT is only visible to the Requester who created the HIT.
    ///             It is not shown to the Worker, or any other Requester.
    ///
    ///
    ///             The RequesterAnnotation parameter may be different for each HIT you submit.
    ///             It does not affect how your HITs are grouped.
    ///
    public let requesterAnnotation: Swift.String?
    ///
    ///             A unique identifier for this request which allows you to retry the call
    ///             on error without creating duplicate HITs.
    ///             This is useful in cases such as network timeouts where it is unclear whether or not
    ///             the call succeeded on the server.
    ///             If the HIT already exists in the system from a previous call using the same UniqueRequestToken,
    ///             subsequent calls will return a AWS.MechanicalTurk.HitAlreadyExists error
    ///             with a message containing the HITId.
    ///
    ///
    ///
    ///                 Note: It is your responsibility to ensure uniqueness of the token.
    ///                 The unique token expires after 24 hours. Subsequent calls using the same
    ///                 UniqueRequestToken made after the 24 hour limit could create duplicate HITs.
    ///
    ///
    public let uniqueRequestToken: Swift.String?

    public init (
        assignmentReviewPolicy: MTurkClientTypes.ReviewPolicy? = nil,
        hITLayoutId: Swift.String? = nil,
        hITLayoutParameters: [MTurkClientTypes.HITLayoutParameter]? = nil,
        hITReviewPolicy: MTurkClientTypes.ReviewPolicy? = nil,
        hITTypeId: Swift.String? = nil,
        lifetimeInSeconds: Swift.Int? = nil,
        maxAssignments: Swift.Int? = nil,
        question: Swift.String? = nil,
        requesterAnnotation: Swift.String? = nil,
        uniqueRequestToken: Swift.String? = nil
    )
    {
        self.assignmentReviewPolicy = assignmentReviewPolicy
        self.hITLayoutId = hITLayoutId
        self.hITLayoutParameters = hITLayoutParameters
        self.hITReviewPolicy = hITReviewPolicy
        self.hITTypeId = hITTypeId
        self.lifetimeInSeconds = lifetimeInSeconds
        self.maxAssignments = maxAssignments
        self.question = question
        self.requesterAnnotation = requesterAnnotation
        self.uniqueRequestToken = uniqueRequestToken
    }
}

struct CreateHITWithHITTypeInputBody: Swift.Equatable {
    public let hITTypeId: Swift.String?
    public let maxAssignments: Swift.Int?
    public let lifetimeInSeconds: Swift.Int?
    public let question: Swift.String?
    public let requesterAnnotation: Swift.String?
    public let uniqueRequestToken: Swift.String?
    public let assignmentReviewPolicy: MTurkClientTypes.ReviewPolicy?
    public let hITReviewPolicy: MTurkClientTypes.ReviewPolicy?
    public let hITLayoutId: Swift.String?
    public let hITLayoutParameters: [MTurkClientTypes.HITLayoutParameter]?
}

extension CreateHITWithHITTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentReviewPolicy = "AssignmentReviewPolicy"
        case hITLayoutId = "HITLayoutId"
        case hITLayoutParameters = "HITLayoutParameters"
        case hITReviewPolicy = "HITReviewPolicy"
        case hITTypeId = "HITTypeId"
        case lifetimeInSeconds = "LifetimeInSeconds"
        case maxAssignments = "MaxAssignments"
        case question = "Question"
        case requesterAnnotation = "RequesterAnnotation"
        case uniqueRequestToken = "UniqueRequestToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
        let maxAssignmentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAssignments)
        maxAssignments = maxAssignmentsDecoded
        let lifetimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lifetimeInSeconds)
        lifetimeInSeconds = lifetimeInSecondsDecoded
        let questionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .question)
        question = questionDecoded
        let requesterAnnotationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requesterAnnotation)
        requesterAnnotation = requesterAnnotationDecoded
        let uniqueRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uniqueRequestToken)
        uniqueRequestToken = uniqueRequestTokenDecoded
        let assignmentReviewPolicyDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.ReviewPolicy.self, forKey: .assignmentReviewPolicy)
        assignmentReviewPolicy = assignmentReviewPolicyDecoded
        let hITReviewPolicyDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.ReviewPolicy.self, forKey: .hITReviewPolicy)
        hITReviewPolicy = hITReviewPolicyDecoded
        let hITLayoutIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITLayoutId)
        hITLayoutId = hITLayoutIdDecoded
        let hITLayoutParametersContainer = try containerValues.decodeIfPresent([MTurkClientTypes.HITLayoutParameter?].self, forKey: .hITLayoutParameters)
        var hITLayoutParametersDecoded0:[MTurkClientTypes.HITLayoutParameter]? = nil
        if let hITLayoutParametersContainer = hITLayoutParametersContainer {
            hITLayoutParametersDecoded0 = [MTurkClientTypes.HITLayoutParameter]()
            for structure0 in hITLayoutParametersContainer {
                if let structure0 = structure0 {
                    hITLayoutParametersDecoded0?.append(structure0)
                }
            }
        }
        hITLayoutParameters = hITLayoutParametersDecoded0
    }
}

extension CreateHITWithHITTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHITWithHITTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHITWithHITTypeOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHITWithHITTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHITWithHITTypeOutputResponse(hIT: \(Swift.String(describing: hIT)))"}
}

extension CreateHITWithHITTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHITWithHITTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hIT = output.hIT
        } else {
            self.hIT = nil
        }
    }
}

public struct CreateHITWithHITTypeOutputResponse: Swift.Equatable {
    ///  Contains the newly created HIT data. For a description of
    ///             the HIT data structure as it appears in responses, see the HIT Data
    ///             Structure documentation.
    ///
    public let hIT: MTurkClientTypes.HIT?

    public init (
        hIT: MTurkClientTypes.HIT? = nil
    )
    {
        self.hIT = hIT
    }
}

struct CreateHITWithHITTypeOutputResponseBody: Swift.Equatable {
    public let hIT: MTurkClientTypes.HIT?
}

extension CreateHITWithHITTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hIT = "HIT"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.HIT.self, forKey: .hIT)
        hIT = hITDecoded
    }
}

public struct CreateQualificationTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateQualificationTypeOutputError>
}

extension CreateQualificationTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateQualificationTypeInput(answerKey: \(Swift.String(describing: answerKey)), autoGranted: \(Swift.String(describing: autoGranted)), autoGrantedValue: \(Swift.String(describing: autoGrantedValue)), description: \(Swift.String(describing: description)), keywords: \(Swift.String(describing: keywords)), name: \(Swift.String(describing: name)), qualificationTypeStatus: \(Swift.String(describing: qualificationTypeStatus)), retryDelayInSeconds: \(Swift.String(describing: retryDelayInSeconds)), test: \(Swift.String(describing: test)), testDurationInSeconds: \(Swift.String(describing: testDurationInSeconds)))"}
}

extension CreateQualificationTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerKey = "AnswerKey"
        case autoGranted = "AutoGranted"
        case autoGrantedValue = "AutoGrantedValue"
        case description = "Description"
        case keywords = "Keywords"
        case name = "Name"
        case qualificationTypeStatus = "QualificationTypeStatus"
        case retryDelayInSeconds = "RetryDelayInSeconds"
        case test = "Test"
        case testDurationInSeconds = "TestDurationInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerKey = answerKey {
            try encodeContainer.encode(answerKey, forKey: .answerKey)
        }
        if let autoGranted = autoGranted {
            try encodeContainer.encode(autoGranted, forKey: .autoGranted)
        }
        if let autoGrantedValue = autoGrantedValue {
            try encodeContainer.encode(autoGrantedValue, forKey: .autoGrantedValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keywords = keywords {
            try encodeContainer.encode(keywords, forKey: .keywords)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let qualificationTypeStatus = qualificationTypeStatus {
            try encodeContainer.encode(qualificationTypeStatus.rawValue, forKey: .qualificationTypeStatus)
        }
        if let retryDelayInSeconds = retryDelayInSeconds {
            try encodeContainer.encode(retryDelayInSeconds, forKey: .retryDelayInSeconds)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let testDurationInSeconds = testDurationInSeconds {
            try encodeContainer.encode(testDurationInSeconds, forKey: .testDurationInSeconds)
        }
    }
}

public struct CreateQualificationTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateQualificationTypeOutputError>
}

public struct CreateQualificationTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateQualificationTypeOutputError>
}

public struct CreateQualificationTypeInput: Swift.Equatable {
    /// The answers to the Qualification test specified in the Test
    ///             parameter, in the form of an AnswerKey data structure.
    ///         Constraints: Must not be longer than 65535 bytes.
    ///         Constraints: None. If not specified, you must process
    ///             Qualification requests manually.
    public let answerKey: Swift.String?
    /// Specifies whether requests for the Qualification type are
    ///             granted immediately, without prompting the Worker with a
    ///             Qualification test.
    ///         Constraints: If the Test parameter is specified, this
    ///             parameter cannot be true.
    public let autoGranted: Swift.Bool?
    /// The Qualification value to use for automatically granted
    ///             Qualifications. This parameter is used only if the AutoGranted
    ///             parameter is true.
    public let autoGrantedValue: Swift.Int?
    /// A long description for the Qualification type. On the Amazon
    ///             Mechanical Turk website, the long description is displayed when a
    ///             Worker examines a Qualification type.
    /// This member is required.
    public let description: Swift.String?
    /// One or more words or phrases that describe the Qualification
    ///             type, separated by commas. The keywords of a type make the type
    ///             easier to find during a search.
    public let keywords: Swift.String?
    ///  The name you give to the Qualification type. The type name
    ///             is used to represent the Qualification to Workers, and to find the
    ///             type using a Qualification type search. It must be unique across all
    ///             of your Qualification types.
    /// This member is required.
    public let name: Swift.String?
    /// The initial status of the Qualification type.
    ///         Constraints: Valid values are: Active | Inactive
    /// This member is required.
    public let qualificationTypeStatus: MTurkClientTypes.QualificationTypeStatus?
    /// The number of seconds that a Worker must wait after
    ///             requesting a Qualification of the Qualification type before the
    ///             worker can retry the Qualification request.
    ///         Constraints: None. If not specified, retries are disabled and
    ///             Workers can request a Qualification of this type only once, even if
    ///             the Worker has not been granted the Qualification. It is not possible
    ///             to disable retries for a Qualification type after it has been created
    ///             with retries enabled. If you want to disable retries, you must delete
    ///             existing retry-enabled Qualification type and then create a new
    ///             Qualification type with retries disabled.
    public let retryDelayInSeconds: Swift.Int?
    ///
    ///             The questions for the Qualification test a Worker must answer
    ///             correctly to obtain a Qualification of this type. If this parameter
    ///             is specified,
    ///             TestDurationInSeconds
    ///             must also be specified.
    ///
    ///         Constraints: Must not be longer than 65535 bytes. Must be a
    ///             QuestionForm data structure. This parameter cannot be specified if
    ///             AutoGranted is true.
    ///         Constraints: None. If not specified, the Worker may request
    ///             the Qualification without answering any questions.
    public let test: Swift.String?
    /// The number of seconds the Worker has to complete the
    ///             Qualification test, starting from the time the Worker requests the
    ///             Qualification.
    public let testDurationInSeconds: Swift.Int?

    public init (
        answerKey: Swift.String? = nil,
        autoGranted: Swift.Bool? = nil,
        autoGrantedValue: Swift.Int? = nil,
        description: Swift.String? = nil,
        keywords: Swift.String? = nil,
        name: Swift.String? = nil,
        qualificationTypeStatus: MTurkClientTypes.QualificationTypeStatus? = nil,
        retryDelayInSeconds: Swift.Int? = nil,
        test: Swift.String? = nil,
        testDurationInSeconds: Swift.Int? = nil
    )
    {
        self.answerKey = answerKey
        self.autoGranted = autoGranted
        self.autoGrantedValue = autoGrantedValue
        self.description = description
        self.keywords = keywords
        self.name = name
        self.qualificationTypeStatus = qualificationTypeStatus
        self.retryDelayInSeconds = retryDelayInSeconds
        self.test = test
        self.testDurationInSeconds = testDurationInSeconds
    }
}

struct CreateQualificationTypeInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let keywords: Swift.String?
    public let description: Swift.String?
    public let qualificationTypeStatus: MTurkClientTypes.QualificationTypeStatus?
    public let retryDelayInSeconds: Swift.Int?
    public let test: Swift.String?
    public let answerKey: Swift.String?
    public let testDurationInSeconds: Swift.Int?
    public let autoGranted: Swift.Bool?
    public let autoGrantedValue: Swift.Int?
}

extension CreateQualificationTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerKey = "AnswerKey"
        case autoGranted = "AutoGranted"
        case autoGrantedValue = "AutoGrantedValue"
        case description = "Description"
        case keywords = "Keywords"
        case name = "Name"
        case qualificationTypeStatus = "QualificationTypeStatus"
        case retryDelayInSeconds = "RetryDelayInSeconds"
        case test = "Test"
        case testDurationInSeconds = "TestDurationInSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let keywordsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywords)
        keywords = keywordsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let qualificationTypeStatusDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.QualificationTypeStatus.self, forKey: .qualificationTypeStatus)
        qualificationTypeStatus = qualificationTypeStatusDecoded
        let retryDelayInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryDelayInSeconds)
        retryDelayInSeconds = retryDelayInSecondsDecoded
        let testDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .test)
        test = testDecoded
        let answerKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .answerKey)
        answerKey = answerKeyDecoded
        let testDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .testDurationInSeconds)
        testDurationInSeconds = testDurationInSecondsDecoded
        let autoGrantedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoGranted)
        autoGranted = autoGrantedDecoded
        let autoGrantedValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .autoGrantedValue)
        autoGrantedValue = autoGrantedValueDecoded
    }
}

extension CreateQualificationTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateQualificationTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateQualificationTypeOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateQualificationTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateQualificationTypeOutputResponse(qualificationType: \(Swift.String(describing: qualificationType)))"}
}

extension CreateQualificationTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateQualificationTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.qualificationType = output.qualificationType
        } else {
            self.qualificationType = nil
        }
    }
}

public struct CreateQualificationTypeOutputResponse: Swift.Equatable {
    /// The created Qualification type, returned as a
    ///             QualificationType data structure.
    public let qualificationType: MTurkClientTypes.QualificationType?

    public init (
        qualificationType: MTurkClientTypes.QualificationType? = nil
    )
    {
        self.qualificationType = qualificationType
    }
}

struct CreateQualificationTypeOutputResponseBody: Swift.Equatable {
    public let qualificationType: MTurkClientTypes.QualificationType?
}

extension CreateQualificationTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationType = "QualificationType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.QualificationType.self, forKey: .qualificationType)
        qualificationType = qualificationTypeDecoded
    }
}

public struct CreateWorkerBlockInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkerBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkerBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkerBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkerBlockOutputError>
}

extension CreateWorkerBlockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkerBlockInput(reason: \(Swift.String(describing: reason)), workerId: \(Swift.String(describing: workerId)))"}
}

extension CreateWorkerBlockInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct CreateWorkerBlockInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkerBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkerBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkerBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkerBlockOutputError>
}

public struct CreateWorkerBlockInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkerBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkerBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkerBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkerBlockOutputError>
}

public struct CreateWorkerBlockInput: Swift.Equatable {
    /// A message explaining the reason for blocking the Worker. This parameter enables you to keep track of your Workers. The Worker does not see this message.
    /// This member is required.
    public let reason: Swift.String?
    /// The ID of the Worker to block.
    /// This member is required.
    public let workerId: Swift.String?

    public init (
        reason: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.reason = reason
        self.workerId = workerId
    }
}

struct CreateWorkerBlockInputBody: Swift.Equatable {
    public let workerId: Swift.String?
    public let reason: Swift.String?
}

extension CreateWorkerBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CreateWorkerBlockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkerBlockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkerBlockOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkerBlockOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkerBlockOutputResponse()"}
}

extension CreateWorkerBlockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateWorkerBlockOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateWorkerBlockOutputResponseBody: Swift.Equatable {
}

extension CreateWorkerBlockOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteHITInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHITOutputError>
}

extension DeleteHITInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHITInput(hITId: \(Swift.String(describing: hITId)))"}
}

extension DeleteHITInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
    }
}

public struct DeleteHITInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHITOutputError>
}

public struct DeleteHITInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHITOutputError>
}

public struct DeleteHITInput: Swift.Equatable {
    /// The ID of the HIT to be deleted.
    /// This member is required.
    public let hITId: Swift.String?

    public init (
        hITId: Swift.String? = nil
    )
    {
        self.hITId = hITId
    }
}

struct DeleteHITInputBody: Swift.Equatable {
    public let hITId: Swift.String?
}

extension DeleteHITInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
    }
}

extension DeleteHITOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHITOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHITOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHITOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHITOutputResponse()"}
}

extension DeleteHITOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHITOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteHITOutputResponseBody: Swift.Equatable {
}

extension DeleteHITOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteQualificationTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteQualificationTypeOutputError>
}

extension DeleteQualificationTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteQualificationTypeInput(qualificationTypeId: \(Swift.String(describing: qualificationTypeId)))"}
}

extension DeleteQualificationTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationTypeId = "QualificationTypeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
    }
}

public struct DeleteQualificationTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteQualificationTypeOutputError>
}

public struct DeleteQualificationTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteQualificationTypeOutputError>
}

public struct DeleteQualificationTypeInput: Swift.Equatable {
    /// The ID of the QualificationType to dispose.
    /// This member is required.
    public let qualificationTypeId: Swift.String?

    public init (
        qualificationTypeId: Swift.String? = nil
    )
    {
        self.qualificationTypeId = qualificationTypeId
    }
}

struct DeleteQualificationTypeInputBody: Swift.Equatable {
    public let qualificationTypeId: Swift.String?
}

extension DeleteQualificationTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationTypeId = "QualificationTypeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
    }
}

extension DeleteQualificationTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteQualificationTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteQualificationTypeOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteQualificationTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteQualificationTypeOutputResponse()"}
}

extension DeleteQualificationTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteQualificationTypeOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteQualificationTypeOutputResponseBody: Swift.Equatable {
}

extension DeleteQualificationTypeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteWorkerBlockInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkerBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorkerBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorkerBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkerBlockOutputError>
}

extension DeleteWorkerBlockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWorkerBlockInput(reason: \(Swift.String(describing: reason)), workerId: \(Swift.String(describing: workerId)))"}
}

extension DeleteWorkerBlockInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct DeleteWorkerBlockInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkerBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorkerBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorkerBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkerBlockOutputError>
}

public struct DeleteWorkerBlockInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkerBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorkerBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkerBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorkerBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkerBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkerBlockOutputError>
}

public struct DeleteWorkerBlockInput: Swift.Equatable {
    /// A message that explains the reason for unblocking the Worker. The Worker does not see this message.
    public let reason: Swift.String?
    /// The ID of the Worker to unblock.
    /// This member is required.
    public let workerId: Swift.String?

    public init (
        reason: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.reason = reason
        self.workerId = workerId
    }
}

struct DeleteWorkerBlockInputBody: Swift.Equatable {
    public let workerId: Swift.String?
    public let reason: Swift.String?
}

extension DeleteWorkerBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DeleteWorkerBlockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkerBlockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkerBlockOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkerBlockOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWorkerBlockOutputResponse()"}
}

extension DeleteWorkerBlockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkerBlockOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteWorkerBlockOutputResponseBody: Swift.Equatable {
}

extension DeleteWorkerBlockOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateQualificationFromWorkerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateQualificationFromWorkerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateQualificationFromWorkerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateQualificationFromWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateQualificationFromWorkerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateQualificationFromWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateQualificationFromWorkerOutputError>
}

extension DisassociateQualificationFromWorkerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateQualificationFromWorkerInput(qualificationTypeId: \(Swift.String(describing: qualificationTypeId)), reason: \(Swift.String(describing: reason)), workerId: \(Swift.String(describing: workerId)))"}
}

extension DisassociateQualificationFromWorkerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationTypeId = "QualificationTypeId"
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct DisassociateQualificationFromWorkerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateQualificationFromWorkerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateQualificationFromWorkerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateQualificationFromWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateQualificationFromWorkerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateQualificationFromWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateQualificationFromWorkerOutputError>
}

public struct DisassociateQualificationFromWorkerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateQualificationFromWorkerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateQualificationFromWorkerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateQualificationFromWorkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateQualificationFromWorkerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateQualificationFromWorkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateQualificationFromWorkerOutputError>
}

public struct DisassociateQualificationFromWorkerInput: Swift.Equatable {
    /// The ID of the Qualification type of the Qualification to be revoked.
    /// This member is required.
    public let qualificationTypeId: Swift.String?
    /// A text message that explains why the Qualification was revoked. The user who had the Qualification sees this message.
    public let reason: Swift.String?
    /// The ID of the Worker who possesses the Qualification to be revoked.
    /// This member is required.
    public let workerId: Swift.String?

    public init (
        qualificationTypeId: Swift.String? = nil,
        reason: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.qualificationTypeId = qualificationTypeId
        self.reason = reason
        self.workerId = workerId
    }
}

struct DisassociateQualificationFromWorkerInputBody: Swift.Equatable {
    public let workerId: Swift.String?
    public let qualificationTypeId: Swift.String?
    public let reason: Swift.String?
}

extension DisassociateQualificationFromWorkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationTypeId = "QualificationTypeId"
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DisassociateQualificationFromWorkerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateQualificationFromWorkerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateQualificationFromWorkerOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateQualificationFromWorkerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateQualificationFromWorkerOutputResponse()"}
}

extension DisassociateQualificationFromWorkerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateQualificationFromWorkerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateQualificationFromWorkerOutputResponseBody: Swift.Equatable {
}

extension DisassociateQualificationFromWorkerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MTurkClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assignmentabandoned
        case assignmentaccepted
        case assignmentapproved
        case assignmentrejected
        case assignmentreturned
        case assignmentsubmitted
        case hitcreated
        case hitdisposed
        case hitexpired
        case hitextended
        case hitreviewable
        case ping
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .assignmentabandoned,
                .assignmentaccepted,
                .assignmentapproved,
                .assignmentrejected,
                .assignmentreturned,
                .assignmentsubmitted,
                .hitcreated,
                .hitdisposed,
                .hitexpired,
                .hitextended,
                .hitreviewable,
                .ping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assignmentabandoned: return "AssignmentAbandoned"
            case .assignmentaccepted: return "AssignmentAccepted"
            case .assignmentapproved: return "AssignmentApproved"
            case .assignmentrejected: return "AssignmentRejected"
            case .assignmentreturned: return "AssignmentReturned"
            case .assignmentsubmitted: return "AssignmentSubmitted"
            case .hitcreated: return "HITCreated"
            case .hitdisposed: return "HITDisposed"
            case .hitexpired: return "HITExpired"
            case .hitextended: return "HITExtended"
            case .hitreviewable: return "HITReviewable"
            case .ping: return "Ping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension GetAccountBalanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountBalanceInput()"}
}

extension GetAccountBalanceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAccountBalanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountBalanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountBalanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountBalanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountBalanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountBalanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountBalanceOutputError>
}

public struct GetAccountBalanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountBalanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountBalanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountBalanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountBalanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountBalanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountBalanceOutputError>
}

public struct GetAccountBalanceInput: Swift.Equatable {

    public init() {}
}

struct GetAccountBalanceInputBody: Swift.Equatable {
}

extension GetAccountBalanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountBalanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountBalanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountBalanceOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountBalanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountBalanceOutputResponse(availableBalance: \(Swift.String(describing: availableBalance)), onHoldBalance: \(Swift.String(describing: onHoldBalance)))"}
}

extension GetAccountBalanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccountBalanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availableBalance = output.availableBalance
            self.onHoldBalance = output.onHoldBalance
        } else {
            self.availableBalance = nil
            self.onHoldBalance = nil
        }
    }
}

public struct GetAccountBalanceOutputResponse: Swift.Equatable {
    /// A string representing a currency amount.
    public let availableBalance: Swift.String?
    /// A string representing a currency amount.
    public let onHoldBalance: Swift.String?

    public init (
        availableBalance: Swift.String? = nil,
        onHoldBalance: Swift.String? = nil
    )
    {
        self.availableBalance = availableBalance
        self.onHoldBalance = onHoldBalance
    }
}

struct GetAccountBalanceOutputResponseBody: Swift.Equatable {
    public let availableBalance: Swift.String?
    public let onHoldBalance: Swift.String?
}

extension GetAccountBalanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availableBalance = "AvailableBalance"
        case onHoldBalance = "OnHoldBalance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availableBalanceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availableBalance)
        availableBalance = availableBalanceDecoded
        let onHoldBalanceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onHoldBalance)
        onHoldBalance = onHoldBalanceDecoded
    }
}

public struct GetAssignmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssignmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssignmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssignmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssignmentOutputError>
}

extension GetAssignmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssignmentInput(assignmentId: \(Swift.String(describing: assignmentId)))"}
}

extension GetAssignmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
    }
}

public struct GetAssignmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssignmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssignmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssignmentOutputError>
}

public struct GetAssignmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssignmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssignmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssignmentOutputError>
}

public struct GetAssignmentInput: Swift.Equatable {
    /// The ID of the Assignment to be retrieved.
    /// This member is required.
    public let assignmentId: Swift.String?

    public init (
        assignmentId: Swift.String? = nil
    )
    {
        self.assignmentId = assignmentId
    }
}

struct GetAssignmentInputBody: Swift.Equatable {
    public let assignmentId: Swift.String?
}

extension GetAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
    }
}

extension GetAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssignmentOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssignmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssignmentOutputResponse(assignment: \(Swift.String(describing: assignment)), hIT: \(Swift.String(describing: hIT)))"}
}

extension GetAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assignment = output.assignment
            self.hIT = output.hIT
        } else {
            self.assignment = nil
            self.hIT = nil
        }
    }
}

public struct GetAssignmentOutputResponse: Swift.Equatable {
    ///  The assignment. The response includes one Assignment
    ///             element.
    ///
    public let assignment: MTurkClientTypes.Assignment?
    ///  The HIT associated with this assignment. The response
    ///             includes one HIT element.
    public let hIT: MTurkClientTypes.HIT?

    public init (
        assignment: MTurkClientTypes.Assignment? = nil,
        hIT: MTurkClientTypes.HIT? = nil
    )
    {
        self.assignment = assignment
        self.hIT = hIT
    }
}

struct GetAssignmentOutputResponseBody: Swift.Equatable {
    public let assignment: MTurkClientTypes.Assignment?
    public let hIT: MTurkClientTypes.HIT?
}

extension GetAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignment = "Assignment"
        case hIT = "HIT"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.Assignment.self, forKey: .assignment)
        assignment = assignmentDecoded
        let hITDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.HIT.self, forKey: .hIT)
        hIT = hITDecoded
    }
}

public struct GetFileUploadURLInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFileUploadURLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFileUploadURLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFileUploadURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFileUploadURLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFileUploadURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFileUploadURLOutputError>
}

extension GetFileUploadURLInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFileUploadURLInput(assignmentId: \(Swift.String(describing: assignmentId)), questionIdentifier: \(Swift.String(describing: questionIdentifier)))"}
}

extension GetFileUploadURLInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case questionIdentifier = "QuestionIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let questionIdentifier = questionIdentifier {
            try encodeContainer.encode(questionIdentifier, forKey: .questionIdentifier)
        }
    }
}

public struct GetFileUploadURLInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFileUploadURLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFileUploadURLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFileUploadURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFileUploadURLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFileUploadURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFileUploadURLOutputError>
}

public struct GetFileUploadURLInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFileUploadURLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFileUploadURLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFileUploadURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFileUploadURLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFileUploadURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFileUploadURLOutputError>
}

public struct GetFileUploadURLInput: Swift.Equatable {
    /// The ID of the assignment that contains the question with a
    ///             FileUploadAnswer.
    /// This member is required.
    public let assignmentId: Swift.String?
    /// The identifier of the question with a FileUploadAnswer, as
    ///             specified in the QuestionForm of the HIT.
    /// This member is required.
    public let questionIdentifier: Swift.String?

    public init (
        assignmentId: Swift.String? = nil,
        questionIdentifier: Swift.String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.questionIdentifier = questionIdentifier
    }
}

struct GetFileUploadURLInputBody: Swift.Equatable {
    public let assignmentId: Swift.String?
    public let questionIdentifier: Swift.String?
}

extension GetFileUploadURLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case questionIdentifier = "QuestionIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let questionIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionIdentifier)
        questionIdentifier = questionIdentifierDecoded
    }
}

extension GetFileUploadURLOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFileUploadURLOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFileUploadURLOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFileUploadURLOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFileUploadURLOutputResponse(fileUploadURL: \(Swift.String(describing: fileUploadURL)))"}
}

extension GetFileUploadURLOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFileUploadURLOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileUploadURL = output.fileUploadURL
        } else {
            self.fileUploadURL = nil
        }
    }
}

public struct GetFileUploadURLOutputResponse: Swift.Equatable {
    ///  A temporary URL for the file that the Worker uploaded for
    ///             the answer.
    ///
    public let fileUploadURL: Swift.String?

    public init (
        fileUploadURL: Swift.String? = nil
    )
    {
        self.fileUploadURL = fileUploadURL
    }
}

struct GetFileUploadURLOutputResponseBody: Swift.Equatable {
    public let fileUploadURL: Swift.String?
}

extension GetFileUploadURLOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileUploadURL = "FileUploadURL"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileUploadURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileUploadURL)
        fileUploadURL = fileUploadURLDecoded
    }
}

public struct GetHITInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHITOutputError>
}

extension GetHITInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetHITInput(hITId: \(Swift.String(describing: hITId)))"}
}

extension GetHITInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
    }
}

public struct GetHITInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHITOutputError>
}

public struct GetHITInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHITOutputError>
}

public struct GetHITInput: Swift.Equatable {
    /// The ID of the HIT to be retrieved.
    /// This member is required.
    public let hITId: Swift.String?

    public init (
        hITId: Swift.String? = nil
    )
    {
        self.hITId = hITId
    }
}

struct GetHITInputBody: Swift.Equatable {
    public let hITId: Swift.String?
}

extension GetHITInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
    }
}

extension GetHITOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHITOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHITOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHITOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetHITOutputResponse(hIT: \(Swift.String(describing: hIT)))"}
}

extension GetHITOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetHITOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hIT = output.hIT
        } else {
            self.hIT = nil
        }
    }
}

public struct GetHITOutputResponse: Swift.Equatable {
    ///  Contains the requested HIT data.
    public let hIT: MTurkClientTypes.HIT?

    public init (
        hIT: MTurkClientTypes.HIT? = nil
    )
    {
        self.hIT = hIT
    }
}

struct GetHITOutputResponseBody: Swift.Equatable {
    public let hIT: MTurkClientTypes.HIT?
}

extension GetHITOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hIT = "HIT"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.HIT.self, forKey: .hIT)
        hIT = hITDecoded
    }
}

public struct GetQualificationScoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetQualificationScoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetQualificationScoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetQualificationScoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetQualificationScoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetQualificationScoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetQualificationScoreOutputError>
}

extension GetQualificationScoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetQualificationScoreInput(qualificationTypeId: \(Swift.String(describing: qualificationTypeId)), workerId: \(Swift.String(describing: workerId)))"}
}

extension GetQualificationScoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationTypeId = "QualificationTypeId"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct GetQualificationScoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetQualificationScoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetQualificationScoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetQualificationScoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetQualificationScoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetQualificationScoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetQualificationScoreOutputError>
}

public struct GetQualificationScoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetQualificationScoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetQualificationScoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetQualificationScoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetQualificationScoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetQualificationScoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetQualificationScoreOutputError>
}

public struct GetQualificationScoreInput: Swift.Equatable {
    /// The ID of the QualificationType.
    /// This member is required.
    public let qualificationTypeId: Swift.String?
    /// The ID of the Worker whose Qualification is being updated.
    /// This member is required.
    public let workerId: Swift.String?

    public init (
        qualificationTypeId: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.qualificationTypeId = qualificationTypeId
        self.workerId = workerId
    }
}

struct GetQualificationScoreInputBody: Swift.Equatable {
    public let qualificationTypeId: Swift.String?
    public let workerId: Swift.String?
}

extension GetQualificationScoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationTypeId = "QualificationTypeId"
        case workerId = "WorkerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
    }
}

extension GetQualificationScoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQualificationScoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQualificationScoreOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQualificationScoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetQualificationScoreOutputResponse(qualification: \(Swift.String(describing: qualification)))"}
}

extension GetQualificationScoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetQualificationScoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.qualification = output.qualification
        } else {
            self.qualification = nil
        }
    }
}

public struct GetQualificationScoreOutputResponse: Swift.Equatable {
    ///  The Qualification data structure of the Qualification
    ///             assigned to a user, including the Qualification type and the value
    ///             (score).
    ///
    public let qualification: MTurkClientTypes.Qualification?

    public init (
        qualification: MTurkClientTypes.Qualification? = nil
    )
    {
        self.qualification = qualification
    }
}

struct GetQualificationScoreOutputResponseBody: Swift.Equatable {
    public let qualification: MTurkClientTypes.Qualification?
}

extension GetQualificationScoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualification = "Qualification"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.Qualification.self, forKey: .qualification)
        qualification = qualificationDecoded
    }
}

public struct GetQualificationTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetQualificationTypeOutputError>
}

extension GetQualificationTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetQualificationTypeInput(qualificationTypeId: \(Swift.String(describing: qualificationTypeId)))"}
}

extension GetQualificationTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationTypeId = "QualificationTypeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
    }
}

public struct GetQualificationTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetQualificationTypeOutputError>
}

public struct GetQualificationTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetQualificationTypeOutputError>
}

public struct GetQualificationTypeInput: Swift.Equatable {
    /// The ID of the QualificationType.
    /// This member is required.
    public let qualificationTypeId: Swift.String?

    public init (
        qualificationTypeId: Swift.String? = nil
    )
    {
        self.qualificationTypeId = qualificationTypeId
    }
}

struct GetQualificationTypeInputBody: Swift.Equatable {
    public let qualificationTypeId: Swift.String?
}

extension GetQualificationTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationTypeId = "QualificationTypeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
    }
}

extension GetQualificationTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQualificationTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQualificationTypeOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQualificationTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetQualificationTypeOutputResponse(qualificationType: \(Swift.String(describing: qualificationType)))"}
}

extension GetQualificationTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetQualificationTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.qualificationType = output.qualificationType
        } else {
            self.qualificationType = nil
        }
    }
}

public struct GetQualificationTypeOutputResponse: Swift.Equatable {
    ///  The returned Qualification Type
    public let qualificationType: MTurkClientTypes.QualificationType?

    public init (
        qualificationType: MTurkClientTypes.QualificationType? = nil
    )
    {
        self.qualificationType = qualificationType
    }
}

struct GetQualificationTypeOutputResponseBody: Swift.Equatable {
    public let qualificationType: MTurkClientTypes.QualificationType?
}

extension GetQualificationTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationType = "QualificationType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.QualificationType.self, forKey: .qualificationType)
        qualificationType = qualificationTypeDecoded
    }
}

extension MTurkClientTypes.HIT: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentDurationInSeconds = "AssignmentDurationInSeconds"
        case autoApprovalDelayInSeconds = "AutoApprovalDelayInSeconds"
        case creationTime = "CreationTime"
        case description = "Description"
        case expiration = "Expiration"
        case hITGroupId = "HITGroupId"
        case hITId = "HITId"
        case hITLayoutId = "HITLayoutId"
        case hITReviewStatus = "HITReviewStatus"
        case hITStatus = "HITStatus"
        case hITTypeId = "HITTypeId"
        case keywords = "Keywords"
        case maxAssignments = "MaxAssignments"
        case numberOfAssignmentsAvailable = "NumberOfAssignmentsAvailable"
        case numberOfAssignmentsCompleted = "NumberOfAssignmentsCompleted"
        case numberOfAssignmentsPending = "NumberOfAssignmentsPending"
        case qualificationRequirements = "QualificationRequirements"
        case question = "Question"
        case requesterAnnotation = "RequesterAnnotation"
        case reward = "Reward"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentDurationInSeconds = assignmentDurationInSeconds {
            try encodeContainer.encode(assignmentDurationInSeconds, forKey: .assignmentDurationInSeconds)
        }
        if let autoApprovalDelayInSeconds = autoApprovalDelayInSeconds {
            try encodeContainer.encode(autoApprovalDelayInSeconds, forKey: .autoApprovalDelayInSeconds)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expiration = expiration {
            try encodeContainer.encode(expiration.timeIntervalSince1970, forKey: .expiration)
        }
        if let hITGroupId = hITGroupId {
            try encodeContainer.encode(hITGroupId, forKey: .hITGroupId)
        }
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let hITLayoutId = hITLayoutId {
            try encodeContainer.encode(hITLayoutId, forKey: .hITLayoutId)
        }
        if let hITReviewStatus = hITReviewStatus {
            try encodeContainer.encode(hITReviewStatus.rawValue, forKey: .hITReviewStatus)
        }
        if let hITStatus = hITStatus {
            try encodeContainer.encode(hITStatus.rawValue, forKey: .hITStatus)
        }
        if let hITTypeId = hITTypeId {
            try encodeContainer.encode(hITTypeId, forKey: .hITTypeId)
        }
        if let keywords = keywords {
            try encodeContainer.encode(keywords, forKey: .keywords)
        }
        if let maxAssignments = maxAssignments {
            try encodeContainer.encode(maxAssignments, forKey: .maxAssignments)
        }
        if let numberOfAssignmentsAvailable = numberOfAssignmentsAvailable {
            try encodeContainer.encode(numberOfAssignmentsAvailable, forKey: .numberOfAssignmentsAvailable)
        }
        if let numberOfAssignmentsCompleted = numberOfAssignmentsCompleted {
            try encodeContainer.encode(numberOfAssignmentsCompleted, forKey: .numberOfAssignmentsCompleted)
        }
        if let numberOfAssignmentsPending = numberOfAssignmentsPending {
            try encodeContainer.encode(numberOfAssignmentsPending, forKey: .numberOfAssignmentsPending)
        }
        if let qualificationRequirements = qualificationRequirements {
            var qualificationRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .qualificationRequirements)
            for qualificationrequirementlist0 in qualificationRequirements {
                try qualificationRequirementsContainer.encode(qualificationrequirementlist0)
            }
        }
        if let question = question {
            try encodeContainer.encode(question, forKey: .question)
        }
        if let requesterAnnotation = requesterAnnotation {
            try encodeContainer.encode(requesterAnnotation, forKey: .requesterAnnotation)
        }
        if let reward = reward {
            try encodeContainer.encode(reward, forKey: .reward)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
        let hITGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITGroupId)
        hITGroupId = hITGroupIdDecoded
        let hITLayoutIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITLayoutId)
        hITLayoutId = hITLayoutIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let questionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .question)
        question = questionDecoded
        let keywordsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywords)
        keywords = keywordsDecoded
        let hITStatusDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.HITStatus.self, forKey: .hITStatus)
        hITStatus = hITStatusDecoded
        let maxAssignmentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAssignments)
        maxAssignments = maxAssignmentsDecoded
        let rewardDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reward)
        reward = rewardDecoded
        let autoApprovalDelayInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .autoApprovalDelayInSeconds)
        autoApprovalDelayInSeconds = autoApprovalDelayInSecondsDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiration)
        expiration = expirationDecoded
        let assignmentDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assignmentDurationInSeconds)
        assignmentDurationInSeconds = assignmentDurationInSecondsDecoded
        let requesterAnnotationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requesterAnnotation)
        requesterAnnotation = requesterAnnotationDecoded
        let qualificationRequirementsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.QualificationRequirement?].self, forKey: .qualificationRequirements)
        var qualificationRequirementsDecoded0:[MTurkClientTypes.QualificationRequirement]? = nil
        if let qualificationRequirementsContainer = qualificationRequirementsContainer {
            qualificationRequirementsDecoded0 = [MTurkClientTypes.QualificationRequirement]()
            for structure0 in qualificationRequirementsContainer {
                if let structure0 = structure0 {
                    qualificationRequirementsDecoded0?.append(structure0)
                }
            }
        }
        qualificationRequirements = qualificationRequirementsDecoded0
        let hITReviewStatusDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.HITReviewStatus.self, forKey: .hITReviewStatus)
        hITReviewStatus = hITReviewStatusDecoded
        let numberOfAssignmentsPendingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssignmentsPending)
        numberOfAssignmentsPending = numberOfAssignmentsPendingDecoded
        let numberOfAssignmentsAvailableDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssignmentsAvailable)
        numberOfAssignmentsAvailable = numberOfAssignmentsAvailableDecoded
        let numberOfAssignmentsCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssignmentsCompleted)
        numberOfAssignmentsCompleted = numberOfAssignmentsCompletedDecoded
    }
}

extension MTurkClientTypes.HIT: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HIT(assignmentDurationInSeconds: \(Swift.String(describing: assignmentDurationInSeconds)), autoApprovalDelayInSeconds: \(Swift.String(describing: autoApprovalDelayInSeconds)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), expiration: \(Swift.String(describing: expiration)), hITGroupId: \(Swift.String(describing: hITGroupId)), hITId: \(Swift.String(describing: hITId)), hITLayoutId: \(Swift.String(describing: hITLayoutId)), hITReviewStatus: \(Swift.String(describing: hITReviewStatus)), hITStatus: \(Swift.String(describing: hITStatus)), hITTypeId: \(Swift.String(describing: hITTypeId)), keywords: \(Swift.String(describing: keywords)), maxAssignments: \(Swift.String(describing: maxAssignments)), numberOfAssignmentsAvailable: \(Swift.String(describing: numberOfAssignmentsAvailable)), numberOfAssignmentsCompleted: \(Swift.String(describing: numberOfAssignmentsCompleted)), numberOfAssignmentsPending: \(Swift.String(describing: numberOfAssignmentsPending)), qualificationRequirements: \(Swift.String(describing: qualificationRequirements)), question: \(Swift.String(describing: question)), requesterAnnotation: \(Swift.String(describing: requesterAnnotation)), reward: \(Swift.String(describing: reward)), title: \(Swift.String(describing: title)))"}
}

extension MTurkClientTypes {
    ///  The HIT data structure represents a single HIT, including
    ///             all the information necessary for a Worker to accept and complete the
    ///             HIT.
    public struct HIT: Swift.Equatable {
        ///  The length of time, in seconds, that a Worker has to
        ///             complete the HIT after accepting it.
        public let assignmentDurationInSeconds: Swift.Int?
        /// The amount of time, in seconds, after the Worker submits an
        ///             assignment for the HIT that the results are automatically approved by
        ///             Amazon Mechanical Turk. This is the amount of time the Requester has
        ///             to reject an assignment submitted by a Worker before the assignment
        ///             is auto-approved and the Worker is paid.
        ///
        public let autoApprovalDelayInSeconds: Swift.Int?
        ///  The date and time the HIT was created.
        public let creationTime: ClientRuntime.Date?
        ///  A general description of the HIT.
        public let description: Swift.String?
        /// The date and time the HIT expires.
        public let expiration: ClientRuntime.Date?
        ///  The ID of the HIT Group of this HIT.
        public let hITGroupId: Swift.String?
        ///  A unique identifier for the HIT.
        public let hITId: Swift.String?
        ///  The ID of the HIT Layout of this HIT.
        public let hITLayoutId: Swift.String?
        ///  Indicates the review status of the HIT. Valid Values are
        ///             NotReviewed | MarkedForReview | ReviewedAppropriate |
        ///             ReviewedInappropriate.
        public let hITReviewStatus: MTurkClientTypes.HITReviewStatus?
        /// The status of the HIT and its assignments. Valid Values are
        ///             Assignable | Unassignable | Reviewable | Reviewing | Disposed.
        ///
        public let hITStatus: MTurkClientTypes.HITStatus?
        /// The ID of the HIT type of this HIT
        public let hITTypeId: Swift.String?
        ///  One or more words or phrases that describe the HIT,
        ///             separated by commas. Search terms similar to the keywords of a HIT
        ///             are more likely to have the HIT in the search results.
        public let keywords: Swift.String?
        /// The number of times the HIT can be accepted and completed
        ///             before the HIT becomes unavailable.
        ///
        public let maxAssignments: Swift.Int?
        ///  The number of assignments for this HIT that are available
        ///             for Workers to accept.
        public let numberOfAssignmentsAvailable: Swift.Int?
        ///  The number of assignments for this HIT that have been
        ///             approved or rejected.
        public let numberOfAssignmentsCompleted: Swift.Int?
        ///  The number of assignments for this HIT that are being
        ///             previewed or have been accepted by Workers, but have not yet been
        ///             submitted, returned, or abandoned.
        public let numberOfAssignmentsPending: Swift.Int?
        ///
        ///             Conditions that a Worker's Qualifications must meet in order
        ///             to accept the HIT. A HIT can have between zero and ten
        ///             Qualification requirements. All requirements must be met in
        ///             order for a Worker to accept the HIT. Additionally, other
        ///             actions can be restricted using the ActionsGuarded
        ///             field on each QualificationRequirement structure.
        ///
        public let qualificationRequirements: [MTurkClientTypes.QualificationRequirement]?
        ///  The data the Worker completing the HIT uses produce the
        ///             results. This is either either a QuestionForm, HTMLQuestion or an
        ///             ExternalQuestion data structure.
        public let question: Swift.String?
        ///  An arbitrary data field the Requester who created the HIT
        ///             can use. This field is visible only to the creator of the HIT.
        public let requesterAnnotation: Swift.String?
        /// A string representing a currency amount.
        public let reward: Swift.String?
        ///  The title of the HIT.
        public let title: Swift.String?

        public init (
            assignmentDurationInSeconds: Swift.Int? = nil,
            autoApprovalDelayInSeconds: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            hITGroupId: Swift.String? = nil,
            hITId: Swift.String? = nil,
            hITLayoutId: Swift.String? = nil,
            hITReviewStatus: MTurkClientTypes.HITReviewStatus? = nil,
            hITStatus: MTurkClientTypes.HITStatus? = nil,
            hITTypeId: Swift.String? = nil,
            keywords: Swift.String? = nil,
            maxAssignments: Swift.Int? = nil,
            numberOfAssignmentsAvailable: Swift.Int? = nil,
            numberOfAssignmentsCompleted: Swift.Int? = nil,
            numberOfAssignmentsPending: Swift.Int? = nil,
            qualificationRequirements: [MTurkClientTypes.QualificationRequirement]? = nil,
            question: Swift.String? = nil,
            requesterAnnotation: Swift.String? = nil,
            reward: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.assignmentDurationInSeconds = assignmentDurationInSeconds
            self.autoApprovalDelayInSeconds = autoApprovalDelayInSeconds
            self.creationTime = creationTime
            self.description = description
            self.expiration = expiration
            self.hITGroupId = hITGroupId
            self.hITId = hITId
            self.hITLayoutId = hITLayoutId
            self.hITReviewStatus = hITReviewStatus
            self.hITStatus = hITStatus
            self.hITTypeId = hITTypeId
            self.keywords = keywords
            self.maxAssignments = maxAssignments
            self.numberOfAssignmentsAvailable = numberOfAssignmentsAvailable
            self.numberOfAssignmentsCompleted = numberOfAssignmentsCompleted
            self.numberOfAssignmentsPending = numberOfAssignmentsPending
            self.qualificationRequirements = qualificationRequirements
            self.question = question
            self.requesterAnnotation = requesterAnnotation
            self.reward = reward
            self.title = title
        }
    }

}

extension MTurkClientTypes {
    public enum HITAccessActions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accept
        case discoverpreviewandaccept
        case previewandaccept
        case sdkUnknown(Swift.String)

        public static var allCases: [HITAccessActions] {
            return [
                .accept,
                .discoverpreviewandaccept,
                .previewandaccept,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accept: return "Accept"
            case .discoverpreviewandaccept: return "DiscoverPreviewAndAccept"
            case .previewandaccept: return "PreviewAndAccept"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HITAccessActions(rawValue: rawValue) ?? HITAccessActions.sdkUnknown(rawValue)
        }
    }
}

extension MTurkClientTypes.HITLayoutParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MTurkClientTypes.HITLayoutParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HITLayoutParameter(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension MTurkClientTypes {
    ///  The HITLayoutParameter data structure defines parameter
    ///             values used with a HITLayout. A HITLayout is a reusable Amazon
    ///             Mechanical Turk project template used to provide Human Intelligence
    ///             Task (HIT) question data for CreateHIT.
    ///
    public struct HITLayoutParameter: Swift.Equatable {
        ///  The name of the parameter in the HITLayout.
        ///
        /// This member is required.
        public let name: Swift.String?
        /// The value substituted for the parameter referenced in the
        ///             HITLayout.
        ///
        /// This member is required.
        public let value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension MTurkClientTypes {
    public enum HITReviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case markedforreview
        case notreviewed
        case reviewedappropriate
        case reviewedinappropriate
        case sdkUnknown(Swift.String)

        public static var allCases: [HITReviewStatus] {
            return [
                .markedforreview,
                .notreviewed,
                .reviewedappropriate,
                .reviewedinappropriate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .markedforreview: return "MarkedForReview"
            case .notreviewed: return "NotReviewed"
            case .reviewedappropriate: return "ReviewedAppropriate"
            case .reviewedinappropriate: return "ReviewedInappropriate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HITReviewStatus(rawValue: rawValue) ?? HITReviewStatus.sdkUnknown(rawValue)
        }
    }
}

extension MTurkClientTypes {
    public enum HITStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assignable
        case disposed
        case reviewable
        case reviewing
        case unassignable
        case sdkUnknown(Swift.String)

        public static var allCases: [HITStatus] {
            return [
                .assignable,
                .disposed,
                .reviewable,
                .reviewing,
                .unassignable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assignable: return "Assignable"
            case .disposed: return "Disposed"
            case .reviewable: return "Reviewable"
            case .reviewing: return "Reviewing"
            case .unassignable: return "Unassignable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HITStatus(rawValue: rawValue) ?? HITStatus.sdkUnknown(rawValue)
        }
    }
}

public struct ListAssignmentsForHITInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssignmentsForHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssignmentsForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssignmentsForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssignmentsForHITOutputError>
}

extension ListAssignmentsForHITInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssignmentsForHITInput(assignmentStatuses: \(Swift.String(describing: assignmentStatuses)), hITId: \(Swift.String(describing: hITId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssignmentsForHITInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatuses = "AssignmentStatuses"
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentStatuses = assignmentStatuses {
            var assignmentStatusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assignmentStatuses)
            for assignmentstatuslist0 in assignmentStatuses {
                try assignmentStatusesContainer.encode(assignmentstatuslist0.rawValue)
            }
        }
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssignmentsForHITInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssignmentsForHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssignmentsForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssignmentsForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssignmentsForHITOutputError>
}

public struct ListAssignmentsForHITInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssignmentsForHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssignmentsForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssignmentsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssignmentsForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssignmentsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssignmentsForHITOutputError>
}

public struct ListAssignmentsForHITInput: Swift.Equatable {
    /// The status of the assignments to return: Submitted | Approved
    ///             | Rejected
    public let assignmentStatuses: [MTurkClientTypes.AssignmentStatus]?
    /// The ID of the HIT.
    /// This member is required.
    public let hITId: Swift.String?
    public let maxResults: Swift.Int?
    /// Pagination token
    public let nextToken: Swift.String?

    public init (
        assignmentStatuses: [MTurkClientTypes.AssignmentStatus]? = nil,
        hITId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assignmentStatuses = assignmentStatuses
        self.hITId = hITId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssignmentsForHITInputBody: Swift.Equatable {
    public let hITId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let assignmentStatuses: [MTurkClientTypes.AssignmentStatus]?
}

extension ListAssignmentsForHITInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatuses = "AssignmentStatuses"
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assignmentStatusesContainer = try containerValues.decodeIfPresent([MTurkClientTypes.AssignmentStatus?].self, forKey: .assignmentStatuses)
        var assignmentStatusesDecoded0:[MTurkClientTypes.AssignmentStatus]? = nil
        if let assignmentStatusesContainer = assignmentStatusesContainer {
            assignmentStatusesDecoded0 = [MTurkClientTypes.AssignmentStatus]()
            for string0 in assignmentStatusesContainer {
                if let string0 = string0 {
                    assignmentStatusesDecoded0?.append(string0)
                }
            }
        }
        assignmentStatuses = assignmentStatusesDecoded0
    }
}

extension ListAssignmentsForHITOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssignmentsForHITOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssignmentsForHITOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssignmentsForHITOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssignmentsForHITOutputResponse(assignments: \(Swift.String(describing: assignments)), nextToken: \(Swift.String(describing: nextToken)), numResults: \(Swift.String(describing: numResults)))"}
}

extension ListAssignmentsForHITOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssignmentsForHITOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assignments = output.assignments
            self.nextToken = output.nextToken
            self.numResults = output.numResults
        } else {
            self.assignments = nil
            self.nextToken = nil
            self.numResults = nil
        }
    }
}

public struct ListAssignmentsForHITOutputResponse: Swift.Equatable {
    ///  The collection of Assignment data structures returned by
    ///             this call.
    public let assignments: [MTurkClientTypes.Assignment]?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    ///  The number of assignments on the page in the filtered
    ///             results list, equivalent to the number of assignments returned by
    ///             this call.
    public let numResults: Swift.Int?

    public init (
        assignments: [MTurkClientTypes.Assignment]? = nil,
        nextToken: Swift.String? = nil,
        numResults: Swift.Int? = nil
    )
    {
        self.assignments = assignments
        self.nextToken = nextToken
        self.numResults = numResults
    }
}

struct ListAssignmentsForHITOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let numResults: Swift.Int?
    public let assignments: [MTurkClientTypes.Assignment]?
}

extension ListAssignmentsForHITOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignments = "Assignments"
        case nextToken = "NextToken"
        case numResults = "NumResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let assignmentsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.Assignment?].self, forKey: .assignments)
        var assignmentsDecoded0:[MTurkClientTypes.Assignment]? = nil
        if let assignmentsContainer = assignmentsContainer {
            assignmentsDecoded0 = [MTurkClientTypes.Assignment]()
            for structure0 in assignmentsContainer {
                if let structure0 = structure0 {
                    assignmentsDecoded0?.append(structure0)
                }
            }
        }
        assignments = assignmentsDecoded0
    }
}

public struct ListBonusPaymentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBonusPaymentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBonusPaymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBonusPaymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBonusPaymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBonusPaymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBonusPaymentsOutputError>
}

extension ListBonusPaymentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBonusPaymentsInput(assignmentId: \(Swift.String(describing: assignmentId)), hITId: \(Swift.String(describing: hITId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBonusPaymentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListBonusPaymentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBonusPaymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBonusPaymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBonusPaymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBonusPaymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBonusPaymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBonusPaymentsOutputError>
}

public struct ListBonusPaymentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBonusPaymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBonusPaymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBonusPaymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBonusPaymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBonusPaymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBonusPaymentsOutputError>
}

public struct ListBonusPaymentsInput: Swift.Equatable {
    /// The ID of the assignment associated with the bonus payments
    ///             to retrieve. If specified, only bonus payments for the given
    ///             assignment are returned. Either the HITId parameter or the
    ///             AssignmentId parameter must be specified
    public let assignmentId: Swift.String?
    /// The ID of the HIT associated with the bonus payments to
    ///             retrieve. If not specified, all bonus payments for all assignments
    ///             for the given HIT are returned. Either the HITId parameter or the
    ///             AssignmentId parameter must be specified
    public let hITId: Swift.String?
    public let maxResults: Swift.Int?
    /// Pagination token
    public let nextToken: Swift.String?

    public init (
        assignmentId: Swift.String? = nil,
        hITId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.hITId = hITId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBonusPaymentsInputBody: Swift.Equatable {
    public let hITId: Swift.String?
    public let assignmentId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListBonusPaymentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBonusPaymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBonusPaymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBonusPaymentsOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBonusPaymentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBonusPaymentsOutputResponse(bonusPayments: \(Swift.String(describing: bonusPayments)), nextToken: \(Swift.String(describing: nextToken)), numResults: \(Swift.String(describing: numResults)))"}
}

extension ListBonusPaymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBonusPaymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bonusPayments = output.bonusPayments
            self.nextToken = output.nextToken
            self.numResults = output.numResults
        } else {
            self.bonusPayments = nil
            self.nextToken = nil
            self.numResults = nil
        }
    }
}

public struct ListBonusPaymentsOutputResponse: Swift.Equatable {
    /// A successful request to the ListBonusPayments operation
    ///             returns a list of BonusPayment objects.
    ///
    public let bonusPayments: [MTurkClientTypes.BonusPayment]?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    /// The number of bonus payments on this page in the filtered
    ///             results list, equivalent to the number of bonus payments being
    ///             returned by this call.
    ///
    public let numResults: Swift.Int?

    public init (
        bonusPayments: [MTurkClientTypes.BonusPayment]? = nil,
        nextToken: Swift.String? = nil,
        numResults: Swift.Int? = nil
    )
    {
        self.bonusPayments = bonusPayments
        self.nextToken = nextToken
        self.numResults = numResults
    }
}

struct ListBonusPaymentsOutputResponseBody: Swift.Equatable {
    public let numResults: Swift.Int?
    public let nextToken: Swift.String?
    public let bonusPayments: [MTurkClientTypes.BonusPayment]?
}

extension ListBonusPaymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bonusPayments = "BonusPayments"
        case nextToken = "NextToken"
        case numResults = "NumResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let bonusPaymentsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.BonusPayment?].self, forKey: .bonusPayments)
        var bonusPaymentsDecoded0:[MTurkClientTypes.BonusPayment]? = nil
        if let bonusPaymentsContainer = bonusPaymentsContainer {
            bonusPaymentsDecoded0 = [MTurkClientTypes.BonusPayment]()
            for structure0 in bonusPaymentsContainer {
                if let structure0 = structure0 {
                    bonusPaymentsDecoded0?.append(structure0)
                }
            }
        }
        bonusPayments = bonusPaymentsDecoded0
    }
}

public struct ListHITsForQualificationTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHITsForQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHITsForQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHITsForQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHITsForQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHITsForQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHITsForQualificationTypeOutputError>
}

extension ListHITsForQualificationTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHITsForQualificationTypeInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), qualificationTypeId: \(Swift.String(describing: qualificationTypeId)))"}
}

extension ListHITsForQualificationTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
    }
}

public struct ListHITsForQualificationTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHITsForQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHITsForQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHITsForQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHITsForQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHITsForQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHITsForQualificationTypeOutputError>
}

public struct ListHITsForQualificationTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHITsForQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHITsForQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHITsForQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHITsForQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHITsForQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHITsForQualificationTypeOutputError>
}

public struct ListHITsForQualificationTypeInput: Swift.Equatable {
    ///
    ///             Limit the number of results returned.
    ///
    public let maxResults: Swift.Int?
    /// Pagination Token
    public let nextToken: Swift.String?
    ///
    ///             The ID of the Qualification type to use when querying HITs.
    ///
    /// This member is required.
    public let qualificationTypeId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        qualificationTypeId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.qualificationTypeId = qualificationTypeId
    }
}

struct ListHITsForQualificationTypeInputBody: Swift.Equatable {
    public let qualificationTypeId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListHITsForQualificationTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListHITsForQualificationTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHITsForQualificationTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHITsForQualificationTypeOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHITsForQualificationTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHITsForQualificationTypeOutputResponse(hITs: \(Swift.String(describing: hITs)), nextToken: \(Swift.String(describing: nextToken)), numResults: \(Swift.String(describing: numResults)))"}
}

extension ListHITsForQualificationTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHITsForQualificationTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hITs = output.hITs
            self.nextToken = output.nextToken
            self.numResults = output.numResults
        } else {
            self.hITs = nil
            self.nextToken = nil
            self.numResults = nil
        }
    }
}

public struct ListHITsForQualificationTypeOutputResponse: Swift.Equatable {
    ///  The list of HIT elements returned by the query.
    public let hITs: [MTurkClientTypes.HIT]?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    ///  The number of HITs on this page in the filtered results
    ///             list, equivalent to the number of HITs being returned by this call.	
    public let numResults: Swift.Int?

    public init (
        hITs: [MTurkClientTypes.HIT]? = nil,
        nextToken: Swift.String? = nil,
        numResults: Swift.Int? = nil
    )
    {
        self.hITs = hITs
        self.nextToken = nextToken
        self.numResults = numResults
    }
}

struct ListHITsForQualificationTypeOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let numResults: Swift.Int?
    public let hITs: [MTurkClientTypes.HIT]?
}

extension ListHITsForQualificationTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITs = "HITs"
        case nextToken = "NextToken"
        case numResults = "NumResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let hITsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.HIT?].self, forKey: .hITs)
        var hITsDecoded0:[MTurkClientTypes.HIT]? = nil
        if let hITsContainer = hITsContainer {
            hITsDecoded0 = [MTurkClientTypes.HIT]()
            for structure0 in hITsContainer {
                if let structure0 = structure0 {
                    hITsDecoded0?.append(structure0)
                }
            }
        }
        hITs = hITsDecoded0
    }
}

public struct ListHITsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHITsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHITsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHITsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHITsOutputError>
}

extension ListHITsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHITsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListHITsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListHITsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHITsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHITsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHITsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHITsOutputError>
}

public struct ListHITsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHITsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHITsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHITsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHITsOutputError>
}

public struct ListHITsInput: Swift.Equatable {
    public let maxResults: Swift.Int?
    /// Pagination token
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHITsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListHITsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListHITsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHITsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHITsOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHITsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHITsOutputResponse(hITs: \(Swift.String(describing: hITs)), nextToken: \(Swift.String(describing: nextToken)), numResults: \(Swift.String(describing: numResults)))"}
}

extension ListHITsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHITsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hITs = output.hITs
            self.nextToken = output.nextToken
            self.numResults = output.numResults
        } else {
            self.hITs = nil
            self.nextToken = nil
            self.numResults = nil
        }
    }
}

public struct ListHITsOutputResponse: Swift.Equatable {
    ///  The list of HIT elements returned by the query.
    public let hITs: [MTurkClientTypes.HIT]?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    /// The number of HITs on this page in the filtered results list,
    ///             equivalent to the number of HITs being returned by this call.
    public let numResults: Swift.Int?

    public init (
        hITs: [MTurkClientTypes.HIT]? = nil,
        nextToken: Swift.String? = nil,
        numResults: Swift.Int? = nil
    )
    {
        self.hITs = hITs
        self.nextToken = nextToken
        self.numResults = numResults
    }
}

struct ListHITsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let numResults: Swift.Int?
    public let hITs: [MTurkClientTypes.HIT]?
}

extension ListHITsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITs = "HITs"
        case nextToken = "NextToken"
        case numResults = "NumResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let hITsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.HIT?].self, forKey: .hITs)
        var hITsDecoded0:[MTurkClientTypes.HIT]? = nil
        if let hITsContainer = hITsContainer {
            hITsDecoded0 = [MTurkClientTypes.HIT]()
            for structure0 in hITsContainer {
                if let structure0 = structure0 {
                    hITsDecoded0?.append(structure0)
                }
            }
        }
        hITs = hITsDecoded0
    }
}

public struct ListQualificationRequestsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListQualificationRequestsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListQualificationRequestsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListQualificationRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListQualificationRequestsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListQualificationRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListQualificationRequestsOutputError>
}

extension ListQualificationRequestsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListQualificationRequestsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), qualificationTypeId: \(Swift.String(describing: qualificationTypeId)))"}
}

extension ListQualificationRequestsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
    }
}

public struct ListQualificationRequestsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListQualificationRequestsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListQualificationRequestsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListQualificationRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListQualificationRequestsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListQualificationRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListQualificationRequestsOutputError>
}

public struct ListQualificationRequestsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListQualificationRequestsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListQualificationRequestsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListQualificationRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListQualificationRequestsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListQualificationRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListQualificationRequestsOutputError>
}

public struct ListQualificationRequestsInput: Swift.Equatable {
    ///  The maximum number of results to return in a single call.
    ///
    public let maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    /// The ID of the QualificationType.
    public let qualificationTypeId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        qualificationTypeId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.qualificationTypeId = qualificationTypeId
    }
}

struct ListQualificationRequestsInputBody: Swift.Equatable {
    public let qualificationTypeId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListQualificationRequestsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListQualificationRequestsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQualificationRequestsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQualificationRequestsOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQualificationRequestsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListQualificationRequestsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), numResults: \(Swift.String(describing: numResults)), qualificationRequests: \(Swift.String(describing: qualificationRequests)))"}
}

extension ListQualificationRequestsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListQualificationRequestsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.numResults = output.numResults
            self.qualificationRequests = output.qualificationRequests
        } else {
            self.nextToken = nil
            self.numResults = nil
            self.qualificationRequests = nil
        }
    }
}

public struct ListQualificationRequestsOutputResponse: Swift.Equatable {
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    /// The number of Qualification requests on this page in the filtered results list,
    ///             equivalent to the number of Qualification requests being returned by this call.
    public let numResults: Swift.Int?
    /// The Qualification request. The response includes one
    ///             QualificationRequest element
    ///             for each Qualification request returned
    ///             by the query.
    public let qualificationRequests: [MTurkClientTypes.QualificationRequest]?

    public init (
        nextToken: Swift.String? = nil,
        numResults: Swift.Int? = nil,
        qualificationRequests: [MTurkClientTypes.QualificationRequest]? = nil
    )
    {
        self.nextToken = nextToken
        self.numResults = numResults
        self.qualificationRequests = qualificationRequests
    }
}

struct ListQualificationRequestsOutputResponseBody: Swift.Equatable {
    public let numResults: Swift.Int?
    public let nextToken: Swift.String?
    public let qualificationRequests: [MTurkClientTypes.QualificationRequest]?
}

extension ListQualificationRequestsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case numResults = "NumResults"
        case qualificationRequests = "QualificationRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let qualificationRequestsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.QualificationRequest?].self, forKey: .qualificationRequests)
        var qualificationRequestsDecoded0:[MTurkClientTypes.QualificationRequest]? = nil
        if let qualificationRequestsContainer = qualificationRequestsContainer {
            qualificationRequestsDecoded0 = [MTurkClientTypes.QualificationRequest]()
            for structure0 in qualificationRequestsContainer {
                if let structure0 = structure0 {
                    qualificationRequestsDecoded0?.append(structure0)
                }
            }
        }
        qualificationRequests = qualificationRequestsDecoded0
    }
}

public struct ListQualificationTypesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListQualificationTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListQualificationTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListQualificationTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListQualificationTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListQualificationTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListQualificationTypesOutputError>
}

extension ListQualificationTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListQualificationTypesInput(maxResults: \(Swift.String(describing: maxResults)), mustBeOwnedByCaller: \(Swift.String(describing: mustBeOwnedByCaller)), mustBeRequestable: \(Swift.String(describing: mustBeRequestable)), nextToken: \(Swift.String(describing: nextToken)), query: \(Swift.String(describing: query)))"}
}

extension ListQualificationTypesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case mustBeOwnedByCaller = "MustBeOwnedByCaller"
        case mustBeRequestable = "MustBeRequestable"
        case nextToken = "NextToken"
        case query = "Query"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let mustBeOwnedByCaller = mustBeOwnedByCaller {
            try encodeContainer.encode(mustBeOwnedByCaller, forKey: .mustBeOwnedByCaller)
        }
        if let mustBeRequestable = mustBeRequestable {
            try encodeContainer.encode(mustBeRequestable, forKey: .mustBeRequestable)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let query = query {
            try encodeContainer.encode(query, forKey: .query)
        }
    }
}

public struct ListQualificationTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListQualificationTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListQualificationTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListQualificationTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListQualificationTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListQualificationTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListQualificationTypesOutputError>
}

public struct ListQualificationTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListQualificationTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListQualificationTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListQualificationTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListQualificationTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListQualificationTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListQualificationTypesOutputError>
}

public struct ListQualificationTypesInput: Swift.Equatable {
    ///  The maximum number of results to return in a single call.
    ///
    public let maxResults: Swift.Int?
    ///  Specifies that only Qualification types that the Requester
    ///             created are returned. If false, the operation returns all
    ///             Qualification types.
    ///
    public let mustBeOwnedByCaller: Swift.Bool?
    /// Specifies that only Qualification types that a user can
    ///             request through the Amazon Mechanical Turk web site, such as by
    ///             taking a Qualification test, are returned as results of the search.
    ///             Some Qualification types, such as those assigned automatically by the
    ///             system, cannot be requested directly by users. If false, all
    ///             Qualification types, including those managed by the system, are
    ///             considered. Valid values are True | False.
    ///
    /// This member is required.
    public let mustBeRequestable: Swift.Bool?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    ///  A text query against all of the searchable attributes of
    ///             Qualification types.
    ///
    public let query: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        mustBeOwnedByCaller: Swift.Bool? = nil,
        mustBeRequestable: Swift.Bool? = nil,
        nextToken: Swift.String? = nil,
        query: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.mustBeOwnedByCaller = mustBeOwnedByCaller
        self.mustBeRequestable = mustBeRequestable
        self.nextToken = nextToken
        self.query = query
    }
}

struct ListQualificationTypesInputBody: Swift.Equatable {
    public let query: Swift.String?
    public let mustBeRequestable: Swift.Bool?
    public let mustBeOwnedByCaller: Swift.Bool?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListQualificationTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case mustBeOwnedByCaller = "MustBeOwnedByCaller"
        case mustBeRequestable = "MustBeRequestable"
        case nextToken = "NextToken"
        case query = "Query"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .query)
        query = queryDecoded
        let mustBeRequestableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustBeRequestable)
        mustBeRequestable = mustBeRequestableDecoded
        let mustBeOwnedByCallerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustBeOwnedByCaller)
        mustBeOwnedByCaller = mustBeOwnedByCallerDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListQualificationTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQualificationTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQualificationTypesOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQualificationTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListQualificationTypesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), numResults: \(Swift.String(describing: numResults)), qualificationTypes: \(Swift.String(describing: qualificationTypes)))"}
}

extension ListQualificationTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListQualificationTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.numResults = output.numResults
            self.qualificationTypes = output.qualificationTypes
        } else {
            self.nextToken = nil
            self.numResults = nil
            self.qualificationTypes = nil
        }
    }
}

public struct ListQualificationTypesOutputResponse: Swift.Equatable {
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    ///  The number of Qualification types on this page in the
    ///             filtered results list, equivalent to the number of types this
    ///             operation returns.
    ///
    public let numResults: Swift.Int?
    ///  The list of QualificationType elements returned by the
    ///             query.
    ///
    public let qualificationTypes: [MTurkClientTypes.QualificationType]?

    public init (
        nextToken: Swift.String? = nil,
        numResults: Swift.Int? = nil,
        qualificationTypes: [MTurkClientTypes.QualificationType]? = nil
    )
    {
        self.nextToken = nextToken
        self.numResults = numResults
        self.qualificationTypes = qualificationTypes
    }
}

struct ListQualificationTypesOutputResponseBody: Swift.Equatable {
    public let numResults: Swift.Int?
    public let nextToken: Swift.String?
    public let qualificationTypes: [MTurkClientTypes.QualificationType]?
}

extension ListQualificationTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case numResults = "NumResults"
        case qualificationTypes = "QualificationTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let qualificationTypesContainer = try containerValues.decodeIfPresent([MTurkClientTypes.QualificationType?].self, forKey: .qualificationTypes)
        var qualificationTypesDecoded0:[MTurkClientTypes.QualificationType]? = nil
        if let qualificationTypesContainer = qualificationTypesContainer {
            qualificationTypesDecoded0 = [MTurkClientTypes.QualificationType]()
            for structure0 in qualificationTypesContainer {
                if let structure0 = structure0 {
                    qualificationTypesDecoded0?.append(structure0)
                }
            }
        }
        qualificationTypes = qualificationTypesDecoded0
    }
}

public struct ListReviewPolicyResultsForHITInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReviewPolicyResultsForHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReviewPolicyResultsForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReviewPolicyResultsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReviewPolicyResultsForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReviewPolicyResultsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReviewPolicyResultsForHITOutputError>
}

extension ListReviewPolicyResultsForHITInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReviewPolicyResultsForHITInput(hITId: \(Swift.String(describing: hITId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), policyLevels: \(Swift.String(describing: policyLevels)), retrieveActions: \(Swift.String(describing: retrieveActions)), retrieveResults: \(Swift.String(describing: retrieveResults)))"}
}

extension ListReviewPolicyResultsForHITInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyLevels = "PolicyLevels"
        case retrieveActions = "RetrieveActions"
        case retrieveResults = "RetrieveResults"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyLevels = policyLevels {
            var policyLevelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyLevels)
            for reviewpolicylevellist0 in policyLevels {
                try policyLevelsContainer.encode(reviewpolicylevellist0.rawValue)
            }
        }
        if let retrieveActions = retrieveActions {
            try encodeContainer.encode(retrieveActions, forKey: .retrieveActions)
        }
        if let retrieveResults = retrieveResults {
            try encodeContainer.encode(retrieveResults, forKey: .retrieveResults)
        }
    }
}

public struct ListReviewPolicyResultsForHITInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReviewPolicyResultsForHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReviewPolicyResultsForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReviewPolicyResultsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReviewPolicyResultsForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReviewPolicyResultsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReviewPolicyResultsForHITOutputError>
}

public struct ListReviewPolicyResultsForHITInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReviewPolicyResultsForHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReviewPolicyResultsForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReviewPolicyResultsForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReviewPolicyResultsForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReviewPolicyResultsForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReviewPolicyResultsForHITOutputError>
}

public struct ListReviewPolicyResultsForHITInput: Swift.Equatable {
    /// The unique identifier of the HIT to retrieve review results for.
    /// This member is required.
    public let hITId: Swift.String?
    /// Limit the number of results returned.
    public let maxResults: Swift.Int?
    /// Pagination token
    public let nextToken: Swift.String?
    ///
    ///             The Policy Level(s) to retrieve review results for - HIT or Assignment.
    ///             If omitted, the default behavior is to retrieve all data for both policy levels.
    ///             For a list of all the described policies, see Review Policies.
    ///
    public let policyLevels: [MTurkClientTypes.ReviewPolicyLevel]?
    ///
    ///             Specify if the operation should retrieve a list of the actions taken executing
    ///             the Review Policies and their outcomes.
    ///
    public let retrieveActions: Swift.Bool?
    ///
    ///             Specify if the operation should retrieve a list of the results computed by the Review Policies.
    ///
    public let retrieveResults: Swift.Bool?

    public init (
        hITId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyLevels: [MTurkClientTypes.ReviewPolicyLevel]? = nil,
        retrieveActions: Swift.Bool? = nil,
        retrieveResults: Swift.Bool? = nil
    )
    {
        self.hITId = hITId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyLevels = policyLevels
        self.retrieveActions = retrieveActions
        self.retrieveResults = retrieveResults
    }
}

struct ListReviewPolicyResultsForHITInputBody: Swift.Equatable {
    public let hITId: Swift.String?
    public let policyLevels: [MTurkClientTypes.ReviewPolicyLevel]?
    public let retrieveActions: Swift.Bool?
    public let retrieveResults: Swift.Bool?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListReviewPolicyResultsForHITInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyLevels = "PolicyLevels"
        case retrieveActions = "RetrieveActions"
        case retrieveResults = "RetrieveResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let policyLevelsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.ReviewPolicyLevel?].self, forKey: .policyLevels)
        var policyLevelsDecoded0:[MTurkClientTypes.ReviewPolicyLevel]? = nil
        if let policyLevelsContainer = policyLevelsContainer {
            policyLevelsDecoded0 = [MTurkClientTypes.ReviewPolicyLevel]()
            for string0 in policyLevelsContainer {
                if let string0 = string0 {
                    policyLevelsDecoded0?.append(string0)
                }
            }
        }
        policyLevels = policyLevelsDecoded0
        let retrieveActionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retrieveActions)
        retrieveActions = retrieveActionsDecoded
        let retrieveResultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retrieveResults)
        retrieveResults = retrieveResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReviewPolicyResultsForHITOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReviewPolicyResultsForHITOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReviewPolicyResultsForHITOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReviewPolicyResultsForHITOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReviewPolicyResultsForHITOutputResponse(assignmentReviewPolicy: \(Swift.String(describing: assignmentReviewPolicy)), assignmentReviewReport: \(Swift.String(describing: assignmentReviewReport)), hITId: \(Swift.String(describing: hITId)), hITReviewPolicy: \(Swift.String(describing: hITReviewPolicy)), hITReviewReport: \(Swift.String(describing: hITReviewReport)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListReviewPolicyResultsForHITOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListReviewPolicyResultsForHITOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assignmentReviewPolicy = output.assignmentReviewPolicy
            self.assignmentReviewReport = output.assignmentReviewReport
            self.hITId = output.hITId
            self.hITReviewPolicy = output.hITReviewPolicy
            self.hITReviewReport = output.hITReviewReport
            self.nextToken = output.nextToken
        } else {
            self.assignmentReviewPolicy = nil
            self.assignmentReviewReport = nil
            self.hITId = nil
            self.hITReviewPolicy = nil
            self.hITReviewReport = nil
            self.nextToken = nil
        }
    }
}

public struct ListReviewPolicyResultsForHITOutputResponse: Swift.Equatable {
    ///  The name of the Assignment-level Review Policy. This
    ///             contains only the PolicyName element.
    ///
    public let assignmentReviewPolicy: MTurkClientTypes.ReviewPolicy?
    ///  Contains both ReviewResult and ReviewAction elements for an
    ///             Assignment.
    ///
    public let assignmentReviewReport: MTurkClientTypes.ReviewReport?
    /// The HITId of the HIT for which results have been returned.
    public let hITId: Swift.String?
    /// The name of the HIT-level Review Policy. This contains only
    ///             the PolicyName element.
    public let hITReviewPolicy: MTurkClientTypes.ReviewPolicy?
    /// Contains both ReviewResult and ReviewAction elements for a particular HIT.
    ///
    public let hITReviewReport: MTurkClientTypes.ReviewReport?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?

    public init (
        assignmentReviewPolicy: MTurkClientTypes.ReviewPolicy? = nil,
        assignmentReviewReport: MTurkClientTypes.ReviewReport? = nil,
        hITId: Swift.String? = nil,
        hITReviewPolicy: MTurkClientTypes.ReviewPolicy? = nil,
        hITReviewReport: MTurkClientTypes.ReviewReport? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assignmentReviewPolicy = assignmentReviewPolicy
        self.assignmentReviewReport = assignmentReviewReport
        self.hITId = hITId
        self.hITReviewPolicy = hITReviewPolicy
        self.hITReviewReport = hITReviewReport
        self.nextToken = nextToken
    }
}

struct ListReviewPolicyResultsForHITOutputResponseBody: Swift.Equatable {
    public let hITId: Swift.String?
    public let assignmentReviewPolicy: MTurkClientTypes.ReviewPolicy?
    public let hITReviewPolicy: MTurkClientTypes.ReviewPolicy?
    public let assignmentReviewReport: MTurkClientTypes.ReviewReport?
    public let hITReviewReport: MTurkClientTypes.ReviewReport?
    public let nextToken: Swift.String?
}

extension ListReviewPolicyResultsForHITOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentReviewPolicy = "AssignmentReviewPolicy"
        case assignmentReviewReport = "AssignmentReviewReport"
        case hITId = "HITId"
        case hITReviewPolicy = "HITReviewPolicy"
        case hITReviewReport = "HITReviewReport"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let assignmentReviewPolicyDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.ReviewPolicy.self, forKey: .assignmentReviewPolicy)
        assignmentReviewPolicy = assignmentReviewPolicyDecoded
        let hITReviewPolicyDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.ReviewPolicy.self, forKey: .hITReviewPolicy)
        hITReviewPolicy = hITReviewPolicyDecoded
        let assignmentReviewReportDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.ReviewReport.self, forKey: .assignmentReviewReport)
        assignmentReviewReport = assignmentReviewReportDecoded
        let hITReviewReportDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.ReviewReport.self, forKey: .hITReviewReport)
        hITReviewReport = hITReviewReportDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListReviewableHITsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReviewableHITsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReviewableHITsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReviewableHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReviewableHITsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReviewableHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReviewableHITsOutputError>
}

extension ListReviewableHITsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReviewableHITsInput(hITTypeId: \(Swift.String(describing: hITTypeId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), status: \(Swift.String(describing: status)))"}
}

extension ListReviewableHITsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITTypeId = "HITTypeId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITTypeId = hITTypeId {
            try encodeContainer.encode(hITTypeId, forKey: .hITTypeId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListReviewableHITsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReviewableHITsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReviewableHITsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReviewableHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReviewableHITsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReviewableHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReviewableHITsOutputError>
}

public struct ListReviewableHITsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReviewableHITsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReviewableHITsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReviewableHITsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReviewableHITsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReviewableHITsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReviewableHITsOutputError>
}

public struct ListReviewableHITsInput: Swift.Equatable {
    ///
    ///             The ID of the HIT type of the HITs to consider for the query.
    ///             If not specified, all HITs for the Reviewer are considered
    ///
    public let hITTypeId: Swift.String?
    ///
    ///             Limit the number of results returned.
    ///
    public let maxResults: Swift.Int?
    /// Pagination Token
    public let nextToken: Swift.String?
    ///
    ///             Can be either Reviewable or Reviewing.
    ///             Reviewable is the default value.
    ///
    public let status: MTurkClientTypes.ReviewableHITStatus?

    public init (
        hITTypeId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: MTurkClientTypes.ReviewableHITStatus? = nil
    )
    {
        self.hITTypeId = hITTypeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListReviewableHITsInputBody: Swift.Equatable {
    public let hITTypeId: Swift.String?
    public let status: MTurkClientTypes.ReviewableHITStatus?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListReviewableHITsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITTypeId = "HITTypeId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.ReviewableHITStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReviewableHITsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReviewableHITsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReviewableHITsOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReviewableHITsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReviewableHITsOutputResponse(hITs: \(Swift.String(describing: hITs)), nextToken: \(Swift.String(describing: nextToken)), numResults: \(Swift.String(describing: numResults)))"}
}

extension ListReviewableHITsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListReviewableHITsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hITs = output.hITs
            self.nextToken = output.nextToken
            self.numResults = output.numResults
        } else {
            self.hITs = nil
            self.nextToken = nil
            self.numResults = nil
        }
    }
}

public struct ListReviewableHITsOutputResponse: Swift.Equatable {
    ///  The list of HIT elements returned by the query.
    public let hITs: [MTurkClientTypes.HIT]?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    ///  The number of HITs on this page in the filtered results
    ///             list, equivalent to the number of HITs being returned by this call.
    ///
    public let numResults: Swift.Int?

    public init (
        hITs: [MTurkClientTypes.HIT]? = nil,
        nextToken: Swift.String? = nil,
        numResults: Swift.Int? = nil
    )
    {
        self.hITs = hITs
        self.nextToken = nextToken
        self.numResults = numResults
    }
}

struct ListReviewableHITsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let numResults: Swift.Int?
    public let hITs: [MTurkClientTypes.HIT]?
}

extension ListReviewableHITsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITs = "HITs"
        case nextToken = "NextToken"
        case numResults = "NumResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let hITsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.HIT?].self, forKey: .hITs)
        var hITsDecoded0:[MTurkClientTypes.HIT]? = nil
        if let hITsContainer = hITsContainer {
            hITsDecoded0 = [MTurkClientTypes.HIT]()
            for structure0 in hITsContainer {
                if let structure0 = structure0 {
                    hITsDecoded0?.append(structure0)
                }
            }
        }
        hITs = hITsDecoded0
    }
}

public struct ListWorkerBlocksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkerBlocksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkerBlocksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkerBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkerBlocksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkerBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkerBlocksOutputError>
}

extension ListWorkerBlocksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkerBlocksInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListWorkerBlocksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorkerBlocksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkerBlocksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkerBlocksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkerBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkerBlocksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkerBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkerBlocksOutputError>
}

public struct ListWorkerBlocksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkerBlocksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkerBlocksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkerBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkerBlocksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkerBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkerBlocksOutputError>
}

public struct ListWorkerBlocksInput: Swift.Equatable {
    public let maxResults: Swift.Int?
    /// Pagination token
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkerBlocksInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListWorkerBlocksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkerBlocksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkerBlocksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkerBlocksOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkerBlocksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkerBlocksOutputResponse(nextToken: \(Swift.String(describing: nextToken)), numResults: \(Swift.String(describing: numResults)), workerBlocks: \(Swift.String(describing: workerBlocks)))"}
}

extension ListWorkerBlocksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkerBlocksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.numResults = output.numResults
            self.workerBlocks = output.workerBlocks
        } else {
            self.nextToken = nil
            self.numResults = nil
            self.workerBlocks = nil
        }
    }
}

public struct ListWorkerBlocksOutputResponse: Swift.Equatable {
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    ///  The number of assignments on the page in the filtered
    ///             results list, equivalent to the number of assignments returned by
    ///             this call.
    public let numResults: Swift.Int?
    ///  The list of WorkerBlocks, containing the collection of
    ///             Worker IDs and reasons for blocking.
    public let workerBlocks: [MTurkClientTypes.WorkerBlock]?

    public init (
        nextToken: Swift.String? = nil,
        numResults: Swift.Int? = nil,
        workerBlocks: [MTurkClientTypes.WorkerBlock]? = nil
    )
    {
        self.nextToken = nextToken
        self.numResults = numResults
        self.workerBlocks = workerBlocks
    }
}

struct ListWorkerBlocksOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let numResults: Swift.Int?
    public let workerBlocks: [MTurkClientTypes.WorkerBlock]?
}

extension ListWorkerBlocksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case numResults = "NumResults"
        case workerBlocks = "WorkerBlocks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let workerBlocksContainer = try containerValues.decodeIfPresent([MTurkClientTypes.WorkerBlock?].self, forKey: .workerBlocks)
        var workerBlocksDecoded0:[MTurkClientTypes.WorkerBlock]? = nil
        if let workerBlocksContainer = workerBlocksContainer {
            workerBlocksDecoded0 = [MTurkClientTypes.WorkerBlock]()
            for structure0 in workerBlocksContainer {
                if let structure0 = structure0 {
                    workerBlocksDecoded0?.append(structure0)
                }
            }
        }
        workerBlocks = workerBlocksDecoded0
    }
}

public struct ListWorkersWithQualificationTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkersWithQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkersWithQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkersWithQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkersWithQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkersWithQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkersWithQualificationTypeOutputError>
}

extension ListWorkersWithQualificationTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkersWithQualificationTypeInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), qualificationTypeId: \(Swift.String(describing: qualificationTypeId)), status: \(Swift.String(describing: status)))"}
}

extension ListWorkersWithQualificationTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListWorkersWithQualificationTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkersWithQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkersWithQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkersWithQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkersWithQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkersWithQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkersWithQualificationTypeOutputError>
}

public struct ListWorkersWithQualificationTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkersWithQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkersWithQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkersWithQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkersWithQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkersWithQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkersWithQualificationTypeOutputError>
}

public struct ListWorkersWithQualificationTypeInput: Swift.Equatable {
    ///
    ///             Limit the number of results returned.
    ///
    public let maxResults: Swift.Int?
    /// Pagination Token
    public let nextToken: Swift.String?
    /// The ID of the Qualification type of the Qualifications to
    ///             return.
    /// This member is required.
    public let qualificationTypeId: Swift.String?
    ///
    ///             The status of the Qualifications to return.
    ///             Can be Granted | Revoked.
    ///
    public let status: MTurkClientTypes.QualificationStatus?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        qualificationTypeId: Swift.String? = nil,
        status: MTurkClientTypes.QualificationStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.qualificationTypeId = qualificationTypeId
        self.status = status
    }
}

struct ListWorkersWithQualificationTypeInputBody: Swift.Equatable {
    public let qualificationTypeId: Swift.String?
    public let status: MTurkClientTypes.QualificationStatus?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListWorkersWithQualificationTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case qualificationTypeId = "QualificationTypeId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.QualificationStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkersWithQualificationTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkersWithQualificationTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkersWithQualificationTypeOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkersWithQualificationTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkersWithQualificationTypeOutputResponse(nextToken: \(Swift.String(describing: nextToken)), numResults: \(Swift.String(describing: numResults)), qualifications: \(Swift.String(describing: qualifications)))"}
}

extension ListWorkersWithQualificationTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkersWithQualificationTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.numResults = output.numResults
            self.qualifications = output.qualifications
        } else {
            self.nextToken = nil
            self.numResults = nil
            self.qualifications = nil
        }
    }
}

public struct ListWorkersWithQualificationTypeOutputResponse: Swift.Equatable {
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
    ///             returns a pagination token in the response. You can use this pagination token
    ///             to retrieve the next set of results.
    ///
    public let nextToken: Swift.String?
    ///  The number of Qualifications on this page in the filtered
    ///             results list, equivalent to the number of Qualifications being
    ///             returned by this call.
    public let numResults: Swift.Int?
    ///  The list of Qualification elements returned by this call.
    ///
    public let qualifications: [MTurkClientTypes.Qualification]?

    public init (
        nextToken: Swift.String? = nil,
        numResults: Swift.Int? = nil,
        qualifications: [MTurkClientTypes.Qualification]? = nil
    )
    {
        self.nextToken = nextToken
        self.numResults = numResults
        self.qualifications = qualifications
    }
}

struct ListWorkersWithQualificationTypeOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let numResults: Swift.Int?
    public let qualifications: [MTurkClientTypes.Qualification]?
}

extension ListWorkersWithQualificationTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case numResults = "NumResults"
        case qualifications = "Qualifications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let qualificationsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.Qualification?].self, forKey: .qualifications)
        var qualificationsDecoded0:[MTurkClientTypes.Qualification]? = nil
        if let qualificationsContainer = qualificationsContainer {
            qualificationsDecoded0 = [MTurkClientTypes.Qualification]()
            for structure0 in qualificationsContainer {
                if let structure0 = structure0 {
                    qualificationsDecoded0?.append(structure0)
                }
            }
        }
        qualifications = qualificationsDecoded0
    }
}

extension MTurkClientTypes.Locale: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case country = "Country"
        case subdivision = "Subdivision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let subdivision = subdivision {
            try encodeContainer.encode(subdivision, forKey: .subdivision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let subdivisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdivision)
        subdivision = subdivisionDecoded
    }
}

extension MTurkClientTypes.Locale: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Locale(country: \(Swift.String(describing: country)), subdivision: \(Swift.String(describing: subdivision)))"}
}

extension MTurkClientTypes {
    /// The Locale data structure represents a geographical region or location.
    public struct Locale: Swift.Equatable {
        ///  The country of the locale. Must be a valid ISO 3166 country
        ///             code. For example, the code US refers to the United States of
        ///             America.
        ///
        /// This member is required.
        public let country: Swift.String?
        /// The state or subdivision of the locale. A valid ISO 3166-2
        ///             subdivision code. For example, the code WA refers to the state of
        ///             Washington.
        public let subdivision: Swift.String?

        public init (
            country: Swift.String? = nil,
            subdivision: Swift.String? = nil
        )
        {
            self.country = country
            self.subdivision = subdivision
        }
    }

}

extension MTurkClientTypes.NotificationSpecification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case eventTypes = "EventTypes"
        case transport = "Transport"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let eventTypes = eventTypes {
            var eventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypes)
            for eventtypelist0 in eventTypes {
                try eventTypesContainer.encode(eventtypelist0.rawValue)
            }
        }
        if let transport = transport {
            try encodeContainer.encode(transport.rawValue, forKey: .transport)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let transportDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.NotificationTransport.self, forKey: .transport)
        transport = transportDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let eventTypesContainer = try containerValues.decodeIfPresent([MTurkClientTypes.EventType?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[MTurkClientTypes.EventType]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [MTurkClientTypes.EventType]()
            for string0 in eventTypesContainer {
                if let string0 = string0 {
                    eventTypesDecoded0?.append(string0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
    }
}

extension MTurkClientTypes.NotificationSpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationSpecification(destination: \(Swift.String(describing: destination)), eventTypes: \(Swift.String(describing: eventTypes)), transport: \(Swift.String(describing: transport)), version: \(Swift.String(describing: version)))"}
}

extension MTurkClientTypes {
    /// The NotificationSpecification data structure describes a HIT
    ///             event notification for a HIT type.
    public struct NotificationSpecification: Swift.Equatable {
        ///
        ///             The target for notification messages. The Destination’s format is determined by the specified Transport:
        ///
        ///
        ///
        ///                 When Transport is Email, the Destination is your email address.
        ///
        ///
        ///                 When Transport is SQS, the Destination is your queue URL.
        ///
        ///
        ///                 When Transport is SNS, the Destination is the ARN of your topic.
        ///
        ///
        /// This member is required.
        public let destination: Swift.String?
        ///  The list of events that should cause notifications to be
        ///             sent. Valid Values: AssignmentAccepted | AssignmentAbandoned |
        ///             AssignmentReturned | AssignmentSubmitted | AssignmentRejected |
        ///             AssignmentApproved | HITCreated | HITExtended | HITDisposed |
        ///             HITReviewable | HITExpired | Ping. The Ping event is only valid for
        ///             the SendTestEventNotification operation.
        ///
        /// This member is required.
        public let eventTypes: [MTurkClientTypes.EventType]?
        ///  The method Amazon Mechanical Turk uses to send the
        ///             notification. Valid Values: Email | SQS | SNS.
        ///
        /// This member is required.
        public let transport: MTurkClientTypes.NotificationTransport?
        /// The version of the Notification API to use. Valid value is
        ///             2006-05-05.
        /// This member is required.
        public let version: Swift.String?

        public init (
            destination: Swift.String? = nil,
            eventTypes: [MTurkClientTypes.EventType]? = nil,
            transport: MTurkClientTypes.NotificationTransport? = nil,
            version: Swift.String? = nil
        )
        {
            self.destination = destination
            self.eventTypes = eventTypes
            self.transport = transport
            self.version = version
        }
    }

}

extension MTurkClientTypes {
    public enum NotificationTransport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sns
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationTransport] {
            return [
                .email,
                .sns,
                .sqs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "Email"
            case .sns: return "SNS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationTransport(rawValue: rawValue) ?? NotificationTransport.sdkUnknown(rawValue)
        }
    }
}

extension MTurkClientTypes {
    public enum NotifyWorkersFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hardfailure
        case softfailure
        case sdkUnknown(Swift.String)

        public static var allCases: [NotifyWorkersFailureCode] {
            return [
                .hardfailure,
                .softfailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hardfailure: return "HardFailure"
            case .softfailure: return "SoftFailure"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotifyWorkersFailureCode(rawValue: rawValue) ?? NotifyWorkersFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension MTurkClientTypes.NotifyWorkersFailureStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notifyWorkersFailureCode = "NotifyWorkersFailureCode"
        case notifyWorkersFailureMessage = "NotifyWorkersFailureMessage"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notifyWorkersFailureCode = notifyWorkersFailureCode {
            try encodeContainer.encode(notifyWorkersFailureCode.rawValue, forKey: .notifyWorkersFailureCode)
        }
        if let notifyWorkersFailureMessage = notifyWorkersFailureMessage {
            try encodeContainer.encode(notifyWorkersFailureMessage, forKey: .notifyWorkersFailureMessage)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notifyWorkersFailureCodeDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.NotifyWorkersFailureCode.self, forKey: .notifyWorkersFailureCode)
        notifyWorkersFailureCode = notifyWorkersFailureCodeDecoded
        let notifyWorkersFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notifyWorkersFailureMessage)
        notifyWorkersFailureMessage = notifyWorkersFailureMessageDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
    }
}

extension MTurkClientTypes.NotifyWorkersFailureStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyWorkersFailureStatus(notifyWorkersFailureCode: \(Swift.String(describing: notifyWorkersFailureCode)), notifyWorkersFailureMessage: \(Swift.String(describing: notifyWorkersFailureMessage)), workerId: \(Swift.String(describing: workerId)))"}
}

extension MTurkClientTypes {
    ///  When MTurk encounters an issue with notifying the Workers
    ///             you specified, it returns back this object with failure details.
    ///
    public struct NotifyWorkersFailureStatus: Swift.Equatable {
        ///  Encoded value for the failure type.
        ///
        public let notifyWorkersFailureCode: MTurkClientTypes.NotifyWorkersFailureCode?
        ///  A message detailing the reason the Worker could not be
        ///             notified.
        ///
        public let notifyWorkersFailureMessage: Swift.String?
        ///  The ID of the Worker.
        public let workerId: Swift.String?

        public init (
            notifyWorkersFailureCode: MTurkClientTypes.NotifyWorkersFailureCode? = nil,
            notifyWorkersFailureMessage: Swift.String? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.notifyWorkersFailureCode = notifyWorkersFailureCode
            self.notifyWorkersFailureMessage = notifyWorkersFailureMessage
            self.workerId = workerId
        }
    }

}

public struct NotifyWorkersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyWorkersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyWorkersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyWorkersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyWorkersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyWorkersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyWorkersOutputError>
}

extension NotifyWorkersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyWorkersInput(messageText: \(Swift.String(describing: messageText)), subject: \(Swift.String(describing: subject)), workerIds: \(Swift.String(describing: workerIds)))"}
}

extension NotifyWorkersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageText = "MessageText"
        case subject = "Subject"
        case workerIds = "WorkerIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageText = messageText {
            try encodeContainer.encode(messageText, forKey: .messageText)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let workerIds = workerIds {
            var workerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workerIds)
            for customeridlist0 in workerIds {
                try workerIdsContainer.encode(customeridlist0)
            }
        }
    }
}

public struct NotifyWorkersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyWorkersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyWorkersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyWorkersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyWorkersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyWorkersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyWorkersOutputError>
}

public struct NotifyWorkersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyWorkersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyWorkersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyWorkersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyWorkersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyWorkersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyWorkersOutputError>
}

public struct NotifyWorkersInput: Swift.Equatable {
    /// The text of the email message to send. Can include up to
    ///             4,096 characters
    /// This member is required.
    public let messageText: Swift.String?
    /// The subject line of the email message to send. Can include up
    ///             to 200 characters.
    /// This member is required.
    public let subject: Swift.String?
    /// A list of Worker IDs you wish to notify. You
    ///             can notify upto
    ///             100 Workers at a time.
    /// This member is required.
    public let workerIds: [Swift.String]?

    public init (
        messageText: Swift.String? = nil,
        subject: Swift.String? = nil,
        workerIds: [Swift.String]? = nil
    )
    {
        self.messageText = messageText
        self.subject = subject
        self.workerIds = workerIds
    }
}

struct NotifyWorkersInputBody: Swift.Equatable {
    public let subject: Swift.String?
    public let messageText: Swift.String?
    public let workerIds: [Swift.String]?
}

extension NotifyWorkersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageText = "MessageText"
        case subject = "Subject"
        case workerIds = "WorkerIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let messageTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageText)
        messageText = messageTextDecoded
        let workerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workerIds)
        var workerIdsDecoded0:[Swift.String]? = nil
        if let workerIdsContainer = workerIdsContainer {
            workerIdsDecoded0 = [Swift.String]()
            for string0 in workerIdsContainer {
                if let string0 = string0 {
                    workerIdsDecoded0?.append(string0)
                }
            }
        }
        workerIds = workerIdsDecoded0
    }
}

extension NotifyWorkersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyWorkersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyWorkersOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyWorkersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyWorkersOutputResponse(notifyWorkersFailureStatuses: \(Swift.String(describing: notifyWorkersFailureStatuses)))"}
}

extension NotifyWorkersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotifyWorkersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.notifyWorkersFailureStatuses = output.notifyWorkersFailureStatuses
        } else {
            self.notifyWorkersFailureStatuses = nil
        }
    }
}

public struct NotifyWorkersOutputResponse: Swift.Equatable {
    ///  When MTurk sends notifications to the list of Workers, it
    ///             returns back any failures it encounters in this list of
    ///             NotifyWorkersFailureStatus objects.
    ///
    public let notifyWorkersFailureStatuses: [MTurkClientTypes.NotifyWorkersFailureStatus]?

    public init (
        notifyWorkersFailureStatuses: [MTurkClientTypes.NotifyWorkersFailureStatus]? = nil
    )
    {
        self.notifyWorkersFailureStatuses = notifyWorkersFailureStatuses
    }
}

struct NotifyWorkersOutputResponseBody: Swift.Equatable {
    public let notifyWorkersFailureStatuses: [MTurkClientTypes.NotifyWorkersFailureStatus]?
}

extension NotifyWorkersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notifyWorkersFailureStatuses = "NotifyWorkersFailureStatuses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notifyWorkersFailureStatusesContainer = try containerValues.decodeIfPresent([MTurkClientTypes.NotifyWorkersFailureStatus?].self, forKey: .notifyWorkersFailureStatuses)
        var notifyWorkersFailureStatusesDecoded0:[MTurkClientTypes.NotifyWorkersFailureStatus]? = nil
        if let notifyWorkersFailureStatusesContainer = notifyWorkersFailureStatusesContainer {
            notifyWorkersFailureStatusesDecoded0 = [MTurkClientTypes.NotifyWorkersFailureStatus]()
            for structure0 in notifyWorkersFailureStatusesContainer {
                if let structure0 = structure0 {
                    notifyWorkersFailureStatusesDecoded0?.append(structure0)
                }
            }
        }
        notifyWorkersFailureStatuses = notifyWorkersFailureStatusesDecoded0
    }
}

extension MTurkClientTypes.ParameterMapEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stringlist0 in values {
                try valuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension MTurkClientTypes.ParameterMapEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterMapEntry(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension MTurkClientTypes {
    ///  This data structure is the data type for the AnswerKey
    ///             parameter of the ScoreMyKnownAnswers/2011-09-01 Review Policy.
    ///
    public struct ParameterMapEntry: Swift.Equatable {
        ///  The QuestionID from the HIT that is used to identify which
        ///             question requires Mechanical Turk to score as part of the
        ///             ScoreMyKnownAnswers/2011-09-01 Review Policy.
        ///
        public let key: Swift.String?
        ///  The list of answers to the question specified in the
        ///             MapEntry Key element. The Worker must match all values in order for
        ///             the answer to be scored correctly.
        ///
        public let values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension MTurkClientTypes.PolicyParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case mapEntries = "MapEntries"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let mapEntries = mapEntries {
            var mapEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mapEntries)
            for parametermapentrylist0 in mapEntries {
                try mapEntriesContainer.encode(parametermapentrylist0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stringlist0 in values {
                try valuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let mapEntriesContainer = try containerValues.decodeIfPresent([MTurkClientTypes.ParameterMapEntry?].self, forKey: .mapEntries)
        var mapEntriesDecoded0:[MTurkClientTypes.ParameterMapEntry]? = nil
        if let mapEntriesContainer = mapEntriesContainer {
            mapEntriesDecoded0 = [MTurkClientTypes.ParameterMapEntry]()
            for structure0 in mapEntriesContainer {
                if let structure0 = structure0 {
                    mapEntriesDecoded0?.append(structure0)
                }
            }
        }
        mapEntries = mapEntriesDecoded0
    }
}

extension MTurkClientTypes.PolicyParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyParameter(key: \(Swift.String(describing: key)), mapEntries: \(Swift.String(describing: mapEntries)), values: \(Swift.String(describing: values)))"}
}

extension MTurkClientTypes {
    ///  Name of the parameter from the Review policy.
    ///
    public struct PolicyParameter: Swift.Equatable {
        ///  Name of the parameter from the list of Review Polices.
        ///
        public let key: Swift.String?
        ///  List of ParameterMapEntry objects.
        ///
        public let mapEntries: [MTurkClientTypes.ParameterMapEntry]?
        ///  The list of values of the Parameter
        public let values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            mapEntries: [MTurkClientTypes.ParameterMapEntry]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.mapEntries = mapEntries
            self.values = values
        }
    }

}

extension MTurkClientTypes.Qualification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantTime = "GrantTime"
        case integerValue = "IntegerValue"
        case localeValue = "LocaleValue"
        case qualificationTypeId = "QualificationTypeId"
        case status = "Status"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantTime = grantTime {
            try encodeContainer.encode(grantTime.timeIntervalSince1970, forKey: .grantTime)
        }
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let localeValue = localeValue {
            try encodeContainer.encode(localeValue, forKey: .localeValue)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let grantTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .grantTime)
        grantTime = grantTimeDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let localeValueDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.Locale.self, forKey: .localeValue)
        localeValue = localeValueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.QualificationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension MTurkClientTypes.Qualification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Qualification(grantTime: \(Swift.String(describing: grantTime)), integerValue: \(Swift.String(describing: integerValue)), localeValue: \(Swift.String(describing: localeValue)), qualificationTypeId: \(Swift.String(describing: qualificationTypeId)), status: \(Swift.String(describing: status)), workerId: \(Swift.String(describing: workerId)))"}
}

extension MTurkClientTypes {
    /// The Qualification data structure represents a Qualification
    ///             assigned to a user, including the Qualification type and the value
    ///             (score).
    public struct Qualification: Swift.Equatable {
        ///  The date and time the Qualification was granted to the
        ///             Worker. If the Worker's Qualification was revoked, and then
        ///             re-granted based on a new Qualification request, GrantTime is the
        ///             date and time of the last call to the AcceptQualificationRequest
        ///             operation.
        public let grantTime: ClientRuntime.Date?
        ///  The value (score) of the Qualification, if the Qualification
        ///             has an integer value.
        public let integerValue: Swift.Int?
        /// The Locale data structure represents a geographical region or location.
        public let localeValue: MTurkClientTypes.Locale?
        ///  The ID of the Qualification type for the Qualification.
        public let qualificationTypeId: Swift.String?
        ///  The status of the Qualification. Valid values are Granted |
        ///             Revoked.
        public let status: MTurkClientTypes.QualificationStatus?
        ///  The ID of the Worker who possesses the Qualification.
        ///
        public let workerId: Swift.String?

        public init (
            grantTime: ClientRuntime.Date? = nil,
            integerValue: Swift.Int? = nil,
            localeValue: MTurkClientTypes.Locale? = nil,
            qualificationTypeId: Swift.String? = nil,
            status: MTurkClientTypes.QualificationStatus? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.grantTime = grantTime
            self.integerValue = integerValue
            self.localeValue = localeValue
            self.qualificationTypeId = qualificationTypeId
            self.status = status
            self.workerId = workerId
        }
    }

}

extension MTurkClientTypes.QualificationRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answer = "Answer"
        case qualificationRequestId = "QualificationRequestId"
        case qualificationTypeId = "QualificationTypeId"
        case submitTime = "SubmitTime"
        case test = "Test"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answer = answer {
            try encodeContainer.encode(answer, forKey: .answer)
        }
        if let qualificationRequestId = qualificationRequestId {
            try encodeContainer.encode(qualificationRequestId, forKey: .qualificationRequestId)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationRequestId)
        qualificationRequestId = qualificationRequestIdDecoded
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let testDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .test)
        test = testDecoded
        let answerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .answer)
        answer = answerDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
    }
}

extension MTurkClientTypes.QualificationRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QualificationRequest(answer: \(Swift.String(describing: answer)), qualificationRequestId: \(Swift.String(describing: qualificationRequestId)), qualificationTypeId: \(Swift.String(describing: qualificationTypeId)), submitTime: \(Swift.String(describing: submitTime)), test: \(Swift.String(describing: test)), workerId: \(Swift.String(describing: workerId)))"}
}

extension MTurkClientTypes {
    ///  The QualificationRequest data structure represents a request
    ///             a Worker has made for a Qualification.
    ///
    public struct QualificationRequest: Swift.Equatable {
        ///  The Worker's answers for the Qualification type's test
        ///             contained in a QuestionFormAnswers document, if the type has a test
        ///             and the Worker has submitted answers. If the Worker does not provide
        ///             any answers, Answer may be empty.
        ///
        public let answer: Swift.String?
        /// The ID of the Qualification request, a unique identifier
        ///             generated when the request was submitted.
        ///
        ///
        public let qualificationRequestId: Swift.String?
        ///  The ID of the Qualification type the Worker is requesting,
        ///             as returned by the CreateQualificationType operation.
        ///
        public let qualificationTypeId: Swift.String?
        /// The date and time the Qualification request had a status of
        ///             Submitted. This is either the time the Worker submitted answers for a
        ///             Qualification test, or the time the Worker requested the
        ///             Qualification if the Qualification type does not have a test.
        ///
        public let submitTime: ClientRuntime.Date?
        ///  The contents of the Qualification test that was presented to
        ///             the Worker, if the type has a test and the Worker has submitted
        ///             answers. This value is identical to the QuestionForm associated with
        ///             the Qualification type at the time the Worker requests the
        ///             Qualification.
        public let test: Swift.String?
        ///  The ID of the Worker requesting the Qualification.
        public let workerId: Swift.String?

        public init (
            answer: Swift.String? = nil,
            qualificationRequestId: Swift.String? = nil,
            qualificationTypeId: Swift.String? = nil,
            submitTime: ClientRuntime.Date? = nil,
            test: Swift.String? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.answer = answer
            self.qualificationRequestId = qualificationRequestId
            self.qualificationTypeId = qualificationTypeId
            self.submitTime = submitTime
            self.test = test
            self.workerId = workerId
        }
    }

}

extension MTurkClientTypes.QualificationRequirement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsGuarded = "ActionsGuarded"
        case comparator = "Comparator"
        case integerValues = "IntegerValues"
        case localeValues = "LocaleValues"
        case qualificationTypeId = "QualificationTypeId"
        case requiredToPreview = "RequiredToPreview"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionsGuarded = actionsGuarded {
            try encodeContainer.encode(actionsGuarded.rawValue, forKey: .actionsGuarded)
        }
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let integerValues = integerValues {
            var integerValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerValues)
            for integerlist0 in integerValues {
                try integerValuesContainer.encode(integerlist0)
            }
        }
        if let localeValues = localeValues {
            var localeValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .localeValues)
            for localelist0 in localeValues {
                try localeValuesContainer.encode(localelist0)
            }
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let requiredToPreview = requiredToPreview {
            try encodeContainer.encode(requiredToPreview, forKey: .requiredToPreview)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let comparatorDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.Comparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let integerValuesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .integerValues)
        var integerValuesDecoded0:[Swift.Int]? = nil
        if let integerValuesContainer = integerValuesContainer {
            integerValuesDecoded0 = [Swift.Int]()
            for integer0 in integerValuesContainer {
                if let integer0 = integer0 {
                    integerValuesDecoded0?.append(integer0)
                }
            }
        }
        integerValues = integerValuesDecoded0
        let localeValuesContainer = try containerValues.decodeIfPresent([MTurkClientTypes.Locale?].self, forKey: .localeValues)
        var localeValuesDecoded0:[MTurkClientTypes.Locale]? = nil
        if let localeValuesContainer = localeValuesContainer {
            localeValuesDecoded0 = [MTurkClientTypes.Locale]()
            for structure0 in localeValuesContainer {
                if let structure0 = structure0 {
                    localeValuesDecoded0?.append(structure0)
                }
            }
        }
        localeValues = localeValuesDecoded0
        let requiredToPreviewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requiredToPreview)
        requiredToPreview = requiredToPreviewDecoded
        let actionsGuardedDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.HITAccessActions.self, forKey: .actionsGuarded)
        actionsGuarded = actionsGuardedDecoded
    }
}

extension MTurkClientTypes.QualificationRequirement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QualificationRequirement(actionsGuarded: \(Swift.String(describing: actionsGuarded)), comparator: \(Swift.String(describing: comparator)), integerValues: \(Swift.String(describing: integerValues)), localeValues: \(Swift.String(describing: localeValues)), qualificationTypeId: \(Swift.String(describing: qualificationTypeId)), requiredToPreview: \(Swift.String(describing: requiredToPreview)))"}
}

extension MTurkClientTypes {
    ///
    ///             The QualificationRequirement data structure describes a Qualification that a Worker must have
    ///             before the Worker is allowed to accept a HIT.
    ///             A requirement may optionally state that a Worker must have the Qualification in order to preview the HIT, or
    ///             see the HIT in search results.
    ///
    public struct QualificationRequirement: Swift.Equatable {
        ///  Setting this attribute prevents Workers whose Qualifications do not meet
        ///             this QualificationRequirement from taking the specified action. Valid arguments include
        ///             "Accept" (Worker cannot accept the HIT, but can preview the HIT and see it in their search results),
        ///             "PreviewAndAccept" (Worker cannot accept or preview the HIT, but can see the HIT in their search results),
        ///             and "DiscoverPreviewAndAccept" (Worker cannot accept, preview, or see the HIT in their search results). It's possible for you to create a HIT with multiple
        ///             QualificationRequirements (which can have different values for the ActionGuarded attribute). In this case,
        ///             the Worker is only permitted to perform an action when they have met all QualificationRequirements guarding
        ///             the action. The actions in the order of least restrictive to most restrictive are Discover, Preview and Accept.
        ///             For example, if a Worker meets all QualificationRequirements that are set to DiscoverPreviewAndAccept, but do
        ///             not meet all requirements that are set with PreviewAndAccept, then the Worker will be able to Discover, i.e. see the
        ///             HIT in their search result, but will not be able to Preview or Accept the HIT. ActionsGuarded should not be used in combination with the
        ///             RequiredToPreview field.
        ///
        public let actionsGuarded: MTurkClientTypes.HITAccessActions?
        /// The kind of comparison to make against a Qualification's
        ///             value. You can compare a Qualification's value to an IntegerValue to
        ///             see if it is LessThan, LessThanOrEqualTo, GreaterThan,
        ///             GreaterThanOrEqualTo, EqualTo, or NotEqualTo the IntegerValue. You
        ///             can compare it to a LocaleValue to see if it is EqualTo, or
        ///             NotEqualTo the LocaleValue. You can check to see if the value is In
        ///             or NotIn a set of IntegerValue
        ///             or LocaleValue values. Lastly, a
        ///             Qualification requirement can also
        ///             test if a Qualification Exists or
        ///             DoesNotExist in the user's profile,
        ///             regardless of its value.
        ///
        /// This member is required.
        public let comparator: MTurkClientTypes.Comparator?
        ///  The integer value to compare against the Qualification's
        ///             value. IntegerValue must not be present if Comparator is Exists or
        ///             DoesNotExist. IntegerValue can only be used if the Qualification type
        ///             has an integer value; it cannot be used with the Worker_Locale
        ///             QualificationType ID. When performing a set comparison by using the
        ///             In or the NotIn comparator, you can use up to 15 IntegerValue
        ///             elements in a QualificationRequirement data structure.
        ///
        public let integerValues: [Swift.Int]?
        ///  The locale value to compare against the Qualification's
        ///             value. The local value must be a valid ISO 3166 country code or
        ///             supports ISO 3166-2 subdivisions. LocaleValue can only be used with a
        ///             Worker_Locale QualificationType ID. LocaleValue can only be used with
        ///             the EqualTo, NotEqualTo, In, and NotIn comparators. You must only use
        ///             a single LocaleValue element when using the EqualTo or NotEqualTo
        ///             comparators. When performing a set comparison by using the In or the
        ///             NotIn comparator, you can use up to 30 LocaleValue elements in a
        ///             QualificationRequirement data structure.
        ///
        public let localeValues: [MTurkClientTypes.Locale]?
        ///  The ID of the Qualification type for the requirement.
        /// This member is required.
        public let qualificationTypeId: Swift.String?
        ///  DEPRECATED: Use the ActionsGuarded field instead.
        ///             If RequiredToPreview is true, the question data for the HIT will not be shown
        ///             when a Worker whose Qualifications do not meet this requirement tries
        ///             to preview the HIT. That is, a Worker's Qualifications must meet all
        ///             of the requirements for which RequiredToPreview is true in order to
        ///             preview the HIT. If a Worker meets all of the requirements where
        ///             RequiredToPreview is true (or if there are no such requirements), but
        ///             does not meet all of the requirements for the HIT, the Worker will be
        ///             allowed to preview the HIT's question data, but will not be allowed
        ///             to accept and complete the HIT. The default is false. This should not
        ///             be used in combination with the ActionsGuarded field.
        ///
        @available(*, deprecated)
        public let requiredToPreview: Swift.Bool?

        public init (
            actionsGuarded: MTurkClientTypes.HITAccessActions? = nil,
            comparator: MTurkClientTypes.Comparator? = nil,
            integerValues: [Swift.Int]? = nil,
            localeValues: [MTurkClientTypes.Locale]? = nil,
            qualificationTypeId: Swift.String? = nil,
            requiredToPreview: Swift.Bool? = nil
        )
        {
            self.actionsGuarded = actionsGuarded
            self.comparator = comparator
            self.integerValues = integerValues
            self.localeValues = localeValues
            self.qualificationTypeId = qualificationTypeId
            self.requiredToPreview = requiredToPreview
        }
    }

}

extension MTurkClientTypes {
    public enum QualificationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case granted
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [QualificationStatus] {
            return [
                .granted,
                .revoked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .granted: return "Granted"
            case .revoked: return "Revoked"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QualificationStatus(rawValue: rawValue) ?? QualificationStatus.sdkUnknown(rawValue)
        }
    }
}

extension MTurkClientTypes.QualificationType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerKey = "AnswerKey"
        case autoGranted = "AutoGranted"
        case autoGrantedValue = "AutoGrantedValue"
        case creationTime = "CreationTime"
        case description = "Description"
        case isRequestable = "IsRequestable"
        case keywords = "Keywords"
        case name = "Name"
        case qualificationTypeId = "QualificationTypeId"
        case qualificationTypeStatus = "QualificationTypeStatus"
        case retryDelayInSeconds = "RetryDelayInSeconds"
        case test = "Test"
        case testDurationInSeconds = "TestDurationInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerKey = answerKey {
            try encodeContainer.encode(answerKey, forKey: .answerKey)
        }
        if let autoGranted = autoGranted {
            try encodeContainer.encode(autoGranted, forKey: .autoGranted)
        }
        if let autoGrantedValue = autoGrantedValue {
            try encodeContainer.encode(autoGrantedValue, forKey: .autoGrantedValue)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isRequestable = isRequestable {
            try encodeContainer.encode(isRequestable, forKey: .isRequestable)
        }
        if let keywords = keywords {
            try encodeContainer.encode(keywords, forKey: .keywords)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let qualificationTypeStatus = qualificationTypeStatus {
            try encodeContainer.encode(qualificationTypeStatus.rawValue, forKey: .qualificationTypeStatus)
        }
        if let retryDelayInSeconds = retryDelayInSeconds {
            try encodeContainer.encode(retryDelayInSeconds, forKey: .retryDelayInSeconds)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let testDurationInSeconds = testDurationInSeconds {
            try encodeContainer.encode(testDurationInSeconds, forKey: .testDurationInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let keywordsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywords)
        keywords = keywordsDecoded
        let qualificationTypeStatusDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.QualificationTypeStatus.self, forKey: .qualificationTypeStatus)
        qualificationTypeStatus = qualificationTypeStatusDecoded
        let testDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .test)
        test = testDecoded
        let testDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .testDurationInSeconds)
        testDurationInSeconds = testDurationInSecondsDecoded
        let answerKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .answerKey)
        answerKey = answerKeyDecoded
        let retryDelayInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryDelayInSeconds)
        retryDelayInSeconds = retryDelayInSecondsDecoded
        let isRequestableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRequestable)
        isRequestable = isRequestableDecoded
        let autoGrantedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoGranted)
        autoGranted = autoGrantedDecoded
        let autoGrantedValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .autoGrantedValue)
        autoGrantedValue = autoGrantedValueDecoded
    }
}

extension MTurkClientTypes.QualificationType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QualificationType(answerKey: \(Swift.String(describing: answerKey)), autoGranted: \(Swift.String(describing: autoGranted)), autoGrantedValue: \(Swift.String(describing: autoGrantedValue)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), isRequestable: \(Swift.String(describing: isRequestable)), keywords: \(Swift.String(describing: keywords)), name: \(Swift.String(describing: name)), qualificationTypeId: \(Swift.String(describing: qualificationTypeId)), qualificationTypeStatus: \(Swift.String(describing: qualificationTypeStatus)), retryDelayInSeconds: \(Swift.String(describing: retryDelayInSeconds)), test: \(Swift.String(describing: test)), testDurationInSeconds: \(Swift.String(describing: testDurationInSeconds)))"}
}

extension MTurkClientTypes {
    ///  The QualificationType data structure represents a
    ///             Qualification type, a description of a property of a Worker that must
    ///             match the requirements of a HIT for the Worker to be able to accept
    ///             the HIT. The type also describes how a Worker can obtain a
    ///             Qualification of that type, such as through a Qualification test.
    ///
    public struct QualificationType: Swift.Equatable {
        /// The answers to the Qualification test specified in the Test
        ///             parameter.
        public let answerKey: Swift.String?
        /// Specifies that requests for the Qualification type are
        ///             granted immediately, without prompting the Worker with a
        ///             Qualification test. Valid values are True | False.
        public let autoGranted: Swift.Bool?
        ///  The Qualification integer value to use for automatically
        ///             granted Qualifications, if AutoGranted is true. This is 1 by default.
        ///
        public let autoGrantedValue: Swift.Int?
        ///  The date and time the Qualification type was created.
        ///
        public let creationTime: ClientRuntime.Date?
        ///  A long description for the Qualification type.
        ///
        public let description: Swift.String?
        ///  Specifies whether the Qualification type is one that a user
        ///             can request through the Amazon Mechanical Turk web site, such as by
        ///             taking a Qualification test. This value is False for Qualifications
        ///             assigned automatically by the system. Valid values are True | False.
        ///
        public let isRequestable: Swift.Bool?
        ///  One or more words or phrases that describe theQualification
        ///             type, separated by commas. The Keywords make the type easier to find
        ///             using a search.
        ///
        public let keywords: Swift.String?
        ///  The name of the Qualification type. The type name is used to
        ///             identify the type, and to find the type using a Qualification type
        ///             search.
        ///
        public let name: Swift.String?
        ///  A unique identifier for the Qualification type. A
        ///             Qualification type is given a Qualification type ID when you call the
        ///             CreateQualificationType operation.
        ///
        public let qualificationTypeId: Swift.String?
        ///  The status of the Qualification type. A Qualification type's
        ///             status determines if users can apply to receive a Qualification of
        ///             this type, and if HITs can be created with requirements based on this
        ///             type. Valid values are Active | Inactive.
        ///
        public let qualificationTypeStatus: MTurkClientTypes.QualificationTypeStatus?
        ///  The amount of time, in seconds, Workers must wait after
        ///             taking the Qualification test before they can take it again. Workers
        ///             can take a Qualification test multiple times if they were not granted
        ///             the Qualification from a previous attempt, or if the test offers a
        ///             gradient score and they want a better score. If not specified,
        ///             retries are disabled and Workers can request a Qualification only
        ///             once.
        ///
        public let retryDelayInSeconds: Swift.Int?
        ///  The questions for a Qualification test associated with this
        ///             Qualification type that a user can take to obtain a Qualification of
        ///             this type. This parameter must be specified if AnswerKey is present.
        ///             A Qualification type cannot have both a specified Test parameter and
        ///             an AutoGranted value of true.
        ///
        public let test: Swift.String?
        ///  The amount of time, in seconds, given to a Worker to
        ///             complete the Qualification test, beginning from the time the Worker
        ///             requests the Qualification.
        ///
        public let testDurationInSeconds: Swift.Int?

        public init (
            answerKey: Swift.String? = nil,
            autoGranted: Swift.Bool? = nil,
            autoGrantedValue: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            isRequestable: Swift.Bool? = nil,
            keywords: Swift.String? = nil,
            name: Swift.String? = nil,
            qualificationTypeId: Swift.String? = nil,
            qualificationTypeStatus: MTurkClientTypes.QualificationTypeStatus? = nil,
            retryDelayInSeconds: Swift.Int? = nil,
            test: Swift.String? = nil,
            testDurationInSeconds: Swift.Int? = nil
        )
        {
            self.answerKey = answerKey
            self.autoGranted = autoGranted
            self.autoGrantedValue = autoGrantedValue
            self.creationTime = creationTime
            self.description = description
            self.isRequestable = isRequestable
            self.keywords = keywords
            self.name = name
            self.qualificationTypeId = qualificationTypeId
            self.qualificationTypeStatus = qualificationTypeStatus
            self.retryDelayInSeconds = retryDelayInSeconds
            self.test = test
            self.testDurationInSeconds = testDurationInSeconds
        }
    }

}

extension MTurkClientTypes {
    public enum QualificationTypeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [QualificationTypeStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QualificationTypeStatus(rawValue: rawValue) ?? QualificationTypeStatus.sdkUnknown(rawValue)
        }
    }
}

public struct RejectAssignmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectAssignmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectAssignmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectAssignmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectAssignmentOutputError>
}

extension RejectAssignmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectAssignmentInput(assignmentId: \(Swift.String(describing: assignmentId)), requesterFeedback: \(Swift.String(describing: requesterFeedback)))"}
}

extension RejectAssignmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case requesterFeedback = "RequesterFeedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let requesterFeedback = requesterFeedback {
            try encodeContainer.encode(requesterFeedback, forKey: .requesterFeedback)
        }
    }
}

public struct RejectAssignmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectAssignmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectAssignmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectAssignmentOutputError>
}

public struct RejectAssignmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectAssignmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectAssignmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectAssignmentOutputError>
}

public struct RejectAssignmentInput: Swift.Equatable {
    ///
    ///             The ID of the assignment. The assignment must correspond to a HIT created by the Requester.
    ///
    /// This member is required.
    public let assignmentId: Swift.String?
    ///
    ///             A message for the Worker, which the Worker can see in the Status section of the web site.
    ///
    /// This member is required.
    public let requesterFeedback: Swift.String?

    public init (
        assignmentId: Swift.String? = nil,
        requesterFeedback: Swift.String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.requesterFeedback = requesterFeedback
    }
}

struct RejectAssignmentInputBody: Swift.Equatable {
    public let assignmentId: Swift.String?
    public let requesterFeedback: Swift.String?
}

extension RejectAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case requesterFeedback = "RequesterFeedback"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let requesterFeedbackDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requesterFeedback)
        requesterFeedback = requesterFeedbackDecoded
    }
}

extension RejectAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectAssignmentOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectAssignmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectAssignmentOutputResponse()"}
}

extension RejectAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RejectAssignmentOutputResponse: Swift.Equatable {

    public init() {}
}

struct RejectAssignmentOutputResponseBody: Swift.Equatable {
}

extension RejectAssignmentOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RejectQualificationRequestInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectQualificationRequestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectQualificationRequestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectQualificationRequestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectQualificationRequestOutputError>
}

extension RejectQualificationRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectQualificationRequestInput(qualificationRequestId: \(Swift.String(describing: qualificationRequestId)), reason: \(Swift.String(describing: reason)))"}
}

extension RejectQualificationRequestInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationRequestId = "QualificationRequestId"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qualificationRequestId = qualificationRequestId {
            try encodeContainer.encode(qualificationRequestId, forKey: .qualificationRequestId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

public struct RejectQualificationRequestInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectQualificationRequestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectQualificationRequestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectQualificationRequestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectQualificationRequestOutputError>
}

public struct RejectQualificationRequestInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectQualificationRequestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectQualificationRequestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectQualificationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectQualificationRequestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectQualificationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectQualificationRequestOutputError>
}

public struct RejectQualificationRequestInput: Swift.Equatable {
    ///
    ///             The ID of the Qualification request, as returned by the
    ///             ListQualificationRequests
    ///             operation.
    ///
    /// This member is required.
    public let qualificationRequestId: Swift.String?
    /// A text message explaining why the request was rejected, to be
    ///             shown to the Worker who made the request.
    public let reason: Swift.String?

    public init (
        qualificationRequestId: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.qualificationRequestId = qualificationRequestId
        self.reason = reason
    }
}

struct RejectQualificationRequestInputBody: Swift.Equatable {
    public let qualificationRequestId: Swift.String?
    public let reason: Swift.String?
}

extension RejectQualificationRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationRequestId = "QualificationRequestId"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationRequestId)
        qualificationRequestId = qualificationRequestIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RejectQualificationRequestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectQualificationRequestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectQualificationRequestOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectQualificationRequestOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectQualificationRequestOutputResponse()"}
}

extension RejectQualificationRequestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RejectQualificationRequestOutputResponse: Swift.Equatable {

    public init() {}
}

struct RejectQualificationRequestOutputResponseBody: Swift.Equatable {
}

extension RejectQualificationRequestOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RequestError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestError(message: \(Swift.String(describing: message)), turkErrorCode: \(Swift.String(describing: turkErrorCode)))"}
}

extension RequestError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.turkErrorCode = output.turkErrorCode
        } else {
            self.message = nil
            self.turkErrorCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request is invalid.
public struct RequestError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var turkErrorCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        turkErrorCode: Swift.String? = nil
    )
    {
        self.message = message
        self.turkErrorCode = turkErrorCode
    }
}

struct RequestErrorBody: Swift.Equatable {
    public let message: Swift.String?
    public let turkErrorCode: Swift.String?
}

extension RequestErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case turkErrorCode = "TurkErrorCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let turkErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .turkErrorCode)
        turkErrorCode = turkErrorCodeDecoded
    }
}

extension MTurkClientTypes.ReviewActionDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId = "ActionId"
        case actionName = "ActionName"
        case completeTime = "CompleteTime"
        case errorCode = "ErrorCode"
        case result = "Result"
        case status = "Status"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let completeTime = completeTime {
            try encodeContainer.encode(completeTime.timeIntervalSince1970, forKey: .completeTime)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let result = result {
            try encodeContainer.encode(result, forKey: .result)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.ReviewActionStatus.self, forKey: .status)
        status = statusDecoded
        let completeTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completeTime)
        completeTime = completeTimeDecoded
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension MTurkClientTypes.ReviewActionDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReviewActionDetail(actionId: \(Swift.String(describing: actionId)), actionName: \(Swift.String(describing: actionName)), completeTime: \(Swift.String(describing: completeTime)), errorCode: \(Swift.String(describing: errorCode)), result: \(Swift.String(describing: result)), status: \(Swift.String(describing: status)), targetId: \(Swift.String(describing: targetId)), targetType: \(Swift.String(describing: targetType)))"}
}

extension MTurkClientTypes {
    ///  Both the AssignmentReviewReport and the HITReviewReport
    ///             elements contains the ReviewActionDetail data structure. This
    ///             structure is returned multiple times for each action specified in the
    ///             Review Policy.
    ///
    public struct ReviewActionDetail: Swift.Equatable {
        /// The unique identifier for the action.
        public let actionId: Swift.String?
        ///  The nature of the action itself. The Review Policy is
        ///             responsible for examining the HIT and Assignments, emitting results,
        ///             and deciding which other actions will be necessary.
        public let actionName: Swift.String?
        ///  The date when the action was completed.
        public let completeTime: ClientRuntime.Date?
        ///  Present only when the Results have a FAILED Status.
        public let errorCode: Swift.String?
        ///  A description of the outcome of the review.
        public let result: Swift.String?
        ///  The current disposition of the action: INTENDED, SUCCEEDED,
        ///             FAILED, or CANCELLED.
        ///
        public let status: MTurkClientTypes.ReviewActionStatus?
        ///  The specific HITId or AssignmentID targeted by the action.
        public let targetId: Swift.String?
        ///  The type of object in TargetId.
        public let targetType: Swift.String?

        public init (
            actionId: Swift.String? = nil,
            actionName: Swift.String? = nil,
            completeTime: ClientRuntime.Date? = nil,
            errorCode: Swift.String? = nil,
            result: Swift.String? = nil,
            status: MTurkClientTypes.ReviewActionStatus? = nil,
            targetId: Swift.String? = nil,
            targetType: Swift.String? = nil
        )
        {
            self.actionId = actionId
            self.actionName = actionName
            self.completeTime = completeTime
            self.errorCode = errorCode
            self.result = result
            self.status = status
            self.targetId = targetId
            self.targetType = targetType
        }
    }

}

extension MTurkClientTypes {
    public enum ReviewActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case intended
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewActionStatus] {
            return [
                .cancelled,
                .failed,
                .intended,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .failed: return "Failed"
            case .intended: return "Intended"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReviewActionStatus(rawValue: rawValue) ?? ReviewActionStatus.sdkUnknown(rawValue)
        }
    }
}

extension MTurkClientTypes.ReviewPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "Parameters"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for policyparameterlist0 in parameters {
                try parametersContainer.encode(policyparameterlist0)
            }
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let parametersContainer = try containerValues.decodeIfPresent([MTurkClientTypes.PolicyParameter?].self, forKey: .parameters)
        var parametersDecoded0:[MTurkClientTypes.PolicyParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [MTurkClientTypes.PolicyParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension MTurkClientTypes.ReviewPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReviewPolicy(parameters: \(Swift.String(describing: parameters)), policyName: \(Swift.String(describing: policyName)))"}
}

extension MTurkClientTypes {
    ///  HIT Review Policy data structures represent HIT review
    ///             policies, which you specify when you create a HIT.
    ///
    public struct ReviewPolicy: Swift.Equatable {
        /// Name of the parameter from the Review policy.
        public let parameters: [MTurkClientTypes.PolicyParameter]?
        ///  Name of a Review Policy: SimplePlurality/2011-09-01 or
        ///             ScoreMyKnownAnswers/2011-09-01
        ///
        /// This member is required.
        public let policyName: Swift.String?

        public init (
            parameters: [MTurkClientTypes.PolicyParameter]? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.policyName = policyName
        }
    }

}

extension MTurkClientTypes {
    public enum ReviewPolicyLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assignment
        case hit
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewPolicyLevel] {
            return [
                .assignment,
                .hit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assignment: return "Assignment"
            case .hit: return "HIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReviewPolicyLevel(rawValue: rawValue) ?? ReviewPolicyLevel.sdkUnknown(rawValue)
        }
    }
}

extension MTurkClientTypes.ReviewReport: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reviewActions = "ReviewActions"
        case reviewResults = "ReviewResults"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reviewActions = reviewActions {
            var reviewActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewActions)
            for reviewactiondetaillist0 in reviewActions {
                try reviewActionsContainer.encode(reviewactiondetaillist0)
            }
        }
        if let reviewResults = reviewResults {
            var reviewResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewResults)
            for reviewresultdetaillist0 in reviewResults {
                try reviewResultsContainer.encode(reviewresultdetaillist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewResultsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.ReviewResultDetail?].self, forKey: .reviewResults)
        var reviewResultsDecoded0:[MTurkClientTypes.ReviewResultDetail]? = nil
        if let reviewResultsContainer = reviewResultsContainer {
            reviewResultsDecoded0 = [MTurkClientTypes.ReviewResultDetail]()
            for structure0 in reviewResultsContainer {
                if let structure0 = structure0 {
                    reviewResultsDecoded0?.append(structure0)
                }
            }
        }
        reviewResults = reviewResultsDecoded0
        let reviewActionsContainer = try containerValues.decodeIfPresent([MTurkClientTypes.ReviewActionDetail?].self, forKey: .reviewActions)
        var reviewActionsDecoded0:[MTurkClientTypes.ReviewActionDetail]? = nil
        if let reviewActionsContainer = reviewActionsContainer {
            reviewActionsDecoded0 = [MTurkClientTypes.ReviewActionDetail]()
            for structure0 in reviewActionsContainer {
                if let structure0 = structure0 {
                    reviewActionsDecoded0?.append(structure0)
                }
            }
        }
        reviewActions = reviewActionsDecoded0
    }
}

extension MTurkClientTypes.ReviewReport: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReviewReport(reviewActions: \(Swift.String(describing: reviewActions)), reviewResults: \(Swift.String(describing: reviewResults)))"}
}

extension MTurkClientTypes {
    ///  Contains both ReviewResult and ReviewAction elements for a
    ///             particular HIT.
    ///
    public struct ReviewReport: Swift.Equatable {
        ///  A list of ReviewAction objects for each action specified in
        ///             the Review Policy.
        ///
        public let reviewActions: [MTurkClientTypes.ReviewActionDetail]?
        ///  A list of ReviewResults objects for each action specified in
        ///             the Review Policy.
        ///
        public let reviewResults: [MTurkClientTypes.ReviewResultDetail]?

        public init (
            reviewActions: [MTurkClientTypes.ReviewActionDetail]? = nil,
            reviewResults: [MTurkClientTypes.ReviewResultDetail]? = nil
        )
        {
            self.reviewActions = reviewActions
            self.reviewResults = reviewResults
        }
    }

}

extension MTurkClientTypes.ReviewResultDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId = "ActionId"
        case key = "Key"
        case questionId = "QuestionId"
        case subjectId = "SubjectId"
        case subjectType = "SubjectType"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let subjectId = subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let subjectType = subjectType {
            try encodeContainer.encode(subjectType, forKey: .subjectType)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let subjectTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectType)
        subjectType = subjectTypeDecoded
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MTurkClientTypes.ReviewResultDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReviewResultDetail(actionId: \(Swift.String(describing: actionId)), key: \(Swift.String(describing: key)), questionId: \(Swift.String(describing: questionId)), subjectId: \(Swift.String(describing: subjectId)), subjectType: \(Swift.String(describing: subjectType)), value: \(Swift.String(describing: value)))"}
}

extension MTurkClientTypes {
    ///  This data structure is returned multiple times for each
    ///             result specified in the Review Policy.
    ///
    public struct ReviewResultDetail: Swift.Equatable {
        ///  A unique identifier of the Review action result.
        ///
        public let actionId: Swift.String?
        ///  Key identifies the particular piece of reviewed information.
        ///
        public let key: Swift.String?
        ///  Specifies the QuestionId the result is describing. Depending
        ///             on whether the TargetType is a HIT or Assignment this results could
        ///             specify multiple values. If TargetType is HIT and QuestionId is
        ///             absent, then the result describes results of the HIT, including the
        ///             HIT agreement score. If ObjectType is Assignment and QuestionId is
        ///             absent, then the result describes the Worker's performance on the
        ///             HIT.
        ///
        public let questionId: Swift.String?
        /// The HITID or AssignmentId about which this result was taken.
        ///             Note that HIT-level Review Policies will often emit results about
        ///             both the HIT itself and its Assignments, while Assignment-level
        ///             review policies generally only emit results about the Assignment
        ///             itself.
        ///
        public let subjectId: Swift.String?
        ///  The type of the object from the SubjectId field.
        public let subjectType: Swift.String?
        ///  The values of Key provided by the review policies you have
        ///             selected.
        ///
        public let value: Swift.String?

        public init (
            actionId: Swift.String? = nil,
            key: Swift.String? = nil,
            questionId: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            subjectType: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.actionId = actionId
            self.key = key
            self.questionId = questionId
            self.subjectId = subjectId
            self.subjectType = subjectType
            self.value = value
        }
    }

}

extension MTurkClientTypes {
    public enum ReviewableHITStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reviewable
        case reviewing
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewableHITStatus] {
            return [
                .reviewable,
                .reviewing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reviewable: return "Reviewable"
            case .reviewing: return "Reviewing"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReviewableHITStatus(rawValue: rawValue) ?? ReviewableHITStatus.sdkUnknown(rawValue)
        }
    }
}

public struct SendBonusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendBonusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendBonusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendBonusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendBonusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendBonusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendBonusOutputError>
}

extension SendBonusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendBonusInput(assignmentId: \(Swift.String(describing: assignmentId)), bonusAmount: \(Swift.String(describing: bonusAmount)), reason: \(Swift.String(describing: reason)), uniqueRequestToken: \(Swift.String(describing: uniqueRequestToken)), workerId: \(Swift.String(describing: workerId)))"}
}

extension SendBonusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case bonusAmount = "BonusAmount"
        case reason = "Reason"
        case uniqueRequestToken = "UniqueRequestToken"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let bonusAmount = bonusAmount {
            try encodeContainer.encode(bonusAmount, forKey: .bonusAmount)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let uniqueRequestToken = uniqueRequestToken {
            try encodeContainer.encode(uniqueRequestToken, forKey: .uniqueRequestToken)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }
}

public struct SendBonusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendBonusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendBonusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendBonusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendBonusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendBonusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendBonusOutputError>
}

public struct SendBonusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendBonusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendBonusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendBonusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendBonusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendBonusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendBonusOutputError>
}

public struct SendBonusInput: Swift.Equatable {
    /// The ID of the assignment for which this bonus is paid.
    /// This member is required.
    public let assignmentId: Swift.String?
    ///
    ///             The Bonus amount is a US Dollar amount specified using a string (for example, "5" represents $5.00 USD and
    ///             "101.42" represents $101.42 USD). Do not include currency symbols or currency codes.
    ///
    /// This member is required.
    public let bonusAmount: Swift.String?
    /// A message that explains the reason for the bonus payment. The
    ///             Worker receiving the bonus can see this message.
    /// This member is required.
    public let reason: Swift.String?
    /// A unique identifier for this request, which allows you to
    ///             retry the call on error without granting multiple bonuses. This is
    ///             useful in cases such as network timeouts where it is unclear whether
    ///             or not the call succeeded on the server. If the bonus already exists
    ///             in the system from a previous call using the same UniqueRequestToken,
    ///             subsequent calls will return an error with a message containing the
    ///             request ID.
    public let uniqueRequestToken: Swift.String?
    /// The ID of the Worker being paid the bonus.
    /// This member is required.
    public let workerId: Swift.String?

    public init (
        assignmentId: Swift.String? = nil,
        bonusAmount: Swift.String? = nil,
        reason: Swift.String? = nil,
        uniqueRequestToken: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.bonusAmount = bonusAmount
        self.reason = reason
        self.uniqueRequestToken = uniqueRequestToken
        self.workerId = workerId
    }
}

struct SendBonusInputBody: Swift.Equatable {
    public let workerId: Swift.String?
    public let bonusAmount: Swift.String?
    public let assignmentId: Swift.String?
    public let reason: Swift.String?
    public let uniqueRequestToken: Swift.String?
}

extension SendBonusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case bonusAmount = "BonusAmount"
        case reason = "Reason"
        case uniqueRequestToken = "UniqueRequestToken"
        case workerId = "WorkerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let bonusAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bonusAmount)
        bonusAmount = bonusAmountDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let uniqueRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uniqueRequestToken)
        uniqueRequestToken = uniqueRequestTokenDecoded
    }
}

extension SendBonusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendBonusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendBonusOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendBonusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendBonusOutputResponse()"}
}

extension SendBonusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendBonusOutputResponse: Swift.Equatable {

    public init() {}
}

struct SendBonusOutputResponseBody: Swift.Equatable {
}

extension SendBonusOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SendTestEventNotificationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendTestEventNotificationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendTestEventNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendTestEventNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendTestEventNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendTestEventNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendTestEventNotificationOutputError>
}

extension SendTestEventNotificationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendTestEventNotificationInput(notification: \(Swift.String(describing: notification)), testEventType: \(Swift.String(describing: testEventType)))"}
}

extension SendTestEventNotificationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notification = "Notification"
        case testEventType = "TestEventType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let testEventType = testEventType {
            try encodeContainer.encode(testEventType.rawValue, forKey: .testEventType)
        }
    }
}

public struct SendTestEventNotificationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendTestEventNotificationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendTestEventNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendTestEventNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendTestEventNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendTestEventNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendTestEventNotificationOutputError>
}

public struct SendTestEventNotificationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendTestEventNotificationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendTestEventNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendTestEventNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendTestEventNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendTestEventNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendTestEventNotificationOutputError>
}

public struct SendTestEventNotificationInput: Swift.Equatable {
    ///
    ///             The notification specification to test. This value is identical to the value
    ///             you would provide to the UpdateNotificationSettings operation when you establish
    ///             the notification specification for a HIT type.
    ///
    /// This member is required.
    public let notification: MTurkClientTypes.NotificationSpecification?
    ///
    ///             The event to simulate to test the notification specification.
    ///             This event is included in the test message even if the notification specification
    ///             does not include the event type.
    ///             The notification specification does not filter out the test event.
    ///
    /// This member is required.
    public let testEventType: MTurkClientTypes.EventType?

    public init (
        notification: MTurkClientTypes.NotificationSpecification? = nil,
        testEventType: MTurkClientTypes.EventType? = nil
    )
    {
        self.notification = notification
        self.testEventType = testEventType
    }
}

struct SendTestEventNotificationInputBody: Swift.Equatable {
    public let notification: MTurkClientTypes.NotificationSpecification?
    public let testEventType: MTurkClientTypes.EventType?
}

extension SendTestEventNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notification = "Notification"
        case testEventType = "TestEventType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.NotificationSpecification.self, forKey: .notification)
        notification = notificationDecoded
        let testEventTypeDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.EventType.self, forKey: .testEventType)
        testEventType = testEventTypeDecoded
    }
}

extension SendTestEventNotificationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendTestEventNotificationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendTestEventNotificationOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendTestEventNotificationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendTestEventNotificationOutputResponse()"}
}

extension SendTestEventNotificationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendTestEventNotificationOutputResponse: Swift.Equatable {

    public init() {}
}

struct SendTestEventNotificationOutputResponseBody: Swift.Equatable {
}

extension SendTestEventNotificationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ServiceFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceFault(message: \(Swift.String(describing: message)), turkErrorCode: \(Swift.String(describing: turkErrorCode)))"}
}

extension ServiceFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.turkErrorCode = output.turkErrorCode
        } else {
            self.message = nil
            self.turkErrorCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Mechanical Turk is temporarily unable to process your request. Try your call again.
public struct ServiceFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var turkErrorCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        turkErrorCode: Swift.String? = nil
    )
    {
        self.message = message
        self.turkErrorCode = turkErrorCode
    }
}

struct ServiceFaultBody: Swift.Equatable {
    public let message: Swift.String?
    public let turkErrorCode: Swift.String?
}

extension ServiceFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case turkErrorCode = "TurkErrorCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let turkErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .turkErrorCode)
        turkErrorCode = turkErrorCodeDecoded
    }
}

public struct UpdateExpirationForHITInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateExpirationForHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateExpirationForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateExpirationForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateExpirationForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateExpirationForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateExpirationForHITOutputError>
}

extension UpdateExpirationForHITInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateExpirationForHITInput(expireAt: \(Swift.String(describing: expireAt)), hITId: \(Swift.String(describing: hITId)))"}
}

extension UpdateExpirationForHITInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expireAt = "ExpireAt"
        case hITId = "HITId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expireAt = expireAt {
            try encodeContainer.encode(expireAt.timeIntervalSince1970, forKey: .expireAt)
        }
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
    }
}

public struct UpdateExpirationForHITInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateExpirationForHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateExpirationForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateExpirationForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateExpirationForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateExpirationForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateExpirationForHITOutputError>
}

public struct UpdateExpirationForHITInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateExpirationForHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateExpirationForHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateExpirationForHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateExpirationForHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateExpirationForHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateExpirationForHITOutputError>
}

public struct UpdateExpirationForHITInput: Swift.Equatable {
    ///
    ///             The date and time at which you want the HIT to expire
    ///
    /// This member is required.
    public let expireAt: ClientRuntime.Date?
    ///
    ///             The HIT to update.
    ///
    /// This member is required.
    public let hITId: Swift.String?

    public init (
        expireAt: ClientRuntime.Date? = nil,
        hITId: Swift.String? = nil
    )
    {
        self.expireAt = expireAt
        self.hITId = hITId
    }
}

struct UpdateExpirationForHITInputBody: Swift.Equatable {
    public let hITId: Swift.String?
    public let expireAt: ClientRuntime.Date?
}

extension UpdateExpirationForHITInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expireAt = "ExpireAt"
        case hITId = "HITId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let expireAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expireAt)
        expireAt = expireAtDecoded
    }
}

extension UpdateExpirationForHITOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateExpirationForHITOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateExpirationForHITOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateExpirationForHITOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateExpirationForHITOutputResponse()"}
}

extension UpdateExpirationForHITOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateExpirationForHITOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateExpirationForHITOutputResponseBody: Swift.Equatable {
}

extension UpdateExpirationForHITOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateHITReviewStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateHITReviewStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateHITReviewStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateHITReviewStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateHITReviewStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateHITReviewStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateHITReviewStatusOutputError>
}

extension UpdateHITReviewStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateHITReviewStatusInput(hITId: \(Swift.String(describing: hITId)), revert: \(Swift.String(describing: revert)))"}
}

extension UpdateHITReviewStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
        case revert = "Revert"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let revert = revert {
            try encodeContainer.encode(revert, forKey: .revert)
        }
    }
}

public struct UpdateHITReviewStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateHITReviewStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateHITReviewStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateHITReviewStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateHITReviewStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateHITReviewStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateHITReviewStatusOutputError>
}

public struct UpdateHITReviewStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateHITReviewStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateHITReviewStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateHITReviewStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateHITReviewStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateHITReviewStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateHITReviewStatusOutputError>
}

public struct UpdateHITReviewStatusInput: Swift.Equatable {
    ///
    ///             The ID of the HIT to update.
    ///
    /// This member is required.
    public let hITId: Swift.String?
    ///
    ///             Specifies how to update the HIT status. Default is False.
    ///
    ///
    ///
    ///
    ///                     Setting this to false will only transition a HIT from Reviewable to Reviewing
    ///
    ///
    ///
    ///
    ///                     Setting this to true will only transition a HIT from Reviewing to Reviewable
    ///
    ///
    ///
    public let revert: Swift.Bool?

    public init (
        hITId: Swift.String? = nil,
        revert: Swift.Bool? = nil
    )
    {
        self.hITId = hITId
        self.revert = revert
    }
}

struct UpdateHITReviewStatusInputBody: Swift.Equatable {
    public let hITId: Swift.String?
    public let revert: Swift.Bool?
}

extension UpdateHITReviewStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
        case revert = "Revert"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let revertDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .revert)
        revert = revertDecoded
    }
}

extension UpdateHITReviewStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateHITReviewStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateHITReviewStatusOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateHITReviewStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateHITReviewStatusOutputResponse()"}
}

extension UpdateHITReviewStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateHITReviewStatusOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateHITReviewStatusOutputResponseBody: Swift.Equatable {
}

extension UpdateHITReviewStatusOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateHITTypeOfHITInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateHITTypeOfHITInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateHITTypeOfHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateHITTypeOfHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateHITTypeOfHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateHITTypeOfHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateHITTypeOfHITOutputError>
}

extension UpdateHITTypeOfHITInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateHITTypeOfHITInput(hITId: \(Swift.String(describing: hITId)), hITTypeId: \(Swift.String(describing: hITTypeId)))"}
}

extension UpdateHITTypeOfHITInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
        case hITTypeId = "HITTypeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hITId = hITId {
            try encodeContainer.encode(hITId, forKey: .hITId)
        }
        if let hITTypeId = hITTypeId {
            try encodeContainer.encode(hITTypeId, forKey: .hITTypeId)
        }
    }
}

public struct UpdateHITTypeOfHITInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateHITTypeOfHITInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateHITTypeOfHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateHITTypeOfHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateHITTypeOfHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateHITTypeOfHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateHITTypeOfHITOutputError>
}

public struct UpdateHITTypeOfHITInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateHITTypeOfHITInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateHITTypeOfHITInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateHITTypeOfHITOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateHITTypeOfHITInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateHITTypeOfHITOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateHITTypeOfHITOutputError>
}

public struct UpdateHITTypeOfHITInput: Swift.Equatable {
    /// The HIT to update.
    /// This member is required.
    public let hITId: Swift.String?
    /// The ID of the new HIT type.
    /// This member is required.
    public let hITTypeId: Swift.String?

    public init (
        hITId: Swift.String? = nil,
        hITTypeId: Swift.String? = nil
    )
    {
        self.hITId = hITId
        self.hITTypeId = hITTypeId
    }
}

struct UpdateHITTypeOfHITInputBody: Swift.Equatable {
    public let hITId: Swift.String?
    public let hITTypeId: Swift.String?
}

extension UpdateHITTypeOfHITInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hITId = "HITId"
        case hITTypeId = "HITTypeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITId)
        hITId = hITIdDecoded
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
    }
}

extension UpdateHITTypeOfHITOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateHITTypeOfHITOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateHITTypeOfHITOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateHITTypeOfHITOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateHITTypeOfHITOutputResponse()"}
}

extension UpdateHITTypeOfHITOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateHITTypeOfHITOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateHITTypeOfHITOutputResponseBody: Swift.Equatable {
}

extension UpdateHITTypeOfHITOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateNotificationSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNotificationSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNotificationSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNotificationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNotificationSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNotificationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNotificationSettingsOutputError>
}

extension UpdateNotificationSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNotificationSettingsInput(active: \(Swift.String(describing: active)), hITTypeId: \(Swift.String(describing: hITTypeId)), notification: \(Swift.String(describing: notification)))"}
}

extension UpdateNotificationSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case hITTypeId = "HITTypeId"
        case notification = "Notification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let hITTypeId = hITTypeId {
            try encodeContainer.encode(hITTypeId, forKey: .hITTypeId)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
    }
}

public struct UpdateNotificationSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNotificationSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNotificationSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNotificationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNotificationSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNotificationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNotificationSettingsOutputError>
}

public struct UpdateNotificationSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNotificationSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNotificationSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNotificationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNotificationSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNotificationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNotificationSettingsOutputError>
}

public struct UpdateNotificationSettingsInput: Swift.Equatable {
    ///
    ///             Specifies whether notifications are sent for HITs of this HIT type,
    ///             according to the notification specification.
    ///             You must specify either the Notification parameter or the Active parameter
    ///             for the call to UpdateNotificationSettings to succeed.
    ///
    public let active: Swift.Bool?
    ///
    ///             The ID of the HIT type whose notification specification is being updated.
    ///
    /// This member is required.
    public let hITTypeId: Swift.String?
    ///
    ///             The notification specification for the HIT type.
    ///
    public let notification: MTurkClientTypes.NotificationSpecification?

    public init (
        active: Swift.Bool? = nil,
        hITTypeId: Swift.String? = nil,
        notification: MTurkClientTypes.NotificationSpecification? = nil
    )
    {
        self.active = active
        self.hITTypeId = hITTypeId
        self.notification = notification
    }
}

struct UpdateNotificationSettingsInputBody: Swift.Equatable {
    public let hITTypeId: Swift.String?
    public let notification: MTurkClientTypes.NotificationSpecification?
    public let active: Swift.Bool?
}

extension UpdateNotificationSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case hITTypeId = "HITTypeId"
        case notification = "Notification"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hITTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hITTypeId)
        hITTypeId = hITTypeIdDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.NotificationSpecification.self, forKey: .notification)
        notification = notificationDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension UpdateNotificationSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNotificationSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNotificationSettingsOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNotificationSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNotificationSettingsOutputResponse()"}
}

extension UpdateNotificationSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNotificationSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateNotificationSettingsOutputResponseBody: Swift.Equatable {
}

extension UpdateNotificationSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateQualificationTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateQualificationTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateQualificationTypeOutputError>
}

extension UpdateQualificationTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQualificationTypeInput(answerKey: \(Swift.String(describing: answerKey)), autoGranted: \(Swift.String(describing: autoGranted)), autoGrantedValue: \(Swift.String(describing: autoGrantedValue)), description: \(Swift.String(describing: description)), qualificationTypeId: \(Swift.String(describing: qualificationTypeId)), qualificationTypeStatus: \(Swift.String(describing: qualificationTypeStatus)), retryDelayInSeconds: \(Swift.String(describing: retryDelayInSeconds)), test: \(Swift.String(describing: test)), testDurationInSeconds: \(Swift.String(describing: testDurationInSeconds)))"}
}

extension UpdateQualificationTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerKey = "AnswerKey"
        case autoGranted = "AutoGranted"
        case autoGrantedValue = "AutoGrantedValue"
        case description = "Description"
        case qualificationTypeId = "QualificationTypeId"
        case qualificationTypeStatus = "QualificationTypeStatus"
        case retryDelayInSeconds = "RetryDelayInSeconds"
        case test = "Test"
        case testDurationInSeconds = "TestDurationInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerKey = answerKey {
            try encodeContainer.encode(answerKey, forKey: .answerKey)
        }
        if let autoGranted = autoGranted {
            try encodeContainer.encode(autoGranted, forKey: .autoGranted)
        }
        if let autoGrantedValue = autoGrantedValue {
            try encodeContainer.encode(autoGrantedValue, forKey: .autoGrantedValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let qualificationTypeId = qualificationTypeId {
            try encodeContainer.encode(qualificationTypeId, forKey: .qualificationTypeId)
        }
        if let qualificationTypeStatus = qualificationTypeStatus {
            try encodeContainer.encode(qualificationTypeStatus.rawValue, forKey: .qualificationTypeStatus)
        }
        if let retryDelayInSeconds = retryDelayInSeconds {
            try encodeContainer.encode(retryDelayInSeconds, forKey: .retryDelayInSeconds)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let testDurationInSeconds = testDurationInSeconds {
            try encodeContainer.encode(testDurationInSeconds, forKey: .testDurationInSeconds)
        }
    }
}

public struct UpdateQualificationTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateQualificationTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateQualificationTypeOutputError>
}

public struct UpdateQualificationTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateQualificationTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateQualificationTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateQualificationTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateQualificationTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateQualificationTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateQualificationTypeOutputError>
}

public struct UpdateQualificationTypeInput: Swift.Equatable {
    /// The answers to the Qualification test specified in the Test parameter, in the form of an AnswerKey data structure.
    public let answerKey: Swift.String?
    /// Specifies whether requests for the Qualification type are granted immediately, without prompting the Worker with a Qualification test.
    ///         Constraints: If the Test parameter is specified, this parameter cannot be true.
    public let autoGranted: Swift.Bool?
    /// The Qualification value to use for automatically granted Qualifications. This parameter is used only if the AutoGranted parameter is true.
    public let autoGrantedValue: Swift.Int?
    /// The new description of the Qualification type.
    public let description: Swift.String?
    /// The ID of the Qualification type to update.
    /// This member is required.
    public let qualificationTypeId: Swift.String?
    /// The new status of the Qualification type - Active | Inactive
    public let qualificationTypeStatus: MTurkClientTypes.QualificationTypeStatus?
    /// The amount of time, in seconds, that Workers must wait
    ///             after requesting a Qualification of the specified Qualification type
    ///             before they can retry the Qualification request. It is not possible to
    ///             disable retries for a Qualification type after it has been created with
    ///             retries enabled. If you want to disable retries, you must dispose of
    ///             the existing retry-enabled Qualification type using
    ///             DisposeQualificationType and then create a new Qualification type with
    ///             retries disabled using CreateQualificationType.
    public let retryDelayInSeconds: Swift.Int?
    /// The questions for the Qualification test a Worker must answer correctly to obtain a Qualification of this type. If this parameter is specified, TestDurationInSeconds must also be specified.
    ///         Constraints: Must not be longer than 65535 bytes. Must be a QuestionForm data structure. This parameter cannot be specified if AutoGranted is true.
    ///         Constraints: None. If not specified, the Worker may request the Qualification without answering any questions.
    public let test: Swift.String?
    /// The number of seconds the Worker has to complete the Qualification test, starting from the time the Worker requests the Qualification.
    public let testDurationInSeconds: Swift.Int?

    public init (
        answerKey: Swift.String? = nil,
        autoGranted: Swift.Bool? = nil,
        autoGrantedValue: Swift.Int? = nil,
        description: Swift.String? = nil,
        qualificationTypeId: Swift.String? = nil,
        qualificationTypeStatus: MTurkClientTypes.QualificationTypeStatus? = nil,
        retryDelayInSeconds: Swift.Int? = nil,
        test: Swift.String? = nil,
        testDurationInSeconds: Swift.Int? = nil
    )
    {
        self.answerKey = answerKey
        self.autoGranted = autoGranted
        self.autoGrantedValue = autoGrantedValue
        self.description = description
        self.qualificationTypeId = qualificationTypeId
        self.qualificationTypeStatus = qualificationTypeStatus
        self.retryDelayInSeconds = retryDelayInSeconds
        self.test = test
        self.testDurationInSeconds = testDurationInSeconds
    }
}

struct UpdateQualificationTypeInputBody: Swift.Equatable {
    public let qualificationTypeId: Swift.String?
    public let description: Swift.String?
    public let qualificationTypeStatus: MTurkClientTypes.QualificationTypeStatus?
    public let test: Swift.String?
    public let answerKey: Swift.String?
    public let testDurationInSeconds: Swift.Int?
    public let retryDelayInSeconds: Swift.Int?
    public let autoGranted: Swift.Bool?
    public let autoGrantedValue: Swift.Int?
}

extension UpdateQualificationTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerKey = "AnswerKey"
        case autoGranted = "AutoGranted"
        case autoGrantedValue = "AutoGrantedValue"
        case description = "Description"
        case qualificationTypeId = "QualificationTypeId"
        case qualificationTypeStatus = "QualificationTypeStatus"
        case retryDelayInSeconds = "RetryDelayInSeconds"
        case test = "Test"
        case testDurationInSeconds = "TestDurationInSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationTypeId)
        qualificationTypeId = qualificationTypeIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let qualificationTypeStatusDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.QualificationTypeStatus.self, forKey: .qualificationTypeStatus)
        qualificationTypeStatus = qualificationTypeStatusDecoded
        let testDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .test)
        test = testDecoded
        let answerKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .answerKey)
        answerKey = answerKeyDecoded
        let testDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .testDurationInSeconds)
        testDurationInSeconds = testDurationInSecondsDecoded
        let retryDelayInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryDelayInSeconds)
        retryDelayInSeconds = retryDelayInSecondsDecoded
        let autoGrantedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoGranted)
        autoGranted = autoGrantedDecoded
        let autoGrantedValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .autoGrantedValue)
        autoGrantedValue = autoGrantedValueDecoded
    }
}

extension UpdateQualificationTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQualificationTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestError" : self = .requestError(try RequestError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFault" : self = .serviceFault(try ServiceFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQualificationTypeOutputError: Swift.Error, Swift.Equatable {
    case requestError(RequestError)
    case serviceFault(ServiceFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQualificationTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQualificationTypeOutputResponse(qualificationType: \(Swift.String(describing: qualificationType)))"}
}

extension UpdateQualificationTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateQualificationTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.qualificationType = output.qualificationType
        } else {
            self.qualificationType = nil
        }
    }
}

public struct UpdateQualificationTypeOutputResponse: Swift.Equatable {
    ///  Contains a QualificationType data structure.
    public let qualificationType: MTurkClientTypes.QualificationType?

    public init (
        qualificationType: MTurkClientTypes.QualificationType? = nil
    )
    {
        self.qualificationType = qualificationType
    }
}

struct UpdateQualificationTypeOutputResponseBody: Swift.Equatable {
    public let qualificationType: MTurkClientTypes.QualificationType?
}

extension UpdateQualificationTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationType = "QualificationType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationTypeDecoded = try containerValues.decodeIfPresent(MTurkClientTypes.QualificationType.self, forKey: .qualificationType)
        qualificationType = qualificationTypeDecoded
    }
}

extension MTurkClientTypes.WorkerBlock: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case workerId = "WorkerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let workerId = workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension MTurkClientTypes.WorkerBlock: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkerBlock(reason: \(Swift.String(describing: reason)), workerId: \(Swift.String(describing: workerId)))"}
}

extension MTurkClientTypes {
    ///  The WorkerBlock data structure represents a Worker who has
    ///             been blocked. It has two elements: the WorkerId and the Reason for
    ///             the block.
    ///
    public struct WorkerBlock: Swift.Equatable {
        ///  A message explaining the reason the Worker was blocked.
        ///
        public let reason: Swift.String?
        ///  The ID of the Worker who accepted the HIT.
        public let workerId: Swift.String?

        public init (
            reason: Swift.String? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.reason = reason
            self.workerId = workerId
        }
    }

}
