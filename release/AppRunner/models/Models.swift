// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateCustomDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomDomainOutputError>
}

extension AssociateCustomDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateCustomDomainInput(domainName: \(Swift.String(describing: domainName)), enableWWWSubdomain: \(Swift.String(describing: enableWWWSubdomain)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension AssociateCustomDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let enableWWWSubdomain = enableWWWSubdomain {
            try encodeContainer.encode(enableWWWSubdomain, forKey: .enableWWWSubdomain)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct AssociateCustomDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomDomainOutputError>
}

public struct AssociateCustomDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomDomainOutputError>
}

public struct AssociateCustomDomainInput: Swift.Equatable {
    /// <p>A custom domain endpoint to associate. Specify a root domain (for example, <code>example.com</code>), a subdomain (for example,
    ///         <code>login.example.com</code> or <code>admin.login.example.com</code>), or a wildcard (for example, <code>*.example.com</code>).</p>
    public let domainName: Swift.String?
    /// <p>Set to <code>true</code> to associate the subdomain <code>www.<i>DomainName</i>
    ///             </code> with the App Runner service in addition to the base
    ///       domain.</p>
    ///          <p>Default: <code>true</code>
    ///          </p>
    public let enableWWWSubdomain: Swift.Bool?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to associate a custom domain name with.</p>
    public let serviceArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        enableWWWSubdomain: Swift.Bool? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.enableWWWSubdomain = enableWWWSubdomain
        self.serviceArn = serviceArn
    }
}

struct AssociateCustomDomainInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
    public let domainName: Swift.String?
    public let enableWWWSubdomain: Swift.Bool?
}

extension AssociateCustomDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableWWWSubdomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWWWSubdomain)
        enableWWWSubdomain = enableWWWSubdomainDecoded
    }
}

extension AssociateCustomDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCustomDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateCustomDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCustomDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateCustomDomainOutputResponse(customDomain: \(Swift.String(describing: customDomain)), dNSTarget: \(Swift.String(describing: dNSTarget)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension AssociateCustomDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateCustomDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDomain = output.customDomain
            self.dNSTarget = output.dNSTarget
            self.serviceArn = output.serviceArn
        } else {
            self.customDomain = nil
            self.dNSTarget = nil
            self.serviceArn = nil
        }
    }
}

public struct AssociateCustomDomainOutputResponse: Swift.Equatable {
    /// <p>A description of the domain name that's being associated.</p>
    public let customDomain: AppRunnerClientTypes.CustomDomain?
    /// <p>The App Runner subdomain of the App Runner service. The custom domain name is mapped to this target name.</p>
    public let dNSTarget: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service with which a custom domain name is associated.</p>
    public let serviceArn: Swift.String?

    public init (
        customDomain: AppRunnerClientTypes.CustomDomain? = nil,
        dNSTarget: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.customDomain = customDomain
        self.dNSTarget = dNSTarget
        self.serviceArn = serviceArn
    }
}

struct AssociateCustomDomainOutputResponseBody: Swift.Equatable {
    public let dNSTarget: Swift.String?
    public let serviceArn: Swift.String?
    public let customDomain: AppRunnerClientTypes.CustomDomain?
}

extension AssociateCustomDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomain = "CustomDomain"
        case dNSTarget = "DNSTarget"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dNSTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dNSTarget)
        dNSTarget = dNSTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CustomDomain.self, forKey: .customDomain)
        customDomain = customDomainDecoded
    }
}

extension AppRunnerClientTypes.AuthenticationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRoleArn = "AccessRoleArn"
        case connectionArn = "ConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRoleArn = accessRoleArn {
            try encodeContainer.encode(accessRoleArn, forKey: .accessRoleArn)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let accessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRoleArn)
        accessRoleArn = accessRoleArnDecoded
    }
}

extension AppRunnerClientTypes.AuthenticationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthenticationConfiguration(accessRoleArn: \(Swift.String(describing: accessRoleArn)), connectionArn: \(Swift.String(describing: connectionArn)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes resources needed to authenticate access to some source repositories. The specific resource depends on the repository provider.</p>
    public struct AuthenticationConfiguration: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the IAM role that grants the App Runner service access to a source repository. It's required for ECR image repositories
        ///       (but not for ECR Public repositories).</p>
        public let accessRoleArn: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the App Runner connection that enables the App Runner service to connect to a source repository. It's required for GitHub code
        ///       repositories.</p>
        public let connectionArn: Swift.String?

        public init (
            accessRoleArn: Swift.String? = nil,
            connectionArn: Swift.String? = nil
        )
        {
            self.accessRoleArn = accessRoleArn
            self.connectionArn = connectionArn
        }
    }

}

extension AppRunnerClientTypes.AutoScalingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case latest = "Latest"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if autoScalingConfigurationRevision != 0 {
            try encodeContainer.encode(autoScalingConfigurationRevision, forKey: .autoScalingConfigurationRevision)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deletedAt = deletedAt {
            try encodeContainer.encode(deletedAt.timeIntervalSince1970, forKey: .deletedAt)
        }
        if latest != false {
            try encodeContainer.encode(latest, forKey: .latest)
        }
        if maxConcurrency != 0 {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if maxSize != 0 {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if minSize != 0 {
            try encodeContainer.encode(minSize, forKey: .minSize)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let autoScalingConfigurationRevisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .autoScalingConfigurationRevision)
        autoScalingConfigurationRevision = autoScalingConfigurationRevisionDecoded
        let latestDecoded = try containerValues.decode(Swift.Bool.self, forKey: .latest)
        latest = latestDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let maxConcurrencyDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let minSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
    }
}

extension AppRunnerClientTypes.AutoScalingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoScalingConfiguration(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)), autoScalingConfigurationName: \(Swift.String(describing: autoScalingConfigurationName)), autoScalingConfigurationRevision: \(Swift.String(describing: autoScalingConfigurationRevision)), createdAt: \(Swift.String(describing: createdAt)), deletedAt: \(Swift.String(describing: deletedAt)), latest: \(Swift.String(describing: latest)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxSize: \(Swift.String(describing: maxSize)), minSize: \(Swift.String(describing: minSize)), status: \(Swift.String(describing: status)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes an AWS App Runner automatic scaling configuration resource. Multiple revisions of a configuration have the same
    ///         <code>AutoScalingConfigurationName</code> and different <code>AutoScalingConfigurationRevision</code> values.</p>
    ///          <p>A higher <code>MinSize</code> increases the spread of your App Runner service over more Availability Zones in the AWS Region. The tradeoff is a higher
    ///       minimal cost.</p>
    ///          <p>A lower <code>MaxSize</code> controls your cost. The tradeoff is lower responsiveness during peak demand.</p>
    public struct AutoScalingConfiguration: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of this auto scaling configuration.</p>
        public let autoScalingConfigurationArn: Swift.String?
        /// <p>The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.</p>
        public let autoScalingConfigurationName: Swift.String?
        /// <p>The revision of this auto scaling configuration. It's unique among all the active configurations (<code>"Status": "ACTIVE"</code>) that share the same
        ///         <code>AutoScalingConfigurationName</code>.</p>
        public let autoScalingConfigurationRevision: Swift.Int
        /// <p>The time when the auto scaling configuration was created. It's in Unix time stamp format.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The time when the auto scaling configuration was deleted. It's in Unix time stamp format.</p>
        public let deletedAt: ClientRuntime.Date?
        /// <p>It's set to <code>true</code> for the configuration with the highest <code>Revision</code> among all configurations that share the same
        ///         <code>Name</code>. It's set to <code>false</code> otherwise.</p>
        public let latest: Swift.Bool
        /// <p>The maximum number of concurrent requests that an instance processes. If the number of concurrent requests exceeds this limit, App Runner scales the service
        ///       up.</p>
        public let maxConcurrency: Swift.Int
        /// <p>The maximum number of instances that a service scales up to. At most <code>MaxSize</code> instances actively serve traffic for your service.</p>
        public let maxSize: Swift.Int
        /// <p>The minimum number of instances that App Runner provisions for a service. The service always has at least <code>MinSize</code> provisioned instances. Some
        ///       of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to be
        ///       quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset.</p>
        ///          <p>App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code.</p>
        public let minSize: Swift.Int
        /// <p>The current state of the auto scaling configuration. If the status of a configuration revision is <code>INACTIVE</code>, it was deleted and can't be
        ///       used. Inactive configuration revisions are permanently removed some time after they are deleted.</p>
        public let status: AppRunnerClientTypes.AutoScalingConfigurationStatus?

        public init (
            autoScalingConfigurationArn: Swift.String? = nil,
            autoScalingConfigurationName: Swift.String? = nil,
            autoScalingConfigurationRevision: Swift.Int = 0,
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            latest: Swift.Bool = false,
            maxConcurrency: Swift.Int = 0,
            maxSize: Swift.Int = 0,
            minSize: Swift.Int = 0,
            status: AppRunnerClientTypes.AutoScalingConfigurationStatus? = nil
        )
        {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.latest = latest
            self.maxConcurrency = maxConcurrency
            self.maxSize = maxSize
            self.minSize = minSize
            self.status = status
        }
    }

}

extension AppRunnerClientTypes {
    public enum AutoScalingConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingConfigurationStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoScalingConfigurationStatus(rawValue: rawValue) ?? AutoScalingConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.AutoScalingConfigurationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if autoScalingConfigurationRevision != 0 {
            try encodeContainer.encode(autoScalingConfigurationRevision, forKey: .autoScalingConfigurationRevision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let autoScalingConfigurationRevisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .autoScalingConfigurationRevision)
        autoScalingConfigurationRevision = autoScalingConfigurationRevisionDecoded
    }
}

extension AppRunnerClientTypes.AutoScalingConfigurationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoScalingConfigurationSummary(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)), autoScalingConfigurationName: \(Swift.String(describing: autoScalingConfigurationName)), autoScalingConfigurationRevision: \(Swift.String(describing: autoScalingConfigurationRevision)))"}
}

extension AppRunnerClientTypes {
    /// <p>Provides summary information about an AWS App Runner automatic scaling configuration resource.</p>
    ///          <p>This type contains limited information about an auto scaling configuration. It includes only identification information, without configuration
    ///       details. It's returned by the <a>ListAutoScalingConfigurations</a> action. Complete configuration information is returned by the <a>CreateAutoScalingConfiguration</a>, <a>DescribeAutoScalingConfiguration</a>, and <a>DeleteAutoScalingConfiguration</a>
    ///       actions using the <a>AutoScalingConfiguration</a> type.</p>
    public struct AutoScalingConfigurationSummary: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of this auto scaling configuration.</p>
        public let autoScalingConfigurationArn: Swift.String?
        /// <p>The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.</p>
        public let autoScalingConfigurationName: Swift.String?
        /// <p>The revision of this auto scaling configuration. It's unique among all the active configurations (<code>"Status": "ACTIVE"</code>) with the same
        ///         <code>AutoScalingConfigurationName</code>.</p>
        public let autoScalingConfigurationRevision: Swift.Int

        public init (
            autoScalingConfigurationArn: Swift.String? = nil,
            autoScalingConfigurationName: Swift.String? = nil,
            autoScalingConfigurationRevision: Swift.Int = 0
        )
        {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
        }
    }

}

extension AppRunnerClientTypes.CertificateValidationRecord: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case status = "Status"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CertificateValidationRecordStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppRunnerClientTypes.CertificateValidationRecord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CertificateValidationRecord(name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes a certificate CNAME record to add to your DNS. For more information, see <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_AssociateCustomDomain.html">AssociateCustomDomain</a>.</p>
    public struct CertificateValidationRecord: Swift.Equatable {
        /// <p>The certificate CNAME record name.</p>
        public let name: Swift.String?
        /// <p>The current state of the certificate CNAME record validation. It should change to <code>SUCCESS</code> after App Runner completes validation with your
        ///       DNS.</p>
        public let status: AppRunnerClientTypes.CertificateValidationRecordStatus?
        /// <p>The record type, always <code>CNAME</code>.</p>
        public let type: Swift.String?
        /// <p>The certificate CNAME record value.</p>
        public let value: Swift.String?

        public init (
            name: Swift.String? = nil,
            status: AppRunnerClientTypes.CertificateValidationRecordStatus? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
            self.type = type
            self.value = value
        }
    }

}

extension AppRunnerClientTypes {
    public enum CertificateValidationRecordStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pendingValidation
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateValidationRecordStatus] {
            return [
                .failed,
                .pendingValidation,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pendingValidation: return "PENDING_VALIDATION"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateValidationRecordStatus(rawValue: rawValue) ?? CertificateValidationRecordStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.CodeConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeConfigurationValues = "CodeConfigurationValues"
        case configurationSource = "ConfigurationSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeConfigurationValues = codeConfigurationValues {
            try encodeContainer.encode(codeConfigurationValues, forKey: .codeConfigurationValues)
        }
        if let configurationSource = configurationSource {
            try encodeContainer.encode(configurationSource.rawValue, forKey: .configurationSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSourceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ConfigurationSource.self, forKey: .configurationSource)
        configurationSource = configurationSourceDecoded
        let codeConfigurationValuesDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CodeConfigurationValues.self, forKey: .codeConfigurationValues)
        codeConfigurationValues = codeConfigurationValuesDecoded
    }
}

extension AppRunnerClientTypes.CodeConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeConfiguration(codeConfigurationValues: \(Swift.String(describing: codeConfigurationValues)), configurationSource: \(Swift.String(describing: configurationSource)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes the configuration that AWS App Runner uses to build and run an App Runner service from a source code repository.</p>
    public struct CodeConfiguration: Swift.Equatable {
        /// <p>The basic configuration for building and running the App Runner service. Use it to quickly launch an App Runner service without providing a
        ///         <code>apprunner.yaml</code> file in the source code repository (or ignoring the file if it exists).</p>
        public let codeConfigurationValues: AppRunnerClientTypes.CodeConfigurationValues?
        /// <p>The source of the App Runner configuration. Values are interpreted as follows:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>REPOSITORY</code> – App Runner reads configuration values from the <code>apprunner.yaml</code> file in the source code repository and
        ///           ignores <code>CodeConfigurationValues</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>API</code> – App Runner uses configuration values provided in <code>CodeConfigurationValues</code> and ignores the
        ///             <code>apprunner.yaml</code> file in the source code repository.</p>
        ///             </li>
        ///          </ul>
        public let configurationSource: AppRunnerClientTypes.ConfigurationSource?

        public init (
            codeConfigurationValues: AppRunnerClientTypes.CodeConfigurationValues? = nil,
            configurationSource: AppRunnerClientTypes.ConfigurationSource? = nil
        )
        {
            self.codeConfigurationValues = codeConfigurationValues
            self.configurationSource = configurationSource
        }
    }

}

extension AppRunnerClientTypes.CodeConfigurationValues: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buildCommand = "BuildCommand"
        case port = "Port"
        case runtime = "Runtime"
        case runtimeEnvironmentVariables = "RuntimeEnvironmentVariables"
        case startCommand = "StartCommand"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let buildCommand = buildCommand {
            try encodeContainer.encode(buildCommand, forKey: .buildCommand)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let runtimeEnvironmentVariables = runtimeEnvironmentVariables {
            var runtimeEnvironmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .runtimeEnvironmentVariables)
            for (dictKey0, runtimeenvironmentvariables0) in runtimeEnvironmentVariables {
                try runtimeEnvironmentVariablesContainer.encode(runtimeenvironmentvariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startCommand = startCommand {
            try encodeContainer.encode(startCommand, forKey: .startCommand)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let buildCommandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildCommand)
        buildCommand = buildCommandDecoded
        let startCommandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startCommand)
        startCommand = startCommandDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .port)
        port = portDecoded
        let runtimeEnvironmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .runtimeEnvironmentVariables)
        var runtimeEnvironmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let runtimeEnvironmentVariablesContainer = runtimeEnvironmentVariablesContainer {
            runtimeEnvironmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, runtimeenvironmentvariablesvalue0) in runtimeEnvironmentVariablesContainer {
                if let runtimeenvironmentvariablesvalue0 = runtimeenvironmentvariablesvalue0 {
                    runtimeEnvironmentVariablesDecoded0?[key0] = runtimeenvironmentvariablesvalue0
                }
            }
        }
        runtimeEnvironmentVariables = runtimeEnvironmentVariablesDecoded0
    }
}

extension AppRunnerClientTypes.CodeConfigurationValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeConfigurationValues(buildCommand: \(Swift.String(describing: buildCommand)), port: \(Swift.String(describing: port)), runtime: \(Swift.String(describing: runtime)), runtimeEnvironmentVariables: \(Swift.String(describing: runtimeEnvironmentVariables)), startCommand: \(Swift.String(describing: startCommand)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes the basic configuration needed for building and running an AWS App Runner service. This type doesn't support the full set of possible
    ///       configuration options. Fur full configuration capabilities, use a <code>apprunner.yaml</code> file in the source code repository.</p>
    public struct CodeConfigurationValues: Swift.Equatable {
        /// <p>The command App Runner runs to build your application.</p>
        public let buildCommand: Swift.String?
        /// <p>The port that your application listens to in the container.</p>
        ///          <p>Default: <code>8080</code>
        ///          </p>
        public let port: Swift.String?
        /// <p>A runtime environment type for building and running an App Runner service.
        ///        It represents a
        ///       programming language runtime.</p>
        public let runtime: AppRunnerClientTypes.Runtime?
        /// <p>The environment variables that are available to your running App Runner service. An array of key-value pairs. Keys with a prefix of
        ///         <code>AWSAPPRUNNER</code> are reserved for system use and aren't valid.</p>
        public let runtimeEnvironmentVariables: [Swift.String:Swift.String]?
        /// <p>The command App Runner runs to start your application.</p>
        public let startCommand: Swift.String?

        public init (
            buildCommand: Swift.String? = nil,
            port: Swift.String? = nil,
            runtime: AppRunnerClientTypes.Runtime? = nil,
            runtimeEnvironmentVariables: [Swift.String:Swift.String]? = nil,
            startCommand: Swift.String? = nil
        )
        {
            self.buildCommand = buildCommand
            self.port = port
            self.runtime = runtime
            self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
            self.startCommand = startCommand
        }
    }

}

extension AppRunnerClientTypes.CodeRepository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeConfiguration = "CodeConfiguration"
        case repositoryUrl = "RepositoryUrl"
        case sourceCodeVersion = "SourceCodeVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeConfiguration = codeConfiguration {
            try encodeContainer.encode(codeConfiguration, forKey: .codeConfiguration)
        }
        if let repositoryUrl = repositoryUrl {
            try encodeContainer.encode(repositoryUrl, forKey: .repositoryUrl)
        }
        if let sourceCodeVersion = sourceCodeVersion {
            try encodeContainer.encode(sourceCodeVersion, forKey: .sourceCodeVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryUrl)
        repositoryUrl = repositoryUrlDecoded
        let sourceCodeVersionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceCodeVersion.self, forKey: .sourceCodeVersion)
        sourceCodeVersion = sourceCodeVersionDecoded
        let codeConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CodeConfiguration.self, forKey: .codeConfiguration)
        codeConfiguration = codeConfigurationDecoded
    }
}

extension AppRunnerClientTypes.CodeRepository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeRepository(codeConfiguration: \(Swift.String(describing: codeConfiguration)), repositoryUrl: \(Swift.String(describing: repositoryUrl)), sourceCodeVersion: \(Swift.String(describing: sourceCodeVersion)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes a source code repository.</p>
    public struct CodeRepository: Swift.Equatable {
        /// <p>Configuration for building and running the service from a source code repository.</p>
        public let codeConfiguration: AppRunnerClientTypes.CodeConfiguration?
        /// <p>The location of the repository that contains the source code.</p>
        public let repositoryUrl: Swift.String?
        /// <p>The version that should be used within the source code repository.</p>
        public let sourceCodeVersion: AppRunnerClientTypes.SourceCodeVersion?

        public init (
            codeConfiguration: AppRunnerClientTypes.CodeConfiguration? = nil,
            repositoryUrl: Swift.String? = nil,
            sourceCodeVersion: AppRunnerClientTypes.SourceCodeVersion? = nil
        )
        {
            self.codeConfiguration = codeConfiguration
            self.repositoryUrl = repositoryUrl
            self.sourceCodeVersion = sourceCodeVersion
        }
    }

}

extension AppRunnerClientTypes {
    public enum ConfigurationSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case api
        case repository
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSource] {
            return [
                .api,
                .repository,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .repository: return "REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationSource(rawValue: rawValue) ?? ConfigurationSource.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.Connection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionName = "ConnectionName"
        case createdAt = "CreatedAt"
        case providerType = "ProviderType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension AppRunnerClientTypes.Connection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Connection(connectionArn: \(Swift.String(describing: connectionArn)), connectionName: \(Swift.String(describing: connectionName)), createdAt: \(Swift.String(describing: createdAt)), providerType: \(Swift.String(describing: providerType)), status: \(Swift.String(describing: status)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes an AWS App Runner connection resource.</p>
    public struct Connection: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of this connection.</p>
        public let connectionArn: Swift.String?
        /// <p>The customer-provided connection name.</p>
        public let connectionName: Swift.String?
        /// <p>The App Runner connection creation time, expressed as a Unix time stamp.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The source repository provider.</p>
        public let providerType: AppRunnerClientTypes.ProviderType?
        /// <p>The current state of the App Runner connection. When the state is <code>AVAILABLE</code>, you can use the connection to create an App Runner service.</p>
        public let status: AppRunnerClientTypes.ConnectionStatus?

        public init (
            connectionArn: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            providerType: AppRunnerClientTypes.ProviderType? = nil,
            status: AppRunnerClientTypes.ConnectionStatus? = nil
        )
        {
            self.connectionArn = connectionArn
            self.connectionName = connectionName
            self.createdAt = createdAt
            self.providerType = providerType
            self.status = status
        }
    }

}

extension AppRunnerClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case error
        case pendingHandshake
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .available,
                .deleted,
                .error,
                .pendingHandshake,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .error: return "ERROR"
            case .pendingHandshake: return "PENDING_HANDSHAKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.ConnectionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionName = "ConnectionName"
        case createdAt = "CreatedAt"
        case providerType = "ProviderType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension AppRunnerClientTypes.ConnectionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionSummary(connectionArn: \(Swift.String(describing: connectionArn)), connectionName: \(Swift.String(describing: connectionName)), createdAt: \(Swift.String(describing: createdAt)), providerType: \(Swift.String(describing: providerType)), status: \(Swift.String(describing: status)))"}
}

extension AppRunnerClientTypes {
    /// <p>Provides summary information about an AWS App Runner connection resource.</p>
    public struct ConnectionSummary: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of this connection.</p>
        public let connectionArn: Swift.String?
        /// <p>The customer-provided connection name.</p>
        public let connectionName: Swift.String?
        /// <p>The App Runner connection creation time, expressed as a Unix time stamp.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The source repository provider.</p>
        public let providerType: AppRunnerClientTypes.ProviderType?
        /// <p>The current state of the App Runner connection. When the state is <code>AVAILABLE</code>, you can use the connection to create an App Runner service.</p>
        public let status: AppRunnerClientTypes.ConnectionStatus?

        public init (
            connectionArn: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            providerType: AppRunnerClientTypes.ProviderType? = nil,
            status: AppRunnerClientTypes.ConnectionStatus? = nil
        )
        {
            self.connectionArn = connectionArn
            self.connectionName = connectionName
            self.createdAt = createdAt
            self.providerType = providerType
            self.status = status
        }
    }

}

public struct CreateAutoScalingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAutoScalingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAutoScalingConfigurationOutputError>
}

extension CreateAutoScalingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAutoScalingConfigurationInput(autoScalingConfigurationName: \(Swift.String(describing: autoScalingConfigurationName)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxSize: \(Swift.String(describing: maxSize)), minSize: \(Swift.String(describing: minSize)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAutoScalingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxSize = maxSize {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if let minSize = minSize {
            try encodeContainer.encode(minSize, forKey: .minSize)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateAutoScalingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAutoScalingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAutoScalingConfigurationOutputError>
}

public struct CreateAutoScalingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAutoScalingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAutoScalingConfigurationOutputError>
}

public struct CreateAutoScalingConfigurationInput: Swift.Equatable {
    /// <p>A name for the auto scaling configuration. When you use it for the first time in an AWS Region, App Runner creates revision number <code>1</code> of this
    ///       name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration.</p>
    public let autoScalingConfigurationName: Swift.String?
    /// <p>The maximum number of concurrent requests that you want an instance to process. If the number of concurrent requests exceeds this limit, App Runner scales
    ///       up your service.</p>
    ///          <p>Default: <code>100</code>
    ///          </p>
    public let maxConcurrency: Swift.Int?
    /// <p>The maximum number of instances that your service scales up to. At most <code>MaxSize</code> instances actively serve traffic for your service.</p>
    ///          <p>Default: <code>25</code>
    ///          </p>
    public let maxSize: Swift.Int?
    /// <p>The minimum number of instances that App Runner provisions for your service. The service always has at least <code>MinSize</code> provisioned instances.
    ///       Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to
    ///       be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset.</p>
    ///          <p>App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code.</p>
    ///          <p>Default: <code>1</code>
    ///          </p>
    public let minSize: Swift.Int?
    /// <p>A list of metadata items that you can associate with your auto scaling configuration resource. A tag is a key-value pair.</p>
    public let tags: [AppRunnerClientTypes.Tag]?

    public init (
        autoScalingConfigurationName: Swift.String? = nil,
        maxConcurrency: Swift.Int? = nil,
        maxSize: Swift.Int? = nil,
        minSize: Swift.Int? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.maxConcurrency = maxConcurrency
        self.maxSize = maxSize
        self.minSize = minSize
        self.tags = tags
    }
}

struct CreateAutoScalingConfigurationInputBody: Swift.Equatable {
    public let autoScalingConfigurationName: Swift.String?
    public let maxConcurrency: Swift.Int?
    public let minSize: Swift.Int?
    public let maxSize: Swift.Int?
    public let tags: [AppRunnerClientTypes.Tag]?
}

extension CreateAutoScalingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let minSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAutoScalingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAutoScalingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAutoScalingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAutoScalingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAutoScalingConfigurationOutputResponse(autoScalingConfiguration: \(Swift.String(describing: autoScalingConfiguration)))"}
}

extension CreateAutoScalingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct CreateAutoScalingConfigurationOutputResponse: Swift.Equatable {
    /// <p>A description of the App Runner auto scaling configuration that's created by this request.</p>
    public let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct CreateAutoScalingConfigurationOutputResponseBody: Swift.Equatable {
    public let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?
}

extension CreateAutoScalingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

public struct CreateConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionInput(connectionName: \(Swift.String(describing: connectionName)), providerType: \(Swift.String(describing: providerType)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case providerType = "ProviderType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Swift.Equatable {
    /// <p>A name for the new connection. It must be unique across all App Runner connections for the AWS account in the AWS Region.</p>
    public let connectionName: Swift.String?
    /// <p>The source repository provider.</p>
    public let providerType: AppRunnerClientTypes.ProviderType?
    /// <p>A list of metadata items that you can associate with your connection resource. A tag is a key-value pair.</p>
    public let tags: [AppRunnerClientTypes.Tag]?

    public init (
        connectionName: Swift.String? = nil,
        providerType: AppRunnerClientTypes.ProviderType? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.connectionName = connectionName
        self.providerType = providerType
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Swift.Equatable {
    public let connectionName: Swift.String?
    public let providerType: AppRunnerClientTypes.ProviderType?
    public let tags: [AppRunnerClientTypes.Tag]?
}

extension CreateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case providerType = "ProviderType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension CreateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Swift.Equatable {
    /// <p>A description of the App Runner connection that's created by this request.</p>
    public let connection: AppRunnerClientTypes.Connection?

    public init (
        connection: AppRunnerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct CreateConnectionOutputResponseBody: Swift.Equatable {
    public let connection: AppRunnerClientTypes.Connection?
}

extension CreateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct CreateServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

extension CreateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceInput(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), healthCheckConfiguration: \(Swift.String(describing: healthCheckConfiguration)), instanceConfiguration: \(Swift.String(describing: instanceConfiguration)), serviceName: \(Swift.String(describing: serviceName)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceName = "ServiceName"
        case sourceConfiguration = "SourceConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let healthCheckConfiguration = healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service. If not provided, App Runner
    ///       associates the latest revision of a default auto scaling configuration.</p>
    public let autoScalingConfigurationArn: Swift.String?
    /// <p>An optional custom encryption key that App Runner uses to encrypt the copy of your source repository that it maintains and your service logs. By default,
    ///       App Runner uses an AWS managed CMK.</p>
    public let encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
    /// <p>The settings for the health check that AWS App Runner performs to monitor the health of your service.</p>
    public let healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    /// <p>The runtime configuration of instances (scaling units) of the App Runner service.</p>
    public let instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    /// <p>A name for the new service. It must be unique across all the running App Runner services in your AWS account in the AWS Region.</p>
    public let serviceName: Swift.String?
    /// <p>The source to deploy to the App Runner service. It can be a code or an image repository.</p>
    public let sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
    /// <p>An optional list of metadata items that you can associate with your service resource. A tag is a key-value pair.</p>
    public let tags: [AppRunnerClientTypes.Tag]?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil,
        encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration? = nil,
        healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
        instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
        serviceName: Swift.String? = nil,
        sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.encryptionConfiguration = encryptionConfiguration
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.serviceName = serviceName
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    public let serviceName: Swift.String?
    public let sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
    public let instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    public let tags: [AppRunnerClientTypes.Tag]?
    public let encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
    public let healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    public let autoScalingConfigurationArn: Swift.String?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceName = "ServiceName"
        case sourceConfiguration = "SourceConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension CreateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceOutputResponse(operationId: \(Swift.String(describing: operationId)), service: \(Swift.String(describing: service)))"}
}

extension CreateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct CreateServiceOutputResponse: Swift.Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_ListOperations.html">ListOperations</a> call to track the operation's progress.</p>
    public let operationId: Swift.String?
    /// <p>A description of the App Runner service that's created by this request.</p>
    public let service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct CreateServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
    public let operationId: Swift.String?
}

extension CreateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes.CustomDomain: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateValidationRecords = "CertificateValidationRecords"
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateValidationRecords = certificateValidationRecords {
            var certificateValidationRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateValidationRecords)
            for certificatevalidationrecordlist0 in certificateValidationRecords {
                try certificateValidationRecordsContainer.encode(certificatevalidationrecordlist0)
            }
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let enableWWWSubdomain = enableWWWSubdomain {
            try encodeContainer.encode(enableWWWSubdomain, forKey: .enableWWWSubdomain)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableWWWSubdomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWWWSubdomain)
        enableWWWSubdomain = enableWWWSubdomainDecoded
        let certificateValidationRecordsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.CertificateValidationRecord?].self, forKey: .certificateValidationRecords)
        var certificateValidationRecordsDecoded0:[AppRunnerClientTypes.CertificateValidationRecord]? = nil
        if let certificateValidationRecordsContainer = certificateValidationRecordsContainer {
            certificateValidationRecordsDecoded0 = [AppRunnerClientTypes.CertificateValidationRecord]()
            for structure0 in certificateValidationRecordsContainer {
                if let structure0 = structure0 {
                    certificateValidationRecordsDecoded0?.append(structure0)
                }
            }
        }
        certificateValidationRecords = certificateValidationRecordsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CustomDomainAssociationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppRunnerClientTypes.CustomDomain: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomDomain(certificateValidationRecords: \(Swift.String(describing: certificateValidationRecords)), domainName: \(Swift.String(describing: domainName)), enableWWWSubdomain: \(Swift.String(describing: enableWWWSubdomain)), status: \(Swift.String(describing: status)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes a custom domain that's associated with an AWS App Runner service.</p>
    public struct CustomDomain: Swift.Equatable {
        /// <p>A list of certificate CNAME records that's used for this domain name.</p>
        public let certificateValidationRecords: [AppRunnerClientTypes.CertificateValidationRecord]?
        /// <p>An associated custom domain endpoint. It can be a root domain (for example, <code>example.com</code>), a subdomain (for example,
        ///         <code>login.example.com</code> or <code>admin.login.example.com</code>), or a wildcard (for example, <code>*.example.com</code>).</p>
        public let domainName: Swift.String?
        /// <p>When <code>true</code>, the subdomain <code>www.<i>DomainName</i>
        ///             </code> is associated with the App Runner service in addition to the base
        ///       domain.</p>
        public let enableWWWSubdomain: Swift.Bool?
        /// <p>The current state of the domain name association.</p>
        public let status: AppRunnerClientTypes.CustomDomainAssociationStatus?

        public init (
            certificateValidationRecords: [AppRunnerClientTypes.CertificateValidationRecord]? = nil,
            domainName: Swift.String? = nil,
            enableWWWSubdomain: Swift.Bool? = nil,
            status: AppRunnerClientTypes.CustomDomainAssociationStatus? = nil
        )
        {
            self.certificateValidationRecords = certificateValidationRecords
            self.domainName = domainName
            self.enableWWWSubdomain = enableWWWSubdomain
            self.status = status
        }
    }

}

extension AppRunnerClientTypes {
    public enum CustomDomainAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case bindingCertificate
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case pendingCertificateDnsValidation
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomDomainAssociationStatus] {
            return [
                .active,
                .bindingCertificate,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .pendingCertificateDnsValidation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .bindingCertificate: return "BINDING_CERTIFICATE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .pendingCertificateDnsValidation: return "PENDING_CERTIFICATE_DNS_VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomDomainAssociationStatus(rawValue: rawValue) ?? CustomDomainAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteAutoScalingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutoScalingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutoScalingConfigurationOutputError>
}

extension DeleteAutoScalingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAutoScalingConfigurationInput(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)))"}
}

extension DeleteAutoScalingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
    }
}

public struct DeleteAutoScalingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutoScalingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutoScalingConfigurationOutputError>
}

public struct DeleteAutoScalingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutoScalingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutoScalingConfigurationOutputError>
}

public struct DeleteAutoScalingConfigurationInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want to delete.</p>
    ///          <p>The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either <code>.../<i>name</i>
    ///             </code> or
    ///           <code>.../<i>name</i>/<i>revision</i>
    ///             </code>. If a revision isn't specified, the latest active revision is deleted.</p>
    public let autoScalingConfigurationArn: Swift.String?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
    }
}

struct DeleteAutoScalingConfigurationInputBody: Swift.Equatable {
    public let autoScalingConfigurationArn: Swift.String?
}

extension DeleteAutoScalingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension DeleteAutoScalingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAutoScalingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAutoScalingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAutoScalingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAutoScalingConfigurationOutputResponse(autoScalingConfiguration: \(Swift.String(describing: autoScalingConfiguration)))"}
}

extension DeleteAutoScalingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct DeleteAutoScalingConfigurationOutputResponse: Swift.Equatable {
    /// <p>A description of the App Runner auto scaling configuration that this request just deleted.</p>
    public let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct DeleteAutoScalingConfigurationOutputResponseBody: Swift.Equatable {
    public let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?
}

extension DeleteAutoScalingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

public struct DeleteConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

extension DeleteConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionInput(connectionArn: \(Swift.String(describing: connectionArn)))"}
}

extension DeleteConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
    }
}

public struct DeleteConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner connection that you want to delete.</p>
    public let connectionArn: Swift.String?

    public init (
        connectionArn: Swift.String? = nil
    )
    {
        self.connectionArn = connectionArn
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
    public let connectionArn: Swift.String?
}

extension DeleteConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// <p>A description of the App Runner connection that this request just deleted.</p>
    public let connection: AppRunnerClientTypes.Connection?

    public init (
        connection: AppRunnerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    public let connection: AppRunnerClientTypes.Connection?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct DeleteServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

extension DeleteServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceInput(serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DeleteServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DeleteServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to delete.</p>
    public let serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
}

extension DeleteServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension DeleteServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceOutputResponse(operationId: \(Swift.String(describing: operationId)), service: \(Swift.String(describing: service)))"}
}

extension DeleteServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct DeleteServiceOutputResponse: Swift.Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a>ListOperations</a> call to track
    ///       the operation's progress.</p>
    public let operationId: Swift.String?
    /// <p>A description of the App Runner service that this request just deleted.</p>
    public let service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct DeleteServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
    public let operationId: Swift.String?
}

extension DeleteServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct DescribeAutoScalingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutoScalingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutoScalingConfigurationOutputError>
}

extension DescribeAutoScalingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAutoScalingConfigurationInput(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)))"}
}

extension DescribeAutoScalingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
    }
}

public struct DescribeAutoScalingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutoScalingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutoScalingConfigurationOutputError>
}

public struct DescribeAutoScalingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutoScalingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutoScalingConfigurationOutputError>
}

public struct DescribeAutoScalingConfigurationInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want a description for.</p>
    ///          <p>The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either <code>.../<i>name</i>
    ///             </code> or
    ///           <code>.../<i>name</i>/<i>revision</i>
    ///             </code>. If a revision isn't specified, the latest active revision is
    ///       described.</p>
    public let autoScalingConfigurationArn: Swift.String?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
    }
}

struct DescribeAutoScalingConfigurationInputBody: Swift.Equatable {
    public let autoScalingConfigurationArn: Swift.String?
}

extension DescribeAutoScalingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension DescribeAutoScalingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutoScalingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAutoScalingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutoScalingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAutoScalingConfigurationOutputResponse(autoScalingConfiguration: \(Swift.String(describing: autoScalingConfiguration)))"}
}

extension DescribeAutoScalingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct DescribeAutoScalingConfigurationOutputResponse: Swift.Equatable {
    /// <p>A full description of the App Runner auto scaling configuration that you specified in this request.</p>
    public let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct DescribeAutoScalingConfigurationOutputResponseBody: Swift.Equatable {
    public let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?
}

extension DescribeAutoScalingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

public struct DescribeCustomDomainsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomDomainsOutputError>
}

extension DescribeCustomDomainsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomDomainsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DescribeCustomDomainsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DescribeCustomDomainsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomDomainsOutputError>
}

public struct DescribeCustomDomainsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomDomainsOutputError>
}

public struct DescribeCustomDomainsInput: Swift.Equatable {
    /// <p>The maximum number of results that each response (result page) can include. It's used for a paginated request.</p>
    ///          <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
    public let maxResults: Swift.Int?
    /// <p>A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be
    ///       identical to the ones that are specified in the initial request.</p>
    ///          <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
    public let nextToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want associated custom domain names to be described for.</p>
    public let serviceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct DescribeCustomDomainsInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeCustomDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeCustomDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomDomainsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomDomainsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomDomainsOutputResponse(customDomains: \(Swift.String(describing: customDomains)), dNSTarget: \(Swift.String(describing: dNSTarget)), nextToken: \(Swift.String(describing: nextToken)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DescribeCustomDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCustomDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDomains = output.customDomains
            self.dNSTarget = output.dNSTarget
            self.nextToken = output.nextToken
            self.serviceArn = output.serviceArn
        } else {
            self.customDomains = nil
            self.dNSTarget = nil
            self.nextToken = nil
            self.serviceArn = nil
        }
    }
}

public struct DescribeCustomDomainsOutputResponse: Swift.Equatable {
    /// <p>A list of descriptions of custom domain names that are associated with the service. In a paginated request, the request returns up to
    ///         <code>MaxResults</code> records per call.</p>
    public let customDomains: [AppRunnerClientTypes.CustomDomain]?
    /// <p>The App Runner subdomain of the App Runner service. The associated custom domain names are mapped to this target name.</p>
    public let dNSTarget: Swift.String?
    /// <p>The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.</p>
    public let nextToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service whose associated custom domain names you want to describe.</p>
    public let serviceArn: Swift.String?

    public init (
        customDomains: [AppRunnerClientTypes.CustomDomain]? = nil,
        dNSTarget: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.customDomains = customDomains
        self.dNSTarget = dNSTarget
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct DescribeCustomDomainsOutputResponseBody: Swift.Equatable {
    public let dNSTarget: Swift.String?
    public let serviceArn: Swift.String?
    public let customDomains: [AppRunnerClientTypes.CustomDomain]?
    public let nextToken: Swift.String?
}

extension DescribeCustomDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomains = "CustomDomains"
        case dNSTarget = "DNSTarget"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dNSTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dNSTarget)
        dNSTarget = dNSTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.CustomDomain?].self, forKey: .customDomains)
        var customDomainsDecoded0:[AppRunnerClientTypes.CustomDomain]? = nil
        if let customDomainsContainer = customDomainsContainer {
            customDomainsDecoded0 = [AppRunnerClientTypes.CustomDomain]()
            for structure0 in customDomainsContainer {
                if let structure0 = structure0 {
                    customDomainsDecoded0?.append(structure0)
                }
            }
        }
        customDomains = customDomainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceOutputError>
}

extension DescribeServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceInput(serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DescribeServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DescribeServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceOutputError>
}

public struct DescribeServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceOutputError>
}

public struct DescribeServiceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want a description for.</p>
    public let serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct DescribeServiceInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
}

extension DescribeServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension DescribeServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceOutputResponse(service: \(Swift.String(describing: service)))"}
}

extension DescribeServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct DescribeServiceOutputResponse: Swift.Equatable {
    /// <p>A full description of the App Runner service that you specified in this request.</p>
    public let service: AppRunnerClientTypes.Service?

    public init (
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct DescribeServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
}

extension DescribeServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

public struct DisassociateCustomDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomDomainOutputError>
}

extension DisassociateCustomDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateCustomDomainInput(domainName: \(Swift.String(describing: domainName)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DisassociateCustomDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DisassociateCustomDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomDomainOutputError>
}

public struct DisassociateCustomDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomDomainOutputError>
}

public struct DisassociateCustomDomainInput: Swift.Equatable {
    /// <p>The domain name that you want to disassociate from the App Runner service.</p>
    public let domainName: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to disassociate a custom domain name from.</p>
    public let serviceArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.serviceArn = serviceArn
    }
}

struct DisassociateCustomDomainInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
    public let domainName: Swift.String?
}

extension DisassociateCustomDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisassociateCustomDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCustomDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateCustomDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCustomDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateCustomDomainOutputResponse(customDomain: \(Swift.String(describing: customDomain)), dNSTarget: \(Swift.String(describing: dNSTarget)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DisassociateCustomDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateCustomDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDomain = output.customDomain
            self.dNSTarget = output.dNSTarget
            self.serviceArn = output.serviceArn
        } else {
            self.customDomain = nil
            self.dNSTarget = nil
            self.serviceArn = nil
        }
    }
}

public struct DisassociateCustomDomainOutputResponse: Swift.Equatable {
    /// <p>A description of the domain name that's being disassociated.</p>
    public let customDomain: AppRunnerClientTypes.CustomDomain?
    /// <p>The App Runner subdomain of the App Runner service. The disassociated custom domain name was mapped to this target name.</p>
    public let dNSTarget: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that a custom domain name is disassociated from.</p>
    public let serviceArn: Swift.String?

    public init (
        customDomain: AppRunnerClientTypes.CustomDomain? = nil,
        dNSTarget: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.customDomain = customDomain
        self.dNSTarget = dNSTarget
        self.serviceArn = serviceArn
    }
}

struct DisassociateCustomDomainOutputResponseBody: Swift.Equatable {
    public let dNSTarget: Swift.String?
    public let serviceArn: Swift.String?
    public let customDomain: AppRunnerClientTypes.CustomDomain?
}

extension DisassociateCustomDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomain = "CustomDomain"
        case dNSTarget = "DNSTarget"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dNSTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dNSTarget)
        dNSTarget = dNSTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CustomDomain.self, forKey: .customDomain)
        customDomain = customDomainDecoded
    }
}

extension AppRunnerClientTypes.EncryptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension AppRunnerClientTypes.EncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionConfiguration(kmsKey: \(Swift.String(describing: kmsKey)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes a custom encryption key that AWS App Runner uses to encrypt copies of the source repository and service logs.</p>
    public struct EncryptionConfiguration: Swift.Equatable {
        /// <p>The ARN of the KMS key that's used for encryption.</p>
        public let kmsKey: Swift.String?

        public init (
            kmsKey: Swift.String? = nil
        )
        {
            self.kmsKey = kmsKey
        }
    }

}

extension AppRunnerClientTypes.HealthCheckConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthyThreshold = "HealthyThreshold"
        case interval = "Interval"
        case path = "Path"
        case `protocol` = "Protocol"
        case timeout = "Timeout"
        case unhealthyThreshold = "UnhealthyThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthyThreshold = healthyThreshold {
            try encodeContainer.encode(healthyThreshold, forKey: .healthyThreshold)
        }
        if let interval = interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let unhealthyThreshold = unhealthyThreshold {
            try encodeContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let healthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyThreshold)
        healthyThreshold = healthyThresholdDecoded
        let unhealthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyThreshold)
        unhealthyThreshold = unhealthyThresholdDecoded
    }
}

extension AppRunnerClientTypes.HealthCheckConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HealthCheckConfiguration(healthyThreshold: \(Swift.String(describing: healthyThreshold)), interval: \(Swift.String(describing: interval)), path: \(Swift.String(describing: path)), protocol: \(Swift.String(describing: `protocol`)), timeout: \(Swift.String(describing: timeout)), unhealthyThreshold: \(Swift.String(describing: unhealthyThreshold)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes the settings for the health check that AWS App Runner performs to monitor the health of a service.</p>
    public struct HealthCheckConfiguration: Swift.Equatable {
        /// <p>The IP protocol that App Runner uses to perform health checks for your service.</p>
        ///          <p>If you set <code>Protocol</code> to <code>HTTP</code>, App Runner sends health check requests to the HTTP path specified by <code>Path</code>.</p>
        ///          <p>Default: <code>TCP</code>
        ///          </p>
        public let `protocol`: AppRunnerClientTypes.HealthCheckProtocol?
        /// <p>The number of consecutive checks that must succeed before App Runner decides that the service is healthy.</p>
        ///          <p>Default: <code>3</code>
        ///          </p>
        public let healthyThreshold: Swift.Int?
        /// <p>The time interval, in seconds, between health checks.</p>
        ///          <p>Default: <code>5</code>
        ///          </p>
        public let interval: Swift.Int?
        /// <p>The URL that health check requests are sent to.</p>
        ///          <p>
        ///             <code>Path</code> is only applicable when you set <code>Protocol</code> to <code>HTTP</code>.</p>
        ///          <p>Default: <code>"/"</code>
        ///          </p>
        public let path: Swift.String?
        /// <p>The time, in seconds, to wait for a health check response before deciding it failed.</p>
        ///          <p>Default: <code>2</code>
        ///          </p>
        public let timeout: Swift.Int?
        /// <p>The number of consecutive checks that must fail before App Runner decides that the service is unhealthy.</p>
        ///          <p>Default: <code>3</code>
        ///          </p>
        public let unhealthyThreshold: Swift.Int?

        public init (
            `protocol`: AppRunnerClientTypes.HealthCheckProtocol? = nil,
            healthyThreshold: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            path: Swift.String? = nil,
            timeout: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int? = nil
        )
        {
            self.`protocol` = `protocol`
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.path = path
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension AppRunnerClientTypes {
    public enum HealthCheckProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocol] {
            return [
                .http,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckProtocol(rawValue: rawValue) ?? HealthCheckProtocol.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.ImageConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "Port"
        case runtimeEnvironmentVariables = "RuntimeEnvironmentVariables"
        case startCommand = "StartCommand"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let runtimeEnvironmentVariables = runtimeEnvironmentVariables {
            var runtimeEnvironmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .runtimeEnvironmentVariables)
            for (dictKey0, runtimeenvironmentvariables0) in runtimeEnvironmentVariables {
                try runtimeEnvironmentVariablesContainer.encode(runtimeenvironmentvariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startCommand = startCommand {
            try encodeContainer.encode(startCommand, forKey: .startCommand)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeEnvironmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .runtimeEnvironmentVariables)
        var runtimeEnvironmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let runtimeEnvironmentVariablesContainer = runtimeEnvironmentVariablesContainer {
            runtimeEnvironmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, runtimeenvironmentvariablesvalue0) in runtimeEnvironmentVariablesContainer {
                if let runtimeenvironmentvariablesvalue0 = runtimeenvironmentvariablesvalue0 {
                    runtimeEnvironmentVariablesDecoded0?[key0] = runtimeenvironmentvariablesvalue0
                }
            }
        }
        runtimeEnvironmentVariables = runtimeEnvironmentVariablesDecoded0
        let startCommandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startCommand)
        startCommand = startCommandDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .port)
        port = portDecoded
    }
}

extension AppRunnerClientTypes.ImageConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageConfiguration(port: \(Swift.String(describing: port)), runtimeEnvironmentVariables: \(Swift.String(describing: runtimeEnvironmentVariables)), startCommand: \(Swift.String(describing: startCommand)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes the configuration that AWS App Runner uses to run an App Runner service using an image pulled from a source image repository.</p>
    public struct ImageConfiguration: Swift.Equatable {
        /// <p>The port that your application listens to in the container.</p>
        ///          <p>Default: <code>8080</code>
        ///          </p>
        public let port: Swift.String?
        /// <p>Environment variables that are available to your running App Runner service. An array of key-value pairs. Keys with a prefix of <code>AWSAPPRUNNER</code>
        ///       are reserved for system use and aren't valid.</p>
        public let runtimeEnvironmentVariables: [Swift.String:Swift.String]?
        /// <p>An optional command that App Runner runs to start the application in the source image. If specified, this command overrides the Docker image’s default start
        ///       command.</p>
        public let startCommand: Swift.String?

        public init (
            port: Swift.String? = nil,
            runtimeEnvironmentVariables: [Swift.String:Swift.String]? = nil,
            startCommand: Swift.String? = nil
        )
        {
            self.port = port
            self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
            self.startCommand = startCommand
        }
    }

}

extension AppRunnerClientTypes.ImageRepository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageConfiguration = "ImageConfiguration"
        case imageIdentifier = "ImageIdentifier"
        case imageRepositoryType = "ImageRepositoryType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageConfiguration = imageConfiguration {
            try encodeContainer.encode(imageConfiguration, forKey: .imageConfiguration)
        }
        if let imageIdentifier = imageIdentifier {
            try encodeContainer.encode(imageIdentifier, forKey: .imageIdentifier)
        }
        if let imageRepositoryType = imageRepositoryType {
            try encodeContainer.encode(imageRepositoryType.rawValue, forKey: .imageRepositoryType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageIdentifier)
        imageIdentifier = imageIdentifierDecoded
        let imageConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ImageConfiguration.self, forKey: .imageConfiguration)
        imageConfiguration = imageConfigurationDecoded
        let imageRepositoryTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ImageRepositoryType.self, forKey: .imageRepositoryType)
        imageRepositoryType = imageRepositoryTypeDecoded
    }
}

extension AppRunnerClientTypes.ImageRepository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageRepository(imageConfiguration: \(Swift.String(describing: imageConfiguration)), imageIdentifier: \(Swift.String(describing: imageIdentifier)), imageRepositoryType: \(Swift.String(describing: imageRepositoryType)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes a source image repository.</p>
    public struct ImageRepository: Swift.Equatable {
        /// <p>Configuration for running the identified image.</p>
        public let imageConfiguration: AppRunnerClientTypes.ImageConfiguration?
        /// <p>The identifier of an image.</p>
        ///          <p>For an image in Amazon Elastic Container Registry (Amazon ECR), this is an image name. For the image name format, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html">Pulling an image</a> in the <i>Amazon ECR User Guide</i>.</p>
        public let imageIdentifier: Swift.String?
        /// <p>The type of the image repository. This reflects the repository provider and whether the repository is private or public.</p>
        public let imageRepositoryType: AppRunnerClientTypes.ImageRepositoryType?

        public init (
            imageConfiguration: AppRunnerClientTypes.ImageConfiguration? = nil,
            imageIdentifier: Swift.String? = nil,
            imageRepositoryType: AppRunnerClientTypes.ImageRepositoryType? = nil
        )
        {
            self.imageConfiguration = imageConfiguration
            self.imageIdentifier = imageIdentifier
            self.imageRepositoryType = imageRepositoryType
        }
    }

}

extension AppRunnerClientTypes {
    public enum ImageRepositoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecr
        case ecrPublic
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageRepositoryType] {
            return [
                .ecr,
                .ecrPublic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecr: return "ECR"
            case .ecrPublic: return "ECR_PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageRepositoryType(rawValue: rawValue) ?? ImageRepositoryType.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.InstanceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpu = "Cpu"
        case instanceRoleArn = "InstanceRoleArn"
        case memory = "Memory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpu = cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let instanceRoleArn = instanceRoleArn {
            try encodeContainer.encode(instanceRoleArn, forKey: .instanceRoleArn)
        }
        if let memory = memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let instanceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceRoleArn)
        instanceRoleArn = instanceRoleArnDecoded
    }
}

extension AppRunnerClientTypes.InstanceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceConfiguration(cpu: \(Swift.String(describing: cpu)), instanceRoleArn: \(Swift.String(describing: instanceRoleArn)), memory: \(Swift.String(describing: memory)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes the runtime configuration of an AWS App Runner service instance (scaling unit).</p>
    public struct InstanceConfiguration: Swift.Equatable {
        /// <p>The number of CPU units reserved for each instance of your App Runner service.</p>
        ///          <p>Default: <code>1 vCPU</code>
        ///          </p>
        public let cpu: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of an IAM role that provides permissions to your App Runner service. These are permissions that your code needs when it calls
        ///       any AWS APIs.</p>
        public let instanceRoleArn: Swift.String?
        /// <p>The amount of memory, in MB or GB, reserved for each instance of your App Runner service.</p>
        ///          <p>Default: <code>2 GB</code>
        ///          </p>
        public let memory: Swift.String?

        public init (
            cpu: Swift.String? = nil,
            instanceRoleArn: Swift.String? = nil,
            memory: Swift.String? = nil
        )
        {
            self.cpu = cpu
            self.instanceRoleArn = instanceRoleArn
            self.memory = memory
        }
    }

}

extension InternalServiceErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServiceErrorException(message: \(Swift.String(describing: message)))"}
}

extension InternalServiceErrorException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An unexpected service exception occurred.</p>
public struct InternalServiceErrorException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more input parameters aren't valid. Refer to the API action's document page, correct the input parameters, and try the action again.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidStateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidStateException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't perform this action when the resource is in its current state.</p>
public struct InvalidStateException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAutoScalingConfigurationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutoScalingConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutoScalingConfigurationsOutputError>
}

extension ListAutoScalingConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAutoScalingConfigurationsInput(autoScalingConfigurationName: \(Swift.String(describing: autoScalingConfigurationName)), latestOnly: \(Swift.String(describing: latestOnly)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAutoScalingConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case latestOnly = "LatestOnly"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if latestOnly != false {
            try encodeContainer.encode(latestOnly, forKey: .latestOnly)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAutoScalingConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutoScalingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutoScalingConfigurationsOutputError>
}

public struct ListAutoScalingConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutoScalingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutoScalingConfigurationsOutputError>
}

public struct ListAutoScalingConfigurationsInput: Swift.Equatable {
    /// <p>The name of the App Runner auto scaling configuration that you want to list. If specified, App Runner lists revisions that share this name. If not specified, App Runner
    ///       returns revisions of all configurations.</p>
    public let autoScalingConfigurationName: Swift.String?
    /// <p>Set to <code>true</code> to list only the latest revision for each requested configuration name.</p>
    ///          <p>Keep as <code>false</code> to list all revisions for each requested configuration name.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let latestOnly: Swift.Bool
    /// <p>The maximum number of results to include in each response (result page). It's used for a paginated request.</p>
    ///          <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
    public let maxResults: Swift.Int?
    /// <p>A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be
    ///       identical to the ones that are specified in the initial request.</p>
    ///          <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
    public let nextToken: Swift.String?

    public init (
        autoScalingConfigurationName: Swift.String? = nil,
        latestOnly: Swift.Bool = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.latestOnly = latestOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAutoScalingConfigurationsInputBody: Swift.Equatable {
    public let autoScalingConfigurationName: Swift.String?
    public let latestOnly: Swift.Bool
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListAutoScalingConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case latestOnly = "LatestOnly"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let latestOnlyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .latestOnly)
        latestOnly = latestOnlyDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAutoScalingConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAutoScalingConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAutoScalingConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAutoScalingConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAutoScalingConfigurationsOutputResponse(autoScalingConfigurationSummaryList: \(Swift.String(describing: autoScalingConfigurationSummaryList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAutoScalingConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAutoScalingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfigurationSummaryList = output.autoScalingConfigurationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.autoScalingConfigurationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAutoScalingConfigurationsOutputResponse: Swift.Equatable {
    /// <p>A list of summary information records for auto scaling configurations. In a paginated request, the request returns up to <code>MaxResults</code>
    ///       records for each call.</p>
    public let autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]?
    /// <p>The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.</p>
    public let nextToken: Swift.String?

    public init (
        autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationSummaryList = autoScalingConfigurationSummaryList
        self.nextToken = nextToken
    }
}

struct ListAutoScalingConfigurationsOutputResponseBody: Swift.Equatable {
    public let autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]?
    public let nextToken: Swift.String?
}

extension ListAutoScalingConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationSummaryList = "AutoScalingConfigurationSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.AutoScalingConfigurationSummary?].self, forKey: .autoScalingConfigurationSummaryList)
        var autoScalingConfigurationSummaryListDecoded0:[AppRunnerClientTypes.AutoScalingConfigurationSummary]? = nil
        if let autoScalingConfigurationSummaryListContainer = autoScalingConfigurationSummaryListContainer {
            autoScalingConfigurationSummaryListDecoded0 = [AppRunnerClientTypes.AutoScalingConfigurationSummary]()
            for structure0 in autoScalingConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    autoScalingConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        autoScalingConfigurationSummaryList = autoScalingConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListConnectionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

extension ListConnectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConnectionsInput(connectionName: \(Swift.String(describing: connectionName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConnectionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListConnectionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInput: Swift.Equatable {
    /// <p>If specified, only this connection is returned. If not specified, the result isn't filtered by name.</p>
    public let connectionName: Swift.String?
    /// <p>The maximum number of results to include in each response (result page). Used for a paginated request.</p>
    ///          <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
    public let maxResults: Swift.Int?
    /// <p>A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be
    ///       identical to the ones specified in the initial request.</p>
    ///          <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
    public let nextToken: Swift.String?

    public init (
        connectionName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionName = connectionName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectionsInputBody: Swift.Equatable {
    public let connectionName: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConnectionsOutputResponse(connectionSummaryList: \(Swift.String(describing: connectionSummaryList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionSummaryList = output.connectionSummaryList
            self.nextToken = output.nextToken
        } else {
            self.connectionSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectionsOutputResponse: Swift.Equatable {
    /// <p>A list of summary information records for connections. In a paginated request, the request returns up to <code>MaxResults</code> records for each
    ///       call.</p>
    public let connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]?
    /// <p>The token that you can pass in a subsequent request to get the next result page. Returned in a paginated request.</p>
    public let nextToken: Swift.String?

    public init (
        connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionSummaryList = connectionSummaryList
        self.nextToken = nextToken
    }
}

struct ListConnectionsOutputResponseBody: Swift.Equatable {
    public let connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]?
    public let nextToken: Swift.String?
}

extension ListConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionSummaryList = "ConnectionSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.ConnectionSummary?].self, forKey: .connectionSummaryList)
        var connectionSummaryListDecoded0:[AppRunnerClientTypes.ConnectionSummary]? = nil
        if let connectionSummaryListContainer = connectionSummaryListContainer {
            connectionSummaryListDecoded0 = [AppRunnerClientTypes.ConnectionSummary]()
            for structure0 in connectionSummaryListContainer {
                if let structure0 = structure0 {
                    connectionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        connectionSummaryList = connectionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOperationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

extension ListOperationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOperationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension ListOperationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct ListOperationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

public struct ListOperationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

public struct ListOperationsInput: Swift.Equatable {
    /// <p>The maximum number of results to include in each response (result page). It's used for a paginated request.</p>
    ///          <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
    public let maxResults: Swift.Int?
    /// <p>A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be
    ///       identical to the ones specified in the initial request.</p>
    ///          <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
    public let nextToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want a list of operations for.</p>
    public let serviceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct ListOperationsInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOperationsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOperationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOperationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), operationSummaryList: \(Swift.String(describing: operationSummaryList)))"}
}

extension ListOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.operationSummaryList = output.operationSummaryList
        } else {
            self.nextToken = nil
            self.operationSummaryList = nil
        }
    }
}

public struct ListOperationsOutputResponse: Swift.Equatable {
    /// <p>The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.</p>
    public let nextToken: Swift.String?
    /// <p>A list of operation summary information records. In a paginated request, the request returns up to <code>MaxResults</code> records for each
    ///       call.</p>
    public let operationSummaryList: [AppRunnerClientTypes.OperationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        operationSummaryList: [AppRunnerClientTypes.OperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.operationSummaryList = operationSummaryList
    }
}

struct ListOperationsOutputResponseBody: Swift.Equatable {
    public let operationSummaryList: [AppRunnerClientTypes.OperationSummary]?
    public let nextToken: Swift.String?
}

extension ListOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case operationSummaryList = "OperationSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.OperationSummary?].self, forKey: .operationSummaryList)
        var operationSummaryListDecoded0:[AppRunnerClientTypes.OperationSummary]? = nil
        if let operationSummaryListContainer = operationSummaryListContainer {
            operationSummaryListDecoded0 = [AppRunnerClientTypes.OperationSummary]()
            for structure0 in operationSummaryListContainer {
                if let structure0 = structure0 {
                    operationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        operationSummaryList = operationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListServicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

extension ListServicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListServicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInput: Swift.Equatable {
    /// <p>The maximum number of results to include in each response (result page). It's used for a paginated request.</p>
    ///          <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
    public let maxResults: Swift.Int?
    /// <p>A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be
    ///       identical to the ones specified in the initial request.</p>
    ///          <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), serviceSummaryList: \(Swift.String(describing: serviceSummaryList)))"}
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceSummaryList = output.serviceSummaryList
        } else {
            self.nextToken = nil
            self.serviceSummaryList = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// <p>The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.</p>
    public let nextToken: Swift.String?
    /// <p>A list of service summary information records. In a paginated request, the request returns up to <code>MaxResults</code> records for each call.</p>
    public let serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceSummaryList = serviceSummaryList
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    public let serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]?
    public let nextToken: Swift.String?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceSummaryList = "ServiceSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.ServiceSummary?].self, forKey: .serviceSummaryList)
        var serviceSummaryListDecoded0:[AppRunnerClientTypes.ServiceSummary]? = nil
        if let serviceSummaryListContainer = serviceSummaryListContainer {
            serviceSummaryListDecoded0 = [AppRunnerClientTypes.ServiceSummary]()
            for structure0 in serviceSummaryListContainer {
                if let structure0 = structure0 {
                    serviceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        serviceSummaryList = serviceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that a tag list is requested for.</p>
    ///          <p>It must be the ARN of an App Runner resource.</p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>A list of the tag key-value pairs that are associated with the resource.</p>
    public let tags: [AppRunnerClientTypes.Tag]?

    public init (
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [AppRunnerClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppRunnerClientTypes {
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case rollbackFailed
        case rollbackInProgress
        case rollbackSucceeded
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .failed,
                .inProgress,
                .pending,
                .rollbackFailed,
                .rollbackInProgress,
                .rollbackSucceeded,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .rollbackFailed: return "ROLLBACK_FAILED"
            case .rollbackInProgress: return "ROLLBACK_IN_PROGRESS"
            case .rollbackSucceeded: return "ROLLBACK_SUCCEEDED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.OperationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedAt = "EndedAt"
        case id = "Id"
        case startedAt = "StartedAt"
        case status = "Status"
        case targetArn = "TargetArn"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.OperationType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension AppRunnerClientTypes.OperationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationSummary(endedAt: \(Swift.String(describing: endedAt)), id: \(Swift.String(describing: id)), startedAt: \(Swift.String(describing: startedAt)), status: \(Swift.String(describing: status)), targetArn: \(Swift.String(describing: targetArn)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension AppRunnerClientTypes {
    /// <p>Provides summary information for an operation that occurred on an AWS App Runner service.</p>
    public struct OperationSummary: Swift.Equatable {
        /// <p>The time when the operation ended. It's in the Unix time stamp format.</p>
        public let endedAt: ClientRuntime.Date?
        /// <p>A unique ID of this operation. It's unique in the scope of the App Runner service.</p>
        public let id: Swift.String?
        /// <p>The time when the operation started. It's in the Unix time stamp format.</p>
        public let startedAt: ClientRuntime.Date?
        /// <p>The current state of the operation.</p>
        public let status: AppRunnerClientTypes.OperationStatus?
        /// <p>The Amazon Resource Name (ARN) of the resource that the operation acted on (for example, an App Runner service).</p>
        public let targetArn: Swift.String?
        /// <p>The type of operation. It indicates a specific action that occured.</p>
        public let type: AppRunnerClientTypes.OperationType?
        /// <p>The time when the operation was last updated. It's in the Unix time stamp format.</p>
        public let updatedAt: ClientRuntime.Date?

        public init (
            endedAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: AppRunnerClientTypes.OperationStatus? = nil,
            targetArn: Swift.String? = nil,
            type: AppRunnerClientTypes.OperationType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.endedAt = endedAt
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.targetArn = targetArn
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension AppRunnerClientTypes {
    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createService
        case deleteService
        case pauseService
        case resumeService
        case startDeployment
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .createService,
                .deleteService,
                .pauseService,
                .resumeService,
                .startDeployment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createService: return "CREATE_SERVICE"
            case .deleteService: return "DELETE_SERVICE"
            case .pauseService: return "PAUSE_SERVICE"
            case .resumeService: return "RESUME_SERVICE"
            case .startDeployment: return "START_DEPLOYMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
        }
    }
}

public struct PauseServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PauseServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PauseServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseServiceOutputError>
}

extension PauseServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PauseServiceInput(serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension PauseServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct PauseServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PauseServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PauseServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseServiceOutputError>
}

public struct PauseServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PauseServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PauseServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseServiceOutputError>
}

public struct PauseServiceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to pause.</p>
    public let serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct PauseServiceInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
}

extension PauseServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension PauseServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PauseServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PauseServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PauseServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PauseServiceOutputResponse(operationId: \(Swift.String(describing: operationId)), service: \(Swift.String(describing: service)))"}
}

extension PauseServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PauseServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct PauseServiceOutputResponse: Swift.Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a>ListOperations</a> call to track
    ///       the operation's progress.</p>
    public let operationId: Swift.String?
    /// <p>A description of the App Runner service that this request just paused.</p>
    public let service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct PauseServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
    public let operationId: Swift.String?
}

extension PauseServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes {
    public enum ProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case github
        case sdkUnknown(Swift.String)

        public static var allCases: [ProviderType] {
            return [
                .github,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .github: return "GITHUB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProviderType(rawValue: rawValue) ?? ProviderType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource doesn't exist for the specified Amazon Resource Name (ARN) in your AWS account.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ResumeServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeServiceOutputError>
}

extension ResumeServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeServiceInput(serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension ResumeServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct ResumeServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeServiceOutputError>
}

public struct ResumeServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeServiceOutputError>
}

public struct ResumeServiceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to resume.</p>
    public let serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct ResumeServiceInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
}

extension ResumeServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension ResumeServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeServiceOutputResponse(operationId: \(Swift.String(describing: operationId)), service: \(Swift.String(describing: service)))"}
}

extension ResumeServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResumeServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct ResumeServiceOutputResponse: Swift.Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a>ListOperations</a> call to track
    ///       the operation's progress.</p>
    public let operationId: Swift.String?
    /// <p>A description of the App Runner service that this request just resumed.</p>
    public let service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct ResumeServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
    public let operationId: Swift.String?
}

extension ResumeServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes {
    public enum Runtime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nodejs12
        case python3
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .nodejs12,
                .python3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nodejs12: return "NODEJS_12"
            case .python3: return "PYTHON_3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Runtime(rawValue: rawValue) ?? Runtime.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.Service: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationSummary = "AutoScalingConfigurationSummary"
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceArn = "ServiceArn"
        case serviceId = "ServiceId"
        case serviceName = "ServiceName"
        case serviceUrl = "ServiceUrl"
        case sourceConfiguration = "SourceConfiguration"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationSummary = autoScalingConfigurationSummary {
            try encodeContainer.encode(autoScalingConfigurationSummary, forKey: .autoScalingConfigurationSummary)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deletedAt = deletedAt {
            try encodeContainer.encode(deletedAt.timeIntervalSince1970, forKey: .deletedAt)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let healthCheckConfiguration = healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceUrl = serviceUrl {
            try encodeContainer.encode(serviceUrl, forKey: .serviceUrl)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUrl)
        serviceUrl = serviceUrlDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let deletedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
        let autoScalingConfigurationSummaryDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfigurationSummary.self, forKey: .autoScalingConfigurationSummary)
        autoScalingConfigurationSummary = autoScalingConfigurationSummaryDecoded
    }
}

extension AppRunnerClientTypes.Service: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Service(autoScalingConfigurationSummary: \(Swift.String(describing: autoScalingConfigurationSummary)), createdAt: \(Swift.String(describing: createdAt)), deletedAt: \(Swift.String(describing: deletedAt)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), healthCheckConfiguration: \(Swift.String(describing: healthCheckConfiguration)), instanceConfiguration: \(Swift.String(describing: instanceConfiguration)), serviceArn: \(Swift.String(describing: serviceArn)), serviceId: \(Swift.String(describing: serviceId)), serviceName: \(Swift.String(describing: serviceName)), serviceUrl: \(Swift.String(describing: serviceUrl)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes an AWS App Runner service. It can describe a service in any state, including deleted services.</p>
    ///          <p>This type contains the full information about a service, including configuration details. It's returned by the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_CreateService.html">CreateService</a>, <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_DescribeService.html">DescribeService</a>, and <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_DeleteService.html">DeleteService</a> actions. A subset of this
    ///       information is returned by the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_ListServices.html">ListServices</a> action using the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_ServiceSummary.html">ServiceSummary</a> type.</p>
    public struct Service: Swift.Equatable {
        /// <p>Summary information for the App Runner automatic scaling configuration resource that's associated with this service.</p>
        public let autoScalingConfigurationSummary: AppRunnerClientTypes.AutoScalingConfigurationSummary?
        /// <p>The time when the App Runner service was created. It's in the Unix time stamp format.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The time when the App Runner service was deleted. It's in the Unix time stamp format.</p>
        public let deletedAt: ClientRuntime.Date?
        /// <p>The encryption key that App Runner uses to encrypt the service logs and the copy of the source repository that App Runner maintains for the service. It can be
        ///       either a customer-provided encryption key or an AWS managed CMK.</p>
        public let encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
        /// <p>The settings for the health check that App Runner performs to monitor the health of this service.</p>
        public let healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
        /// <p>The runtime configuration of instances (scaling units) of this service.</p>
        public let instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
        /// <p>The Amazon Resource Name (ARN) of this service.</p>
        public let serviceArn: Swift.String?
        /// <p>An ID that App Runner generated for this service. It's unique within the AWS Region.</p>
        public let serviceId: Swift.String?
        /// <p>The customer-provided service name.</p>
        public let serviceName: Swift.String?
        /// <p>A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.</p>
        public let serviceUrl: Swift.String?
        /// <p>The source deployed to the App Runner service. It can be a code or an image repository.</p>
        public let sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
        /// <p>The current state of the App Runner service. These particular values mean the following.</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>CREATE_FAILED</code> – The service failed to create. To troubleshoot this failure, read the failure events and logs, change any
        ///           parameters that need to be fixed, and retry the call to create the service.</p>
        ///                <p>The failed service isn't usable, and still counts towards your service quota. When you're done analyzing the failure, delete the service.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>DELETE_FAILED</code> – The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure
        ///           that all related resources are removed.</p>
        ///             </li>
        ///          </ul>
        public let status: AppRunnerClientTypes.ServiceStatus?
        /// <p>The time when the App Runner service was last updated at. It's in the Unix time stamp format.</p>
        public let updatedAt: ClientRuntime.Date?

        public init (
            autoScalingConfigurationSummary: AppRunnerClientTypes.AutoScalingConfigurationSummary? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration? = nil,
            healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
            instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceUrl: Swift.String? = nil,
            sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil,
            status: AppRunnerClientTypes.ServiceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.autoScalingConfigurationSummary = autoScalingConfigurationSummary
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.encryptionConfiguration = encryptionConfiguration
            self.healthCheckConfiguration = healthCheckConfiguration
            self.instanceConfiguration = instanceConfiguration
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceUrl = serviceUrl
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>App Runner can't create this resource. You've reached your account quota for this resource type.</p>
///          <p>For App Runner per-resource quotas, see <a href="https://docs.aws.amazon.com/general/latest/gr/apprunner.html">AWS App Runner endpoints and quotas</a> in the
///         <i>AWS General Reference</i>.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppRunnerClientTypes {
    public enum ServiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case deleted
        case deleteFailed
        case operationInProgress
        case paused
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .createFailed,
                .deleted,
                .deleteFailed,
                .operationInProgress,
                .paused,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .operationInProgress: return "OPERATION_IN_PROGRESS"
            case .paused: return "PAUSED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceStatus(rawValue: rawValue) ?? ServiceStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.ServiceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case serviceArn = "ServiceArn"
        case serviceId = "ServiceId"
        case serviceName = "ServiceName"
        case serviceUrl = "ServiceUrl"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceUrl = serviceUrl {
            try encodeContainer.encode(serviceUrl, forKey: .serviceUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUrl)
        serviceUrl = serviceUrlDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppRunnerClientTypes.ServiceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSummary(createdAt: \(Swift.String(describing: createdAt)), serviceArn: \(Swift.String(describing: serviceArn)), serviceId: \(Swift.String(describing: serviceId)), serviceName: \(Swift.String(describing: serviceName)), serviceUrl: \(Swift.String(describing: serviceUrl)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension AppRunnerClientTypes {
    /// <p>Provides summary information for an AWS App Runner service.</p>
    ///          <p>This type contains limited information about a service. It doesn't include configuration details. It's returned by the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_ListServices.html">ListServices</a> action. Complete service information is returned by the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_CreateService.html">CreateService</a>, <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_DescribeService.html">DescribeService</a>, and <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_DeleteService.html">DeleteService</a> actions using the <a href="https://docs.aws.amazon.com/apprunner/latest/api/API_Service.html">Service</a> type.</p>
    public struct ServiceSummary: Swift.Equatable {
        /// <p>The time when the App Runner service was created. It's in the Unix time stamp format.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The Amazon Resource Name (ARN) of this service.</p>
        public let serviceArn: Swift.String?
        /// <p>An ID that App Runner generated for this service. It's unique within the AWS Region.</p>
        public let serviceId: Swift.String?
        /// <p>The customer-provided service name.</p>
        public let serviceName: Swift.String?
        /// <p>A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.</p>
        public let serviceUrl: Swift.String?
        /// <p>The current state of the App Runner service. These particular values mean the following.</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>CREATE_FAILED</code> – The service failed to create. Read the failure events and logs, change any parameters that need to be fixed,
        ///           and retry the call to create the service.</p>
        ///                <p>The failed service isn't usable, and still counts towards your service quota. When you're done analyzing the failure, delete the service.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>DELETE_FAILED</code> – The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure
        ///           that all related resources are removed.</p>
        ///             </li>
        ///          </ul>
        public let status: AppRunnerClientTypes.ServiceStatus?
        /// <p>The time when the App Runner service was last updated. It's in theUnix time stamp format.</p>
        public let updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceUrl: Swift.String? = nil,
            status: AppRunnerClientTypes.ServiceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceUrl = serviceUrl
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension AppRunnerClientTypes.SourceCodeVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceCodeVersionType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppRunnerClientTypes.SourceCodeVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceCodeVersion(type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension AppRunnerClientTypes {
    /// <p>Identifies a version of code that AWS App Runner refers to within a source code repository.</p>
    public struct SourceCodeVersion: Swift.Equatable {
        /// <p>The type of version identifier.</p>
        ///          <p>For a git-based repository, branches represent versions.</p>
        public let type: AppRunnerClientTypes.SourceCodeVersionType?
        /// <p>A source code version.</p>
        ///          <p>For a git-based repository, a branch name maps to a specific version. App Runner uses the most recent commit to the branch.</p>
        public let value: Swift.String?

        public init (
            type: AppRunnerClientTypes.SourceCodeVersionType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension AppRunnerClientTypes {
    public enum SourceCodeVersionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case branch
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceCodeVersionType] {
            return [
                .branch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .branch: return "BRANCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceCodeVersionType(rawValue: rawValue) ?? SourceCodeVersionType.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.SourceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationConfiguration = "AuthenticationConfiguration"
        case autoDeploymentsEnabled = "AutoDeploymentsEnabled"
        case codeRepository = "CodeRepository"
        case imageRepository = "ImageRepository"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationConfiguration = authenticationConfiguration {
            try encodeContainer.encode(authenticationConfiguration, forKey: .authenticationConfiguration)
        }
        if let autoDeploymentsEnabled = autoDeploymentsEnabled {
            try encodeContainer.encode(autoDeploymentsEnabled, forKey: .autoDeploymentsEnabled)
        }
        if let codeRepository = codeRepository {
            try encodeContainer.encode(codeRepository, forKey: .codeRepository)
        }
        if let imageRepository = imageRepository {
            try encodeContainer.encode(imageRepository, forKey: .imageRepository)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeRepositoryDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CodeRepository.self, forKey: .codeRepository)
        codeRepository = codeRepositoryDecoded
        let imageRepositoryDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ImageRepository.self, forKey: .imageRepository)
        imageRepository = imageRepositoryDecoded
        let autoDeploymentsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploymentsEnabled)
        autoDeploymentsEnabled = autoDeploymentsEnabledDecoded
        let authenticationConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AuthenticationConfiguration.self, forKey: .authenticationConfiguration)
        authenticationConfiguration = authenticationConfigurationDecoded
    }
}

extension AppRunnerClientTypes.SourceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceConfiguration(authenticationConfiguration: \(Swift.String(describing: authenticationConfiguration)), autoDeploymentsEnabled: \(Swift.String(describing: autoDeploymentsEnabled)), codeRepository: \(Swift.String(describing: codeRepository)), imageRepository: \(Swift.String(describing: imageRepository)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes the source deployed to an AWS App Runner service. It can be a code or an image repository.</p>
    public struct SourceConfiguration: Swift.Equatable {
        /// <p>Describes the resources that are needed to authenticate access to some source repositories.</p>
        public let authenticationConfiguration: AppRunnerClientTypes.AuthenticationConfiguration?
        /// <p>If <code>true</code>, continuous integration from the source repository is enabled for the App Runner service. Each repository change (source code commit or
        ///       new image version) starts a deployment.</p>
        ///          <p>Default: <code>true</code>
        ///          </p>
        public let autoDeploymentsEnabled: Swift.Bool?
        /// <p>The description of a source code repository.</p>
        ///          <p>You must provide either this member or <code>ImageRepository</code> (but not both).</p>
        public let codeRepository: AppRunnerClientTypes.CodeRepository?
        /// <p>The description of a source image
        ///       repository.</p>
        ///          <p>You must provide either this member or <code>CodeRepository</code> (but not both).</p>
        public let imageRepository: AppRunnerClientTypes.ImageRepository?

        public init (
            authenticationConfiguration: AppRunnerClientTypes.AuthenticationConfiguration? = nil,
            autoDeploymentsEnabled: Swift.Bool? = nil,
            codeRepository: AppRunnerClientTypes.CodeRepository? = nil,
            imageRepository: AppRunnerClientTypes.ImageRepository? = nil
        )
        {
            self.authenticationConfiguration = authenticationConfiguration
            self.autoDeploymentsEnabled = autoDeploymentsEnabled
            self.codeRepository = codeRepository
            self.imageRepository = imageRepository
        }
    }

}

public struct StartDeploymentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

extension StartDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDeploymentInput(serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension StartDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct StartDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to manually deploy to.</p>
    public let serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct StartDeploymentInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
}

extension StartDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension StartDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeploymentOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDeploymentOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension StartDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct StartDeploymentOutputResponse: Swift.Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a>ListOperations</a> call to track
    ///       the operation's progress.</p>
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct StartDeploymentOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension StartDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppRunnerClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension AppRunnerClientTypes {
    /// <p>Describes a tag that is applied to an AWS App Runner resource. A tag is a metadata item consisting of a key-value pair.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The key of the tag.</p>
        public let key: Swift.String?
        /// <p>The value of the tag.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to update tags for.</p>
    ///          <p>It must be the ARN of an App Runner resource.</p>
    public let resourceArn: Swift.String?
    /// <p>A list of tag key-value pairs to add or update. If a key is new to the resource, the tag is added with the provided value. If a key is already
    ///       associated with the resource, the value of the tag is updated.</p>
    public let tags: [AppRunnerClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [AppRunnerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
    ///          <p>It must be the ARN of an App Runner resource.</p>
    public let resourceArn: Swift.String?
    /// <p>A list of tag keys that you want to remove.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

extension UpdateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceInput(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)), healthCheckConfiguration: \(Swift.String(describing: healthCheckConfiguration)), instanceConfiguration: \(Swift.String(describing: instanceConfiguration)), serviceArn: \(Swift.String(describing: serviceArn)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)))"}
}

extension UpdateServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceArn = "ServiceArn"
        case sourceConfiguration = "SourceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let healthCheckConfiguration = healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
    }
}

public struct UpdateServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service.</p>
    public let autoScalingConfigurationArn: Swift.String?
    /// <p>The settings for the health check that AWS App Runner performs to monitor the health of your service.</p>
    public let healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    /// <p>The runtime configuration to apply to instances (scaling units) of the App Runner service.</p>
    public let instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to update.</p>
    public let serviceArn: Swift.String?
    /// <p>The source configuration to apply to the App Runner service.</p>
    ///          <p>You can change the configuration of the code or image repository that the service uses. However, you can't switch from code to image or the other way
    ///       around. This means that you must provide the same structure member of <code>SourceConfiguration</code> that you originally included when you created the
    ///       service. Specifically, you can include either <code>CodeRepository</code> or <code>ImageRepository</code>. To update the source configuration, set the
    ///       values to members of the structure that you include.</p>
    public let sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil,
        healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
        instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
        serviceArn: Swift.String? = nil,
        sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.serviceArn = serviceArn
        self.sourceConfiguration = sourceConfiguration
    }
}

struct UpdateServiceInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
    public let sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
    public let instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    public let autoScalingConfigurationArn: Swift.String?
    public let healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
}

extension UpdateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceArn = "ServiceArn"
        case sourceConfiguration = "SourceConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
    }
}

extension UpdateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceOutputResponse(operationId: \(Swift.String(describing: operationId)), service: \(Swift.String(describing: service)))"}
}

extension UpdateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct UpdateServiceOutputResponse: Swift.Equatable {
    /// <p>The unique ID of the asynchronous operation that this request started. You can use it combined with the <a>ListOperations</a> call to track
    ///       the operation's progress.</p>
    public let operationId: Swift.String?
    /// <p>A description of the App Runner service updated by this request. All configuration values in the returned <code>Service</code> structure reflect
    ///       configuration changes that are being applied by this request.</p>
    public let service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct UpdateServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
    public let operationId: Swift.String?
}

extension UpdateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}
