// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension NetworkManagerClientTypes.AWSLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetArn = "SubnetArn"
        case zone = "Zone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetArn = subnetArn {
            try encodeContainer.encode(subnetArn, forKey: .subnetArn)
        }
        if let zone = zone {
            try encodeContainer.encode(zone, forKey: .zone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zone)
        zone = zoneDecoded
        let subnetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetArn)
        subnetArn = subnetArnDecoded
    }
}

extension NetworkManagerClientTypes.AWSLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AWSLocation(subnetArn: \(Swift.String(describing: subnetArn)), zone: \(Swift.String(describing: zone)))"}
}

extension NetworkManagerClientTypes {
    /// Specifies a location in Amazon Web Services.
    public struct AWSLocation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the subnet that the device is located in.
        public var subnetArn: Swift.String?
        /// The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
        public var zone: Swift.String?

        public init (
            subnetArn: Swift.String? = nil,
            zone: Swift.String? = nil
        )
        {
            self.subnetArn = subnetArn
            self.zone = zone
        }
    }

}

extension AcceptAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptAttachmentInput(attachmentId: \(Swift.String(describing: attachmentId)))"}
}

extension AcceptAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AcceptAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptAttachmentOutputError>
}

public struct AcceptAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptAttachmentOutputError>
}

public struct AcceptAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AcceptAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptAttachmentOutputError>
}

public struct AcceptAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AcceptAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let attachmentId = input.attachmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attachmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/attachments/\(attachmentId.urlPercentEncoding())/accept"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptAttachmentOutputError>
}

public struct AcceptAttachmentInput: Swift.Equatable {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct AcceptAttachmentInputBody: Swift.Equatable {
}

extension AcceptAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AcceptAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptAttachmentOutputResponse(attachment: \(Swift.String(describing: attachment)))"}
}

extension AcceptAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachment = output.attachment
        } else {
            self.attachment = nil
        }
    }
}

public struct AcceptAttachmentOutputResponse: Swift.Equatable {
    /// The response to the attachment request.
    public var attachment: NetworkManagerClientTypes.Attachment?

    public init (
        attachment: NetworkManagerClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

struct AcceptAttachmentOutputResponseBody: Swift.Equatable {
    public let attachment: NetworkManagerClientTypes.Attachment?
}

extension AcceptAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateConnectPeerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateConnectPeerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateConnectPeerOutputError>
}

extension AssociateConnectPeerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateConnectPeerInput(connectPeerId: \(Swift.String(describing: connectPeerId)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension AssociateConnectPeerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerId = "ConnectPeerId"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectPeerId = connectPeerId {
            try encodeContainer.encode(connectPeerId, forKey: .connectPeerId)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

public struct AssociateConnectPeerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateConnectPeerOutputError>
}

public struct AssociateConnectPeerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateConnectPeerOutputError>
}

public struct AssociateConnectPeerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateConnectPeerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateConnectPeerOutputError>
}

public struct AssociateConnectPeerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateConnectPeerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connect-peer-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateConnectPeerOutputError>
}

public struct AssociateConnectPeerInput: Swift.Equatable {
    /// The ID of the Connect peer.
    /// This member is required.
    public var connectPeerId: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of your global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?

    public init (
        connectPeerId: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct AssociateConnectPeerInputBody: Swift.Equatable {
    public let connectPeerId: Swift.String?
    public let deviceId: Swift.String?
    public let linkId: Swift.String?
}

extension AssociateConnectPeerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerId = "ConnectPeerId"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectPeerId)
        connectPeerId = connectPeerIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateConnectPeerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateConnectPeerOutputResponse(connectPeerAssociation: \(Swift.String(describing: connectPeerAssociation)))"}
}

extension AssociateConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeerAssociation = output.connectPeerAssociation
        } else {
            self.connectPeerAssociation = nil
        }
    }
}

public struct AssociateConnectPeerOutputResponse: Swift.Equatable {
    /// The response to the Connect peer request.
    public var connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation?

    public init (
        connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation? = nil
    )
    {
        self.connectPeerAssociation = connectPeerAssociation
    }
}

struct AssociateConnectPeerOutputResponseBody: Swift.Equatable {
    public let connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation?
}

extension AssociateConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerAssociation = "ConnectPeerAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerAssociation.self, forKey: .connectPeerAssociation)
        connectPeerAssociation = connectPeerAssociationDecoded
    }
}

public struct AssociateCustomerGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomerGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomerGatewayOutputError>
}

extension AssociateCustomerGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateCustomerGatewayInput(customerGatewayArn: \(Swift.String(describing: customerGatewayArn)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension AssociateCustomerGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerGatewayArn = customerGatewayArn {
            try encodeContainer.encode(customerGatewayArn, forKey: .customerGatewayArn)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

public struct AssociateCustomerGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomerGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomerGatewayOutputError>
}

public struct AssociateCustomerGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomerGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomerGatewayOutputError>
}

public struct AssociateCustomerGatewayInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomerGatewayInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateCustomerGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateCustomerGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomerGatewayOutputError>
}

public struct AssociateCustomerGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomerGatewayInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateCustomerGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateCustomerGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomerGatewayOutputError>
}

public struct AssociateCustomerGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the customer gateway.
    /// This member is required.
    public var customerGatewayArn: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?

    public init (
        customerGatewayArn: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct AssociateCustomerGatewayInputBody: Swift.Equatable {
    public let customerGatewayArn: Swift.String?
    public let deviceId: Swift.String?
    public let linkId: Swift.String?
}

extension AssociateCustomerGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerGatewayArn)
        customerGatewayArn = customerGatewayArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateCustomerGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCustomerGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateCustomerGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCustomerGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateCustomerGatewayOutputResponse(customerGatewayAssociation: \(Swift.String(describing: customerGatewayAssociation)))"}
}

extension AssociateCustomerGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateCustomerGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerGatewayAssociation = output.customerGatewayAssociation
        } else {
            self.customerGatewayAssociation = nil
        }
    }
}

public struct AssociateCustomerGatewayOutputResponse: Swift.Equatable {
    /// The customer gateway association.
    public var customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?

    public init (
        customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation? = nil
    )
    {
        self.customerGatewayAssociation = customerGatewayAssociation
    }
}

struct AssociateCustomerGatewayOutputResponseBody: Swift.Equatable {
    public let customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?
}

extension AssociateCustomerGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayAssociation = "CustomerGatewayAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CustomerGatewayAssociation.self, forKey: .customerGatewayAssociation)
        customerGatewayAssociation = customerGatewayAssociationDecoded
    }
}

public struct AssociateLinkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLinkOutputError>
}

extension AssociateLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateLinkInput(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension AssociateLinkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

public struct AssociateLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLinkOutputError>
}

public struct AssociateLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLinkOutputError>
}

public struct AssociateLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLinkOutputError>
}

public struct AssociateLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLinkOutputError>
}

public struct AssociateLinkInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct AssociateLinkInputBody: Swift.Equatable {
    public let deviceId: Swift.String?
    public let linkId: Swift.String?
}

extension AssociateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateLinkOutputResponse(linkAssociation: \(Swift.String(describing: linkAssociation)))"}
}

extension AssociateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkAssociation = output.linkAssociation
        } else {
            self.linkAssociation = nil
        }
    }
}

public struct AssociateLinkOutputResponse: Swift.Equatable {
    /// The link association.
    public var linkAssociation: NetworkManagerClientTypes.LinkAssociation?

    public init (
        linkAssociation: NetworkManagerClientTypes.LinkAssociation? = nil
    )
    {
        self.linkAssociation = linkAssociation
    }
}

struct AssociateLinkOutputResponseBody: Swift.Equatable {
    public let linkAssociation: NetworkManagerClientTypes.LinkAssociation?
}

extension AssociateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkAssociation = "LinkAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkAssociation.self, forKey: .linkAssociation)
        linkAssociation = linkAssociationDecoded
    }
}

public struct AssociateTransitGatewayConnectPeerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTransitGatewayConnectPeerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

extension AssociateTransitGatewayConnectPeerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTransitGatewayConnectPeerInput(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), transitGatewayConnectPeerArn: \(Swift.String(describing: transitGatewayConnectPeerArn)))"}
}

extension AssociateTransitGatewayConnectPeerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let transitGatewayConnectPeerArn = transitGatewayConnectPeerArn {
            try encodeContainer.encode(transitGatewayConnectPeerArn, forKey: .transitGatewayConnectPeerArn)
        }
    }
}

public struct AssociateTransitGatewayConnectPeerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTransitGatewayConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

public struct AssociateTransitGatewayConnectPeerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTransitGatewayConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

public struct AssociateTransitGatewayConnectPeerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTransitGatewayConnectPeerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateTransitGatewayConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateTransitGatewayConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

public struct AssociateTransitGatewayConnectPeerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTransitGatewayConnectPeerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateTransitGatewayConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateTransitGatewayConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

public struct AssociateTransitGatewayConnectPeerInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Connect peer.
    /// This member is required.
    public var transitGatewayConnectPeerArn: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        transitGatewayConnectPeerArn: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

struct AssociateTransitGatewayConnectPeerInputBody: Swift.Equatable {
    public let transitGatewayConnectPeerArn: Swift.String?
    public let deviceId: Swift.String?
    public let linkId: Swift.String?
}

extension AssociateTransitGatewayConnectPeerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayConnectPeerArn)
        transitGatewayConnectPeerArn = transitGatewayConnectPeerArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateTransitGatewayConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTransitGatewayConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateTransitGatewayConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTransitGatewayConnectPeerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTransitGatewayConnectPeerOutputResponse(transitGatewayConnectPeerAssociation: \(Swift.String(describing: transitGatewayConnectPeerAssociation)))"}
}

extension AssociateTransitGatewayConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateTransitGatewayConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayConnectPeerAssociation = output.transitGatewayConnectPeerAssociation
        } else {
            self.transitGatewayConnectPeerAssociation = nil
        }
    }
}

public struct AssociateTransitGatewayConnectPeerOutputResponse: Swift.Equatable {
    /// The transit gateway Connect peer association.
    public var transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?

    public init (
        transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation? = nil
    )
    {
        self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
    }
}

struct AssociateTransitGatewayConnectPeerOutputResponseBody: Swift.Equatable {
    public let transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?
}

extension AssociateTransitGatewayConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation.self, forKey: .transitGatewayConnectPeerAssociation)
        transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociationDecoded
    }
}

extension NetworkManagerClientTypes.Attachment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
        case attachmentPolicyRuleNumber = "AttachmentPolicyRuleNumber"
        case attachmentType = "AttachmentType"
        case coreNetworkArn = "CoreNetworkArn"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case edgeLocation = "EdgeLocation"
        case ownerAccountId = "OwnerAccountId"
        case proposedSegmentChange = "ProposedSegmentChange"
        case resourceArn = "ResourceArn"
        case segmentName = "SegmentName"
        case state = "State"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let attachmentPolicyRuleNumber = attachmentPolicyRuleNumber {
            try encodeContainer.encode(attachmentPolicyRuleNumber, forKey: .attachmentPolicyRuleNumber)
        }
        if let attachmentType = attachmentType {
            try encodeContainer.encode(attachmentType.rawValue, forKey: .attachmentType)
        }
        if let coreNetworkArn = coreNetworkArn {
            try encodeContainer.encode(coreNetworkArn, forKey: .coreNetworkArn)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let edgeLocation = edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let proposedSegmentChange = proposedSegmentChange {
            try encodeContainer.encode(proposedSegmentChange, forKey: .proposedSegmentChange)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let segmentName = segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let coreNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkArn)
        coreNetworkArn = coreNetworkArnDecoded
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let attachmentTypeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AttachmentType.self, forKey: .attachmentType)
        attachmentType = attachmentTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AttachmentState.self, forKey: .state)
        state = stateDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let attachmentPolicyRuleNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentPolicyRuleNumber)
        attachmentPolicyRuleNumber = attachmentPolicyRuleNumberDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let proposedSegmentChangeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ProposedSegmentChange.self, forKey: .proposedSegmentChange)
        proposedSegmentChange = proposedSegmentChangeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension NetworkManagerClientTypes.Attachment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attachment(attachmentId: \(Swift.String(describing: attachmentId)), attachmentPolicyRuleNumber: \(Swift.String(describing: attachmentPolicyRuleNumber)), attachmentType: \(Swift.String(describing: attachmentType)), coreNetworkArn: \(Swift.String(describing: coreNetworkArn)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), createdAt: \(Swift.String(describing: createdAt)), edgeLocation: \(Swift.String(describing: edgeLocation)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), proposedSegmentChange: \(Swift.String(describing: proposedSegmentChange)), resourceArn: \(Swift.String(describing: resourceArn)), segmentName: \(Swift.String(describing: segmentName)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network attachment.
    public struct Attachment: Swift.Equatable {
        /// The ID of the attachment.
        public var attachmentId: Swift.String?
        /// The policy rule number associated with the attachment.
        public var attachmentPolicyRuleNumber: Swift.Int?
        /// The type of attachment.
        public var attachmentType: NetworkManagerClientTypes.AttachmentType?
        /// The ARN of a core network.
        public var coreNetworkArn: Swift.String?
        /// A core network ID.
        public var coreNetworkId: Swift.String?
        /// The timestamp when the attachment was created.
        public var createdAt: ClientRuntime.Date?
        /// The Region where the edge is located.
        public var edgeLocation: Swift.String?
        /// The ID of the attachment account owner.
        public var ownerAccountId: Swift.String?
        /// The attachment to move from one segment to another.
        public var proposedSegmentChange: NetworkManagerClientTypes.ProposedSegmentChange?
        /// The attachment resource ARN.
        public var resourceArn: Swift.String?
        /// The name of the segment attachment.
        public var segmentName: Swift.String?
        /// The state of the attachment.
        public var state: NetworkManagerClientTypes.AttachmentState?
        /// The tags associated with the attachment.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The timestamp when the attachment was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            attachmentId: Swift.String? = nil,
            attachmentPolicyRuleNumber: Swift.Int? = nil,
            attachmentType: NetworkManagerClientTypes.AttachmentType? = nil,
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            edgeLocation: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            proposedSegmentChange: NetworkManagerClientTypes.ProposedSegmentChange? = nil,
            resourceArn: Swift.String? = nil,
            segmentName: Swift.String? = nil,
            state: NetworkManagerClientTypes.AttachmentState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.attachmentId = attachmentId
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.attachmentType = attachmentType
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.ownerAccountId = ownerAccountId
            self.proposedSegmentChange = proposedSegmentChange
            self.resourceArn = resourceArn
            self.segmentName = segmentName
            self.state = state
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension NetworkManagerClientTypes {
    public enum AttachmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case pendingAttachmentAcceptance
        case pendingNetworkUpdate
        case pendingTagAcceptance
        case rejected
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentState] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .pendingAttachmentAcceptance,
                .pendingNetworkUpdate,
                .pendingTagAcceptance,
                .rejected,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pendingAttachmentAcceptance: return "PENDING_ATTACHMENT_ACCEPTANCE"
            case .pendingNetworkUpdate: return "PENDING_NETWORK_UPDATE"
            case .pendingTagAcceptance: return "PENDING_TAG_ACCEPTANCE"
            case .rejected: return "REJECTED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentState(rawValue: rawValue) ?? AttachmentState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum AttachmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connect
        case siteToSiteVpn
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentType] {
            return [
                .connect,
                .siteToSiteVpn,
                .vpc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connect: return "CONNECT"
            case .siteToSiteVpn: return "SITE_TO_SITE_VPN"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentType(rawValue: rawValue) ?? AttachmentType.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.Bandwidth: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadSpeed = "DownloadSpeed"
        case uploadSpeed = "UploadSpeed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downloadSpeed = downloadSpeed {
            try encodeContainer.encode(downloadSpeed, forKey: .downloadSpeed)
        }
        if let uploadSpeed = uploadSpeed {
            try encodeContainer.encode(uploadSpeed, forKey: .uploadSpeed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadSpeedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uploadSpeed)
        uploadSpeed = uploadSpeedDecoded
        let downloadSpeedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downloadSpeed)
        downloadSpeed = downloadSpeedDecoded
    }
}

extension NetworkManagerClientTypes.Bandwidth: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Bandwidth(downloadSpeed: \(Swift.String(describing: downloadSpeed)), uploadSpeed: \(Swift.String(describing: uploadSpeed)))"}
}

extension NetworkManagerClientTypes {
    /// Describes bandwidth information.
    public struct Bandwidth: Swift.Equatable {
        /// Download speed in Mbps.
        public var downloadSpeed: Swift.Int?
        /// Upload speed in Mbps.
        public var uploadSpeed: Swift.Int?

        public init (
            downloadSpeed: Swift.Int? = nil,
            uploadSpeed: Swift.Int? = nil
        )
        {
            self.downloadSpeed = downloadSpeed
            self.uploadSpeed = uploadSpeed
        }
    }

}

extension NetworkManagerClientTypes.BgpOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case peerAsn = "PeerAsn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let peerAsn = peerAsn {
            try encodeContainer.encode(peerAsn, forKey: .peerAsn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let peerAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .peerAsn)
        peerAsn = peerAsnDecoded
    }
}

extension NetworkManagerClientTypes.BgpOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BgpOptions(peerAsn: \(Swift.String(describing: peerAsn)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the BGP options.
    public struct BgpOptions: Swift.Equatable {
        /// The Peer ASN of the BGP.
        public var peerAsn: Swift.Int?

        public init (
            peerAsn: Swift.Int? = nil
        )
        {
            self.peerAsn = peerAsn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ChangeAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeAction] {
            return [
                .add,
                .modify,
                .remove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeAction(rawValue: rawValue) ?? ChangeAction.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum ChangeSetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case executing
        case executionSucceeded
        case failedGeneration
        case outOfDate
        case pendingGeneration
        case readyToExecute
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeSetState] {
            return [
                .executing,
                .executionSucceeded,
                .failedGeneration,
                .outOfDate,
                .pendingGeneration,
                .readyToExecute,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .executing: return "EXECUTING"
            case .executionSucceeded: return "EXECUTION_SUCCEEDED"
            case .failedGeneration: return "FAILED_GENERATION"
            case .outOfDate: return "OUT_OF_DATE"
            case .pendingGeneration: return "PENDING_GENERATION"
            case .readyToExecute: return "READY_TO_EXECUTE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeSetState(rawValue: rawValue) ?? ChangeSetState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachmentMapping
        case attachmentRoutePropagation
        case attachmentRouteStatic
        case coreNetworkEdge
        case coreNetworkSegment
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .attachmentMapping,
                .attachmentRoutePropagation,
                .attachmentRouteStatic,
                .coreNetworkEdge,
                .coreNetworkSegment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachmentMapping: return "ATTACHMENT_MAPPING"
            case .attachmentRoutePropagation: return "ATTACHMENT_ROUTE_PROPAGATION"
            case .attachmentRouteStatic: return "ATTACHMENT_ROUTE_STATIC"
            case .coreNetworkEdge: return "CORE_NETWORK_EDGE"
            case .coreNetworkSegment: return "CORE_NETWORK_SEGMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict processing the request. Updating or deleting the resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension NetworkManagerClientTypes.ConnectAttachment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
        case options = "Options"
        case transportAttachmentId = "TransportAttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachment = attachment {
            try encodeContainer.encode(attachment, forKey: .attachment)
        }
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let transportAttachmentId = transportAttachmentId {
            try encodeContainer.encode(transportAttachmentId, forKey: .transportAttachmentId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let transportAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transportAttachmentId)
        transportAttachmentId = transportAttachmentIdDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectAttachmentOptions.self, forKey: .options)
        options = optionsDecoded
    }
}

extension NetworkManagerClientTypes.ConnectAttachment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectAttachment(attachment: \(Swift.String(describing: attachment)), options: \(Swift.String(describing: options)), transportAttachmentId: \(Swift.String(describing: transportAttachmentId)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect attachment.
    public struct ConnectAttachment: Swift.Equatable {
        /// The attachment details.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// Options for connecting an attachment.
        public var options: NetworkManagerClientTypes.ConnectAttachmentOptions?
        /// The ID of the transport attachment.
        public var transportAttachmentId: Swift.String?

        public init (
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            options: NetworkManagerClientTypes.ConnectAttachmentOptions? = nil,
            transportAttachmentId: Swift.String? = nil
        )
        {
            self.attachment = attachment
            self.options = options
            self.transportAttachmentId = transportAttachmentId
        }
    }

}

extension NetworkManagerClientTypes.ConnectAttachmentOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TunnelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension NetworkManagerClientTypes.ConnectAttachmentOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectAttachmentOptions(protocol: \(Swift.String(describing: `protocol`)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect attachment options.
    public struct ConnectAttachmentOptions: Swift.Equatable {
        /// The protocol used for the attachment connection.
        public var `protocol`: NetworkManagerClientTypes.TunnelProtocol?

        public init (
            `protocol`: NetworkManagerClientTypes.TunnelProtocol? = nil
        )
        {
            self.`protocol` = `protocol`
        }
    }

}

extension NetworkManagerClientTypes.ConnectPeer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case connectAttachmentId = "ConnectAttachmentId"
        case connectPeerId = "ConnectPeerId"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case edgeLocation = "EdgeLocation"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let connectAttachmentId = connectAttachmentId {
            try encodeContainer.encode(connectAttachmentId, forKey: .connectAttachmentId)
        }
        if let connectPeerId = connectPeerId {
            try encodeContainer.encode(connectPeerId, forKey: .connectPeerId)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let edgeLocation = edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let connectAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectAttachmentId)
        connectAttachmentId = connectAttachmentIdDecoded
        let connectPeerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectPeerId)
        connectPeerId = connectPeerIdDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.ConnectPeer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectPeer(configuration: \(Swift.String(describing: configuration)), connectAttachmentId: \(Swift.String(describing: connectAttachmentId)), connectPeerId: \(Swift.String(describing: connectPeerId)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), createdAt: \(Swift.String(describing: createdAt)), edgeLocation: \(Swift.String(describing: edgeLocation)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect peer.
    public struct ConnectPeer: Swift.Equatable {
        /// The configuration of the Connect peer.
        public var configuration: NetworkManagerClientTypes.ConnectPeerConfiguration?
        /// The ID of the attachment to connect.
        public var connectAttachmentId: Swift.String?
        /// The ID of the Connect peer.
        public var connectPeerId: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when the Connect peer was created.
        public var createdAt: ClientRuntime.Date?
        /// The Connect peer Regions where edges are located.
        public var edgeLocation: Swift.String?
        /// The state of the Connect peer.
        public var state: NetworkManagerClientTypes.ConnectPeerState?
        /// The tags associated with the Connect peer.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            configuration: NetworkManagerClientTypes.ConnectPeerConfiguration? = nil,
            connectAttachmentId: Swift.String? = nil,
            connectPeerId: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            edgeLocation: Swift.String? = nil,
            state: NetworkManagerClientTypes.ConnectPeerState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.configuration = configuration
            self.connectAttachmentId = connectAttachmentId
            self.connectPeerId = connectPeerId
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.ConnectPeerAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerId = "ConnectPeerId"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectPeerId = connectPeerId {
            try encodeContainer.encode(connectPeerId, forKey: .connectPeerId)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectPeerId)
        connectPeerId = connectPeerIdDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes.ConnectPeerAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectPeerAssociation(connectPeerId: \(Swift.String(describing: connectPeerId)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), state: \(Swift.String(describing: state)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect peer association.
    public struct ConnectPeerAssociation: Swift.Equatable {
        /// The ID of the Connect peer.
        public var connectPeerId: Swift.String?
        /// The ID of the device to connect to.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The state of the Connect peer association.
        public var state: NetworkManagerClientTypes.ConnectPeerAssociationState?

        public init (
            connectPeerId: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.ConnectPeerAssociationState? = nil
        )
        {
            self.connectPeerId = connectPeerId
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ConnectPeerAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectPeerAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectPeerAssociationState(rawValue: rawValue) ?? ConnectPeerAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.ConnectPeerBgpConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkAddress = "CoreNetworkAddress"
        case coreNetworkAsn = "CoreNetworkAsn"
        case peerAddress = "PeerAddress"
        case peerAsn = "PeerAsn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkAddress = coreNetworkAddress {
            try encodeContainer.encode(coreNetworkAddress, forKey: .coreNetworkAddress)
        }
        if let coreNetworkAsn = coreNetworkAsn {
            try encodeContainer.encode(coreNetworkAsn, forKey: .coreNetworkAsn)
        }
        if let peerAddress = peerAddress {
            try encodeContainer.encode(peerAddress, forKey: .peerAddress)
        }
        if let peerAsn = peerAsn {
            try encodeContainer.encode(peerAsn, forKey: .peerAsn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .coreNetworkAsn)
        coreNetworkAsn = coreNetworkAsnDecoded
        let peerAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .peerAsn)
        peerAsn = peerAsnDecoded
        let coreNetworkAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkAddress)
        coreNetworkAddress = coreNetworkAddressDecoded
        let peerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .peerAddress)
        peerAddress = peerAddressDecoded
    }
}

extension NetworkManagerClientTypes.ConnectPeerBgpConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectPeerBgpConfiguration(coreNetworkAddress: \(Swift.String(describing: coreNetworkAddress)), coreNetworkAsn: \(Swift.String(describing: coreNetworkAsn)), peerAddress: \(Swift.String(describing: peerAddress)), peerAsn: \(Swift.String(describing: peerAsn)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network BGP configuration.
    public struct ConnectPeerBgpConfiguration: Swift.Equatable {
        /// The address of a core network.
        public var coreNetworkAddress: Swift.String?
        /// The ASN of the Coret Network.
        public var coreNetworkAsn: Swift.Int?
        /// The address of a core network Connect peer.
        public var peerAddress: Swift.String?
        /// The ASN of the Connect peer.
        public var peerAsn: Swift.Int?

        public init (
            coreNetworkAddress: Swift.String? = nil,
            coreNetworkAsn: Swift.Int? = nil,
            peerAddress: Swift.String? = nil,
            peerAsn: Swift.Int? = nil
        )
        {
            self.coreNetworkAddress = coreNetworkAddress
            self.coreNetworkAsn = coreNetworkAsn
            self.peerAddress = peerAddress
            self.peerAsn = peerAsn
        }
    }

}

extension NetworkManagerClientTypes.ConnectPeerConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpConfigurations = "BgpConfigurations"
        case coreNetworkAddress = "CoreNetworkAddress"
        case insideCidrBlocks = "InsideCidrBlocks"
        case peerAddress = "PeerAddress"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bgpConfigurations = bgpConfigurations {
            var bgpConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bgpConfigurations)
            for connectpeerbgpconfigurationlist0 in bgpConfigurations {
                try bgpConfigurationsContainer.encode(connectpeerbgpconfigurationlist0)
            }
        }
        if let coreNetworkAddress = coreNetworkAddress {
            try encodeContainer.encode(coreNetworkAddress, forKey: .coreNetworkAddress)
        }
        if let insideCidrBlocks = insideCidrBlocks {
            var insideCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insideCidrBlocks)
            for constrainedstringlist0 in insideCidrBlocks {
                try insideCidrBlocksContainer.encode(constrainedstringlist0)
            }
        }
        if let peerAddress = peerAddress {
            try encodeContainer.encode(peerAddress, forKey: .peerAddress)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkAddress)
        coreNetworkAddress = coreNetworkAddressDecoded
        let peerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .peerAddress)
        peerAddress = peerAddressDecoded
        let insideCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .insideCidrBlocks)
        var insideCidrBlocksDecoded0:[Swift.String]? = nil
        if let insideCidrBlocksContainer = insideCidrBlocksContainer {
            insideCidrBlocksDecoded0 = [Swift.String]()
            for string0 in insideCidrBlocksContainer {
                if let string0 = string0 {
                    insideCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        insideCidrBlocks = insideCidrBlocksDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TunnelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let bgpConfigurationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.ConnectPeerBgpConfiguration?].self, forKey: .bgpConfigurations)
        var bgpConfigurationsDecoded0:[NetworkManagerClientTypes.ConnectPeerBgpConfiguration]? = nil
        if let bgpConfigurationsContainer = bgpConfigurationsContainer {
            bgpConfigurationsDecoded0 = [NetworkManagerClientTypes.ConnectPeerBgpConfiguration]()
            for structure0 in bgpConfigurationsContainer {
                if let structure0 = structure0 {
                    bgpConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        bgpConfigurations = bgpConfigurationsDecoded0
    }
}

extension NetworkManagerClientTypes.ConnectPeerConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectPeerConfiguration(bgpConfigurations: \(Swift.String(describing: bgpConfigurations)), coreNetworkAddress: \(Swift.String(describing: coreNetworkAddress)), insideCidrBlocks: \(Swift.String(describing: insideCidrBlocks)), peerAddress: \(Swift.String(describing: peerAddress)), protocol: \(Swift.String(describing: `protocol`)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect peer configuration.
    public struct ConnectPeerConfiguration: Swift.Equatable {
        /// The protocol used for a Connect peer configuration.
        public var `protocol`: NetworkManagerClientTypes.TunnelProtocol?
        /// The Connect peer BGP configurations.
        public var bgpConfigurations: [NetworkManagerClientTypes.ConnectPeerBgpConfiguration]?
        /// The IP address of a core network.
        public var coreNetworkAddress: Swift.String?
        /// The inside IP addresses used for a Connect peer configuration.
        public var insideCidrBlocks: [Swift.String]?
        /// The IP address of the Connect peer.
        public var peerAddress: Swift.String?

        public init (
            `protocol`: NetworkManagerClientTypes.TunnelProtocol? = nil,
            bgpConfigurations: [NetworkManagerClientTypes.ConnectPeerBgpConfiguration]? = nil,
            coreNetworkAddress: Swift.String? = nil,
            insideCidrBlocks: [Swift.String]? = nil,
            peerAddress: Swift.String? = nil
        )
        {
            self.`protocol` = `protocol`
            self.bgpConfigurations = bgpConfigurations
            self.coreNetworkAddress = coreNetworkAddress
            self.insideCidrBlocks = insideCidrBlocks
            self.peerAddress = peerAddress
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ConnectPeerState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectPeerState] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectPeerState(rawValue: rawValue) ?? ConnectPeerState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.ConnectPeerSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectAttachmentId = "ConnectAttachmentId"
        case connectPeerId = "ConnectPeerId"
        case connectPeerState = "ConnectPeerState"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case edgeLocation = "EdgeLocation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectAttachmentId = connectAttachmentId {
            try encodeContainer.encode(connectAttachmentId, forKey: .connectAttachmentId)
        }
        if let connectPeerId = connectPeerId {
            try encodeContainer.encode(connectPeerId, forKey: .connectPeerId)
        }
        if let connectPeerState = connectPeerState {
            try encodeContainer.encode(connectPeerState.rawValue, forKey: .connectPeerState)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let edgeLocation = edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let connectAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectAttachmentId)
        connectAttachmentId = connectAttachmentIdDecoded
        let connectPeerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectPeerId)
        connectPeerId = connectPeerIdDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let connectPeerStateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerState.self, forKey: .connectPeerState)
        connectPeerState = connectPeerStateDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.ConnectPeerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectPeerSummary(connectAttachmentId: \(Swift.String(describing: connectAttachmentId)), connectPeerId: \(Swift.String(describing: connectPeerId)), connectPeerState: \(Swift.String(describing: connectPeerState)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), createdAt: \(Swift.String(describing: createdAt)), edgeLocation: \(Swift.String(describing: edgeLocation)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Summary description of a Connect peer.
    public struct ConnectPeerSummary: Swift.Equatable {
        /// The ID of a Connect peer attachment.
        public var connectAttachmentId: Swift.String?
        /// The ID of a Connect peer.
        public var connectPeerId: Swift.String?
        /// The state of a Connect peer.
        public var connectPeerState: NetworkManagerClientTypes.ConnectPeerState?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a Connect peer was created.
        public var createdAt: ClientRuntime.Date?
        /// The Region where the edge is located.
        public var edgeLocation: Swift.String?
        /// The tags associated with a Connect peer summary.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            connectAttachmentId: Swift.String? = nil,
            connectPeerId: Swift.String? = nil,
            connectPeerState: NetworkManagerClientTypes.ConnectPeerState? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            edgeLocation: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.connectAttachmentId = connectAttachmentId
            self.connectPeerId = connectPeerId
            self.connectPeerState = connectPeerState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.Connection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case connectionArn = "ConnectionArn"
        case connectionId = "ConnectionId"
        case createdAt = "CreatedAt"
        case description = "Description"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedDeviceId = connectedDeviceId {
            try encodeContainer.encode(connectedDeviceId, forKey: .connectedDeviceId)
        }
        if let connectedLinkId = connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let connectedDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedDeviceId)
        connectedDeviceId = connectedDeviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectionState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.Connection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Connection(connectedDeviceId: \(Swift.String(describing: connectedDeviceId)), connectedLinkId: \(Swift.String(describing: connectedLinkId)), connectionArn: \(Swift.String(describing: connectionArn)), connectionId: \(Swift.String(describing: connectionId)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a connection.
    public struct Connection: Swift.Equatable {
        /// The ID of the second device in the connection.
        public var connectedDeviceId: Swift.String?
        /// The ID of the link for the second device in the connection.
        public var connectedLinkId: Swift.String?
        /// The Amazon Resource Name (ARN) of the connection.
        public var connectionArn: Swift.String?
        /// The ID of the connection.
        public var connectionId: Swift.String?
        /// The date and time that the connection was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the connection.
        public var description: Swift.String?
        /// The ID of the first device in the connection.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link for the first device in the connection.
        public var linkId: Swift.String?
        /// The state of the connection.
        public var state: NetworkManagerClientTypes.ConnectionState?
        /// The tags for the connection.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            connectedDeviceId: Swift.String? = nil,
            connectedLinkId: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.ConnectionState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.connectedDeviceId = connectedDeviceId
            self.connectedLinkId = connectedLinkId
            self.connectionArn = connectionArn
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.description = description
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.ConnectionHealth: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case timestamp = "Timestamp"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectionType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension NetworkManagerClientTypes.ConnectionHealth: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionHealth(status: \(Swift.String(describing: status)), timestamp: \(Swift.String(describing: timestamp)), type: \(Swift.String(describing: type)))"}
}

extension NetworkManagerClientTypes {
    /// Describes connection health.
    public struct ConnectionHealth: Swift.Equatable {
        /// The connection status.
        public var status: NetworkManagerClientTypes.ConnectionStatus?
        /// The time the status was last updated.
        public var timestamp: ClientRuntime.Date?
        /// The connection type.
        public var type: NetworkManagerClientTypes.ConnectionType?

        public init (
            status: NetworkManagerClientTypes.ConnectionStatus? = nil,
            timestamp: ClientRuntime.Date? = nil,
            type: NetworkManagerClientTypes.ConnectionType? = nil
        )
        {
            self.status = status
            self.timestamp = timestamp
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case down
        case up
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .down,
                .up,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .down: return "DOWN"
            case .up: return "UP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bgp
        case ipsec
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .bgp,
                .ipsec,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bgp: return "BGP"
            case .ipsec: return "IPSEC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.CoreNetwork: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkArn = "CoreNetworkArn"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case description = "Description"
        case edges = "Edges"
        case globalNetworkId = "GlobalNetworkId"
        case segments = "Segments"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkArn = coreNetworkArn {
            try encodeContainer.encode(coreNetworkArn, forKey: .coreNetworkArn)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let edges = edges {
            var edgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edges)
            for corenetworkedgelist0 in edges {
                try edgesContainer.encode(corenetworkedgelist0)
            }
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let segments = segments {
            var segmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segments)
            for corenetworksegmentlist0 in segments {
                try segmentsContainer.encode(corenetworksegmentlist0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let coreNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkArn)
        coreNetworkArn = coreNetworkArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkState.self, forKey: .state)
        state = stateDecoded
        let segmentsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkSegment?].self, forKey: .segments)
        var segmentsDecoded0:[NetworkManagerClientTypes.CoreNetworkSegment]? = nil
        if let segmentsContainer = segmentsContainer {
            segmentsDecoded0 = [NetworkManagerClientTypes.CoreNetworkSegment]()
            for structure0 in segmentsContainer {
                if let structure0 = structure0 {
                    segmentsDecoded0?.append(structure0)
                }
            }
        }
        segments = segmentsDecoded0
        let edgesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkEdge?].self, forKey: .edges)
        var edgesDecoded0:[NetworkManagerClientTypes.CoreNetworkEdge]? = nil
        if let edgesContainer = edgesContainer {
            edgesDecoded0 = [NetworkManagerClientTypes.CoreNetworkEdge]()
            for structure0 in edgesContainer {
                if let structure0 = structure0 {
                    edgesDecoded0?.append(structure0)
                }
            }
        }
        edges = edgesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.CoreNetwork: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetwork(coreNetworkArn: \(Swift.String(describing: coreNetworkArn)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), edges: \(Swift.String(describing: edges)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), segments: \(Swift.String(describing: segments)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network.
    public struct CoreNetwork: Swift.Equatable {
        /// The ARN of a core network.
        public var coreNetworkArn: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a core network was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of a core network.
        public var description: Swift.String?
        /// The edges within a core network.
        public var edges: [NetworkManagerClientTypes.CoreNetworkEdge]?
        /// The ID of the global network that your core network is a part of.
        public var globalNetworkId: Swift.String?
        /// The segments within a core network.
        public var segments: [NetworkManagerClientTypes.CoreNetworkSegment]?
        /// The current state of a core network.
        public var state: NetworkManagerClientTypes.CoreNetworkState?
        /// The tags associated with a core network.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            edges: [NetworkManagerClientTypes.CoreNetworkEdge]? = nil,
            globalNetworkId: Swift.String? = nil,
            segments: [NetworkManagerClientTypes.CoreNetworkSegment]? = nil,
            state: NetworkManagerClientTypes.CoreNetworkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.edges = edges
            self.globalNetworkId = globalNetworkId
            self.segments = segments
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case identifier = "Identifier"
        case newValues = "NewValues"
        case previousValues = "PreviousValues"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let newValues = newValues {
            try encodeContainer.encode(newValues, forKey: .newValues)
        }
        if let previousValues = previousValues {
            try encodeContainer.encode(previousValues, forKey: .previousValues)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeType.self, forKey: .type)
        type = typeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeAction.self, forKey: .action)
        action = actionDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let previousValuesDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkChangeValues.self, forKey: .previousValues)
        previousValues = previousValuesDecoded
        let newValuesDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkChangeValues.self, forKey: .newValues)
        newValues = newValuesDecoded
    }
}

extension NetworkManagerClientTypes.CoreNetworkChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetworkChange(action: \(Swift.String(describing: action)), identifier: \(Swift.String(describing: identifier)), newValues: \(Swift.String(describing: newValues)), previousValues: \(Swift.String(describing: previousValues)), type: \(Swift.String(describing: type)))"}
}

extension NetworkManagerClientTypes {
    /// Details describing a core network change.
    public struct CoreNetworkChange: Swift.Equatable {
        /// The action to take for a core network.
        public var action: NetworkManagerClientTypes.ChangeAction?
        /// The resource identifier.
        public var identifier: Swift.String?
        /// The new value for a core network
        public var newValues: NetworkManagerClientTypes.CoreNetworkChangeValues?
        /// The previous values for a core network.
        public var previousValues: NetworkManagerClientTypes.CoreNetworkChangeValues?
        /// The type of change.
        public var type: NetworkManagerClientTypes.ChangeType?

        public init (
            action: NetworkManagerClientTypes.ChangeAction? = nil,
            identifier: Swift.String? = nil,
            newValues: NetworkManagerClientTypes.CoreNetworkChangeValues? = nil,
            previousValues: NetworkManagerClientTypes.CoreNetworkChangeValues? = nil,
            type: NetworkManagerClientTypes.ChangeType? = nil
        )
        {
            self.action = action
            self.identifier = identifier
            self.newValues = newValues
            self.previousValues = previousValues
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkChangeValues: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn = "Asn"
        case cidr = "Cidr"
        case destinationIdentifier = "DestinationIdentifier"
        case edgeLocations = "EdgeLocations"
        case insideCidrBlocks = "InsideCidrBlocks"
        case segmentName = "SegmentName"
        case sharedSegments = "SharedSegments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asn = asn {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let destinationIdentifier = destinationIdentifier {
            try encodeContainer.encode(destinationIdentifier, forKey: .destinationIdentifier)
        }
        if let edgeLocations = edgeLocations {
            var edgeLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeLocations)
            for externalregioncodelist0 in edgeLocations {
                try edgeLocationsContainer.encode(externalregioncodelist0)
            }
        }
        if let insideCidrBlocks = insideCidrBlocks {
            var insideCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insideCidrBlocks)
            for constrainedstringlist0 in insideCidrBlocks {
                try insideCidrBlocksContainer.encode(constrainedstringlist0)
            }
        }
        if let segmentName = segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
        if let sharedSegments = sharedSegments {
            var sharedSegmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedSegments)
            for constrainedstringlist0 in sharedSegments {
                try sharedSegmentsContainer.encode(constrainedstringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let edgeLocationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .edgeLocations)
        var edgeLocationsDecoded0:[Swift.String]? = nil
        if let edgeLocationsContainer = edgeLocationsContainer {
            edgeLocationsDecoded0 = [Swift.String]()
            for string0 in edgeLocationsContainer {
                if let string0 = string0 {
                    edgeLocationsDecoded0?.append(string0)
                }
            }
        }
        edgeLocations = edgeLocationsDecoded0
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn)
        asn = asnDecoded
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
        let destinationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIdentifier)
        destinationIdentifier = destinationIdentifierDecoded
        let insideCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .insideCidrBlocks)
        var insideCidrBlocksDecoded0:[Swift.String]? = nil
        if let insideCidrBlocksContainer = insideCidrBlocksContainer {
            insideCidrBlocksDecoded0 = [Swift.String]()
            for string0 in insideCidrBlocksContainer {
                if let string0 = string0 {
                    insideCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        insideCidrBlocks = insideCidrBlocksDecoded0
        let sharedSegmentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedSegments)
        var sharedSegmentsDecoded0:[Swift.String]? = nil
        if let sharedSegmentsContainer = sharedSegmentsContainer {
            sharedSegmentsDecoded0 = [Swift.String]()
            for string0 in sharedSegmentsContainer {
                if let string0 = string0 {
                    sharedSegmentsDecoded0?.append(string0)
                }
            }
        }
        sharedSegments = sharedSegmentsDecoded0
    }
}

extension NetworkManagerClientTypes.CoreNetworkChangeValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetworkChangeValues(asn: \(Swift.String(describing: asn)), cidr: \(Swift.String(describing: cidr)), destinationIdentifier: \(Swift.String(describing: destinationIdentifier)), edgeLocations: \(Swift.String(describing: edgeLocations)), insideCidrBlocks: \(Swift.String(describing: insideCidrBlocks)), segmentName: \(Swift.String(describing: segmentName)), sharedSegments: \(Swift.String(describing: sharedSegments)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network change.
    public struct CoreNetworkChangeValues: Swift.Equatable {
        /// The ASN of a core network.
        public var asn: Swift.Int?
        /// The IP addresses used for a core network.
        public var cidr: Swift.String?
        /// The ID of the destination.
        public var destinationIdentifier: Swift.String?
        /// The Regions where edges are located in a core network.
        public var edgeLocations: [Swift.String]?
        /// The inside IP addresses used for core network change values.
        public var insideCidrBlocks: [Swift.String]?
        /// The names of the segments in a core network.
        public var segmentName: Swift.String?
        /// The shared segments for a core network change value.
        public var sharedSegments: [Swift.String]?

        public init (
            asn: Swift.Int? = nil,
            cidr: Swift.String? = nil,
            destinationIdentifier: Swift.String? = nil,
            edgeLocations: [Swift.String]? = nil,
            insideCidrBlocks: [Swift.String]? = nil,
            segmentName: Swift.String? = nil,
            sharedSegments: [Swift.String]? = nil
        )
        {
            self.asn = asn
            self.cidr = cidr
            self.destinationIdentifier = destinationIdentifier
            self.edgeLocations = edgeLocations
            self.insideCidrBlocks = insideCidrBlocks
            self.segmentName = segmentName
            self.sharedSegments = sharedSegments
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkEdge: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn = "Asn"
        case edgeLocation = "EdgeLocation"
        case insideCidrBlocks = "InsideCidrBlocks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asn = asn {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let edgeLocation = edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let insideCidrBlocks = insideCidrBlocks {
            var insideCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insideCidrBlocks)
            for constrainedstringlist0 in insideCidrBlocks {
                try insideCidrBlocksContainer.encode(constrainedstringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn)
        asn = asnDecoded
        let insideCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .insideCidrBlocks)
        var insideCidrBlocksDecoded0:[Swift.String]? = nil
        if let insideCidrBlocksContainer = insideCidrBlocksContainer {
            insideCidrBlocksDecoded0 = [Swift.String]()
            for string0 in insideCidrBlocksContainer {
                if let string0 = string0 {
                    insideCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        insideCidrBlocks = insideCidrBlocksDecoded0
    }
}

extension NetworkManagerClientTypes.CoreNetworkEdge: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetworkEdge(asn: \(Swift.String(describing: asn)), edgeLocation: \(Swift.String(describing: edgeLocation)), insideCidrBlocks: \(Swift.String(describing: insideCidrBlocks)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network edge.
    public struct CoreNetworkEdge: Swift.Equatable {
        /// The ASN of a core network edge.
        public var asn: Swift.Int?
        /// The Region where a core network edge is located.
        public var edgeLocation: Swift.String?
        /// The inside IP addresses used for core network edges.
        public var insideCidrBlocks: [Swift.String]?

        public init (
            asn: Swift.Int? = nil,
            edgeLocation: Swift.String? = nil,
            insideCidrBlocks: [Swift.String]? = nil
        )
        {
            self.asn = asn
            self.edgeLocation = edgeLocation
            self.insideCidrBlocks = insideCidrBlocks
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case changeSetState = "ChangeSetState"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case description = "Description"
        case policyDocument = "PolicyDocument"
        case policyErrors = "PolicyErrors"
        case policyVersionId = "PolicyVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias.rawValue, forKey: .alias)
        }
        if let changeSetState = changeSetState {
            try encodeContainer.encode(changeSetState.rawValue, forKey: .changeSetState)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyErrors = policyErrors {
            var policyErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyErrors)
            for corenetworkpolicyerrorlist0 in policyErrors {
                try policyErrorsContainer.encode(corenetworkpolicyerrorlist0)
            }
        }
        if let policyVersionId = policyVersionId {
            try encodeContainer.encode(policyVersionId, forKey: .policyVersionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicyAlias.self, forKey: .alias)
        alias = aliasDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let changeSetStateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeSetState.self, forKey: .changeSetState)
        changeSetState = changeSetStateDecoded
        let policyErrorsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkPolicyError?].self, forKey: .policyErrors)
        var policyErrorsDecoded0:[NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil
        if let policyErrorsContainer = policyErrorsContainer {
            policyErrorsDecoded0 = [NetworkManagerClientTypes.CoreNetworkPolicyError]()
            for structure0 in policyErrorsContainer {
                if let structure0 = structure0 {
                    policyErrorsDecoded0?.append(structure0)
                }
            }
        }
        policyErrors = policyErrorsDecoded0
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension NetworkManagerClientTypes.CoreNetworkPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetworkPolicy(alias: \(Swift.String(describing: alias)), changeSetState: \(Swift.String(describing: changeSetState)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), policyDocument: \(Swift.String(describing: policyDocument)), policyErrors: \(Swift.String(describing: policyErrors)), policyVersionId: \(Swift.String(describing: policyVersionId)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network policy. You can have only one LIVE Core Policy.
    public struct CoreNetworkPolicy: Swift.Equatable {
        /// Whether a core network policy is the current LIVE policy or the most recently submitted policy.
        public var alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias?
        /// The state of a core network policy.
        public var changeSetState: NetworkManagerClientTypes.ChangeSetState?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a core network policy was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of a core network policy.
        public var description: Swift.String?
        /// Describes a core network policy.
        public var policyDocument: Swift.String?
        /// Describes any errors in a core network policy.
        public var policyErrors: [NetworkManagerClientTypes.CoreNetworkPolicyError]?
        /// The ID of the policy version.
        public var policyVersionId: Swift.Int?

        public init (
            alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias? = nil,
            changeSetState: NetworkManagerClientTypes.ChangeSetState? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            policyDocument: Swift.String? = nil,
            policyErrors: [NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil,
            policyVersionId: Swift.Int? = nil
        )
        {
            self.alias = alias
            self.changeSetState = changeSetState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.policyDocument = policyDocument
            self.policyErrors = policyErrors
            self.policyVersionId = policyVersionId
        }
    }

}

extension NetworkManagerClientTypes {
    public enum CoreNetworkPolicyAlias: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case latest
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [CoreNetworkPolicyAlias] {
            return [
                .latest,
                .live,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .latest: return "LATEST"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoreNetworkPolicyAlias(rawValue: rawValue) ?? CoreNetworkPolicyAlias.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.CoreNetworkPolicyError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension NetworkManagerClientTypes.CoreNetworkPolicyError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetworkPolicyError(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)), path: \(Swift.String(describing: path)))"}
}

extension NetworkManagerClientTypes {
    /// Provides details about an error in a core network policy.
    public struct CoreNetworkPolicyError: Swift.Equatable {
        /// The error code associated with a core network policy error.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message associated with a core network policy error code.
        /// This member is required.
        public var message: Swift.String?
        /// The JSON path where the error was discovered in the policy document.
        public var path: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
            self.path = path
        }
    }

}

extension CoreNetworkPolicyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetworkPolicyException(errors: \(Swift.String(describing: errors)), message: \(Swift.String(describing: message)))"}
}

extension CoreNetworkPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CoreNetworkPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.message = output.message
        } else {
            self.errors = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Describes a core network policy exception.
public struct CoreNetworkPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Describes a core network policy exception.
    public var errors: [NetworkManagerClientTypes.CoreNetworkPolicyError]?
    /// This member is required.
    public var message: Swift.String?

    public init (
        errors: [NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil,
        message: Swift.String? = nil
    )
    {
        self.errors = errors
        self.message = message
    }
}

struct CoreNetworkPolicyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let errors: [NetworkManagerClientTypes.CoreNetworkPolicyError]?
}

extension CoreNetworkPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkPolicyError?].self, forKey: .errors)
        var errorsDecoded0:[NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [NetworkManagerClientTypes.CoreNetworkPolicyError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension NetworkManagerClientTypes.CoreNetworkPolicyVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case changeSetState = "ChangeSetState"
        case coreNetworkId = "CoreNetworkId"
        case createdAt = "CreatedAt"
        case description = "Description"
        case policyVersionId = "PolicyVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias.rawValue, forKey: .alias)
        }
        if let changeSetState = changeSetState {
            try encodeContainer.encode(changeSetState.rawValue, forKey: .changeSetState)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyVersionId = policyVersionId {
            try encodeContainer.encode(policyVersionId, forKey: .policyVersionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicyAlias.self, forKey: .alias)
        alias = aliasDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let changeSetStateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ChangeSetState.self, forKey: .changeSetState)
        changeSetState = changeSetStateDecoded
    }
}

extension NetworkManagerClientTypes.CoreNetworkPolicyVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetworkPolicyVersion(alias: \(Swift.String(describing: alias)), changeSetState: \(Swift.String(describing: changeSetState)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), policyVersionId: \(Swift.String(describing: policyVersionId)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network policy version.
    public struct CoreNetworkPolicyVersion: Swift.Equatable {
        /// Whether a core network policy is the current policy or the most recently submitted policy.
        public var alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias?
        /// The status of the policy version change set.
        public var changeSetState: NetworkManagerClientTypes.ChangeSetState?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a core network policy version was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of a core network policy version.
        public var description: Swift.String?
        /// The ID of the policy version.
        public var policyVersionId: Swift.Int?

        public init (
            alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias? = nil,
            changeSetState: NetworkManagerClientTypes.ChangeSetState? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            policyVersionId: Swift.Int? = nil
        )
        {
            self.alias = alias
            self.changeSetState = changeSetState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.policyVersionId = policyVersionId
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkSegment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edgeLocations = "EdgeLocations"
        case name = "Name"
        case sharedSegments = "SharedSegments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edgeLocations = edgeLocations {
            var edgeLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeLocations)
            for externalregioncodelist0 in edgeLocations {
                try edgeLocationsContainer.encode(externalregioncodelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sharedSegments = sharedSegments {
            var sharedSegmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedSegments)
            for constrainedstringlist0 in sharedSegments {
                try sharedSegmentsContainer.encode(constrainedstringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let edgeLocationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .edgeLocations)
        var edgeLocationsDecoded0:[Swift.String]? = nil
        if let edgeLocationsContainer = edgeLocationsContainer {
            edgeLocationsDecoded0 = [Swift.String]()
            for string0 in edgeLocationsContainer {
                if let string0 = string0 {
                    edgeLocationsDecoded0?.append(string0)
                }
            }
        }
        edgeLocations = edgeLocationsDecoded0
        let sharedSegmentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedSegments)
        var sharedSegmentsDecoded0:[Swift.String]? = nil
        if let sharedSegmentsContainer = sharedSegmentsContainer {
            sharedSegmentsDecoded0 = [Swift.String]()
            for string0 in sharedSegmentsContainer {
                if let string0 = string0 {
                    sharedSegmentsDecoded0?.append(string0)
                }
            }
        }
        sharedSegments = sharedSegmentsDecoded0
    }
}

extension NetworkManagerClientTypes.CoreNetworkSegment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetworkSegment(edgeLocations: \(Swift.String(describing: edgeLocations)), name: \(Swift.String(describing: name)), sharedSegments: \(Swift.String(describing: sharedSegments)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a core network segment, which are dedicated routes. Only attachments within this segment can communicate with each other.
    public struct CoreNetworkSegment: Swift.Equatable {
        /// The Regions where the edges are located.
        public var edgeLocations: [Swift.String]?
        /// The name of a core network segment.
        public var name: Swift.String?
        /// The shared segments of a core network.
        public var sharedSegments: [Swift.String]?

        public init (
            edgeLocations: [Swift.String]? = nil,
            name: Swift.String? = nil,
            sharedSegments: [Swift.String]? = nil
        )
        {
            self.edgeLocations = edgeLocations
            self.name = name
            self.sharedSegments = sharedSegments
        }
    }

}

extension NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkId = "CoreNetworkId"
        case edgeLocation = "EdgeLocation"
        case segmentName = "SegmentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let edgeLocation = edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let segmentName = segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
    }
}

extension NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetworkSegmentEdgeIdentifier(coreNetworkId: \(Swift.String(describing: coreNetworkId)), edgeLocation: \(Swift.String(describing: edgeLocation)), segmentName: \(Swift.String(describing: segmentName)))"}
}

extension NetworkManagerClientTypes {
    /// Returns details about a core network edge.
    public struct CoreNetworkSegmentEdgeIdentifier: Swift.Equatable {
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The Region where the segment edge is located.
        public var edgeLocation: Swift.String?
        /// The name of the segment edge.
        public var segmentName: Swift.String?

        public init (
            coreNetworkId: Swift.String? = nil,
            edgeLocation: Swift.String? = nil,
            segmentName: Swift.String? = nil
        )
        {
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.segmentName = segmentName
        }
    }

}

extension NetworkManagerClientTypes {
    public enum CoreNetworkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CoreNetworkState] {
            return [
                .available,
                .creating,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoreNetworkState(rawValue: rawValue) ?? CoreNetworkState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.CoreNetworkSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkArn = "CoreNetworkArn"
        case coreNetworkId = "CoreNetworkId"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkArn = coreNetworkArn {
            try encodeContainer.encode(coreNetworkArn, forKey: .coreNetworkArn)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let coreNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkArn)
        coreNetworkArn = coreNetworkArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.CoreNetworkSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreNetworkSummary(coreNetworkArn: \(Swift.String(describing: coreNetworkArn)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Returns summary information about a core network.
    public struct CoreNetworkSummary: Swift.Equatable {
        /// a core network ARN.
        public var coreNetworkArn: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The description of a core network.
        public var description: Swift.String?
        /// The global network ID.
        public var globalNetworkId: Swift.String?
        /// The ID of the account owner.
        public var ownerAccountId: Swift.String?
        /// The state of a core network.
        public var state: NetworkManagerClientTypes.CoreNetworkState?
        /// The key-value tags associated with a core network summary.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            state: NetworkManagerClientTypes.CoreNetworkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.ownerAccountId = ownerAccountId
            self.state = state
            self.tags = tags
        }
    }

}

public struct CreateConnectAttachmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectAttachmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectAttachmentOutputError>
}

extension CreateConnectAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectAttachmentInput(clientToken: \(Swift.String(describing: clientToken)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), edgeLocation: \(Swift.String(describing: edgeLocation)), options: \(Swift.String(describing: options)), tags: \(Swift.String(describing: tags)), transportAttachmentId: \(Swift.String(describing: transportAttachmentId)))"}
}

extension CreateConnectAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case edgeLocation = "EdgeLocation"
        case options = "Options"
        case tags = "Tags"
        case transportAttachmentId = "TransportAttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let edgeLocation = edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let transportAttachmentId = transportAttachmentId {
            try encodeContainer.encode(transportAttachmentId, forKey: .transportAttachmentId)
        }
    }
}

public struct CreateConnectAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectAttachmentOutputError>
}

public struct CreateConnectAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectAttachmentOutputError>
}

public struct CreateConnectAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateConnectAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConnectAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectAttachmentOutputError>
}

public struct CreateConnectAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateConnectAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/connect-attachments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConnectAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectAttachmentOutputError>
}

public struct CreateConnectAttachmentInput: Swift.Equatable {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network where you want to create the attachment.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The Region where the edge is located.
    /// This member is required.
    public var edgeLocation: Swift.String?
    /// Options for creating an attachment.
    /// This member is required.
    public var options: NetworkManagerClientTypes.ConnectAttachmentOptions?
    /// The list of key-value tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ID of the attachment between the two connections.
    /// This member is required.
    public var transportAttachmentId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        edgeLocation: Swift.String? = nil,
        options: NetworkManagerClientTypes.ConnectAttachmentOptions? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        transportAttachmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.edgeLocation = edgeLocation
        self.options = options
        self.tags = tags
        self.transportAttachmentId = transportAttachmentId
    }
}

struct CreateConnectAttachmentInputBody: Swift.Equatable {
    public let coreNetworkId: Swift.String?
    public let edgeLocation: Swift.String?
    public let transportAttachmentId: Swift.String?
    public let options: NetworkManagerClientTypes.ConnectAttachmentOptions?
    public let tags: [NetworkManagerClientTypes.Tag]?
    public let clientToken: Swift.String?
}

extension CreateConnectAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case edgeLocation = "EdgeLocation"
        case options = "Options"
        case tags = "Tags"
        case transportAttachmentId = "TransportAttachmentId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let transportAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transportAttachmentId)
        transportAttachmentId = transportAttachmentIdDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectAttachmentOptions.self, forKey: .options)
        options = optionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateConnectAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectAttachmentOutputResponse(connectAttachment: \(Swift.String(describing: connectAttachment)))"}
}

extension CreateConnectAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectAttachment = output.connectAttachment
        } else {
            self.connectAttachment = nil
        }
    }
}

public struct CreateConnectAttachmentOutputResponse: Swift.Equatable {
    /// The response to a Connect attachment request.
    public var connectAttachment: NetworkManagerClientTypes.ConnectAttachment?

    public init (
        connectAttachment: NetworkManagerClientTypes.ConnectAttachment? = nil
    )
    {
        self.connectAttachment = connectAttachment
    }
}

struct CreateConnectAttachmentOutputResponseBody: Swift.Equatable {
    public let connectAttachment: NetworkManagerClientTypes.ConnectAttachment?
}

extension CreateConnectAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectAttachment = "ConnectAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectAttachment.self, forKey: .connectAttachment)
        connectAttachment = connectAttachmentDecoded
    }
}

public struct CreateConnectPeerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectPeerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectPeerOutputError>
}

extension CreateConnectPeerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectPeerInput(bgpOptions: \(Swift.String(describing: bgpOptions)), clientToken: \(Swift.String(describing: clientToken)), connectAttachmentId: \(Swift.String(describing: connectAttachmentId)), coreNetworkAddress: \(Swift.String(describing: coreNetworkAddress)), insideCidrBlocks: \(Swift.String(describing: insideCidrBlocks)), peerAddress: \(Swift.String(describing: peerAddress)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateConnectPeerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpOptions = "BgpOptions"
        case clientToken = "ClientToken"
        case connectAttachmentId = "ConnectAttachmentId"
        case coreNetworkAddress = "CoreNetworkAddress"
        case insideCidrBlocks = "InsideCidrBlocks"
        case peerAddress = "PeerAddress"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bgpOptions = bgpOptions {
            try encodeContainer.encode(bgpOptions, forKey: .bgpOptions)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let connectAttachmentId = connectAttachmentId {
            try encodeContainer.encode(connectAttachmentId, forKey: .connectAttachmentId)
        }
        if let coreNetworkAddress = coreNetworkAddress {
            try encodeContainer.encode(coreNetworkAddress, forKey: .coreNetworkAddress)
        }
        if let insideCidrBlocks = insideCidrBlocks {
            var insideCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insideCidrBlocks)
            for constrainedstringlist0 in insideCidrBlocks {
                try insideCidrBlocksContainer.encode(constrainedstringlist0)
            }
        }
        if let peerAddress = peerAddress {
            try encodeContainer.encode(peerAddress, forKey: .peerAddress)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConnectPeerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectPeerOutputError>
}

public struct CreateConnectPeerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectPeerOutputError>
}

public struct CreateConnectPeerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectPeerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectPeerOutputError>
}

public struct CreateConnectPeerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectPeerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/connect-peers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectPeerOutputError>
}

public struct CreateConnectPeerInput: Swift.Equatable {
    /// The Connect peer BGP options.
    public var bgpOptions: NetworkManagerClientTypes.BgpOptions?
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of the connection attachment.
    /// This member is required.
    public var connectAttachmentId: Swift.String?
    /// A Connect peer core network address.
    public var coreNetworkAddress: Swift.String?
    /// The inside IP addresses used for BGP peering.
    /// This member is required.
    public var insideCidrBlocks: [Swift.String]?
    /// The Connect peer address.
    /// This member is required.
    public var peerAddress: Swift.String?
    /// The tags associated with the peer request.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        bgpOptions: NetworkManagerClientTypes.BgpOptions? = nil,
        clientToken: Swift.String? = nil,
        connectAttachmentId: Swift.String? = nil,
        coreNetworkAddress: Swift.String? = nil,
        insideCidrBlocks: [Swift.String]? = nil,
        peerAddress: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.bgpOptions = bgpOptions
        self.clientToken = clientToken
        self.connectAttachmentId = connectAttachmentId
        self.coreNetworkAddress = coreNetworkAddress
        self.insideCidrBlocks = insideCidrBlocks
        self.peerAddress = peerAddress
        self.tags = tags
    }
}

struct CreateConnectPeerInputBody: Swift.Equatable {
    public let connectAttachmentId: Swift.String?
    public let coreNetworkAddress: Swift.String?
    public let peerAddress: Swift.String?
    public let bgpOptions: NetworkManagerClientTypes.BgpOptions?
    public let insideCidrBlocks: [Swift.String]?
    public let tags: [NetworkManagerClientTypes.Tag]?
    public let clientToken: Swift.String?
}

extension CreateConnectPeerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bgpOptions = "BgpOptions"
        case clientToken = "ClientToken"
        case connectAttachmentId = "ConnectAttachmentId"
        case coreNetworkAddress = "CoreNetworkAddress"
        case insideCidrBlocks = "InsideCidrBlocks"
        case peerAddress = "PeerAddress"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectAttachmentId)
        connectAttachmentId = connectAttachmentIdDecoded
        let coreNetworkAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkAddress)
        coreNetworkAddress = coreNetworkAddressDecoded
        let peerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .peerAddress)
        peerAddress = peerAddressDecoded
        let bgpOptionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.BgpOptions.self, forKey: .bgpOptions)
        bgpOptions = bgpOptionsDecoded
        let insideCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .insideCidrBlocks)
        var insideCidrBlocksDecoded0:[Swift.String]? = nil
        if let insideCidrBlocksContainer = insideCidrBlocksContainer {
            insideCidrBlocksDecoded0 = [Swift.String]()
            for string0 in insideCidrBlocksContainer {
                if let string0 = string0 {
                    insideCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        insideCidrBlocks = insideCidrBlocksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectPeerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectPeerOutputResponse(connectPeer: \(Swift.String(describing: connectPeer)))"}
}

extension CreateConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeer = output.connectPeer
        } else {
            self.connectPeer = nil
        }
    }
}

public struct CreateConnectPeerOutputResponse: Swift.Equatable {
    /// The response to the request.
    public var connectPeer: NetworkManagerClientTypes.ConnectPeer?

    public init (
        connectPeer: NetworkManagerClientTypes.ConnectPeer? = nil
    )
    {
        self.connectPeer = connectPeer
    }
}

struct CreateConnectPeerOutputResponseBody: Swift.Equatable {
    public let connectPeer: NetworkManagerClientTypes.ConnectPeer?
}

extension CreateConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeer = "ConnectPeer"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeer.self, forKey: .connectPeer)
        connectPeer = connectPeerDecoded
    }
}

public struct CreateConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionInput(connectedDeviceId: \(Swift.String(describing: connectedDeviceId)), connectedLinkId: \(Swift.String(describing: connectedLinkId)), description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedDeviceId = connectedDeviceId {
            try encodeContainer.encode(connectedDeviceId, forKey: .connectedDeviceId)
        }
        if let connectedLinkId = connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Swift.Equatable {
    /// The ID of the second device in the connection.
    /// This member is required.
    public var connectedDeviceId: Swift.String?
    /// The ID of the link for the second device.
    public var connectedLinkId: Swift.String?
    /// A description of the connection. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the first device in the connection.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link for the first device.
    public var linkId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        connectedDeviceId: Swift.String? = nil,
        connectedLinkId: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.connectedDeviceId = connectedDeviceId
        self.connectedLinkId = connectedLinkId
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Swift.Equatable {
    public let deviceId: Swift.String?
    public let connectedDeviceId: Swift.String?
    public let linkId: Swift.String?
    public let connectedLinkId: Swift.String?
    public let description: Swift.String?
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let connectedDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedDeviceId)
        connectedDeviceId = connectedDeviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension CreateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Swift.Equatable {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init (
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct CreateConnectionOutputResponseBody: Swift.Equatable {
    public let connection: NetworkManagerClientTypes.Connection?
}

extension CreateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct CreateCoreNetworkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCoreNetworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCoreNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCoreNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCoreNetworkOutputError>
}

extension CreateCoreNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCoreNetworkInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), policyDocument: \(Swift.String(describing: policyDocument)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateCoreNetworkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case policyDocument = "PolicyDocument"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateCoreNetworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCoreNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCoreNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCoreNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCoreNetworkOutputError>
}

public struct CreateCoreNetworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCoreNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCoreNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCoreNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCoreNetworkOutputError>
}

public struct CreateCoreNetworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCoreNetworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateCoreNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCoreNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCoreNetworkOutputError>
}

public struct CreateCoreNetworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCoreNetworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateCoreNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/core-networks"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCoreNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCoreNetworkOutputError>
}

public struct CreateCoreNetworkInput: Swift.Equatable {
    /// The client token associated with a core network request.
    public var clientToken: Swift.String?
    /// The description of a core network.
    public var description: Swift.String?
    /// The ID of the global network that a core network will be a part of.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The policy document for creating a core network.
    public var policyDocument: Swift.String?
    /// Key-value tags associated with a core network request.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.policyDocument = policyDocument
        self.tags = tags
    }
}

struct CreateCoreNetworkInputBody: Swift.Equatable {
    public let globalNetworkId: Swift.String?
    public let description: Swift.String?
    public let tags: [NetworkManagerClientTypes.Tag]?
    public let policyDocument: Swift.String?
    public let clientToken: Swift.String?
}

extension CreateCoreNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case policyDocument = "PolicyDocument"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateCoreNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCoreNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CoreNetworkPolicyException" : self = .coreNetworkPolicyException(try CoreNetworkPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCoreNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case coreNetworkPolicyException(CoreNetworkPolicyException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCoreNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCoreNetworkOutputResponse(coreNetwork: \(Swift.String(describing: coreNetwork)))"}
}

extension CreateCoreNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCoreNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetwork = output.coreNetwork
        } else {
            self.coreNetwork = nil
        }
    }
}

public struct CreateCoreNetworkOutputResponse: Swift.Equatable {
    /// Returns details about a core network.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init (
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

struct CreateCoreNetworkOutputResponseBody: Swift.Equatable {
    public let coreNetwork: NetworkManagerClientTypes.CoreNetwork?
}

extension CreateCoreNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetwork = "CoreNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetwork.self, forKey: .coreNetwork)
        coreNetwork = coreNetworkDecoded
    }
}

public struct CreateDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceOutputError>
}

extension CreateDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeviceInput(aWSLocation: \(Swift.String(describing: aWSLocation)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)))"}
}

extension CreateDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSLocation = aWSLocation {
            try encodeContainer.encode(aWSLocation, forKey: .aWSLocation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }
}

public struct CreateDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceOutputError>
}

public struct CreateDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceOutputError>
}

public struct CreateDeviceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceOutputError>
}

public struct CreateDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceOutputError>
}

public struct CreateDeviceInput: Swift.Equatable {
    /// The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.
    public var aWSLocation: NetworkManagerClientTypes.AWSLocation?
    /// A description of the device. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The location of the device.
    public var location: NetworkManagerClientTypes.Location?
    /// The model of the device. Constraints: Maximum length of 128 characters.
    public var model: Swift.String?
    /// The serial number of the device. Constraints: Maximum length of 128 characters.
    public var serialNumber: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The type of the device.
    public var type: Swift.String?
    /// The vendor of the device. Constraints: Maximum length of 128 characters.
    public var vendor: Swift.String?

    public init (
        aWSLocation: NetworkManagerClientTypes.AWSLocation? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        model: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        type: Swift.String? = nil,
        vendor: Swift.String? = nil
    )
    {
        self.aWSLocation = aWSLocation
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.tags = tags
        self.type = type
        self.vendor = vendor
    }
}

struct CreateDeviceInputBody: Swift.Equatable {
    public let aWSLocation: NetworkManagerClientTypes.AWSLocation?
    public let description: Swift.String?
    public let type: Swift.String?
    public let vendor: Swift.String?
    public let model: Swift.String?
    public let serialNumber: Swift.String?
    public let location: NetworkManagerClientTypes.Location?
    public let siteId: Swift.String?
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aWSLocationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AWSLocation.self, forKey: .aWSLocation)
        aWSLocation = aWSLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeviceOutputResponse(device: \(Swift.String(describing: device)))"}
}

extension CreateDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct CreateDeviceOutputResponse: Swift.Equatable {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init (
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct CreateDeviceOutputResponseBody: Swift.Equatable {
    public let device: NetworkManagerClientTypes.Device?
}

extension CreateDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct CreateGlobalNetworkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalNetworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalNetworkOutputError>
}

extension CreateGlobalNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlobalNetworkInput(description: \(Swift.String(describing: description)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateGlobalNetworkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateGlobalNetworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalNetworkOutputError>
}

public struct CreateGlobalNetworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalNetworkOutputError>
}

public struct CreateGlobalNetworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalNetworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalNetworkOutputError>
}

public struct CreateGlobalNetworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalNetworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/global-networks"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalNetworkOutputError>
}

public struct CreateGlobalNetworkInput: Swift.Equatable {
    /// A description of the global network. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.tags = tags
    }
}

struct CreateGlobalNetworkInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateGlobalNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGlobalNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGlobalNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGlobalNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGlobalNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlobalNetworkOutputResponse(globalNetwork: \(Swift.String(describing: globalNetwork)))"}
}

extension CreateGlobalNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct CreateGlobalNetworkOutputResponse: Swift.Equatable {
    /// Information about the global network object.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init (
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct CreateGlobalNetworkOutputResponseBody: Swift.Equatable {
    public let globalNetwork: NetworkManagerClientTypes.GlobalNetwork?
}

extension CreateGlobalNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

public struct CreateLinkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLinkOutputError>
}

extension CreateLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLinkInput(bandwidth: \(Swift.String(describing: bandwidth)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), provider: \(Swift.String(describing: provider)), siteId: \(Swift.String(describing: siteId)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateLinkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct CreateLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLinkOutputError>
}

public struct CreateLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLinkOutputError>
}

public struct CreateLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLinkOutputError>
}

public struct CreateLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/links"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLinkOutputError>
}

public struct CreateLinkInput: Swift.Equatable {
    /// The upload speed and download speed in Mbps.
    /// This member is required.
    public var bandwidth: NetworkManagerClientTypes.Bandwidth?
    /// A description of the link. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The provider of the link. Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^
    public var provider: Swift.String?
    /// The ID of the site.
    /// This member is required.
    public var siteId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The type of the link. Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^
    public var type: Swift.String?

    public init (
        bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        provider: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        type: Swift.String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.provider = provider
        self.siteId = siteId
        self.tags = tags
        self.type = type
    }
}

struct CreateLinkInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let type: Swift.String?
    public let bandwidth: NetworkManagerClientTypes.Bandwidth?
    public let provider: Swift.String?
    public let siteId: Swift.String?
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLinkOutputResponse(link: \(Swift.String(describing: link)))"}
}

extension CreateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct CreateLinkOutputResponse: Swift.Equatable {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init (
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

struct CreateLinkOutputResponseBody: Swift.Equatable {
    public let link: NetworkManagerClientTypes.Link?
}

extension CreateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case link = "Link"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Link.self, forKey: .link)
        link = linkDecoded
    }
}

public struct CreateSiteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

extension CreateSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSiteInput(description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSiteInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInput: Swift.Equatable {
    /// A description of your site. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.
    ///
    /// * Address: The physical address of the site.
    ///
    /// * Latitude: The latitude of the site.
    ///
    /// * Longitude: The longitude of the site.
    public var location: NetworkManagerClientTypes.Location?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.tags = tags
    }
}

struct CreateSiteInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let location: NetworkManagerClientTypes.Location?
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSiteOutputResponse(site: \(Swift.String(describing: site)))"}
}

extension CreateSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct CreateSiteOutputResponse: Swift.Equatable {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init (
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct CreateSiteOutputResponseBody: Swift.Equatable {
    public let site: NetworkManagerClientTypes.Site?
}

extension CreateSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

public struct CreateSiteToSiteVpnAttachmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteToSiteVpnAttachmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteToSiteVpnAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteToSiteVpnAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteToSiteVpnAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteToSiteVpnAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteToSiteVpnAttachmentOutputError>
}

extension CreateSiteToSiteVpnAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSiteToSiteVpnAttachmentInput(clientToken: \(Swift.String(describing: clientToken)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), tags: \(Swift.String(describing: tags)), vpnConnectionArn: \(Swift.String(describing: vpnConnectionArn)))"}
}

extension CreateSiteToSiteVpnAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case tags = "Tags"
        case vpnConnectionArn = "VpnConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpnConnectionArn = vpnConnectionArn {
            try encodeContainer.encode(vpnConnectionArn, forKey: .vpnConnectionArn)
        }
    }
}

public struct CreateSiteToSiteVpnAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteToSiteVpnAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteToSiteVpnAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteToSiteVpnAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteToSiteVpnAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteToSiteVpnAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteToSiteVpnAttachmentOutputError>
}

public struct CreateSiteToSiteVpnAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteToSiteVpnAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteToSiteVpnAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteToSiteVpnAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteToSiteVpnAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteToSiteVpnAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteToSiteVpnAttachmentOutputError>
}

public struct CreateSiteToSiteVpnAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteToSiteVpnAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSiteToSiteVpnAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteToSiteVpnAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSiteToSiteVpnAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteToSiteVpnAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteToSiteVpnAttachmentOutputError>
}

public struct CreateSiteToSiteVpnAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteToSiteVpnAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSiteToSiteVpnAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteToSiteVpnAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/site-to-site-vpn-attachments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSiteToSiteVpnAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteToSiteVpnAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteToSiteVpnAttachmentOutputError>
}

public struct CreateSiteToSiteVpnAttachmentInput: Swift.Equatable {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network where you're creating a site-to-site VPN attachment.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ARN identifying the VPN attachment.
    /// This member is required.
    public var vpnConnectionArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        vpnConnectionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.tags = tags
        self.vpnConnectionArn = vpnConnectionArn
    }
}

struct CreateSiteToSiteVpnAttachmentInputBody: Swift.Equatable {
    public let coreNetworkId: Swift.String?
    public let vpnConnectionArn: Swift.String?
    public let tags: [NetworkManagerClientTypes.Tag]?
    public let clientToken: Swift.String?
}

extension CreateSiteToSiteVpnAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case tags = "Tags"
        case vpnConnectionArn = "VpnConnectionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let vpnConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnConnectionArn)
        vpnConnectionArn = vpnConnectionArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateSiteToSiteVpnAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSiteToSiteVpnAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSiteToSiteVpnAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSiteToSiteVpnAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSiteToSiteVpnAttachmentOutputResponse(siteToSiteVpnAttachment: \(Swift.String(describing: siteToSiteVpnAttachment)))"}
}

extension CreateSiteToSiteVpnAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSiteToSiteVpnAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.siteToSiteVpnAttachment = output.siteToSiteVpnAttachment
        } else {
            self.siteToSiteVpnAttachment = nil
        }
    }
}

public struct CreateSiteToSiteVpnAttachmentOutputResponse: Swift.Equatable {
    /// Details about a site-to-site VPN attachment.
    public var siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment?

    public init (
        siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment? = nil
    )
    {
        self.siteToSiteVpnAttachment = siteToSiteVpnAttachment
    }
}

struct CreateSiteToSiteVpnAttachmentOutputResponseBody: Swift.Equatable {
    public let siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment?
}

extension CreateSiteToSiteVpnAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case siteToSiteVpnAttachment = "SiteToSiteVpnAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteToSiteVpnAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.SiteToSiteVpnAttachment.self, forKey: .siteToSiteVpnAttachment)
        siteToSiteVpnAttachment = siteToSiteVpnAttachmentDecoded
    }
}

public struct CreateVpcAttachmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVpcAttachmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVpcAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVpcAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVpcAttachmentOutputError>
}

extension CreateVpcAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVpcAttachmentInput(clientToken: \(Swift.String(describing: clientToken)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), options: \(Swift.String(describing: options)), subnetArns: \(Swift.String(describing: subnetArns)), tags: \(Swift.String(describing: tags)), vpcArn: \(Swift.String(describing: vpcArn)))"}
}

extension CreateVpcAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case options = "Options"
        case subnetArns = "SubnetArns"
        case tags = "Tags"
        case vpcArn = "VpcArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let subnetArns = subnetArns {
            var subnetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetArns)
            for subnetarnlist0 in subnetArns {
                try subnetArnsContainer.encode(subnetarnlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpcArn = vpcArn {
            try encodeContainer.encode(vpcArn, forKey: .vpcArn)
        }
    }
}

public struct CreateVpcAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVpcAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVpcAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVpcAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVpcAttachmentOutputError>
}

public struct CreateVpcAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVpcAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVpcAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVpcAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVpcAttachmentOutputError>
}

public struct CreateVpcAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVpcAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateVpcAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVpcAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVpcAttachmentOutputError>
}

public struct CreateVpcAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVpcAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateVpcAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/vpc-attachments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVpcAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVpcAttachmentOutputError>
}

public struct CreateVpcAttachmentInput: Swift.Equatable {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network for the VPC attachment.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// Options for the VPC attachment.
    public var options: NetworkManagerClientTypes.VpcOptions?
    /// The subnet ARN of the VPC attachment.
    /// This member is required.
    public var subnetArns: [Swift.String]?
    /// The key-value tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ARN of the VPC.
    /// This member is required.
    public var vpcArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        options: NetworkManagerClientTypes.VpcOptions? = nil,
        subnetArns: [Swift.String]? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        vpcArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.options = options
        self.subnetArns = subnetArns
        self.tags = tags
        self.vpcArn = vpcArn
    }
}

struct CreateVpcAttachmentInputBody: Swift.Equatable {
    public let coreNetworkId: Swift.String?
    public let vpcArn: Swift.String?
    public let subnetArns: [Swift.String]?
    public let options: NetworkManagerClientTypes.VpcOptions?
    public let tags: [NetworkManagerClientTypes.Tag]?
    public let clientToken: Swift.String?
}

extension CreateVpcAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case coreNetworkId = "CoreNetworkId"
        case options = "Options"
        case subnetArns = "SubnetArns"
        case tags = "Tags"
        case vpcArn = "VpcArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let vpcArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcArn)
        vpcArn = vpcArnDecoded
        let subnetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetArns)
        var subnetArnsDecoded0:[Swift.String]? = nil
        if let subnetArnsContainer = subnetArnsContainer {
            subnetArnsDecoded0 = [Swift.String]()
            for string0 in subnetArnsContainer {
                if let string0 = string0 {
                    subnetArnsDecoded0?.append(string0)
                }
            }
        }
        subnetArns = subnetArnsDecoded0
        let optionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcOptions.self, forKey: .options)
        options = optionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVpcAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVpcAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVpcAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVpcAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVpcAttachmentOutputResponse(vpcAttachment: \(Swift.String(describing: vpcAttachment)))"}
}

extension CreateVpcAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateVpcAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcAttachment = output.vpcAttachment
        } else {
            self.vpcAttachment = nil
        }
    }
}

public struct CreateVpcAttachmentOutputResponse: Swift.Equatable {
    /// Provides details about the VPC attachment.
    public var vpcAttachment: NetworkManagerClientTypes.VpcAttachment?

    public init (
        vpcAttachment: NetworkManagerClientTypes.VpcAttachment? = nil
    )
    {
        self.vpcAttachment = vpcAttachment
    }
}

struct CreateVpcAttachmentOutputResponseBody: Swift.Equatable {
    public let vpcAttachment: NetworkManagerClientTypes.VpcAttachment?
}

extension CreateVpcAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcAttachment = "VpcAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcAttachment.self, forKey: .vpcAttachment)
        vpcAttachment = vpcAttachmentDecoded
    }
}

extension NetworkManagerClientTypes.CustomerGatewayAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerGatewayArn = customerGatewayArn {
            try encodeContainer.encode(customerGatewayArn, forKey: .customerGatewayArn)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerGatewayArn)
        customerGatewayArn = customerGatewayArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CustomerGatewayAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes.CustomerGatewayAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerGatewayAssociation(customerGatewayArn: \(Swift.String(describing: customerGatewayArn)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), state: \(Swift.String(describing: state)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the association between a customer gateway, a device, and a link.
    public struct CustomerGatewayAssociation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the customer gateway.
        public var customerGatewayArn: Swift.String?
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The association state.
        public var state: NetworkManagerClientTypes.CustomerGatewayAssociationState?

        public init (
            customerGatewayArn: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.CustomerGatewayAssociationState? = nil
        )
        {
            self.customerGatewayArn = customerGatewayArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }
    }

}

extension NetworkManagerClientTypes {
    public enum CustomerGatewayAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerGatewayAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomerGatewayAssociationState(rawValue: rawValue) ?? CustomerGatewayAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAttachmentInput(attachmentId: \(Swift.String(describing: attachmentId)))"}
}

extension DeleteAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAttachmentOutputError>
}

public struct DeleteAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAttachmentOutputError>
}

public struct DeleteAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAttachmentOutputError>
}

public struct DeleteAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let attachmentId = input.attachmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attachmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/attachments/\(attachmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAttachmentOutputError>
}

public struct DeleteAttachmentInput: Swift.Equatable {
    /// The ID of the attachment to delete.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct DeleteAttachmentInputBody: Swift.Equatable {
}

extension DeleteAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAttachmentOutputResponse(attachment: \(Swift.String(describing: attachment)))"}
}

extension DeleteAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachment = output.attachment
        } else {
            self.attachment = nil
        }
    }
}

public struct DeleteAttachmentOutputResponse: Swift.Equatable {
    /// Information about the deleted attachment.
    public var attachment: NetworkManagerClientTypes.Attachment?

    public init (
        attachment: NetworkManagerClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

struct DeleteAttachmentOutputResponseBody: Swift.Equatable {
    public let attachment: NetworkManagerClientTypes.Attachment?
}

extension DeleteAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
    }
}

extension DeleteConnectPeerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectPeerInput(connectPeerId: \(Swift.String(describing: connectPeerId)))"}
}

extension DeleteConnectPeerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteConnectPeerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectPeerOutputError>
}

public struct DeleteConnectPeerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectPeerOutputError>
}

public struct DeleteConnectPeerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectPeerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectPeerOutputError>
}

public struct DeleteConnectPeerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectPeerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let connectPeerId = input.connectPeerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("connectPeerId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/connect-peers/\(connectPeerId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectPeerOutputError>
}

public struct DeleteConnectPeerInput: Swift.Equatable {
    /// The ID of the deleted Connect peer.
    /// This member is required.
    public var connectPeerId: Swift.String?

    public init (
        connectPeerId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
    }
}

struct DeleteConnectPeerInputBody: Swift.Equatable {
}

extension DeleteConnectPeerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectPeerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectPeerOutputResponse(connectPeer: \(Swift.String(describing: connectPeer)))"}
}

extension DeleteConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeer = output.connectPeer
        } else {
            self.connectPeer = nil
        }
    }
}

public struct DeleteConnectPeerOutputResponse: Swift.Equatable {
    /// Information about the deleted Connect peer.
    public var connectPeer: NetworkManagerClientTypes.ConnectPeer?

    public init (
        connectPeer: NetworkManagerClientTypes.ConnectPeer? = nil
    )
    {
        self.connectPeer = connectPeer
    }
}

struct DeleteConnectPeerOutputResponseBody: Swift.Equatable {
    public let connectPeer: NetworkManagerClientTypes.ConnectPeer?
}

extension DeleteConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeer = "ConnectPeer"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeer.self, forKey: .connectPeer)
        connectPeer = connectPeerDecoded
    }
}

extension DeleteConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionInput(connectionId: \(Swift.String(describing: connectionId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension DeleteConnectionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let connectionId = input.connectionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("connectionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections/\(connectionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Swift.Equatable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
}

extension DeleteConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init (
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    public let connection: NetworkManagerClientTypes.Connection?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension DeleteCoreNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCoreNetworkInput(coreNetworkId: \(Swift.String(describing: coreNetworkId)))"}
}

extension DeleteCoreNetworkInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCoreNetworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCoreNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCoreNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreNetworkOutputError>
}

public struct DeleteCoreNetworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCoreNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCoreNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreNetworkOutputError>
}

public struct DeleteCoreNetworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreNetworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteCoreNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCoreNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreNetworkOutputError>
}

public struct DeleteCoreNetworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreNetworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteCoreNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreNetworkId = input.coreNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/core-networks/\(coreNetworkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCoreNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreNetworkOutputError>
}

public struct DeleteCoreNetworkInput: Swift.Equatable {
    /// The network ID of the deleted core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?

    public init (
        coreNetworkId: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
    }
}

struct DeleteCoreNetworkInputBody: Swift.Equatable {
}

extension DeleteCoreNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCoreNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCoreNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCoreNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCoreNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCoreNetworkOutputResponse(coreNetwork: \(Swift.String(describing: coreNetwork)))"}
}

extension DeleteCoreNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteCoreNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetwork = output.coreNetwork
        } else {
            self.coreNetwork = nil
        }
    }
}

public struct DeleteCoreNetworkOutputResponse: Swift.Equatable {
    /// Information about the deleted core network.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init (
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

struct DeleteCoreNetworkOutputResponseBody: Swift.Equatable {
    public let coreNetwork: NetworkManagerClientTypes.CoreNetwork?
}

extension DeleteCoreNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetwork = "CoreNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetwork.self, forKey: .coreNetwork)
        coreNetwork = coreNetworkDecoded
    }
}

extension DeleteCoreNetworkPolicyVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCoreNetworkPolicyVersionInput(coreNetworkId: \(Swift.String(describing: coreNetworkId)), policyVersionId: \(Swift.String(describing: policyVersionId)))"}
}

extension DeleteCoreNetworkPolicyVersionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCoreNetworkPolicyVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreNetworkPolicyVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCoreNetworkPolicyVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreNetworkPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCoreNetworkPolicyVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreNetworkPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreNetworkPolicyVersionOutputError>
}

public struct DeleteCoreNetworkPolicyVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreNetworkPolicyVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCoreNetworkPolicyVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreNetworkPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCoreNetworkPolicyVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreNetworkPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreNetworkPolicyVersionOutputError>
}

public struct DeleteCoreNetworkPolicyVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreNetworkPolicyVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteCoreNetworkPolicyVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreNetworkPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCoreNetworkPolicyVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreNetworkPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreNetworkPolicyVersionOutputError>
}

public struct DeleteCoreNetworkPolicyVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreNetworkPolicyVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteCoreNetworkPolicyVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreNetworkPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreNetworkId = input.coreNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let policyVersionId = input.policyVersionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("policyVersionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy-versions/\(policyVersionId)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCoreNetworkPolicyVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreNetworkPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreNetworkPolicyVersionOutputError>
}

public struct DeleteCoreNetworkPolicyVersionInput: Swift.Equatable {
    /// The ID of a core network for the deleted policy.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The version ID of the deleted policy.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init (
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

struct DeleteCoreNetworkPolicyVersionInputBody: Swift.Equatable {
}

extension DeleteCoreNetworkPolicyVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCoreNetworkPolicyVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCoreNetworkPolicyVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCoreNetworkPolicyVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCoreNetworkPolicyVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCoreNetworkPolicyVersionOutputResponse(coreNetworkPolicy: \(Swift.String(describing: coreNetworkPolicy)))"}
}

extension DeleteCoreNetworkPolicyVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteCoreNetworkPolicyVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkPolicy = output.coreNetworkPolicy
        } else {
            self.coreNetworkPolicy = nil
        }
    }
}

public struct DeleteCoreNetworkPolicyVersionOutputResponse: Swift.Equatable {
    /// Returns information about the deleted policy version.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init (
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

struct DeleteCoreNetworkPolicyVersionOutputResponseBody: Swift.Equatable {
    public let coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?
}

extension DeleteCoreNetworkPolicyVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkPolicy = "CoreNetworkPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkPolicyDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicy.self, forKey: .coreNetworkPolicy)
        coreNetworkPolicy = coreNetworkPolicyDecoded
    }
}

extension DeleteDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDeviceInput(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension DeleteDeviceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let deviceId = input.deviceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deviceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteDeviceInputBody: Swift.Equatable {
}

extension DeleteDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDeviceOutputResponse(device: \(Swift.String(describing: device)))"}
}

extension DeleteDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct DeleteDeviceOutputResponse: Swift.Equatable {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init (
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct DeleteDeviceOutputResponseBody: Swift.Equatable {
    public let device: NetworkManagerClientTypes.Device?
}

extension DeleteDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

extension DeleteGlobalNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGlobalNetworkInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension DeleteGlobalNetworkInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteGlobalNetworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalNetworkOutputError>
}

public struct DeleteGlobalNetworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalNetworkOutputError>
}

public struct DeleteGlobalNetworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalNetworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalNetworkOutputError>
}

public struct DeleteGlobalNetworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalNetworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalNetworkOutputError>
}

public struct DeleteGlobalNetworkInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteGlobalNetworkInputBody: Swift.Equatable {
}

extension DeleteGlobalNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGlobalNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGlobalNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGlobalNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGlobalNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGlobalNetworkOutputResponse(globalNetwork: \(Swift.String(describing: globalNetwork)))"}
}

extension DeleteGlobalNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct DeleteGlobalNetworkOutputResponse: Swift.Equatable {
    /// Information about the global network.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init (
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct DeleteGlobalNetworkOutputResponseBody: Swift.Equatable {
    public let globalNetwork: NetworkManagerClientTypes.GlobalNetwork?
}

extension DeleteGlobalNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

extension DeleteLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLinkInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension DeleteLinkInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLinkOutputError>
}

public struct DeleteLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLinkOutputError>
}

public struct DeleteLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLinkOutputError>
}

public struct DeleteLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let linkId = input.linkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("linkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/links/\(linkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLinkOutputError>
}

public struct DeleteLinkInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct DeleteLinkInputBody: Swift.Equatable {
}

extension DeleteLinkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLinkOutputResponse(link: \(Swift.String(describing: link)))"}
}

extension DeleteLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct DeleteLinkOutputResponse: Swift.Equatable {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init (
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

struct DeleteLinkOutputResponseBody: Swift.Equatable {
    public let link: NetworkManagerClientTypes.Link?
}

extension DeleteLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case link = "Link"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Link.self, forKey: .link)
        link = linkDecoded
    }
}

extension DeleteResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourcePolicyInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension DeleteResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourcePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteResourcePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResourcePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourcePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteResourcePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/resource-policy/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResourcePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The ARN of the policy to delete.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourcePolicyOutputResponse()"}
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteResourcePolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteResourcePolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSiteInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), siteId: \(Swift.String(describing: siteId)))"}
}

extension DeleteSiteInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites/\(siteId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.siteId = siteId
    }
}

struct DeleteSiteInputBody: Swift.Equatable {
}

extension DeleteSiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSiteOutputResponse(site: \(Swift.String(describing: site)))"}
}

extension DeleteSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct DeleteSiteOutputResponse: Swift.Equatable {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init (
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct DeleteSiteOutputResponseBody: Swift.Equatable {
    public let site: NetworkManagerClientTypes.Site?
}

extension DeleteSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension DeregisterTransitGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterTransitGatewayInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), transitGatewayArn: \(Swift.String(describing: transitGatewayArn)))"}
}

extension DeregisterTransitGatewayInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeregisterTransitGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTransitGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTransitGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTransitGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTransitGatewayOutputError>
}

public struct DeregisterTransitGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTransitGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTransitGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTransitGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTransitGatewayOutputError>
}

public struct DeregisterTransitGatewayInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTransitGatewayInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeregisterTransitGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterTransitGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTransitGatewayOutputError>
}

public struct DeregisterTransitGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTransitGatewayInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeregisterTransitGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let transitGatewayArn = input.transitGatewayArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("transitGatewayArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations/\(transitGatewayArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterTransitGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTransitGatewayOutputError>
}

public struct DeregisterTransitGatewayInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway.
    /// This member is required.
    public var transitGatewayArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        transitGatewayArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayArn = transitGatewayArn
    }
}

struct DeregisterTransitGatewayInputBody: Swift.Equatable {
}

extension DeregisterTransitGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterTransitGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTransitGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTransitGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTransitGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterTransitGatewayOutputResponse(transitGatewayRegistration: \(Swift.String(describing: transitGatewayRegistration)))"}
}

extension DeregisterTransitGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterTransitGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayRegistration = output.transitGatewayRegistration
        } else {
            self.transitGatewayRegistration = nil
        }
    }
}

public struct DeregisterTransitGatewayOutputResponse: Swift.Equatable {
    /// The transit gateway registration information.
    public var transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?

    public init (
        transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration? = nil
    )
    {
        self.transitGatewayRegistration = transitGatewayRegistration
    }
}

struct DeregisterTransitGatewayOutputResponseBody: Swift.Equatable {
    public let transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?
}

extension DeregisterTransitGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayRegistration = "TransitGatewayRegistration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistration.self, forKey: .transitGatewayRegistration)
        transitGatewayRegistration = transitGatewayRegistrationDecoded
    }
}

extension DescribeGlobalNetworksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGlobalNetworksInput(globalNetworkIds: \(Swift.String(describing: globalNetworkIds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeGlobalNetworksInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeGlobalNetworksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalNetworksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGlobalNetworksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGlobalNetworksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalNetworksOutputError>
}

public struct DescribeGlobalNetworksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalNetworksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGlobalNetworksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let globalNetworkIds = input.operationInput.globalNetworkIds {
            globalNetworkIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "globalNetworkIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGlobalNetworksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalNetworksOutputError>
}

public struct DescribeGlobalNetworksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalNetworksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeGlobalNetworksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGlobalNetworksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalNetworksOutputError>
}

public struct DescribeGlobalNetworksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalNetworksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeGlobalNetworksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/global-networks"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGlobalNetworksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalNetworksOutputError>
}

public struct DescribeGlobalNetworksInput: Swift.Equatable {
    /// The IDs of one or more global networks. The maximum is 10.
    public var globalNetworkIds: [Swift.String]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        globalNetworkIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.globalNetworkIds = globalNetworkIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeGlobalNetworksInputBody: Swift.Equatable {
}

extension DescribeGlobalNetworksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGlobalNetworksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGlobalNetworksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGlobalNetworksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGlobalNetworksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGlobalNetworksOutputResponse(globalNetworks: \(Swift.String(describing: globalNetworks)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeGlobalNetworksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGlobalNetworksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetworks = output.globalNetworks
            self.nextToken = output.nextToken
        } else {
            self.globalNetworks = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeGlobalNetworksOutputResponse: Swift.Equatable {
    /// Information about the global networks.
    public var globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.globalNetworks = globalNetworks
        self.nextToken = nextToken
    }
}

struct DescribeGlobalNetworksOutputResponseBody: Swift.Equatable {
    public let globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]?
    public let nextToken: Swift.String?
}

extension DescribeGlobalNetworksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetworks = "GlobalNetworks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworksContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.GlobalNetwork?].self, forKey: .globalNetworks)
        var globalNetworksDecoded0:[NetworkManagerClientTypes.GlobalNetwork]? = nil
        if let globalNetworksContainer = globalNetworksContainer {
            globalNetworksDecoded0 = [NetworkManagerClientTypes.GlobalNetwork]()
            for structure0 in globalNetworksContainer {
                if let structure0 = structure0 {
                    globalNetworksDecoded0?.append(structure0)
                }
            }
        }
        globalNetworks = globalNetworksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NetworkManagerClientTypes.Device: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSLocation = "AWSLocation"
        case createdAt = "CreatedAt"
        case description = "Description"
        case deviceArn = "DeviceArn"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSLocation = aWSLocation {
            try encodeContainer.encode(aWSLocation, forKey: .aWSLocation)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let aWSLocationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AWSLocation.self, forKey: .aWSLocation)
        aWSLocation = aWSLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.DeviceState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.Device: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Device(aWSLocation: \(Swift.String(describing: aWSLocation)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), deviceArn: \(Swift.String(describing: deviceArn)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a device.
    public struct Device: Swift.Equatable {
        /// The Amazon Web Services location of the device.
        public var aWSLocation: NetworkManagerClientTypes.AWSLocation?
        /// The date and time that the site was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the device.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the device.
        public var deviceArn: Swift.String?
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The site location.
        public var location: NetworkManagerClientTypes.Location?
        /// The device model.
        public var model: Swift.String?
        /// The device serial number.
        public var serialNumber: Swift.String?
        /// The site ID.
        public var siteId: Swift.String?
        /// The device state.
        public var state: NetworkManagerClientTypes.DeviceState?
        /// The tags for the device.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The device type.
        public var type: Swift.String?
        /// The device vendor.
        public var vendor: Swift.String?

        public init (
            aWSLocation: NetworkManagerClientTypes.AWSLocation? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceArn: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            location: NetworkManagerClientTypes.Location? = nil,
            model: Swift.String? = nil,
            serialNumber: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.DeviceState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            type: Swift.String? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.aWSLocation = aWSLocation
            self.createdAt = createdAt
            self.description = description
            self.deviceArn = deviceArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.model = model
            self.serialNumber = serialNumber
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
            self.vendor = vendor
        }
    }

}

extension NetworkManagerClientTypes {
    public enum DeviceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceState(rawValue: rawValue) ?? DeviceState.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateConnectPeerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateConnectPeerInput(connectPeerId: \(Swift.String(describing: connectPeerId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension DisassociateConnectPeerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateConnectPeerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateConnectPeerOutputError>
}

public struct DisassociateConnectPeerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateConnectPeerOutputError>
}

public struct DisassociateConnectPeerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateConnectPeerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateConnectPeerOutputError>
}

public struct DisassociateConnectPeerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateConnectPeerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let connectPeerId = input.connectPeerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("connectPeerId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connect-peer-associations/\(connectPeerId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateConnectPeerOutputError>
}

public struct DisassociateConnectPeerInput: Swift.Equatable {
    /// The ID of the Connect peer to disassociate from a device.
    /// This member is required.
    public var connectPeerId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        connectPeerId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
        self.globalNetworkId = globalNetworkId
    }
}

struct DisassociateConnectPeerInputBody: Swift.Equatable {
}

extension DisassociateConnectPeerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateConnectPeerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateConnectPeerOutputResponse(connectPeerAssociation: \(Swift.String(describing: connectPeerAssociation)))"}
}

extension DisassociateConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeerAssociation = output.connectPeerAssociation
        } else {
            self.connectPeerAssociation = nil
        }
    }
}

public struct DisassociateConnectPeerOutputResponse: Swift.Equatable {
    /// Describes the Connect peer association.
    public var connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation?

    public init (
        connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation? = nil
    )
    {
        self.connectPeerAssociation = connectPeerAssociation
    }
}

struct DisassociateConnectPeerOutputResponseBody: Swift.Equatable {
    public let connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation?
}

extension DisassociateConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerAssociation = "ConnectPeerAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeerAssociation.self, forKey: .connectPeerAssociation)
        connectPeerAssociation = connectPeerAssociationDecoded
    }
}

extension DisassociateCustomerGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateCustomerGatewayInput(customerGatewayArn: \(Swift.String(describing: customerGatewayArn)), globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension DisassociateCustomerGatewayInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateCustomerGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomerGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCustomerGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomerGatewayOutputError>
}

public struct DisassociateCustomerGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomerGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCustomerGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomerGatewayOutputError>
}

public struct DisassociateCustomerGatewayInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomerGatewayInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateCustomerGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateCustomerGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomerGatewayOutputError>
}

public struct DisassociateCustomerGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomerGatewayInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateCustomerGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let customerGatewayArn = input.customerGatewayArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("customerGatewayArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations/\(customerGatewayArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateCustomerGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomerGatewayOutputError>
}

public struct DisassociateCustomerGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the customer gateway.
    /// This member is required.
    public var customerGatewayArn: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        customerGatewayArn: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.globalNetworkId = globalNetworkId
    }
}

struct DisassociateCustomerGatewayInputBody: Swift.Equatable {
}

extension DisassociateCustomerGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateCustomerGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCustomerGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateCustomerGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCustomerGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateCustomerGatewayOutputResponse(customerGatewayAssociation: \(Swift.String(describing: customerGatewayAssociation)))"}
}

extension DisassociateCustomerGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateCustomerGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerGatewayAssociation = output.customerGatewayAssociation
        } else {
            self.customerGatewayAssociation = nil
        }
    }
}

public struct DisassociateCustomerGatewayOutputResponse: Swift.Equatable {
    /// Information about the customer gateway association.
    public var customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?

    public init (
        customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation? = nil
    )
    {
        self.customerGatewayAssociation = customerGatewayAssociation
    }
}

struct DisassociateCustomerGatewayOutputResponseBody: Swift.Equatable {
    public let customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?
}

extension DisassociateCustomerGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayAssociation = "CustomerGatewayAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CustomerGatewayAssociation.self, forKey: .customerGatewayAssociation)
        customerGatewayAssociation = customerGatewayAssociationDecoded
    }
}

extension DisassociateLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateLinkInput(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension DisassociateLinkInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLinkOutputError>
}

public struct DisassociateLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let deviceId = input.operationInput.deviceId {
            let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            input.builder.withQueryItem(deviceIdQueryItem)
        }
        if let linkId = input.operationInput.linkId {
            let linkIdQueryItem = ClientRuntime.URLQueryItem(name: "linkId".urlPercentEncoding(), value: Swift.String(linkId).urlPercentEncoding())
            input.builder.withQueryItem(linkIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLinkOutputError>
}

public struct DisassociateLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLinkOutputError>
}

public struct DisassociateLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLinkOutputError>
}

public struct DisassociateLinkInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct DisassociateLinkInputBody: Swift.Equatable {
}

extension DisassociateLinkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateLinkOutputResponse(linkAssociation: \(Swift.String(describing: linkAssociation)))"}
}

extension DisassociateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkAssociation = output.linkAssociation
        } else {
            self.linkAssociation = nil
        }
    }
}

public struct DisassociateLinkOutputResponse: Swift.Equatable {
    /// Information about the link association.
    public var linkAssociation: NetworkManagerClientTypes.LinkAssociation?

    public init (
        linkAssociation: NetworkManagerClientTypes.LinkAssociation? = nil
    )
    {
        self.linkAssociation = linkAssociation
    }
}

struct DisassociateLinkOutputResponseBody: Swift.Equatable {
    public let linkAssociation: NetworkManagerClientTypes.LinkAssociation?
}

extension DisassociateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkAssociation = "LinkAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkAssociation.self, forKey: .linkAssociation)
        linkAssociation = linkAssociationDecoded
    }
}

extension DisassociateTransitGatewayConnectPeerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTransitGatewayConnectPeerInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), transitGatewayConnectPeerArn: \(Swift.String(describing: transitGatewayConnectPeerArn)))"}
}

extension DisassociateTransitGatewayConnectPeerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateTransitGatewayConnectPeerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTransitGatewayConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTransitGatewayConnectPeerOutputError>
}

public struct DisassociateTransitGatewayConnectPeerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTransitGatewayConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTransitGatewayConnectPeerOutputError>
}

public struct DisassociateTransitGatewayConnectPeerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTransitGatewayConnectPeerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateTransitGatewayConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateTransitGatewayConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTransitGatewayConnectPeerOutputError>
}

public struct DisassociateTransitGatewayConnectPeerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTransitGatewayConnectPeerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateTransitGatewayConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let transitGatewayConnectPeerArn = input.transitGatewayConnectPeerArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("transitGatewayConnectPeerArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations/\(transitGatewayConnectPeerArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateTransitGatewayConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTransitGatewayConnectPeerOutputError>
}

public struct DisassociateTransitGatewayConnectPeerInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
    /// This member is required.
    public var transitGatewayConnectPeerArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        transitGatewayConnectPeerArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

struct DisassociateTransitGatewayConnectPeerInputBody: Swift.Equatable {
}

extension DisassociateTransitGatewayConnectPeerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTransitGatewayConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTransitGatewayConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateTransitGatewayConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTransitGatewayConnectPeerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTransitGatewayConnectPeerOutputResponse(transitGatewayConnectPeerAssociation: \(Swift.String(describing: transitGatewayConnectPeerAssociation)))"}
}

extension DisassociateTransitGatewayConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateTransitGatewayConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayConnectPeerAssociation = output.transitGatewayConnectPeerAssociation
        } else {
            self.transitGatewayConnectPeerAssociation = nil
        }
    }
}

public struct DisassociateTransitGatewayConnectPeerOutputResponse: Swift.Equatable {
    /// The transit gateway Connect peer association.
    public var transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?

    public init (
        transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation? = nil
    )
    {
        self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
    }
}

struct DisassociateTransitGatewayConnectPeerOutputResponseBody: Swift.Equatable {
    public let transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?
}

extension DisassociateTransitGatewayConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation.self, forKey: .transitGatewayConnectPeerAssociation)
        transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociationDecoded
    }
}

extension ExecuteCoreNetworkChangeSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteCoreNetworkChangeSetInput(coreNetworkId: \(Swift.String(describing: coreNetworkId)), policyVersionId: \(Swift.String(describing: policyVersionId)))"}
}

extension ExecuteCoreNetworkChangeSetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ExecuteCoreNetworkChangeSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteCoreNetworkChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteCoreNetworkChangeSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteCoreNetworkChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteCoreNetworkChangeSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteCoreNetworkChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteCoreNetworkChangeSetOutputError>
}

public struct ExecuteCoreNetworkChangeSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteCoreNetworkChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteCoreNetworkChangeSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteCoreNetworkChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteCoreNetworkChangeSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteCoreNetworkChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteCoreNetworkChangeSetOutputError>
}

public struct ExecuteCoreNetworkChangeSetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteCoreNetworkChangeSetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ExecuteCoreNetworkChangeSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteCoreNetworkChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExecuteCoreNetworkChangeSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteCoreNetworkChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteCoreNetworkChangeSetOutputError>
}

public struct ExecuteCoreNetworkChangeSetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteCoreNetworkChangeSetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ExecuteCoreNetworkChangeSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteCoreNetworkChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreNetworkId = input.coreNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let policyVersionId = input.policyVersionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("policyVersionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-change-sets/\(policyVersionId)/execute"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExecuteCoreNetworkChangeSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteCoreNetworkChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteCoreNetworkChangeSetOutputError>
}

public struct ExecuteCoreNetworkChangeSetInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The ID of the policy version.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init (
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

struct ExecuteCoreNetworkChangeSetInputBody: Swift.Equatable {
}

extension ExecuteCoreNetworkChangeSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExecuteCoreNetworkChangeSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteCoreNetworkChangeSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteCoreNetworkChangeSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteCoreNetworkChangeSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteCoreNetworkChangeSetOutputResponse()"}
}

extension ExecuteCoreNetworkChangeSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ExecuteCoreNetworkChangeSetOutputResponse: Swift.Equatable {

    public init() {}
}

struct ExecuteCoreNetworkChangeSetOutputResponseBody: Swift.Equatable {
}

extension ExecuteCoreNetworkChangeSetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectAttachmentInput(attachmentId: \(Swift.String(describing: attachmentId)))"}
}

extension GetConnectAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetConnectAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectAttachmentOutputError>
}

public struct GetConnectAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectAttachmentOutputError>
}

public struct GetConnectAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetConnectAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectAttachmentOutputError>
}

public struct GetConnectAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetConnectAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let attachmentId = input.attachmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attachmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/connect-attachments/\(attachmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectAttachmentOutputError>
}

public struct GetConnectAttachmentInput: Swift.Equatable {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct GetConnectAttachmentInputBody: Swift.Equatable {
}

extension GetConnectAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectAttachmentOutputResponse(connectAttachment: \(Swift.String(describing: connectAttachment)))"}
}

extension GetConnectAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConnectAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectAttachment = output.connectAttachment
        } else {
            self.connectAttachment = nil
        }
    }
}

public struct GetConnectAttachmentOutputResponse: Swift.Equatable {
    /// Details about the Connect attachment.
    public var connectAttachment: NetworkManagerClientTypes.ConnectAttachment?

    public init (
        connectAttachment: NetworkManagerClientTypes.ConnectAttachment? = nil
    )
    {
        self.connectAttachment = connectAttachment
    }
}

struct GetConnectAttachmentOutputResponseBody: Swift.Equatable {
    public let connectAttachment: NetworkManagerClientTypes.ConnectAttachment?
}

extension GetConnectAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectAttachment = "ConnectAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectAttachment.self, forKey: .connectAttachment)
        connectAttachment = connectAttachmentDecoded
    }
}

extension GetConnectPeerAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectPeerAssociationsInput(connectPeerIds: \(Swift.String(describing: connectPeerIds)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetConnectPeerAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetConnectPeerAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectPeerAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectPeerAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectPeerAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectPeerAssociationsOutputError>
}

public struct GetConnectPeerAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectPeerAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectPeerAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectPeerIds = input.operationInput.connectPeerIds {
            connectPeerIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "connectPeerIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectPeerAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectPeerAssociationsOutputError>
}

public struct GetConnectPeerAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectPeerAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetConnectPeerAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectPeerAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectPeerAssociationsOutputError>
}

public struct GetConnectPeerAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectPeerAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetConnectPeerAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connect-peer-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectPeerAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectPeerAssociationsOutputError>
}

public struct GetConnectPeerAssociationsInput: Swift.Equatable {
    /// The IDs of the Connect peers.
    public var connectPeerIds: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectPeerIds: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectPeerIds = connectPeerIds
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetConnectPeerAssociationsInputBody: Swift.Equatable {
}

extension GetConnectPeerAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectPeerAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectPeerAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectPeerAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectPeerAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectPeerAssociationsOutputResponse(connectPeerAssociations: \(Swift.String(describing: connectPeerAssociations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetConnectPeerAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConnectPeerAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeerAssociations = output.connectPeerAssociations
            self.nextToken = output.nextToken
        } else {
            self.connectPeerAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct GetConnectPeerAssociationsOutputResponse: Swift.Equatable {
    /// Displays a list of Connect peer associations.
    public var connectPeerAssociations: [NetworkManagerClientTypes.ConnectPeerAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectPeerAssociations: [NetworkManagerClientTypes.ConnectPeerAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectPeerAssociations = connectPeerAssociations
        self.nextToken = nextToken
    }
}

struct GetConnectPeerAssociationsOutputResponseBody: Swift.Equatable {
    public let connectPeerAssociations: [NetworkManagerClientTypes.ConnectPeerAssociation]?
    public let nextToken: Swift.String?
}

extension GetConnectPeerAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeerAssociations = "ConnectPeerAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.ConnectPeerAssociation?].self, forKey: .connectPeerAssociations)
        var connectPeerAssociationsDecoded0:[NetworkManagerClientTypes.ConnectPeerAssociation]? = nil
        if let connectPeerAssociationsContainer = connectPeerAssociationsContainer {
            connectPeerAssociationsDecoded0 = [NetworkManagerClientTypes.ConnectPeerAssociation]()
            for structure0 in connectPeerAssociationsContainer {
                if let structure0 = structure0 {
                    connectPeerAssociationsDecoded0?.append(structure0)
                }
            }
        }
        connectPeerAssociations = connectPeerAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetConnectPeerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectPeerInput(connectPeerId: \(Swift.String(describing: connectPeerId)))"}
}

extension GetConnectPeerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetConnectPeerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectPeerOutputError>
}

public struct GetConnectPeerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectPeerOutputError>
}

public struct GetConnectPeerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectPeerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectPeerOutputError>
}

public struct GetConnectPeerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectPeerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let connectPeerId = input.connectPeerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("connectPeerId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/connect-peers/\(connectPeerId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectPeerOutputError>
}

public struct GetConnectPeerInput: Swift.Equatable {
    /// The ID of the Connect peer.
    /// This member is required.
    public var connectPeerId: Swift.String?

    public init (
        connectPeerId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
    }
}

struct GetConnectPeerInputBody: Swift.Equatable {
}

extension GetConnectPeerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectPeerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectPeerOutputResponse(connectPeer: \(Swift.String(describing: connectPeer)))"}
}

extension GetConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeer = output.connectPeer
        } else {
            self.connectPeer = nil
        }
    }
}

public struct GetConnectPeerOutputResponse: Swift.Equatable {
    /// Returns information about a core network Connect peer.
    public var connectPeer: NetworkManagerClientTypes.ConnectPeer?

    public init (
        connectPeer: NetworkManagerClientTypes.ConnectPeer? = nil
    )
    {
        self.connectPeer = connectPeer
    }
}

struct GetConnectPeerOutputResponseBody: Swift.Equatable {
    public let connectPeer: NetworkManagerClientTypes.ConnectPeer?
}

extension GetConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeer = "ConnectPeer"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeerDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectPeer.self, forKey: .connectPeer)
        connectPeer = connectPeerDecoded
    }
}

extension GetConnectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectionsInput(connectionIds: \(Swift.String(describing: connectionIds)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetConnectionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetConnectionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let deviceId = input.operationInput.deviceId {
            let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            input.builder.withQueryItem(deviceIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let connectionIds = input.operationInput.connectionIds {
            connectionIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "connectionIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetConnectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetConnectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInput: Swift.Equatable {
    /// One or more connection IDs.
    public var connectionIds: [Swift.String]?
    /// The ID of the device.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectionIds: [Swift.String]? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionIds = connectionIds
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetConnectionsInputBody: Swift.Equatable {
}

extension GetConnectionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectionsOutputResponse(connections: \(Swift.String(describing: connections)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
            self.nextToken = output.nextToken
        } else {
            self.connections = nil
            self.nextToken = nil
        }
    }
}

public struct GetConnectionsOutputResponse: Swift.Equatable {
    /// Information about the connections.
    public var connections: [NetworkManagerClientTypes.Connection]?
    /// The token to use for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connections: [NetworkManagerClientTypes.Connection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

struct GetConnectionsOutputResponseBody: Swift.Equatable {
    public let connections: [NetworkManagerClientTypes.Connection]?
    public let nextToken: Swift.String?
}

extension GetConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[NetworkManagerClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [NetworkManagerClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCoreNetworkChangeSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCoreNetworkChangeSetInput(coreNetworkId: \(Swift.String(describing: coreNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), policyVersionId: \(Swift.String(describing: policyVersionId)))"}
}

extension GetCoreNetworkChangeSetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCoreNetworkChangeSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCoreNetworkChangeSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCoreNetworkChangeSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkChangeSetOutputError>
}

public struct GetCoreNetworkChangeSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCoreNetworkChangeSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCoreNetworkChangeSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkChangeSetOutputError>
}

public struct GetCoreNetworkChangeSetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkChangeSetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCoreNetworkChangeSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCoreNetworkChangeSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkChangeSetOutputError>
}

public struct GetCoreNetworkChangeSetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkChangeSetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCoreNetworkChangeSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreNetworkId = input.coreNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let policyVersionId = input.policyVersionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("policyVersionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-change-sets/\(policyVersionId)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCoreNetworkChangeSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkChangeSetOutputError>
}

public struct GetCoreNetworkChangeSetInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the policy version.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init (
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyVersionId = policyVersionId
    }
}

struct GetCoreNetworkChangeSetInputBody: Swift.Equatable {
}

extension GetCoreNetworkChangeSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreNetworkChangeSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreNetworkChangeSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCoreNetworkChangeSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreNetworkChangeSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCoreNetworkChangeSetOutputResponse(coreNetworkChanges: \(Swift.String(describing: coreNetworkChanges)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetCoreNetworkChangeSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCoreNetworkChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkChanges = output.coreNetworkChanges
            self.nextToken = output.nextToken
        } else {
            self.coreNetworkChanges = nil
            self.nextToken = nil
        }
    }
}

public struct GetCoreNetworkChangeSetOutputResponse: Swift.Equatable {
    /// Describes a core network changes.
    public var coreNetworkChanges: [NetworkManagerClientTypes.CoreNetworkChange]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        coreNetworkChanges: [NetworkManagerClientTypes.CoreNetworkChange]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkChanges = coreNetworkChanges
        self.nextToken = nextToken
    }
}

struct GetCoreNetworkChangeSetOutputResponseBody: Swift.Equatable {
    public let coreNetworkChanges: [NetworkManagerClientTypes.CoreNetworkChange]?
    public let nextToken: Swift.String?
}

extension GetCoreNetworkChangeSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkChanges = "CoreNetworkChanges"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkChangesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkChange?].self, forKey: .coreNetworkChanges)
        var coreNetworkChangesDecoded0:[NetworkManagerClientTypes.CoreNetworkChange]? = nil
        if let coreNetworkChangesContainer = coreNetworkChangesContainer {
            coreNetworkChangesDecoded0 = [NetworkManagerClientTypes.CoreNetworkChange]()
            for structure0 in coreNetworkChangesContainer {
                if let structure0 = structure0 {
                    coreNetworkChangesDecoded0?.append(structure0)
                }
            }
        }
        coreNetworkChanges = coreNetworkChangesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCoreNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCoreNetworkInput(coreNetworkId: \(Swift.String(describing: coreNetworkId)))"}
}

extension GetCoreNetworkInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCoreNetworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCoreNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCoreNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkOutputError>
}

public struct GetCoreNetworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCoreNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCoreNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkOutputError>
}

public struct GetCoreNetworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCoreNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCoreNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkOutputError>
}

public struct GetCoreNetworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCoreNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreNetworkId = input.coreNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/core-networks/\(coreNetworkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCoreNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkOutputError>
}

public struct GetCoreNetworkInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?

    public init (
        coreNetworkId: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
    }
}

struct GetCoreNetworkInputBody: Swift.Equatable {
}

extension GetCoreNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCoreNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCoreNetworkOutputResponse(coreNetwork: \(Swift.String(describing: coreNetwork)))"}
}

extension GetCoreNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCoreNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetwork = output.coreNetwork
        } else {
            self.coreNetwork = nil
        }
    }
}

public struct GetCoreNetworkOutputResponse: Swift.Equatable {
    /// Details about a core network.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init (
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

struct GetCoreNetworkOutputResponseBody: Swift.Equatable {
    public let coreNetwork: NetworkManagerClientTypes.CoreNetwork?
}

extension GetCoreNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetwork = "CoreNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetwork.self, forKey: .coreNetwork)
        coreNetwork = coreNetworkDecoded
    }
}

extension GetCoreNetworkPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCoreNetworkPolicyInput(alias: \(Swift.String(describing: alias)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), policyVersionId: \(Swift.String(describing: policyVersionId)))"}
}

extension GetCoreNetworkPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCoreNetworkPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCoreNetworkPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCoreNetworkPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkPolicyOutputError>
}

public struct GetCoreNetworkPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCoreNetworkPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let alias = input.operationInput.alias {
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(aliasQueryItem)
        }
        if let policyVersionId = input.operationInput.policyVersionId {
            let policyVersionIdQueryItem = ClientRuntime.URLQueryItem(name: "policyVersionId".urlPercentEncoding(), value: Swift.String(policyVersionId).urlPercentEncoding())
            input.builder.withQueryItem(policyVersionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCoreNetworkPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkPolicyOutputError>
}

public struct GetCoreNetworkPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCoreNetworkPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCoreNetworkPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkPolicyOutputError>
}

public struct GetCoreNetworkPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreNetworkPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCoreNetworkPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreNetworkPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreNetworkId = input.coreNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCoreNetworkPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreNetworkPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreNetworkPolicyOutputError>
}

public struct GetCoreNetworkPolicyInput: Swift.Equatable {
    /// The alias of a core network policy
    public var alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias?
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The ID of a core network policy version.
    public var policyVersionId: Swift.Int?

    public init (
        alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias? = nil,
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.alias = alias
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

struct GetCoreNetworkPolicyInputBody: Swift.Equatable {
}

extension GetCoreNetworkPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreNetworkPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreNetworkPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCoreNetworkPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreNetworkPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCoreNetworkPolicyOutputResponse(coreNetworkPolicy: \(Swift.String(describing: coreNetworkPolicy)))"}
}

extension GetCoreNetworkPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCoreNetworkPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkPolicy = output.coreNetworkPolicy
        } else {
            self.coreNetworkPolicy = nil
        }
    }
}

public struct GetCoreNetworkPolicyOutputResponse: Swift.Equatable {
    /// The details about a core network policy.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init (
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

struct GetCoreNetworkPolicyOutputResponseBody: Swift.Equatable {
    public let coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?
}

extension GetCoreNetworkPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkPolicy = "CoreNetworkPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkPolicyDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicy.self, forKey: .coreNetworkPolicy)
        coreNetworkPolicy = coreNetworkPolicyDecoded
    }
}

extension GetCustomerGatewayAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCustomerGatewayAssociationsInput(customerGatewayArns: \(Swift.String(describing: customerGatewayArns)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetCustomerGatewayAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCustomerGatewayAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCustomerGatewayAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCustomerGatewayAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCustomerGatewayAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCustomerGatewayAssociationsOutputError>
}

public struct GetCustomerGatewayAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCustomerGatewayAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCustomerGatewayAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let customerGatewayArns = input.operationInput.customerGatewayArns {
            customerGatewayArns.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "customerGatewayArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCustomerGatewayAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCustomerGatewayAssociationsOutputError>
}

public struct GetCustomerGatewayAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCustomerGatewayAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCustomerGatewayAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCustomerGatewayAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCustomerGatewayAssociationsOutputError>
}

public struct GetCustomerGatewayAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCustomerGatewayAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCustomerGatewayAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCustomerGatewayAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCustomerGatewayAssociationsOutputError>
}

public struct GetCustomerGatewayAssociationsInput: Swift.Equatable {
    /// One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.
    public var customerGatewayArns: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        customerGatewayArns: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerGatewayArns = customerGatewayArns
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCustomerGatewayAssociationsInputBody: Swift.Equatable {
}

extension GetCustomerGatewayAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCustomerGatewayAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCustomerGatewayAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCustomerGatewayAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCustomerGatewayAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCustomerGatewayAssociationsOutputResponse(customerGatewayAssociations: \(Swift.String(describing: customerGatewayAssociations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetCustomerGatewayAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCustomerGatewayAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerGatewayAssociations = output.customerGatewayAssociations
            self.nextToken = output.nextToken
        } else {
            self.customerGatewayAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct GetCustomerGatewayAssociationsOutputResponse: Swift.Equatable {
    /// The customer gateway associations.
    public var customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerGatewayAssociations = customerGatewayAssociations
        self.nextToken = nextToken
    }
}

struct GetCustomerGatewayAssociationsOutputResponseBody: Swift.Equatable {
    public let customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]?
    public let nextToken: Swift.String?
}

extension GetCustomerGatewayAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayAssociations = "CustomerGatewayAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CustomerGatewayAssociation?].self, forKey: .customerGatewayAssociations)
        var customerGatewayAssociationsDecoded0:[NetworkManagerClientTypes.CustomerGatewayAssociation]? = nil
        if let customerGatewayAssociationsContainer = customerGatewayAssociationsContainer {
            customerGatewayAssociationsDecoded0 = [NetworkManagerClientTypes.CustomerGatewayAssociation]()
            for structure0 in customerGatewayAssociationsContainer {
                if let structure0 = structure0 {
                    customerGatewayAssociationsDecoded0?.append(structure0)
                }
            }
        }
        customerGatewayAssociations = customerGatewayAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDevicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicesInput(deviceIds: \(Swift.String(describing: deviceIds)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), siteId: \(Swift.String(describing: siteId)))"}
}

extension GetDevicesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDevicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesOutputError>
}

public struct GetDevicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let deviceIds = input.operationInput.deviceIds {
            deviceIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "deviceIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let siteId = input.operationInput.siteId {
            let siteIdQueryItem = ClientRuntime.URLQueryItem(name: "siteId".urlPercentEncoding(), value: Swift.String(siteId).urlPercentEncoding())
            input.builder.withQueryItem(siteIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesOutputError>
}

public struct GetDevicesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDevicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesOutputError>
}

public struct GetDevicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDevicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesOutputError>
}

public struct GetDevicesInput: Swift.Equatable {
    /// One or more device IDs. The maximum is 10.
    public var deviceIds: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?

    public init (
        deviceIds: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.siteId = siteId
    }
}

struct GetDevicesInputBody: Swift.Equatable {
}

extension GetDevicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicesOutputResponse(devices: \(Swift.String(describing: devices)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct GetDevicesOutputResponse: Swift.Equatable {
    /// The devices.
    public var devices: [NetworkManagerClientTypes.Device]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        devices: [NetworkManagerClientTypes.Device]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct GetDevicesOutputResponseBody: Swift.Equatable {
    public let devices: [NetworkManagerClientTypes.Device]?
    public let nextToken: Swift.String?
}

extension GetDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[NetworkManagerClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [NetworkManagerClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetLinkAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLinkAssociationsInput(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetLinkAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLinkAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinkAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinkAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAssociationsOutputError>
}

public struct GetLinkAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinkAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let deviceId = input.operationInput.deviceId {
            let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            input.builder.withQueryItem(deviceIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let linkId = input.operationInput.linkId {
            let linkIdQueryItem = ClientRuntime.URLQueryItem(name: "linkId".urlPercentEncoding(), value: Swift.String(linkId).urlPercentEncoding())
            input.builder.withQueryItem(linkIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinkAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAssociationsOutputError>
}

public struct GetLinkAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLinkAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLinkAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAssociationsOutputError>
}

public struct GetLinkAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLinkAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLinkAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAssociationsOutputError>
}

public struct GetLinkAssociationsInput: Swift.Equatable {
    /// The ID of the device.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetLinkAssociationsInputBody: Swift.Equatable {
}

extension GetLinkAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLinkAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLinkAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLinkAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLinkAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLinkAssociationsOutputResponse(linkAssociations: \(Swift.String(describing: linkAssociations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetLinkAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLinkAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkAssociations = output.linkAssociations
            self.nextToken = output.nextToken
        } else {
            self.linkAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct GetLinkAssociationsOutputResponse: Swift.Equatable {
    /// The link associations.
    public var linkAssociations: [NetworkManagerClientTypes.LinkAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        linkAssociations: [NetworkManagerClientTypes.LinkAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkAssociations = linkAssociations
        self.nextToken = nextToken
    }
}

struct GetLinkAssociationsOutputResponseBody: Swift.Equatable {
    public let linkAssociations: [NetworkManagerClientTypes.LinkAssociation]?
    public let nextToken: Swift.String?
}

extension GetLinkAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkAssociations = "LinkAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.LinkAssociation?].self, forKey: .linkAssociations)
        var linkAssociationsDecoded0:[NetworkManagerClientTypes.LinkAssociation]? = nil
        if let linkAssociationsContainer = linkAssociationsContainer {
            linkAssociationsDecoded0 = [NetworkManagerClientTypes.LinkAssociation]()
            for structure0 in linkAssociationsContainer {
                if let structure0 = structure0 {
                    linkAssociationsDecoded0?.append(structure0)
                }
            }
        }
        linkAssociations = linkAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetLinksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLinksInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkIds: \(Swift.String(describing: linkIds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), provider: \(Swift.String(describing: provider)), siteId: \(Swift.String(describing: siteId)), type: \(Swift.String(describing: type)))"}
}

extension GetLinksInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLinksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinksOutputError>
}

public struct GetLinksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let siteId = input.operationInput.siteId {
            let siteIdQueryItem = ClientRuntime.URLQueryItem(name: "siteId".urlPercentEncoding(), value: Swift.String(siteId).urlPercentEncoding())
            input.builder.withQueryItem(siteIdQueryItem)
        }
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let linkIds = input.operationInput.linkIds {
            linkIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "linkIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let provider = input.operationInput.provider {
            let providerQueryItem = ClientRuntime.URLQueryItem(name: "provider".urlPercentEncoding(), value: Swift.String(provider).urlPercentEncoding())
            input.builder.withQueryItem(providerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinksOutputError>
}

public struct GetLinksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLinksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLinksInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinksOutputError>
}

public struct GetLinksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLinksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/links"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLinksInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinksOutputError>
}

public struct GetLinksInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// One or more link IDs. The maximum is 10.
    public var linkIds: [Swift.String]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The link provider.
    public var provider: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The link type.
    public var type: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        linkIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        provider: Swift.String? = nil,
        siteId: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.linkIds = linkIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provider = provider
        self.siteId = siteId
        self.type = type
    }
}

struct GetLinksInputBody: Swift.Equatable {
}

extension GetLinksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLinksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLinksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLinksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLinksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLinksOutputResponse(links: \(Swift.String(describing: links)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetLinksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLinksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.links = output.links
            self.nextToken = output.nextToken
        } else {
            self.links = nil
            self.nextToken = nil
        }
    }
}

public struct GetLinksOutputResponse: Swift.Equatable {
    /// The links.
    public var links: [NetworkManagerClientTypes.Link]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        links: [NetworkManagerClientTypes.Link]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.links = links
        self.nextToken = nextToken
    }
}

struct GetLinksOutputResponseBody: Swift.Equatable {
    public let links: [NetworkManagerClientTypes.Link]?
    public let nextToken: Swift.String?
}

extension GetLinksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case links = "Links"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linksContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Link?].self, forKey: .links)
        var linksDecoded0:[NetworkManagerClientTypes.Link]? = nil
        if let linksContainer = linksContainer {
            linksDecoded0 = [NetworkManagerClientTypes.Link]()
            for structure0 in linksContainer {
                if let structure0 = structure0 {
                    linksDecoded0?.append(structure0)
                }
            }
        }
        links = linksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNetworkResourceCountsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkResourceCountsInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension GetNetworkResourceCountsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetNetworkResourceCountsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourceCountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkResourceCountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourceCountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkResourceCountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourceCountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourceCountsOutputError>
}

public struct GetNetworkResourceCountsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourceCountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkResourceCountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourceCountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkResourceCountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourceCountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourceCountsOutputError>
}

public struct GetNetworkResourceCountsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourceCountsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetNetworkResourceCountsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourceCountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkResourceCountsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourceCountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourceCountsOutputError>
}

public struct GetNetworkResourceCountsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourceCountsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetNetworkResourceCountsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourceCountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resource-count"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkResourceCountsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourceCountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourceCountsOutputError>
}

public struct GetNetworkResourceCountsInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon
    ///
    /// * dx-gateway
    ///
    /// * dx-vif
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * connection
    ///
    /// * device
    ///
    /// * link
    ///
    /// * site
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway
    ///
    /// * transit-gateway
    ///
    /// * transit-gateway-attachment
    ///
    /// * transit-gateway-connect-peer
    ///
    /// * transit-gateway-route-table
    ///
    /// * vpn-connection
    public var resourceType: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct GetNetworkResourceCountsInputBody: Swift.Equatable {
}

extension GetNetworkResourceCountsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkResourceCountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkResourceCountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkResourceCountsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkResourceCountsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkResourceCountsOutputResponse(networkResourceCounts: \(Swift.String(describing: networkResourceCounts)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetNetworkResourceCountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNetworkResourceCountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkResourceCounts = output.networkResourceCounts
            self.nextToken = output.nextToken
        } else {
            self.networkResourceCounts = nil
            self.nextToken = nil
        }
    }
}

public struct GetNetworkResourceCountsOutputResponse: Swift.Equatable {
    /// The count of resources.
    public var networkResourceCounts: [NetworkManagerClientTypes.NetworkResourceCount]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        networkResourceCounts: [NetworkManagerClientTypes.NetworkResourceCount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkResourceCounts = networkResourceCounts
        self.nextToken = nextToken
    }
}

struct GetNetworkResourceCountsOutputResponseBody: Swift.Equatable {
    public let networkResourceCounts: [NetworkManagerClientTypes.NetworkResourceCount]?
    public let nextToken: Swift.String?
}

extension GetNetworkResourceCountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResourceCounts = "NetworkResourceCounts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourceCountsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.NetworkResourceCount?].self, forKey: .networkResourceCounts)
        var networkResourceCountsDecoded0:[NetworkManagerClientTypes.NetworkResourceCount]? = nil
        if let networkResourceCountsContainer = networkResourceCountsContainer {
            networkResourceCountsDecoded0 = [NetworkManagerClientTypes.NetworkResourceCount]()
            for structure0 in networkResourceCountsContainer {
                if let structure0 = structure0 {
                    networkResourceCountsDecoded0?.append(structure0)
                }
            }
        }
        networkResourceCounts = networkResourceCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNetworkResourceRelationshipsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkResourceRelationshipsInput(accountId: \(Swift.String(describing: accountId)), awsRegion: \(Swift.String(describing: awsRegion)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registeredGatewayArn: \(Swift.String(describing: registeredGatewayArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension GetNetworkResourceRelationshipsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetNetworkResourceRelationshipsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourceRelationshipsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkResourceRelationshipsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourceRelationshipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkResourceRelationshipsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourceRelationshipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourceRelationshipsOutputError>
}

public struct GetNetworkResourceRelationshipsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourceRelationshipsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkResourceRelationshipsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourceRelationshipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let coreNetworkId = input.operationInput.coreNetworkId {
            let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            input.builder.withQueryItem(coreNetworkIdQueryItem)
        }
        if let accountId = input.operationInput.accountId {
            let accountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            input.builder.withQueryItem(accountIdQueryItem)
        }
        if let registeredGatewayArn = input.operationInput.registeredGatewayArn {
            let registeredGatewayArnQueryItem = ClientRuntime.URLQueryItem(name: "registeredGatewayArn".urlPercentEncoding(), value: Swift.String(registeredGatewayArn).urlPercentEncoding())
            input.builder.withQueryItem(registeredGatewayArnQueryItem)
        }
        if let awsRegion = input.operationInput.awsRegion {
            let awsRegionQueryItem = ClientRuntime.URLQueryItem(name: "awsRegion".urlPercentEncoding(), value: Swift.String(awsRegion).urlPercentEncoding())
            input.builder.withQueryItem(awsRegionQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkResourceRelationshipsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourceRelationshipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourceRelationshipsOutputError>
}

public struct GetNetworkResourceRelationshipsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourceRelationshipsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetNetworkResourceRelationshipsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourceRelationshipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkResourceRelationshipsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourceRelationshipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourceRelationshipsOutputError>
}

public struct GetNetworkResourceRelationshipsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourceRelationshipsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetNetworkResourceRelationshipsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourceRelationshipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resource-relationships"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkResourceRelationshipsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourceRelationshipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourceRelationshipsOutputError>
}

public struct GetNetworkResourceRelationshipsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The Amazon Web Services Region.
    public var awsRegion: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the registered gateway.
    public var registeredGatewayArn: Swift.String?
    /// The ARN of the gateway.
    public var resourceArn: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon
    ///
    /// * dx-gateway
    ///
    /// * dx-vif
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * connection
    ///
    /// * device
    ///
    /// * link
    ///
    /// * site
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway
    ///
    /// * transit-gateway
    ///
    /// * transit-gateway-attachment
    ///
    /// * transit-gateway-connect-peer
    ///
    /// * transit-gateway-route-table
    ///
    /// * vpn-connection
    public var resourceType: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registeredGatewayArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.coreNetworkId = coreNetworkId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registeredGatewayArn = registeredGatewayArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

struct GetNetworkResourceRelationshipsInputBody: Swift.Equatable {
}

extension GetNetworkResourceRelationshipsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkResourceRelationshipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkResourceRelationshipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkResourceRelationshipsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkResourceRelationshipsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkResourceRelationshipsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), relationships: \(Swift.String(describing: relationships)))"}
}

extension GetNetworkResourceRelationshipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNetworkResourceRelationshipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.relationships = output.relationships
        } else {
            self.nextToken = nil
            self.relationships = nil
        }
    }
}

public struct GetNetworkResourceRelationshipsOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The resource relationships.
    public var relationships: [NetworkManagerClientTypes.Relationship]?

    public init (
        nextToken: Swift.String? = nil,
        relationships: [NetworkManagerClientTypes.Relationship]? = nil
    )
    {
        self.nextToken = nextToken
        self.relationships = relationships
    }
}

struct GetNetworkResourceRelationshipsOutputResponseBody: Swift.Equatable {
    public let relationships: [NetworkManagerClientTypes.Relationship]?
    public let nextToken: Swift.String?
}

extension GetNetworkResourceRelationshipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case relationships = "Relationships"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relationshipsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Relationship?].self, forKey: .relationships)
        var relationshipsDecoded0:[NetworkManagerClientTypes.Relationship]? = nil
        if let relationshipsContainer = relationshipsContainer {
            relationshipsDecoded0 = [NetworkManagerClientTypes.Relationship]()
            for structure0 in relationshipsContainer {
                if let structure0 = structure0 {
                    relationshipsDecoded0?.append(structure0)
                }
            }
        }
        relationships = relationshipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNetworkResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkResourcesInput(accountId: \(Swift.String(describing: accountId)), awsRegion: \(Swift.String(describing: awsRegion)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registeredGatewayArn: \(Swift.String(describing: registeredGatewayArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension GetNetworkResourcesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetNetworkResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourcesOutputError>
}

public struct GetNetworkResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let coreNetworkId = input.operationInput.coreNetworkId {
            let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            input.builder.withQueryItem(coreNetworkIdQueryItem)
        }
        if let accountId = input.operationInput.accountId {
            let accountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            input.builder.withQueryItem(accountIdQueryItem)
        }
        if let registeredGatewayArn = input.operationInput.registeredGatewayArn {
            let registeredGatewayArnQueryItem = ClientRuntime.URLQueryItem(name: "registeredGatewayArn".urlPercentEncoding(), value: Swift.String(registeredGatewayArn).urlPercentEncoding())
            input.builder.withQueryItem(registeredGatewayArnQueryItem)
        }
        if let awsRegion = input.operationInput.awsRegion {
            let awsRegionQueryItem = ClientRuntime.URLQueryItem(name: "awsRegion".urlPercentEncoding(), value: Swift.String(awsRegion).urlPercentEncoding())
            input.builder.withQueryItem(awsRegionQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourcesOutputError>
}

public struct GetNetworkResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetNetworkResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourcesOutputError>
}

public struct GetNetworkResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetNetworkResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resources"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkResourcesOutputError>
}

public struct GetNetworkResourcesInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The Amazon Web Services Region.
    public var awsRegion: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the gateway.
    public var registeredGatewayArn: Swift.String?
    /// The ARN of the resource.
    public var resourceArn: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon - The definition model is [Connection](https://docs.aws.amazon.com/directconnect/latest/APIReference/API_Connection.html).
    ///
    /// * dx-gateway - The definition model is [DirectConnectGateway](https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DirectConnectGateway.html).
    ///
    /// * dx-vif - The definition model is [VirtualInterface](https://docs.aws.amazon.com/directconnect/latest/APIReference/API_VirtualInterface.html).
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * connection - The definition model is [Connection](https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Connection.html).
    ///
    /// * device - The definition model is [Device](https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Device.html).
    ///
    /// * link - The definition model is [Link](https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Link.html).
    ///
    /// * site - The definition model is [Site](https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Site.html).
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway - The definition model is [CustomerGateway](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CustomerGateway.html).
    ///
    /// * transit-gateway - The definition model is [TransitGateway](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGateway.html).
    ///
    /// * transit-gateway-attachment - The definition model is [TransitGatewayAttachment](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayAttachment.html).
    ///
    /// * transit-gateway-connect-peer - The definition model is [TransitGatewayConnectPeer](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayConnectPeer.html).
    ///
    /// * transit-gateway-route-table - The definition model is [TransitGatewayRouteTable](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayRouteTable.html).
    ///
    /// * vpn-connection - The definition model is [VpnConnection](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnConnection.html).
    public var resourceType: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registeredGatewayArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.coreNetworkId = coreNetworkId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registeredGatewayArn = registeredGatewayArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

struct GetNetworkResourcesInputBody: Swift.Equatable {
}

extension GetNetworkResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkResourcesOutputResponse(networkResources: \(Swift.String(describing: networkResources)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetNetworkResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNetworkResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkResources = output.networkResources
            self.nextToken = output.nextToken
        } else {
            self.networkResources = nil
            self.nextToken = nil
        }
    }
}

public struct GetNetworkResourcesOutputResponse: Swift.Equatable {
    /// The network resources.
    public var networkResources: [NetworkManagerClientTypes.NetworkResource]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        networkResources: [NetworkManagerClientTypes.NetworkResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkResources = networkResources
        self.nextToken = nextToken
    }
}

struct GetNetworkResourcesOutputResponseBody: Swift.Equatable {
    public let networkResources: [NetworkManagerClientTypes.NetworkResource]?
    public let nextToken: Swift.String?
}

extension GetNetworkResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResources = "NetworkResources"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourcesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.NetworkResource?].self, forKey: .networkResources)
        var networkResourcesDecoded0:[NetworkManagerClientTypes.NetworkResource]? = nil
        if let networkResourcesContainer = networkResourcesContainer {
            networkResourcesDecoded0 = [NetworkManagerClientTypes.NetworkResource]()
            for structure0 in networkResourcesContainer {
                if let structure0 = structure0 {
                    networkResourcesDecoded0?.append(structure0)
                }
            }
        }
        networkResources = networkResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetNetworkRoutesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkRoutesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkRoutesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkRoutesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkRoutesOutputError>
}

extension GetNetworkRoutesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkRoutesInput(destinationFilters: \(Swift.String(describing: destinationFilters)), exactCidrMatches: \(Swift.String(describing: exactCidrMatches)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), longestPrefixMatches: \(Swift.String(describing: longestPrefixMatches)), prefixListIds: \(Swift.String(describing: prefixListIds)), routeTableIdentifier: \(Swift.String(describing: routeTableIdentifier)), states: \(Swift.String(describing: states)), subnetOfMatches: \(Swift.String(describing: subnetOfMatches)), supernetOfMatches: \(Swift.String(describing: supernetOfMatches)), types: \(Swift.String(describing: types)))"}
}

extension GetNetworkRoutesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationFilters = "DestinationFilters"
        case exactCidrMatches = "ExactCidrMatches"
        case longestPrefixMatches = "LongestPrefixMatches"
        case prefixListIds = "PrefixListIds"
        case routeTableIdentifier = "RouteTableIdentifier"
        case states = "States"
        case subnetOfMatches = "SubnetOfMatches"
        case supernetOfMatches = "SupernetOfMatches"
        case types = "Types"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationFilters = destinationFilters {
            var destinationFiltersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .destinationFilters)
            for (dictKey0, filtermap0) in destinationFilters {
                try destinationFiltersContainer.encode(filtermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let exactCidrMatches = exactCidrMatches {
            var exactCidrMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exactCidrMatches)
            for constrainedstringlist0 in exactCidrMatches {
                try exactCidrMatchesContainer.encode(constrainedstringlist0)
            }
        }
        if let longestPrefixMatches = longestPrefixMatches {
            var longestPrefixMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .longestPrefixMatches)
            for constrainedstringlist0 in longestPrefixMatches {
                try longestPrefixMatchesContainer.encode(constrainedstringlist0)
            }
        }
        if let prefixListIds = prefixListIds {
            var prefixListIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .prefixListIds)
            for constrainedstringlist0 in prefixListIds {
                try prefixListIdsContainer.encode(constrainedstringlist0)
            }
        }
        if let routeTableIdentifier = routeTableIdentifier {
            try encodeContainer.encode(routeTableIdentifier, forKey: .routeTableIdentifier)
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for routestatelist0 in states {
                try statesContainer.encode(routestatelist0.rawValue)
            }
        }
        if let subnetOfMatches = subnetOfMatches {
            var subnetOfMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetOfMatches)
            for constrainedstringlist0 in subnetOfMatches {
                try subnetOfMatchesContainer.encode(constrainedstringlist0)
            }
        }
        if let supernetOfMatches = supernetOfMatches {
            var supernetOfMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supernetOfMatches)
            for constrainedstringlist0 in supernetOfMatches {
                try supernetOfMatchesContainer.encode(constrainedstringlist0)
            }
        }
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for routetypelist0 in types {
                try typesContainer.encode(routetypelist0.rawValue)
            }
        }
    }
}

public struct GetNetworkRoutesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkRoutesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkRoutesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkRoutesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkRoutesOutputError>
}

public struct GetNetworkRoutesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkRoutesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkRoutesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkRoutesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkRoutesOutputError>
}

public struct GetNetworkRoutesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkRoutesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetNetworkRoutesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkRoutesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkRoutesOutputError>
}

public struct GetNetworkRoutesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkRoutesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetNetworkRoutesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-routes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkRoutesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkRoutesOutputError>
}

public struct GetNetworkRoutesInput: Swift.Equatable {
    /// Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.
    public var destinationFilters: [Swift.String:[Swift.String]]?
    /// An exact CIDR block.
    public var exactCidrMatches: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The most specific route that matches the traffic (longest prefix match).
    public var longestPrefixMatches: [Swift.String]?
    /// The IDs of the prefix lists.
    public var prefixListIds: [Swift.String]?
    /// The ID of the route table.
    /// This member is required.
    public var routeTableIdentifier: NetworkManagerClientTypes.RouteTableIdentifier?
    /// The route states.
    public var states: [NetworkManagerClientTypes.RouteState]?
    /// The routes with a subnet that match the specified CIDR filter.
    public var subnetOfMatches: [Swift.String]?
    /// The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.
    public var supernetOfMatches: [Swift.String]?
    /// The route types.
    public var types: [NetworkManagerClientTypes.RouteType]?

    public init (
        destinationFilters: [Swift.String:[Swift.String]]? = nil,
        exactCidrMatches: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        longestPrefixMatches: [Swift.String]? = nil,
        prefixListIds: [Swift.String]? = nil,
        routeTableIdentifier: NetworkManagerClientTypes.RouteTableIdentifier? = nil,
        states: [NetworkManagerClientTypes.RouteState]? = nil,
        subnetOfMatches: [Swift.String]? = nil,
        supernetOfMatches: [Swift.String]? = nil,
        types: [NetworkManagerClientTypes.RouteType]? = nil
    )
    {
        self.destinationFilters = destinationFilters
        self.exactCidrMatches = exactCidrMatches
        self.globalNetworkId = globalNetworkId
        self.longestPrefixMatches = longestPrefixMatches
        self.prefixListIds = prefixListIds
        self.routeTableIdentifier = routeTableIdentifier
        self.states = states
        self.subnetOfMatches = subnetOfMatches
        self.supernetOfMatches = supernetOfMatches
        self.types = types
    }
}

struct GetNetworkRoutesInputBody: Swift.Equatable {
    public let routeTableIdentifier: NetworkManagerClientTypes.RouteTableIdentifier?
    public let exactCidrMatches: [Swift.String]?
    public let longestPrefixMatches: [Swift.String]?
    public let subnetOfMatches: [Swift.String]?
    public let supernetOfMatches: [Swift.String]?
    public let prefixListIds: [Swift.String]?
    public let states: [NetworkManagerClientTypes.RouteState]?
    public let types: [NetworkManagerClientTypes.RouteType]?
    public let destinationFilters: [Swift.String:[Swift.String]]?
}

extension GetNetworkRoutesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationFilters = "DestinationFilters"
        case exactCidrMatches = "ExactCidrMatches"
        case longestPrefixMatches = "LongestPrefixMatches"
        case prefixListIds = "PrefixListIds"
        case routeTableIdentifier = "RouteTableIdentifier"
        case states = "States"
        case subnetOfMatches = "SubnetOfMatches"
        case supernetOfMatches = "SupernetOfMatches"
        case types = "Types"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeTableIdentifierDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteTableIdentifier.self, forKey: .routeTableIdentifier)
        routeTableIdentifier = routeTableIdentifierDecoded
        let exactCidrMatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exactCidrMatches)
        var exactCidrMatchesDecoded0:[Swift.String]? = nil
        if let exactCidrMatchesContainer = exactCidrMatchesContainer {
            exactCidrMatchesDecoded0 = [Swift.String]()
            for string0 in exactCidrMatchesContainer {
                if let string0 = string0 {
                    exactCidrMatchesDecoded0?.append(string0)
                }
            }
        }
        exactCidrMatches = exactCidrMatchesDecoded0
        let longestPrefixMatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .longestPrefixMatches)
        var longestPrefixMatchesDecoded0:[Swift.String]? = nil
        if let longestPrefixMatchesContainer = longestPrefixMatchesContainer {
            longestPrefixMatchesDecoded0 = [Swift.String]()
            for string0 in longestPrefixMatchesContainer {
                if let string0 = string0 {
                    longestPrefixMatchesDecoded0?.append(string0)
                }
            }
        }
        longestPrefixMatches = longestPrefixMatchesDecoded0
        let subnetOfMatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetOfMatches)
        var subnetOfMatchesDecoded0:[Swift.String]? = nil
        if let subnetOfMatchesContainer = subnetOfMatchesContainer {
            subnetOfMatchesDecoded0 = [Swift.String]()
            for string0 in subnetOfMatchesContainer {
                if let string0 = string0 {
                    subnetOfMatchesDecoded0?.append(string0)
                }
            }
        }
        subnetOfMatches = subnetOfMatchesDecoded0
        let supernetOfMatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supernetOfMatches)
        var supernetOfMatchesDecoded0:[Swift.String]? = nil
        if let supernetOfMatchesContainer = supernetOfMatchesContainer {
            supernetOfMatchesDecoded0 = [Swift.String]()
            for string0 in supernetOfMatchesContainer {
                if let string0 = string0 {
                    supernetOfMatchesDecoded0?.append(string0)
                }
            }
        }
        supernetOfMatches = supernetOfMatchesDecoded0
        let prefixListIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .prefixListIds)
        var prefixListIdsDecoded0:[Swift.String]? = nil
        if let prefixListIdsContainer = prefixListIdsContainer {
            prefixListIdsDecoded0 = [Swift.String]()
            for string0 in prefixListIdsContainer {
                if let string0 = string0 {
                    prefixListIdsDecoded0?.append(string0)
                }
            }
        }
        prefixListIds = prefixListIdsDecoded0
        let statesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.RouteState?].self, forKey: .states)
        var statesDecoded0:[NetworkManagerClientTypes.RouteState]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [NetworkManagerClientTypes.RouteState]()
            for string0 in statesContainer {
                if let string0 = string0 {
                    statesDecoded0?.append(string0)
                }
            }
        }
        states = statesDecoded0
        let typesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.RouteType?].self, forKey: .types)
        var typesDecoded0:[NetworkManagerClientTypes.RouteType]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [NetworkManagerClientTypes.RouteType]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
        let destinationFiltersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .destinationFilters)
        var destinationFiltersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let destinationFiltersContainer = destinationFiltersContainer {
            destinationFiltersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, filtervalues0) in destinationFiltersContainer {
                var filtervalues0Decoded0: [Swift.String]? = nil
                if let filtervalues0 = filtervalues0 {
                    filtervalues0Decoded0 = [Swift.String]()
                    for string1 in filtervalues0 {
                        if let string1 = string1 {
                            filtervalues0Decoded0?.append(string1)
                        }
                    }
                }
                destinationFiltersDecoded0?[key0] = filtervalues0Decoded0
            }
        }
        destinationFilters = destinationFiltersDecoded0
    }
}

extension GetNetworkRoutesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkRoutesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkRoutesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkRoutesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkRoutesOutputResponse(coreNetworkSegmentEdge: \(Swift.String(describing: coreNetworkSegmentEdge)), networkRoutes: \(Swift.String(describing: networkRoutes)), routeTableArn: \(Swift.String(describing: routeTableArn)), routeTableTimestamp: \(Swift.String(describing: routeTableTimestamp)), routeTableType: \(Swift.String(describing: routeTableType)))"}
}

extension GetNetworkRoutesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNetworkRoutesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkSegmentEdge = output.coreNetworkSegmentEdge
            self.networkRoutes = output.networkRoutes
            self.routeTableArn = output.routeTableArn
            self.routeTableTimestamp = output.routeTableTimestamp
            self.routeTableType = output.routeTableType
        } else {
            self.coreNetworkSegmentEdge = nil
            self.networkRoutes = nil
            self.routeTableArn = nil
            self.routeTableTimestamp = nil
            self.routeTableType = nil
        }
    }
}

public struct GetNetworkRoutesOutputResponse: Swift.Equatable {
    /// Describes a core network segment edge.
    public var coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier?
    /// The network routes.
    public var networkRoutes: [NetworkManagerClientTypes.NetworkRoute]?
    /// The ARN of the route table.
    public var routeTableArn: Swift.String?
    /// The route table creation time.
    public var routeTableTimestamp: ClientRuntime.Date?
    /// The route table type.
    public var routeTableType: NetworkManagerClientTypes.RouteTableType?

    public init (
        coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier? = nil,
        networkRoutes: [NetworkManagerClientTypes.NetworkRoute]? = nil,
        routeTableArn: Swift.String? = nil,
        routeTableTimestamp: ClientRuntime.Date? = nil,
        routeTableType: NetworkManagerClientTypes.RouteTableType? = nil
    )
    {
        self.coreNetworkSegmentEdge = coreNetworkSegmentEdge
        self.networkRoutes = networkRoutes
        self.routeTableArn = routeTableArn
        self.routeTableTimestamp = routeTableTimestamp
        self.routeTableType = routeTableType
    }
}

struct GetNetworkRoutesOutputResponseBody: Swift.Equatable {
    public let routeTableArn: Swift.String?
    public let coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier?
    public let routeTableType: NetworkManagerClientTypes.RouteTableType?
    public let routeTableTimestamp: ClientRuntime.Date?
    public let networkRoutes: [NetworkManagerClientTypes.NetworkRoute]?
}

extension GetNetworkRoutesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkSegmentEdge = "CoreNetworkSegmentEdge"
        case networkRoutes = "NetworkRoutes"
        case routeTableArn = "RouteTableArn"
        case routeTableTimestamp = "RouteTableTimestamp"
        case routeTableType = "RouteTableType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableArn)
        routeTableArn = routeTableArnDecoded
        let coreNetworkSegmentEdgeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier.self, forKey: .coreNetworkSegmentEdge)
        coreNetworkSegmentEdge = coreNetworkSegmentEdgeDecoded
        let routeTableTypeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteTableType.self, forKey: .routeTableType)
        routeTableType = routeTableTypeDecoded
        let routeTableTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .routeTableTimestamp)
        routeTableTimestamp = routeTableTimestampDecoded
        let networkRoutesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.NetworkRoute?].self, forKey: .networkRoutes)
        var networkRoutesDecoded0:[NetworkManagerClientTypes.NetworkRoute]? = nil
        if let networkRoutesContainer = networkRoutesContainer {
            networkRoutesDecoded0 = [NetworkManagerClientTypes.NetworkRoute]()
            for structure0 in networkRoutesContainer {
                if let structure0 = structure0 {
                    networkRoutesDecoded0?.append(structure0)
                }
            }
        }
        networkRoutes = networkRoutesDecoded0
    }
}

extension GetNetworkTelemetryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkTelemetryInput(accountId: \(Swift.String(describing: accountId)), awsRegion: \(Swift.String(describing: awsRegion)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registeredGatewayArn: \(Swift.String(describing: registeredGatewayArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension GetNetworkTelemetryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetNetworkTelemetryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkTelemetryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkTelemetryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkTelemetryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkTelemetryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkTelemetryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkTelemetryOutputError>
}

public struct GetNetworkTelemetryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkTelemetryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkTelemetryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkTelemetryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let coreNetworkId = input.operationInput.coreNetworkId {
            let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            input.builder.withQueryItem(coreNetworkIdQueryItem)
        }
        if let accountId = input.operationInput.accountId {
            let accountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            input.builder.withQueryItem(accountIdQueryItem)
        }
        if let registeredGatewayArn = input.operationInput.registeredGatewayArn {
            let registeredGatewayArnQueryItem = ClientRuntime.URLQueryItem(name: "registeredGatewayArn".urlPercentEncoding(), value: Swift.String(registeredGatewayArn).urlPercentEncoding())
            input.builder.withQueryItem(registeredGatewayArnQueryItem)
        }
        if let awsRegion = input.operationInput.awsRegion {
            let awsRegionQueryItem = ClientRuntime.URLQueryItem(name: "awsRegion".urlPercentEncoding(), value: Swift.String(awsRegion).urlPercentEncoding())
            input.builder.withQueryItem(awsRegionQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkTelemetryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkTelemetryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkTelemetryOutputError>
}

public struct GetNetworkTelemetryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkTelemetryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetNetworkTelemetryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkTelemetryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkTelemetryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkTelemetryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkTelemetryOutputError>
}

public struct GetNetworkTelemetryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkTelemetryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetNetworkTelemetryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkTelemetryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-telemetry"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkTelemetryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkTelemetryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkTelemetryOutputError>
}

public struct GetNetworkTelemetryInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The Amazon Web Services Region.
    public var awsRegion: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the gateway.
    public var registeredGatewayArn: Swift.String?
    /// The ARN of the resource.
    public var resourceArn: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon
    ///
    /// * dx-gateway
    ///
    /// * dx-vif
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * connection
    ///
    /// * device
    ///
    /// * link
    ///
    /// * site
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway
    ///
    /// * transit-gateway
    ///
    /// * transit-gateway-attachment
    ///
    /// * transit-gateway-connect-peer
    ///
    /// * transit-gateway-route-table
    ///
    /// * vpn-connection
    public var resourceType: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registeredGatewayArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.coreNetworkId = coreNetworkId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registeredGatewayArn = registeredGatewayArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

struct GetNetworkTelemetryInputBody: Swift.Equatable {
}

extension GetNetworkTelemetryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkTelemetryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkTelemetryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkTelemetryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkTelemetryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkTelemetryOutputResponse(networkTelemetry: \(Swift.String(describing: networkTelemetry)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetNetworkTelemetryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNetworkTelemetryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkTelemetry = output.networkTelemetry
            self.nextToken = output.nextToken
        } else {
            self.networkTelemetry = nil
            self.nextToken = nil
        }
    }
}

public struct GetNetworkTelemetryOutputResponse: Swift.Equatable {
    /// The network telemetry.
    public var networkTelemetry: [NetworkManagerClientTypes.NetworkTelemetry]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        networkTelemetry: [NetworkManagerClientTypes.NetworkTelemetry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkTelemetry = networkTelemetry
        self.nextToken = nextToken
    }
}

struct GetNetworkTelemetryOutputResponseBody: Swift.Equatable {
    public let networkTelemetry: [NetworkManagerClientTypes.NetworkTelemetry]?
    public let nextToken: Swift.String?
}

extension GetNetworkTelemetryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkTelemetry = "NetworkTelemetry"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkTelemetryContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.NetworkTelemetry?].self, forKey: .networkTelemetry)
        var networkTelemetryDecoded0:[NetworkManagerClientTypes.NetworkTelemetry]? = nil
        if let networkTelemetryContainer = networkTelemetryContainer {
            networkTelemetryDecoded0 = [NetworkManagerClientTypes.NetworkTelemetry]()
            for structure0 in networkTelemetryContainer {
                if let structure0 = structure0 {
                    networkTelemetryDecoded0?.append(structure0)
                }
            }
        }
        networkTelemetry = networkTelemetryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePolicyInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension GetResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetResourcePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourcePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetResourcePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/resource-policy/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourcePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
}

extension GetResourcePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePolicyOutputResponse(policyDocument: \(Swift.String(describing: policyDocument)))"}
}

extension GetResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyDocument = output.policyDocument
        } else {
            self.policyDocument = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Swift.Equatable {
    /// The resource policy document.
    public var policyDocument: Swift.String?

    public init (
        policyDocument: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
    }
}

struct GetResourcePolicyOutputResponseBody: Swift.Equatable {
    public let policyDocument: Swift.String?
}

extension GetResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension GetRouteAnalysisInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRouteAnalysisInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), routeAnalysisId: \(Swift.String(describing: routeAnalysisId)))"}
}

extension GetRouteAnalysisInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRouteAnalysisInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRouteAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRouteAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRouteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRouteAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRouteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRouteAnalysisOutputError>
}

public struct GetRouteAnalysisInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRouteAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRouteAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRouteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRouteAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRouteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRouteAnalysisOutputError>
}

public struct GetRouteAnalysisInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRouteAnalysisInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRouteAnalysisInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRouteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRouteAnalysisInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRouteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRouteAnalysisOutputError>
}

public struct GetRouteAnalysisInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRouteAnalysisInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRouteAnalysisInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRouteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let routeAnalysisId = input.routeAnalysisId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("routeAnalysisId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/route-analyses/\(routeAnalysisId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRouteAnalysisInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRouteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRouteAnalysisOutputError>
}

public struct GetRouteAnalysisInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the route analysis.
    /// This member is required.
    public var routeAnalysisId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        routeAnalysisId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.routeAnalysisId = routeAnalysisId
    }
}

struct GetRouteAnalysisInputBody: Swift.Equatable {
}

extension GetRouteAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRouteAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRouteAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRouteAnalysisOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRouteAnalysisOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRouteAnalysisOutputResponse(routeAnalysis: \(Swift.String(describing: routeAnalysis)))"}
}

extension GetRouteAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRouteAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.routeAnalysis = output.routeAnalysis
        } else {
            self.routeAnalysis = nil
        }
    }
}

public struct GetRouteAnalysisOutputResponse: Swift.Equatable {
    /// The route analysis.
    public var routeAnalysis: NetworkManagerClientTypes.RouteAnalysis?

    public init (
        routeAnalysis: NetworkManagerClientTypes.RouteAnalysis? = nil
    )
    {
        self.routeAnalysis = routeAnalysis
    }
}

struct GetRouteAnalysisOutputResponseBody: Swift.Equatable {
    public let routeAnalysis: NetworkManagerClientTypes.RouteAnalysis?
}

extension GetRouteAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeAnalysis = "RouteAnalysis"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeAnalysisDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysis.self, forKey: .routeAnalysis)
        routeAnalysis = routeAnalysisDecoded
    }
}

extension GetSiteToSiteVpnAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSiteToSiteVpnAttachmentInput(attachmentId: \(Swift.String(describing: attachmentId)))"}
}

extension GetSiteToSiteVpnAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSiteToSiteVpnAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteToSiteVpnAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSiteToSiteVpnAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteToSiteVpnAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSiteToSiteVpnAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteToSiteVpnAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteToSiteVpnAttachmentOutputError>
}

public struct GetSiteToSiteVpnAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteToSiteVpnAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSiteToSiteVpnAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteToSiteVpnAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSiteToSiteVpnAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteToSiteVpnAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteToSiteVpnAttachmentOutputError>
}

public struct GetSiteToSiteVpnAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteToSiteVpnAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSiteToSiteVpnAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteToSiteVpnAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSiteToSiteVpnAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteToSiteVpnAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteToSiteVpnAttachmentOutputError>
}

public struct GetSiteToSiteVpnAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteToSiteVpnAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSiteToSiteVpnAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteToSiteVpnAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let attachmentId = input.attachmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attachmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/site-to-site-vpn-attachments/\(attachmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSiteToSiteVpnAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteToSiteVpnAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteToSiteVpnAttachmentOutputError>
}

public struct GetSiteToSiteVpnAttachmentInput: Swift.Equatable {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct GetSiteToSiteVpnAttachmentInputBody: Swift.Equatable {
}

extension GetSiteToSiteVpnAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSiteToSiteVpnAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSiteToSiteVpnAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSiteToSiteVpnAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSiteToSiteVpnAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSiteToSiteVpnAttachmentOutputResponse(siteToSiteVpnAttachment: \(Swift.String(describing: siteToSiteVpnAttachment)))"}
}

extension GetSiteToSiteVpnAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSiteToSiteVpnAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.siteToSiteVpnAttachment = output.siteToSiteVpnAttachment
        } else {
            self.siteToSiteVpnAttachment = nil
        }
    }
}

public struct GetSiteToSiteVpnAttachmentOutputResponse: Swift.Equatable {
    /// Describes the site-to-site attachment.
    public var siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment?

    public init (
        siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment? = nil
    )
    {
        self.siteToSiteVpnAttachment = siteToSiteVpnAttachment
    }
}

struct GetSiteToSiteVpnAttachmentOutputResponseBody: Swift.Equatable {
    public let siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment?
}

extension GetSiteToSiteVpnAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case siteToSiteVpnAttachment = "SiteToSiteVpnAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteToSiteVpnAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.SiteToSiteVpnAttachment.self, forKey: .siteToSiteVpnAttachment)
        siteToSiteVpnAttachment = siteToSiteVpnAttachmentDecoded
    }
}

extension GetSitesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSitesInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), siteIds: \(Swift.String(describing: siteIds)))"}
}

extension GetSitesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSitesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSitesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSitesOutputError>
}

public struct GetSitesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSitesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let siteIds = input.operationInput.siteIds {
            siteIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "siteIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSitesOutputError>
}

public struct GetSitesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSitesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSitesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSitesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSitesOutputError>
}

public struct GetSitesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSitesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSitesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSitesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSitesOutputError>
}

public struct GetSitesInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// One or more site IDs. The maximum is 10.
    public var siteIds: [Swift.String]?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        siteIds: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.siteIds = siteIds
    }
}

struct GetSitesInputBody: Swift.Equatable {
}

extension GetSitesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSitesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSitesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSitesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sites: \(Swift.String(describing: sites)))"}
}

extension GetSitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sites = output.sites
        } else {
            self.nextToken = nil
            self.sites = nil
        }
    }
}

public struct GetSitesOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The sites.
    public var sites: [NetworkManagerClientTypes.Site]?

    public init (
        nextToken: Swift.String? = nil,
        sites: [NetworkManagerClientTypes.Site]? = nil
    )
    {
        self.nextToken = nextToken
        self.sites = sites
    }
}

struct GetSitesOutputResponseBody: Swift.Equatable {
    public let sites: [NetworkManagerClientTypes.Site]?
    public let nextToken: Swift.String?
}

extension GetSitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sites = "Sites"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sitesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Site?].self, forKey: .sites)
        var sitesDecoded0:[NetworkManagerClientTypes.Site]? = nil
        if let sitesContainer = sitesContainer {
            sitesDecoded0 = [NetworkManagerClientTypes.Site]()
            for structure0 in sitesContainer {
                if let structure0 = structure0 {
                    sitesDecoded0?.append(structure0)
                }
            }
        }
        sites = sitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTransitGatewayConnectPeerAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTransitGatewayConnectPeerAssociationsInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), transitGatewayConnectPeerArns: \(Swift.String(describing: transitGatewayConnectPeerArns)))"}
}

extension GetTransitGatewayConnectPeerAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetTransitGatewayConnectPeerAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayConnectPeerAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayConnectPeerAssociationsOutputError>
}

public struct GetTransitGatewayConnectPeerAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayConnectPeerAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let transitGatewayConnectPeerArns = input.operationInput.transitGatewayConnectPeerArns {
            transitGatewayConnectPeerArns.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "transitGatewayConnectPeerArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayConnectPeerAssociationsOutputError>
}

public struct GetTransitGatewayConnectPeerAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayConnectPeerAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTransitGatewayConnectPeerAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTransitGatewayConnectPeerAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayConnectPeerAssociationsOutputError>
}

public struct GetTransitGatewayConnectPeerAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayConnectPeerAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTransitGatewayConnectPeerAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTransitGatewayConnectPeerAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayConnectPeerAssociationsOutputError>
}

public struct GetTransitGatewayConnectPeerAssociationsInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// One or more transit gateway Connect peer Amazon Resource Names (ARNs).
    public var transitGatewayConnectPeerArns: [Swift.String]?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        transitGatewayConnectPeerArns: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayConnectPeerArns = transitGatewayConnectPeerArns
    }
}

struct GetTransitGatewayConnectPeerAssociationsInputBody: Swift.Equatable {
}

extension GetTransitGatewayConnectPeerAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTransitGatewayConnectPeerAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTransitGatewayConnectPeerAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTransitGatewayConnectPeerAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTransitGatewayConnectPeerAssociationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), transitGatewayConnectPeerAssociations: \(Swift.String(describing: transitGatewayConnectPeerAssociations)))"}
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTransitGatewayConnectPeerAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.transitGatewayConnectPeerAssociations = output.transitGatewayConnectPeerAssociations
        } else {
            self.nextToken = nil
            self.transitGatewayConnectPeerAssociations = nil
        }
    }
}

public struct GetTransitGatewayConnectPeerAssociationsOutputResponse: Swift.Equatable {
    /// The token to use for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the transit gateway Connect peer associations.
    public var transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]?

    public init (
        nextToken: Swift.String? = nil,
        transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociations
    }
}

struct GetTransitGatewayConnectPeerAssociationsOutputResponseBody: Swift.Equatable {
    public let transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]?
    public let nextToken: Swift.String?
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case transitGatewayConnectPeerAssociations = "TransitGatewayConnectPeerAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?].self, forKey: .transitGatewayConnectPeerAssociations)
        var transitGatewayConnectPeerAssociationsDecoded0:[NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]? = nil
        if let transitGatewayConnectPeerAssociationsContainer = transitGatewayConnectPeerAssociationsContainer {
            transitGatewayConnectPeerAssociationsDecoded0 = [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]()
            for structure0 in transitGatewayConnectPeerAssociationsContainer {
                if let structure0 = structure0 {
                    transitGatewayConnectPeerAssociationsDecoded0?.append(structure0)
                }
            }
        }
        transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTransitGatewayRegistrationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTransitGatewayRegistrationsInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), transitGatewayArns: \(Swift.String(describing: transitGatewayArns)))"}
}

extension GetTransitGatewayRegistrationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetTransitGatewayRegistrationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayRegistrationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTransitGatewayRegistrationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTransitGatewayRegistrationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayRegistrationsOutputError>
}

public struct GetTransitGatewayRegistrationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayRegistrationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTransitGatewayRegistrationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let transitGatewayArns = input.operationInput.transitGatewayArns {
            transitGatewayArns.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "transitGatewayArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTransitGatewayRegistrationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayRegistrationsOutputError>
}

public struct GetTransitGatewayRegistrationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayRegistrationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTransitGatewayRegistrationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTransitGatewayRegistrationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayRegistrationsOutputError>
}

public struct GetTransitGatewayRegistrationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayRegistrationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTransitGatewayRegistrationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTransitGatewayRegistrationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayRegistrationsOutputError>
}

public struct GetTransitGatewayRegistrationsInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.
    public var transitGatewayArns: [Swift.String]?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        transitGatewayArns: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayArns = transitGatewayArns
    }
}

struct GetTransitGatewayRegistrationsInputBody: Swift.Equatable {
}

extension GetTransitGatewayRegistrationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTransitGatewayRegistrationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTransitGatewayRegistrationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTransitGatewayRegistrationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTransitGatewayRegistrationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTransitGatewayRegistrationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), transitGatewayRegistrations: \(Swift.String(describing: transitGatewayRegistrations)))"}
}

extension GetTransitGatewayRegistrationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTransitGatewayRegistrationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.transitGatewayRegistrations = output.transitGatewayRegistrations
        } else {
            self.nextToken = nil
            self.transitGatewayRegistrations = nil
        }
    }
}

public struct GetTransitGatewayRegistrationsOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The transit gateway registrations.
    public var transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]?

    public init (
        nextToken: Swift.String? = nil,
        transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]? = nil
    )
    {
        self.nextToken = nextToken
        self.transitGatewayRegistrations = transitGatewayRegistrations
    }
}

struct GetTransitGatewayRegistrationsOutputResponseBody: Swift.Equatable {
    public let transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]?
    public let nextToken: Swift.String?
}

extension GetTransitGatewayRegistrationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case transitGatewayRegistrations = "TransitGatewayRegistrations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.TransitGatewayRegistration?].self, forKey: .transitGatewayRegistrations)
        var transitGatewayRegistrationsDecoded0:[NetworkManagerClientTypes.TransitGatewayRegistration]? = nil
        if let transitGatewayRegistrationsContainer = transitGatewayRegistrationsContainer {
            transitGatewayRegistrationsDecoded0 = [NetworkManagerClientTypes.TransitGatewayRegistration]()
            for structure0 in transitGatewayRegistrationsContainer {
                if let structure0 = structure0 {
                    transitGatewayRegistrationsDecoded0?.append(structure0)
                }
            }
        }
        transitGatewayRegistrations = transitGatewayRegistrationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetVpcAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVpcAttachmentInput(attachmentId: \(Swift.String(describing: attachmentId)))"}
}

extension GetVpcAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVpcAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVpcAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVpcAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVpcAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVpcAttachmentOutputError>
}

public struct GetVpcAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVpcAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVpcAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVpcAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVpcAttachmentOutputError>
}

public struct GetVpcAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVpcAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVpcAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVpcAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVpcAttachmentOutputError>
}

public struct GetVpcAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVpcAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVpcAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let attachmentId = input.attachmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attachmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/vpc-attachments/\(attachmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVpcAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVpcAttachmentOutputError>
}

public struct GetVpcAttachmentInput: Swift.Equatable {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct GetVpcAttachmentInputBody: Swift.Equatable {
}

extension GetVpcAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVpcAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVpcAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVpcAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVpcAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVpcAttachmentOutputResponse(vpcAttachment: \(Swift.String(describing: vpcAttachment)))"}
}

extension GetVpcAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVpcAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcAttachment = output.vpcAttachment
        } else {
            self.vpcAttachment = nil
        }
    }
}

public struct GetVpcAttachmentOutputResponse: Swift.Equatable {
    /// Returns details about a VPC attachment.
    public var vpcAttachment: NetworkManagerClientTypes.VpcAttachment?

    public init (
        vpcAttachment: NetworkManagerClientTypes.VpcAttachment? = nil
    )
    {
        self.vpcAttachment = vpcAttachment
    }
}

struct GetVpcAttachmentOutputResponseBody: Swift.Equatable {
    public let vpcAttachment: NetworkManagerClientTypes.VpcAttachment?
}

extension GetVpcAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcAttachment = "VpcAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcAttachment.self, forKey: .vpcAttachment)
        vpcAttachment = vpcAttachmentDecoded
    }
}

extension NetworkManagerClientTypes.GlobalNetwork: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkArn = "GlobalNetworkArn"
        case globalNetworkId = "GlobalNetworkId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkArn = globalNetworkArn {
            try encodeContainer.encode(globalNetworkArn, forKey: .globalNetworkArn)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let globalNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkArn)
        globalNetworkArn = globalNetworkArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetworkState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.GlobalNetwork: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlobalNetwork(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), globalNetworkArn: \(Swift.String(describing: globalNetworkArn)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a global network. This is a single private network acting as a high-level container for your network objects, including an Amazon Web Services-manged Core Network.
    public struct GlobalNetwork: Swift.Equatable {
        /// The date and time that the global network was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the global network.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the global network.
        public var globalNetworkArn: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the global network.
        public var state: NetworkManagerClientTypes.GlobalNetworkState?
        /// The tags for the global network.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkArn: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.GlobalNetworkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkArn = globalNetworkArn
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    public enum GlobalNetworkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GlobalNetworkState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GlobalNetworkState(rawValue: rawValue) ?? GlobalNetworkState.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed due to an internal error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// Indicates when to retry the request.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.Link: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case linkArn = "LinkArn"
        case linkId = "LinkId"
        case provider = "Provider"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkArn = linkArn {
            try encodeContainer.encode(linkArn, forKey: .linkArn)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let linkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkArn)
        linkArn = linkArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.Link: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Link(bandwidth: \(Swift.String(describing: bandwidth)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkArn: \(Swift.String(describing: linkArn)), linkId: \(Swift.String(describing: linkId)), provider: \(Swift.String(describing: provider)), siteId: \(Swift.String(describing: siteId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a link.
    public struct Link: Swift.Equatable {
        /// The bandwidth for the link.
        public var bandwidth: NetworkManagerClientTypes.Bandwidth?
        /// The date and time that the link was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the link.
        public var description: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The Amazon Resource Name (ARN) of the link.
        public var linkArn: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The provider of the link.
        public var provider: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The state of the link.
        public var state: NetworkManagerClientTypes.LinkState?
        /// The tags for the link.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The type of the link.
        public var type: Swift.String?

        public init (
            bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkArn: Swift.String? = nil,
            linkId: Swift.String? = nil,
            provider: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.LinkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            type: Swift.String? = nil
        )
        {
            self.bandwidth = bandwidth
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.linkArn = linkArn
            self.linkId = linkId
            self.provider = provider
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes.LinkAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkAssociationState = "LinkAssociationState"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkAssociationState = linkAssociationState {
            try encodeContainer.encode(linkAssociationState.rawValue, forKey: .linkAssociationState)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let linkAssociationStateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkAssociationState.self, forKey: .linkAssociationState)
        linkAssociationState = linkAssociationStateDecoded
    }
}

extension NetworkManagerClientTypes.LinkAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LinkAssociation(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkAssociationState: \(Swift.String(describing: linkAssociationState)), linkId: \(Swift.String(describing: linkId)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the association between a device and a link.
    public struct LinkAssociation: Swift.Equatable {
        /// The device ID for the link association.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the association.
        public var linkAssociationState: NetworkManagerClientTypes.LinkAssociationState?
        /// The ID of the link.
        public var linkId: Swift.String?

        public init (
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkAssociationState: NetworkManagerClientTypes.LinkAssociationState? = nil,
            linkId: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkAssociationState = linkAssociationState
            self.linkId = linkId
        }
    }

}

extension NetworkManagerClientTypes {
    public enum LinkAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [LinkAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LinkAssociationState(rawValue: rawValue) ?? LinkAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum LinkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LinkState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LinkState(rawValue: rawValue) ?? LinkState.sdkUnknown(rawValue)
        }
    }
}

extension ListAttachmentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAttachmentsInput(attachmentType: \(Swift.String(describing: attachmentType)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), edgeLocation: \(Swift.String(describing: edgeLocation)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), state: \(Swift.String(describing: state)))"}
}

extension ListAttachmentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAttachmentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttachmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttachmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttachmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttachmentsOutputError>
}

public struct ListAttachmentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttachmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttachmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let coreNetworkId = input.operationInput.coreNetworkId {
            let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            input.builder.withQueryItem(coreNetworkIdQueryItem)
        }
        if let attachmentType = input.operationInput.attachmentType {
            let attachmentTypeQueryItem = ClientRuntime.URLQueryItem(name: "attachmentType".urlPercentEncoding(), value: Swift.String(attachmentType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(attachmentTypeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let state = input.operationInput.state {
            let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stateQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let edgeLocation = input.operationInput.edgeLocation {
            let edgeLocationQueryItem = ClientRuntime.URLQueryItem(name: "edgeLocation".urlPercentEncoding(), value: Swift.String(edgeLocation).urlPercentEncoding())
            input.builder.withQueryItem(edgeLocationQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttachmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttachmentsOutputError>
}

public struct ListAttachmentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttachmentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAttachmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAttachmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttachmentsOutputError>
}

public struct ListAttachmentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttachmentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAttachmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/attachments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAttachmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttachmentsOutputError>
}

public struct ListAttachmentsInput: Swift.Equatable {
    /// The type of attachment.
    public var attachmentType: NetworkManagerClientTypes.AttachmentType?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The Region where the edge is located.
    public var edgeLocation: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The state of the attachment.
    public var state: NetworkManagerClientTypes.AttachmentState?

    public init (
        attachmentType: NetworkManagerClientTypes.AttachmentType? = nil,
        coreNetworkId: Swift.String? = nil,
        edgeLocation: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: NetworkManagerClientTypes.AttachmentState? = nil
    )
    {
        self.attachmentType = attachmentType
        self.coreNetworkId = coreNetworkId
        self.edgeLocation = edgeLocation
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListAttachmentsInputBody: Swift.Equatable {
}

extension ListAttachmentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAttachmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttachmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttachmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachmentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAttachmentsOutputResponse(attachments: \(Swift.String(describing: attachments)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAttachmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAttachmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachments = output.attachments
            self.nextToken = output.nextToken
        } else {
            self.attachments = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttachmentsOutputResponse: Swift.Equatable {
    /// Describes the list of attachments.
    public var attachments: [NetworkManagerClientTypes.Attachment]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        attachments: [NetworkManagerClientTypes.Attachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.nextToken = nextToken
    }
}

struct ListAttachmentsOutputResponseBody: Swift.Equatable {
    public let attachments: [NetworkManagerClientTypes.Attachment]?
    public let nextToken: Swift.String?
}

extension ListAttachmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Attachment?].self, forKey: .attachments)
        var attachmentsDecoded0:[NetworkManagerClientTypes.Attachment]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [NetworkManagerClientTypes.Attachment]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectPeersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConnectPeersInput(connectAttachmentId: \(Swift.String(describing: connectAttachmentId)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConnectPeersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListConnectPeersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectPeersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectPeersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectPeersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectPeersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectPeersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectPeersOutputError>
}

public struct ListConnectPeersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectPeersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectPeersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectPeersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectAttachmentId = input.operationInput.connectAttachmentId {
            let connectAttachmentIdQueryItem = ClientRuntime.URLQueryItem(name: "connectAttachmentId".urlPercentEncoding(), value: Swift.String(connectAttachmentId).urlPercentEncoding())
            input.builder.withQueryItem(connectAttachmentIdQueryItem)
        }
        if let coreNetworkId = input.operationInput.coreNetworkId {
            let coreNetworkIdQueryItem = ClientRuntime.URLQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            input.builder.withQueryItem(coreNetworkIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectPeersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectPeersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectPeersOutputError>
}

public struct ListConnectPeersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectPeersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListConnectPeersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectPeersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConnectPeersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectPeersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectPeersOutputError>
}

public struct ListConnectPeersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectPeersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListConnectPeersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectPeersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/connect-peers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConnectPeersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectPeersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectPeersOutputError>
}

public struct ListConnectPeersInput: Swift.Equatable {
    /// The ID of the attachment.
    public var connectAttachmentId: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectAttachmentId: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectAttachmentId = connectAttachmentId
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectPeersInputBody: Swift.Equatable {
}

extension ListConnectPeersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConnectPeersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectPeersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectPeersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectPeersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConnectPeersOutputResponse(connectPeers: \(Swift.String(describing: connectPeers)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConnectPeersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConnectPeersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectPeers = output.connectPeers
            self.nextToken = output.nextToken
        } else {
            self.connectPeers = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectPeersOutputResponse: Swift.Equatable {
    /// Describes the Connect peers.
    public var connectPeers: [NetworkManagerClientTypes.ConnectPeerSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectPeers: [NetworkManagerClientTypes.ConnectPeerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectPeers = connectPeers
        self.nextToken = nextToken
    }
}

struct ListConnectPeersOutputResponseBody: Swift.Equatable {
    public let connectPeers: [NetworkManagerClientTypes.ConnectPeerSummary]?
    public let nextToken: Swift.String?
}

extension ListConnectPeersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectPeers = "ConnectPeers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectPeersContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.ConnectPeerSummary?].self, forKey: .connectPeers)
        var connectPeersDecoded0:[NetworkManagerClientTypes.ConnectPeerSummary]? = nil
        if let connectPeersContainer = connectPeersContainer {
            connectPeersDecoded0 = [NetworkManagerClientTypes.ConnectPeerSummary]()
            for structure0 in connectPeersContainer {
                if let structure0 = structure0 {
                    connectPeersDecoded0?.append(structure0)
                }
            }
        }
        connectPeers = connectPeersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoreNetworkPolicyVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCoreNetworkPolicyVersionsInput(coreNetworkId: \(Swift.String(describing: coreNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCoreNetworkPolicyVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCoreNetworkPolicyVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreNetworkPolicyVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCoreNetworkPolicyVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreNetworkPolicyVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCoreNetworkPolicyVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreNetworkPolicyVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreNetworkPolicyVersionsOutputError>
}

public struct ListCoreNetworkPolicyVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreNetworkPolicyVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCoreNetworkPolicyVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreNetworkPolicyVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCoreNetworkPolicyVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreNetworkPolicyVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreNetworkPolicyVersionsOutputError>
}

public struct ListCoreNetworkPolicyVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreNetworkPolicyVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCoreNetworkPolicyVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreNetworkPolicyVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCoreNetworkPolicyVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreNetworkPolicyVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreNetworkPolicyVersionsOutputError>
}

public struct ListCoreNetworkPolicyVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreNetworkPolicyVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCoreNetworkPolicyVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreNetworkPolicyVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreNetworkId = input.coreNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy-versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCoreNetworkPolicyVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreNetworkPolicyVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreNetworkPolicyVersionsOutputError>
}

public struct ListCoreNetworkPolicyVersionsInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoreNetworkPolicyVersionsInputBody: Swift.Equatable {
}

extension ListCoreNetworkPolicyVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCoreNetworkPolicyVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoreNetworkPolicyVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCoreNetworkPolicyVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoreNetworkPolicyVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCoreNetworkPolicyVersionsOutputResponse(coreNetworkPolicyVersions: \(Swift.String(describing: coreNetworkPolicyVersions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCoreNetworkPolicyVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCoreNetworkPolicyVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkPolicyVersions = output.coreNetworkPolicyVersions
            self.nextToken = output.nextToken
        } else {
            self.coreNetworkPolicyVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoreNetworkPolicyVersionsOutputResponse: Swift.Equatable {
    /// Describes core network policy versions.
    public var coreNetworkPolicyVersions: [NetworkManagerClientTypes.CoreNetworkPolicyVersion]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        coreNetworkPolicyVersions: [NetworkManagerClientTypes.CoreNetworkPolicyVersion]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkPolicyVersions = coreNetworkPolicyVersions
        self.nextToken = nextToken
    }
}

struct ListCoreNetworkPolicyVersionsOutputResponseBody: Swift.Equatable {
    public let coreNetworkPolicyVersions: [NetworkManagerClientTypes.CoreNetworkPolicyVersion]?
    public let nextToken: Swift.String?
}

extension ListCoreNetworkPolicyVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkPolicyVersions = "CoreNetworkPolicyVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkPolicyVersionsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkPolicyVersion?].self, forKey: .coreNetworkPolicyVersions)
        var coreNetworkPolicyVersionsDecoded0:[NetworkManagerClientTypes.CoreNetworkPolicyVersion]? = nil
        if let coreNetworkPolicyVersionsContainer = coreNetworkPolicyVersionsContainer {
            coreNetworkPolicyVersionsDecoded0 = [NetworkManagerClientTypes.CoreNetworkPolicyVersion]()
            for structure0 in coreNetworkPolicyVersionsContainer {
                if let structure0 = structure0 {
                    coreNetworkPolicyVersionsDecoded0?.append(structure0)
                }
            }
        }
        coreNetworkPolicyVersions = coreNetworkPolicyVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoreNetworksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCoreNetworksInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCoreNetworksInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCoreNetworksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreNetworksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCoreNetworksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCoreNetworksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreNetworksOutputError>
}

public struct ListCoreNetworksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreNetworksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCoreNetworksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCoreNetworksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreNetworksOutputError>
}

public struct ListCoreNetworksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreNetworksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCoreNetworksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCoreNetworksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreNetworksOutputError>
}

public struct ListCoreNetworksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreNetworksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCoreNetworksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/core-networks"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCoreNetworksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreNetworksOutputError>
}

public struct ListCoreNetworksInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoreNetworksInputBody: Swift.Equatable {
}

extension ListCoreNetworksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCoreNetworksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoreNetworksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCoreNetworksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoreNetworksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCoreNetworksOutputResponse(coreNetworks: \(Swift.String(describing: coreNetworks)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCoreNetworksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCoreNetworksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworks = output.coreNetworks
            self.nextToken = output.nextToken
        } else {
            self.coreNetworks = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoreNetworksOutputResponse: Swift.Equatable {
    /// Describes the list of core networks.
    public var coreNetworks: [NetworkManagerClientTypes.CoreNetworkSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        coreNetworks: [NetworkManagerClientTypes.CoreNetworkSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworks = coreNetworks
        self.nextToken = nextToken
    }
}

struct ListCoreNetworksOutputResponseBody: Swift.Equatable {
    public let coreNetworks: [NetworkManagerClientTypes.CoreNetworkSummary]?
    public let nextToken: Swift.String?
}

extension ListCoreNetworksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworks = "CoreNetworks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworksContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CoreNetworkSummary?].self, forKey: .coreNetworks)
        var coreNetworksDecoded0:[NetworkManagerClientTypes.CoreNetworkSummary]? = nil
        if let coreNetworksContainer = coreNetworksContainer {
            coreNetworksDecoded0 = [NetworkManagerClientTypes.CoreNetworkSummary]()
            for structure0 in coreNetworksContainer {
                if let structure0 = structure0 {
                    coreNetworksDecoded0?.append(structure0)
                }
            }
        }
        coreNetworks = coreNetworksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tagList: \(Swift.String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags.
    public var tagList: [NetworkManagerClientTypes.Tag]?

    public init (
        tagList: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tagList: [NetworkManagerClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension NetworkManagerClientTypes.Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case latitude = "Latitude"
        case longitude = "Longitude"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let latitude = latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let latitudeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longitude)
        longitude = longitudeDecoded
    }
}

extension NetworkManagerClientTypes.Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension NetworkManagerClientTypes {
    /// Describes a location.
    public struct Location: Swift.Equatable {
        /// The physical address.
        public var address: Swift.String?
        /// The latitude.
        public var latitude: Swift.String?
        /// The longitude.
        public var longitude: Swift.String?

        public init (
            address: Swift.String? = nil,
            latitude: Swift.String? = nil,
            longitude: Swift.String? = nil
        )
        {
            self.address = address
            self.latitude = latitude
            self.longitude = longitude
        }
    }

}

extension NetworkManagerClientTypes.NetworkResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case coreNetworkId = "CoreNetworkId"
        case definition = "Definition"
        case definitionTimestamp = "DefinitionTimestamp"
        case metadata = "Metadata"
        case registeredGatewayArn = "RegisteredGatewayArn"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let definitionTimestamp = definitionTimestamp {
            try encodeContainer.encode(definitionTimestamp.timeIntervalSince1970, forKey: .definitionTimestamp)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, networkresourcemetadatamap0) in metadata {
                try metadataContainer.encode(networkresourcemetadatamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let registeredGatewayArn = registeredGatewayArn {
            try encodeContainer.encode(registeredGatewayArn, forKey: .registeredGatewayArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registeredGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredGatewayArn)
        registeredGatewayArn = registeredGatewayArnDecoded
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let definitionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .definitionTimestamp)
        definitionTimestamp = definitionTimestampDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, constrainedstring0) in metadataContainer {
                if let constrainedstring0 = constrainedstring0 {
                    metadataDecoded0?[key0] = constrainedstring0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension NetworkManagerClientTypes.NetworkResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkResource(accountId: \(Swift.String(describing: accountId)), awsRegion: \(Swift.String(describing: awsRegion)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), definition: \(Swift.String(describing: definition)), definitionTimestamp: \(Swift.String(describing: definitionTimestamp)), metadata: \(Swift.String(describing: metadata)), registeredGatewayArn: \(Swift.String(describing: registeredGatewayArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a network resource.
    public struct NetworkResource: Swift.Equatable {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The Amazon Web Services Region.
        public var awsRegion: Swift.String?
        /// a core network ID.
        public var coreNetworkId: Swift.String?
        /// Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.
        public var definition: Swift.String?
        /// The time that the resource definition was retrieved.
        public var definitionTimestamp: ClientRuntime.Date?
        /// The resource metadata.
        public var metadata: [Swift.String:Swift.String]?
        /// The ARN of the gateway.
        public var registeredGatewayArn: Swift.String?
        /// The ARN of the resource.
        public var resourceArn: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The resource type. The following are the supported resource types for Direct Connect:
        ///
        /// * dxcon
        ///
        /// * dx-gateway
        ///
        /// * dx-vif
        ///
        ///
        /// The following are the supported resource types for Network Manager:
        ///
        /// * connection
        ///
        /// * device
        ///
        /// * link
        ///
        /// * site
        ///
        ///
        /// The following are the supported resource types for Amazon VPC:
        ///
        /// * customer-gateway
        ///
        /// * transit-gateway
        ///
        /// * transit-gateway-attachment
        ///
        /// * transit-gateway-connect-peer
        ///
        /// * transit-gateway-route-table
        ///
        /// * vpn-connection
        public var resourceType: Swift.String?
        /// The tags.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            definition: Swift.String? = nil,
            definitionTimestamp: ClientRuntime.Date? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            registeredGatewayArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.definition = definition
            self.definitionTimestamp = definitionTimestamp
            self.metadata = metadata
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.NetworkResourceCount: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension NetworkManagerClientTypes.NetworkResourceCount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkResourceCount(count: \(Swift.String(describing: count)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a resource count.
    public struct NetworkResourceCount: Swift.Equatable {
        /// The resource count.
        public var count: Swift.Int?
        /// The resource type.
        public var resourceType: Swift.String?

        public init (
            count: Swift.Int? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.count = count
            self.resourceType = resourceType
        }
    }

}

extension NetworkManagerClientTypes.NetworkResourceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case isMiddlebox = "IsMiddlebox"
        case nameTag = "NameTag"
        case registeredGatewayArn = "RegisteredGatewayArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if isMiddlebox != false {
            try encodeContainer.encode(isMiddlebox, forKey: .isMiddlebox)
        }
        if let nameTag = nameTag {
            try encodeContainer.encode(nameTag, forKey: .nameTag)
        }
        if let registeredGatewayArn = registeredGatewayArn {
            try encodeContainer.encode(registeredGatewayArn, forKey: .registeredGatewayArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registeredGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredGatewayArn)
        registeredGatewayArn = registeredGatewayArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let nameTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nameTag)
        nameTag = nameTagDecoded
        let isMiddleboxDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isMiddlebox)
        isMiddlebox = isMiddleboxDecoded
    }
}

extension NetworkManagerClientTypes.NetworkResourceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkResourceSummary(definition: \(Swift.String(describing: definition)), isMiddlebox: \(Swift.String(describing: isMiddlebox)), nameTag: \(Swift.String(describing: nameTag)), registeredGatewayArn: \(Swift.String(describing: registeredGatewayArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a network resource.
    public struct NetworkResourceSummary: Swift.Equatable {
        /// Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.
        public var definition: Swift.String?
        /// Indicates whether this is a middlebox appliance.
        public var isMiddlebox: Swift.Bool
        /// The value for the Name tag.
        public var nameTag: Swift.String?
        /// The ARN of the gateway.
        public var registeredGatewayArn: Swift.String?
        /// The ARN of the resource.
        public var resourceArn: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?

        public init (
            definition: Swift.String? = nil,
            isMiddlebox: Swift.Bool = false,
            nameTag: Swift.String? = nil,
            registeredGatewayArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.definition = definition
            self.isMiddlebox = isMiddlebox
            self.nameTag = nameTag
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }
    }

}

extension NetworkManagerClientTypes.NetworkRoute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinations = "Destinations"
        case prefixListId = "PrefixListId"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCidrBlock = destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for networkroutedestinationlist0 in destinations {
                try destinationsContainer.encode(networkroutedestinationlist0)
            }
        }
        if let prefixListId = prefixListId {
            try encodeContainer.encode(prefixListId, forKey: .prefixListId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.NetworkRouteDestination?].self, forKey: .destinations)
        var destinationsDecoded0:[NetworkManagerClientTypes.NetworkRouteDestination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [NetworkManagerClientTypes.NetworkRouteDestination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let prefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefixListId)
        prefixListId = prefixListIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteType.self, forKey: .type)
        type = typeDecoded
    }
}

extension NetworkManagerClientTypes.NetworkRoute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkRoute(destinationCidrBlock: \(Swift.String(describing: destinationCidrBlock)), destinations: \(Swift.String(describing: destinations)), prefixListId: \(Swift.String(describing: prefixListId)), state: \(Swift.String(describing: state)), type: \(Swift.String(describing: type)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a network route.
    public struct NetworkRoute: Swift.Equatable {
        /// A unique identifier for the route, such as a CIDR block.
        public var destinationCidrBlock: Swift.String?
        /// The destinations.
        public var destinations: [NetworkManagerClientTypes.NetworkRouteDestination]?
        /// The ID of the prefix list.
        public var prefixListId: Swift.String?
        /// The route state. The possible values are active and blackhole.
        public var state: NetworkManagerClientTypes.RouteState?
        /// The route type. The possible values are propagated and static.
        public var type: NetworkManagerClientTypes.RouteType?

        public init (
            destinationCidrBlock: Swift.String? = nil,
            destinations: [NetworkManagerClientTypes.NetworkRouteDestination]? = nil,
            prefixListId: Swift.String? = nil,
            state: NetworkManagerClientTypes.RouteState? = nil,
            type: NetworkManagerClientTypes.RouteType? = nil
        )
        {
            self.destinationCidrBlock = destinationCidrBlock
            self.destinations = destinations
            self.prefixListId = prefixListId
            self.state = state
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes.NetworkRouteDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkAttachmentId = "CoreNetworkAttachmentId"
        case edgeLocation = "EdgeLocation"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case segmentName = "SegmentName"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkAttachmentId = coreNetworkAttachmentId {
            try encodeContainer.encode(coreNetworkAttachmentId, forKey: .coreNetworkAttachmentId)
        }
        if let edgeLocation = edgeLocation {
            try encodeContainer.encode(edgeLocation, forKey: .edgeLocation)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let segmentName = segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
        if let transitGatewayAttachmentId = transitGatewayAttachmentId {
            try encodeContainer.encode(transitGatewayAttachmentId, forKey: .transitGatewayAttachmentId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkAttachmentId)
        coreNetworkAttachmentId = coreNetworkAttachmentIdDecoded
        let transitGatewayAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayAttachmentId)
        transitGatewayAttachmentId = transitGatewayAttachmentIdDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
        let edgeLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeLocation)
        edgeLocation = edgeLocationDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension NetworkManagerClientTypes.NetworkRouteDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkRouteDestination(coreNetworkAttachmentId: \(Swift.String(describing: coreNetworkAttachmentId)), edgeLocation: \(Swift.String(describing: edgeLocation)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), segmentName: \(Swift.String(describing: segmentName)), transitGatewayAttachmentId: \(Swift.String(describing: transitGatewayAttachmentId)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the destination of a network route.
    public struct NetworkRouteDestination: Swift.Equatable {
        /// The ID of a core network attachment.
        public var coreNetworkAttachmentId: Swift.String?
        /// The edge location for the network destination.
        public var edgeLocation: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?
        /// The name of the segment.
        public var segmentName: Swift.String?
        /// The ID of the transit gateway attachment.
        public var transitGatewayAttachmentId: Swift.String?

        public init (
            coreNetworkAttachmentId: Swift.String? = nil,
            edgeLocation: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            segmentName: Swift.String? = nil,
            transitGatewayAttachmentId: Swift.String? = nil
        )
        {
            self.coreNetworkAttachmentId = coreNetworkAttachmentId
            self.edgeLocation = edgeLocation
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.segmentName = segmentName
            self.transitGatewayAttachmentId = transitGatewayAttachmentId
        }
    }

}

extension NetworkManagerClientTypes.NetworkTelemetry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case address = "Address"
        case awsRegion = "AwsRegion"
        case coreNetworkId = "CoreNetworkId"
        case health = "Health"
        case registeredGatewayArn = "RegisteredGatewayArn"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let coreNetworkId = coreNetworkId {
            try encodeContainer.encode(coreNetworkId, forKey: .coreNetworkId)
        }
        if let health = health {
            try encodeContainer.encode(health, forKey: .health)
        }
        if let registeredGatewayArn = registeredGatewayArn {
            try encodeContainer.encode(registeredGatewayArn, forKey: .registeredGatewayArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registeredGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredGatewayArn)
        registeredGatewayArn = registeredGatewayArnDecoded
        let coreNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreNetworkId)
        coreNetworkId = coreNetworkIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let healthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectionHealth.self, forKey: .health)
        health = healthDecoded
    }
}

extension NetworkManagerClientTypes.NetworkTelemetry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkTelemetry(accountId: \(Swift.String(describing: accountId)), address: \(Swift.String(describing: address)), awsRegion: \(Swift.String(describing: awsRegion)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), health: \(Swift.String(describing: health)), registeredGatewayArn: \(Swift.String(describing: registeredGatewayArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the telemetry information for a resource.
    public struct NetworkTelemetry: Swift.Equatable {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The address.
        public var address: Swift.String?
        /// The Amazon Web Services Region.
        public var awsRegion: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The connection health.
        public var health: NetworkManagerClientTypes.ConnectionHealth?
        /// The ARN of the gateway.
        public var registeredGatewayArn: Swift.String?
        /// The ARN of the resource.
        public var resourceArn: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            address: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            health: NetworkManagerClientTypes.ConnectionHealth? = nil,
            registeredGatewayArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.address = address
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.health = health
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension NetworkManagerClientTypes.PathComponent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case resource = "Resource"
        case sequence = "Sequence"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCidrBlock = destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let sequence = sequence {
            try encodeContainer.encode(sequence, forKey: .sequence)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sequenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sequence)
        sequence = sequenceDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.NetworkResourceSummary.self, forKey: .resource)
        resource = resourceDecoded
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
    }
}

extension NetworkManagerClientTypes.PathComponent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PathComponent(destinationCidrBlock: \(Swift.String(describing: destinationCidrBlock)), resource: \(Swift.String(describing: resource)), sequence: \(Swift.String(describing: sequence)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a path component.
    public struct PathComponent: Swift.Equatable {
        /// The destination CIDR block in the route table.
        public var destinationCidrBlock: Swift.String?
        /// The resource.
        public var resource: NetworkManagerClientTypes.NetworkResourceSummary?
        /// The sequence number in the path. The destination is 0.
        public var sequence: Swift.Int?

        public init (
            destinationCidrBlock: Swift.String? = nil,
            resource: NetworkManagerClientTypes.NetworkResourceSummary? = nil,
            sequence: Swift.Int? = nil
        )
        {
            self.destinationCidrBlock = destinationCidrBlock
            self.resource = resource
            self.sequence = sequence
        }
    }

}

extension NetworkManagerClientTypes.ProposedSegmentChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentPolicyRuleNumber = "AttachmentPolicyRuleNumber"
        case segmentName = "SegmentName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentPolicyRuleNumber = attachmentPolicyRuleNumber {
            try encodeContainer.encode(attachmentPolicyRuleNumber, forKey: .attachmentPolicyRuleNumber)
        }
        if let segmentName = segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let attachmentPolicyRuleNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentPolicyRuleNumber)
        attachmentPolicyRuleNumber = attachmentPolicyRuleNumberDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
    }
}

extension NetworkManagerClientTypes.ProposedSegmentChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProposedSegmentChange(attachmentPolicyRuleNumber: \(Swift.String(describing: attachmentPolicyRuleNumber)), segmentName: \(Swift.String(describing: segmentName)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a proposed segment change. In some cases, the segment change must first be evaluated and accepted.
    public struct ProposedSegmentChange: Swift.Equatable {
        /// The rule number in the policy document that applies to this change.
        public var attachmentPolicyRuleNumber: Swift.Int?
        /// The name of the segment to change.
        public var segmentName: Swift.String?
        /// The key-value tags that changed for the segment.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            attachmentPolicyRuleNumber: Swift.Int? = nil,
            segmentName: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.segmentName = segmentName
            self.tags = tags
        }
    }

}

public struct PutCoreNetworkPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutCoreNetworkPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutCoreNetworkPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutCoreNetworkPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutCoreNetworkPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutCoreNetworkPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutCoreNetworkPolicyOutputError>
}

extension PutCoreNetworkPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutCoreNetworkPolicyInput(clientToken: \(Swift.String(describing: clientToken)), coreNetworkId: \(Swift.String(describing: coreNetworkId)), description: \(Swift.String(describing: description)), latestVersionId: \(Swift.String(describing: latestVersionId)), policyDocument: \(Swift.String(describing: policyDocument)))"}
}

extension PutCoreNetworkPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case latestVersionId = "LatestVersionId"
        case policyDocument = "PolicyDocument"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let latestVersionId = latestVersionId {
            try encodeContainer.encode(latestVersionId, forKey: .latestVersionId)
        }
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
    }
}

public struct PutCoreNetworkPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutCoreNetworkPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutCoreNetworkPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutCoreNetworkPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutCoreNetworkPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutCoreNetworkPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutCoreNetworkPolicyOutputError>
}

public struct PutCoreNetworkPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutCoreNetworkPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutCoreNetworkPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutCoreNetworkPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutCoreNetworkPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutCoreNetworkPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutCoreNetworkPolicyOutputError>
}

public struct PutCoreNetworkPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutCoreNetworkPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutCoreNetworkPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutCoreNetworkPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutCoreNetworkPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutCoreNetworkPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutCoreNetworkPolicyOutputError>
}

public struct PutCoreNetworkPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutCoreNetworkPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutCoreNetworkPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutCoreNetworkPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreNetworkId = input.coreNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutCoreNetworkPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutCoreNetworkPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutCoreNetworkPolicyOutputError>
}

public struct PutCoreNetworkPolicyInput: Swift.Equatable {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// a core network policy description.
    public var description: Swift.String?
    /// The ID of a core network policy.
    public var latestVersionId: Swift.Int?
    /// The policy document.
    /// This member is required.
    public var policyDocument: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        description: Swift.String? = nil,
        latestVersionId: Swift.Int? = nil,
        policyDocument: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.description = description
        self.latestVersionId = latestVersionId
        self.policyDocument = policyDocument
    }
}

struct PutCoreNetworkPolicyInputBody: Swift.Equatable {
    public let policyDocument: Swift.String?
    public let description: Swift.String?
    public let latestVersionId: Swift.Int?
    public let clientToken: Swift.String?
}

extension PutCoreNetworkPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case latestVersionId = "LatestVersionId"
        case policyDocument = "PolicyDocument"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let latestVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestVersionId)
        latestVersionId = latestVersionIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension PutCoreNetworkPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutCoreNetworkPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CoreNetworkPolicyException" : self = .coreNetworkPolicyException(try CoreNetworkPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutCoreNetworkPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case coreNetworkPolicyException(CoreNetworkPolicyException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutCoreNetworkPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutCoreNetworkPolicyOutputResponse(coreNetworkPolicy: \(Swift.String(describing: coreNetworkPolicy)))"}
}

extension PutCoreNetworkPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutCoreNetworkPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkPolicy = output.coreNetworkPolicy
        } else {
            self.coreNetworkPolicy = nil
        }
    }
}

public struct PutCoreNetworkPolicyOutputResponse: Swift.Equatable {
    /// Describes the changed core network policy.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init (
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

struct PutCoreNetworkPolicyOutputResponseBody: Swift.Equatable {
    public let coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?
}

extension PutCoreNetworkPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkPolicy = "CoreNetworkPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkPolicyDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicy.self, forKey: .coreNetworkPolicy)
        coreNetworkPolicy = coreNetworkPolicyDecoded
    }
}

public struct PutResourcePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

extension PutResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutResourcePolicyInput(policyDocument: \(Swift.String(describing: policyDocument)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension PutResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
    }
}

public struct PutResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutResourcePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutResourcePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutResourcePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/resource-policy/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutResourcePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// The JSON resource policy document.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The ARN of the resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        policyDocument: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    public let policyDocument: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutResourcePolicyOutputResponse()"}
}

extension PutResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutResourcePolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutResourcePolicyOutputResponseBody: Swift.Equatable {
}

extension PutResourcePolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RegisterTransitGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTransitGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTransitGatewayOutputError>
}

extension RegisterTransitGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTransitGatewayInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), transitGatewayArn: \(Swift.String(describing: transitGatewayArn)))"}
}

extension RegisterTransitGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayArn = "TransitGatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transitGatewayArn = transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
    }
}

public struct RegisterTransitGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTransitGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTransitGatewayOutputError>
}

public struct RegisterTransitGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTransitGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTransitGatewayOutputError>
}

public struct RegisterTransitGatewayInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTransitGatewayInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RegisterTransitGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterTransitGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTransitGatewayOutputError>
}

public struct RegisterTransitGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTransitGatewayInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RegisterTransitGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterTransitGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTransitGatewayOutputError>
}

public struct RegisterTransitGatewayInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway.
    /// This member is required.
    public var transitGatewayArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        transitGatewayArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayArn = transitGatewayArn
    }
}

struct RegisterTransitGatewayInputBody: Swift.Equatable {
    public let transitGatewayArn: Swift.String?
}

extension RegisterTransitGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayArn = "TransitGatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
    }
}

extension RegisterTransitGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTransitGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTransitGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTransitGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTransitGatewayOutputResponse(transitGatewayRegistration: \(Swift.String(describing: transitGatewayRegistration)))"}
}

extension RegisterTransitGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterTransitGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayRegistration = output.transitGatewayRegistration
        } else {
            self.transitGatewayRegistration = nil
        }
    }
}

public struct RegisterTransitGatewayOutputResponse: Swift.Equatable {
    /// Information about the transit gateway registration.
    public var transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?

    public init (
        transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration? = nil
    )
    {
        self.transitGatewayRegistration = transitGatewayRegistration
    }
}

struct RegisterTransitGatewayOutputResponseBody: Swift.Equatable {
    public let transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?
}

extension RegisterTransitGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayRegistration = "TransitGatewayRegistration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistration.self, forKey: .transitGatewayRegistration)
        transitGatewayRegistration = transitGatewayRegistrationDecoded
    }
}

extension RejectAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectAttachmentInput(attachmentId: \(Swift.String(describing: attachmentId)))"}
}

extension RejectAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RejectAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectAttachmentOutputError>
}

public struct RejectAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectAttachmentOutputError>
}

public struct RejectAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RejectAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RejectAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<RejectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectAttachmentOutputError>
}

public struct RejectAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RejectAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let attachmentId = input.attachmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attachmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/attachments/\(attachmentId.urlPercentEncoding())/reject"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RejectAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<RejectAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectAttachmentOutputError>
}

public struct RejectAttachmentInput: Swift.Equatable {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct RejectAttachmentInputBody: Swift.Equatable {
}

extension RejectAttachmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RejectAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectAttachmentOutputResponse(attachment: \(Swift.String(describing: attachment)))"}
}

extension RejectAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RejectAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachment = output.attachment
        } else {
            self.attachment = nil
        }
    }
}

public struct RejectAttachmentOutputResponse: Swift.Equatable {
    /// Describes the rejected attachment request.
    public var attachment: NetworkManagerClientTypes.Attachment?

    public init (
        attachment: NetworkManagerClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

struct RejectAttachmentOutputResponseBody: Swift.Equatable {
    public let attachment: NetworkManagerClientTypes.Attachment?
}

extension RejectAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
    }
}

extension NetworkManagerClientTypes.Relationship: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from = "From"
        case to = "To"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let from = from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let to = to {
            try encodeContainer.encode(to, forKey: .to)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .to)
        to = toDecoded
    }
}

extension NetworkManagerClientTypes.Relationship: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Relationship(from: \(Swift.String(describing: from)), to: \(Swift.String(describing: to)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a resource relationship.
    public struct Relationship: Swift.Equatable {
        /// The ARN of the resource.
        public var from: Swift.String?
        /// The ARN of the resource.
        public var to: Swift.String?

        public init (
            from: Swift.String? = nil,
            to: Swift.String? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.context = output.context
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.context = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The specified resource could not be found.
    public var context: [Swift.String:Swift.String]?
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.context = context
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
    public let context: [Swift.String:Swift.String]?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context = "Context"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, exceptioncontextvalue0) in contextContainer {
                if let exceptioncontextvalue0 = exceptioncontextvalue0 {
                    contextDecoded0?[key0] = exceptioncontextvalue0
                }
            }
        }
        context = contextDecoded0
    }
}

extension RestoreCoreNetworkPolicyVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreCoreNetworkPolicyVersionInput(coreNetworkId: \(Swift.String(describing: coreNetworkId)), policyVersionId: \(Swift.String(describing: policyVersionId)))"}
}

extension RestoreCoreNetworkPolicyVersionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RestoreCoreNetworkPolicyVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreCoreNetworkPolicyVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreCoreNetworkPolicyVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreCoreNetworkPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreCoreNetworkPolicyVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreCoreNetworkPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreCoreNetworkPolicyVersionOutputError>
}

public struct RestoreCoreNetworkPolicyVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreCoreNetworkPolicyVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreCoreNetworkPolicyVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreCoreNetworkPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreCoreNetworkPolicyVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreCoreNetworkPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreCoreNetworkPolicyVersionOutputError>
}

public struct RestoreCoreNetworkPolicyVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreCoreNetworkPolicyVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RestoreCoreNetworkPolicyVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreCoreNetworkPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreCoreNetworkPolicyVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreCoreNetworkPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreCoreNetworkPolicyVersionOutputError>
}

public struct RestoreCoreNetworkPolicyVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreCoreNetworkPolicyVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RestoreCoreNetworkPolicyVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreCoreNetworkPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreNetworkId = input.coreNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let policyVersionId = input.policyVersionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("policyVersionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy-versions/\(policyVersionId)/restore"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreCoreNetworkPolicyVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreCoreNetworkPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreCoreNetworkPolicyVersionOutputError>
}

public struct RestoreCoreNetworkPolicyVersionInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The ID of the policy version to restore.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init (
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

struct RestoreCoreNetworkPolicyVersionInputBody: Swift.Equatable {
}

extension RestoreCoreNetworkPolicyVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RestoreCoreNetworkPolicyVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreCoreNetworkPolicyVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreCoreNetworkPolicyVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreCoreNetworkPolicyVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreCoreNetworkPolicyVersionOutputResponse(coreNetworkPolicy: \(Swift.String(describing: coreNetworkPolicy)))"}
}

extension RestoreCoreNetworkPolicyVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreCoreNetworkPolicyVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetworkPolicy = output.coreNetworkPolicy
        } else {
            self.coreNetworkPolicy = nil
        }
    }
}

public struct RestoreCoreNetworkPolicyVersionOutputResponse: Swift.Equatable {
    /// Describes the restored core network policy.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init (
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

struct RestoreCoreNetworkPolicyVersionOutputResponseBody: Swift.Equatable {
    public let coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?
}

extension RestoreCoreNetworkPolicyVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkPolicy = "CoreNetworkPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkPolicyDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkPolicy.self, forKey: .coreNetworkPolicy)
        coreNetworkPolicy = coreNetworkPolicyDecoded
    }
}

extension NetworkManagerClientTypes.RouteAnalysis: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case forwardPath = "ForwardPath"
        case globalNetworkId = "GlobalNetworkId"
        case includeReturnPath = "IncludeReturnPath"
        case ownerAccountId = "OwnerAccountId"
        case returnPath = "ReturnPath"
        case routeAnalysisId = "RouteAnalysisId"
        case source = "Source"
        case startTimestamp = "StartTimestamp"
        case status = "Status"
        case useMiddleboxes = "UseMiddleboxes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forwardPath = forwardPath {
            try encodeContainer.encode(forwardPath, forKey: .forwardPath)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if includeReturnPath != false {
            try encodeContainer.encode(includeReturnPath, forKey: .includeReturnPath)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let returnPath = returnPath {
            try encodeContainer.encode(returnPath, forKey: .returnPath)
        }
        if let routeAnalysisId = routeAnalysisId {
            try encodeContainer.encode(routeAnalysisId, forKey: .routeAnalysisId)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let startTimestamp = startTimestamp {
            try encodeContainer.encode(startTimestamp.timeIntervalSince1970, forKey: .startTimestamp)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if useMiddleboxes != false {
            try encodeContainer.encode(useMiddleboxes, forKey: .useMiddleboxes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let routeAnalysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeAnalysisId)
        routeAnalysisId = routeAnalysisIdDecoded
        let startTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisStatus.self, forKey: .status)
        status = statusDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisEndpointOptions.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisEndpointOptions.self, forKey: .destination)
        destination = destinationDecoded
        let includeReturnPathDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeReturnPath)
        includeReturnPath = includeReturnPathDecoded
        let useMiddleboxesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useMiddleboxes)
        useMiddleboxes = useMiddleboxesDecoded
        let forwardPathDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisPath.self, forKey: .forwardPath)
        forwardPath = forwardPathDecoded
        let returnPathDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisPath.self, forKey: .returnPath)
        returnPath = returnPathDecoded
    }
}

extension NetworkManagerClientTypes.RouteAnalysis: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteAnalysis(destination: \(Swift.String(describing: destination)), forwardPath: \(Swift.String(describing: forwardPath)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), includeReturnPath: \(Swift.String(describing: includeReturnPath)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), returnPath: \(Swift.String(describing: returnPath)), routeAnalysisId: \(Swift.String(describing: routeAnalysisId)), source: \(Swift.String(describing: source)), startTimestamp: \(Swift.String(describing: startTimestamp)), status: \(Swift.String(describing: status)), useMiddleboxes: \(Swift.String(describing: useMiddleboxes)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a route analysis.
    public struct RouteAnalysis: Swift.Equatable {
        /// The destination.
        public var destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptions?
        /// The forward path.
        public var forwardPath: NetworkManagerClientTypes.RouteAnalysisPath?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// Indicates whether to analyze the return path. The return path is not analyzed if the forward path analysis does not succeed.
        public var includeReturnPath: Swift.Bool
        /// The ID of the AWS account that created the route analysis.
        public var ownerAccountId: Swift.String?
        /// The return path.
        public var returnPath: NetworkManagerClientTypes.RouteAnalysisPath?
        /// The ID of the route analysis.
        public var routeAnalysisId: Swift.String?
        /// The source.
        public var source: NetworkManagerClientTypes.RouteAnalysisEndpointOptions?
        /// The time that the analysis started.
        public var startTimestamp: ClientRuntime.Date?
        /// The status of the route analysis.
        public var status: NetworkManagerClientTypes.RouteAnalysisStatus?
        /// Indicates whether to include the location of middlebox appliances in the route analysis.
        public var useMiddleboxes: Swift.Bool

        public init (
            destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptions? = nil,
            forwardPath: NetworkManagerClientTypes.RouteAnalysisPath? = nil,
            globalNetworkId: Swift.String? = nil,
            includeReturnPath: Swift.Bool = false,
            ownerAccountId: Swift.String? = nil,
            returnPath: NetworkManagerClientTypes.RouteAnalysisPath? = nil,
            routeAnalysisId: Swift.String? = nil,
            source: NetworkManagerClientTypes.RouteAnalysisEndpointOptions? = nil,
            startTimestamp: ClientRuntime.Date? = nil,
            status: NetworkManagerClientTypes.RouteAnalysisStatus? = nil,
            useMiddleboxes: Swift.Bool = false
        )
        {
            self.destination = destination
            self.forwardPath = forwardPath
            self.globalNetworkId = globalNetworkId
            self.includeReturnPath = includeReturnPath
            self.ownerAccountId = ownerAccountId
            self.returnPath = returnPath
            self.routeAnalysisId = routeAnalysisId
            self.source = source
            self.startTimestamp = startTimestamp
            self.status = status
            self.useMiddleboxes = useMiddleboxes
        }
    }

}

extension NetworkManagerClientTypes.RouteAnalysisCompletion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reasonCode = "ReasonCode"
        case reasonContext = "ReasonContext"
        case resultCode = "ResultCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reasonCode = reasonCode {
            try encodeContainer.encode(reasonCode.rawValue, forKey: .reasonCode)
        }
        if let reasonContext = reasonContext {
            var reasonContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .reasonContext)
            for (dictKey0, reasoncontextmap0) in reasonContext {
                try reasonContextContainer.encode(reasoncontextmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resultCode = resultCode {
            try encodeContainer.encode(resultCode.rawValue, forKey: .resultCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultCodeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisCompletionResultCode.self, forKey: .resultCode)
        resultCode = resultCodeDecoded
        let reasonCodeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisCompletionReasonCode.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let reasonContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .reasonContext)
        var reasonContextDecoded0: [Swift.String:Swift.String]? = nil
        if let reasonContextContainer = reasonContextContainer {
            reasonContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, reasoncontextvalue0) in reasonContextContainer {
                if let reasoncontextvalue0 = reasoncontextvalue0 {
                    reasonContextDecoded0?[key0] = reasoncontextvalue0
                }
            }
        }
        reasonContext = reasonContextDecoded0
    }
}

extension NetworkManagerClientTypes.RouteAnalysisCompletion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteAnalysisCompletion(reasonCode: \(Swift.String(describing: reasonCode)), reasonContext: \(Swift.String(describing: reasonContext)), resultCode: \(Swift.String(describing: resultCode)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the status of an analysis at completion.
    public struct RouteAnalysisCompletion: Swift.Equatable {
        /// The reason code. Available only if a connection is not found.
        ///
        /// * BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND - Found a black hole route with the destination CIDR block.
        ///
        /// * CYCLIC_PATH_DETECTED - Found the same resource multiple times while traversing the path.
        ///
        /// * INACTIVE_ROUTE_FOR_DESTINATION_FOUND - Found an inactive route with the destination CIDR block.
        ///
        /// * MAX_HOPS_EXCEEDED - Analysis exceeded 64 hops without finding the destination.
        ///
        /// * ROUTE_NOT_FOUND - Cannot find a route table with the destination CIDR block.
        ///
        /// * TGW_ATTACH_ARN_NO_MATCH - Found an attachment, but not with the correct destination ARN.
        ///
        /// * TGW_ATTACH_NOT_FOUND - Cannot find an attachment.
        ///
        /// * TGW_ATTACH_NOT_IN_TGW - Found an attachment, but not to the correct transit gateway.
        ///
        /// * TGW_ATTACH_STABLE_ROUTE_TABLE_NOT_FOUND - The state of the route table association is not associated.
        public var reasonCode: NetworkManagerClientTypes.RouteAnalysisCompletionReasonCode?
        /// Additional information about the path. Available only if a connection is not found.
        public var reasonContext: [Swift.String:Swift.String]?
        /// The result of the analysis. If the status is NOT_CONNECTED, check the reason code.
        public var resultCode: NetworkManagerClientTypes.RouteAnalysisCompletionResultCode?

        public init (
            reasonCode: NetworkManagerClientTypes.RouteAnalysisCompletionReasonCode? = nil,
            reasonContext: [Swift.String:Swift.String]? = nil,
            resultCode: NetworkManagerClientTypes.RouteAnalysisCompletionResultCode? = nil
        )
        {
            self.reasonCode = reasonCode
            self.reasonContext = reasonContext
            self.resultCode = resultCode
        }
    }

}

extension NetworkManagerClientTypes {
    public enum RouteAnalysisCompletionReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blackholeRouteForDestinationFound
        case cyclicPathDetected
        case inactiveRouteForDestinationFound
        case maxHopsExceeded
        case noDestinationArnProvided
        case possibleMiddlebox
        case routeNotFound
        case transitGatewayAttachment
        case transitGatewayAttachmentNotFound
        case transitGatewayAttachmentNotInTransitGateway
        case transitGatewayAttachmentStableRouteTableNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteAnalysisCompletionReasonCode] {
            return [
                .blackholeRouteForDestinationFound,
                .cyclicPathDetected,
                .inactiveRouteForDestinationFound,
                .maxHopsExceeded,
                .noDestinationArnProvided,
                .possibleMiddlebox,
                .routeNotFound,
                .transitGatewayAttachment,
                .transitGatewayAttachmentNotFound,
                .transitGatewayAttachmentNotInTransitGateway,
                .transitGatewayAttachmentStableRouteTableNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blackholeRouteForDestinationFound: return "BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND"
            case .cyclicPathDetected: return "CYCLIC_PATH_DETECTED"
            case .inactiveRouteForDestinationFound: return "INACTIVE_ROUTE_FOR_DESTINATION_FOUND"
            case .maxHopsExceeded: return "MAX_HOPS_EXCEEDED"
            case .noDestinationArnProvided: return "NO_DESTINATION_ARN_PROVIDED"
            case .possibleMiddlebox: return "POSSIBLE_MIDDLEBOX"
            case .routeNotFound: return "ROUTE_NOT_FOUND"
            case .transitGatewayAttachment: return "TRANSIT_GATEWAY_ATTACHMENT_ATTACH_ARN_NO_MATCH"
            case .transitGatewayAttachmentNotFound: return "TRANSIT_GATEWAY_ATTACHMENT_NOT_FOUND"
            case .transitGatewayAttachmentNotInTransitGateway: return "TRANSIT_GATEWAY_ATTACHMENT_NOT_IN_TRANSIT_GATEWAY"
            case .transitGatewayAttachmentStableRouteTableNotFound: return "TRANSIT_GATEWAY_ATTACHMENT_STABLE_ROUTE_TABLE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteAnalysisCompletionReasonCode(rawValue: rawValue) ?? RouteAnalysisCompletionReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum RouteAnalysisCompletionResultCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteAnalysisCompletionResultCode] {
            return [
                .connected,
                .notConnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteAnalysisCompletionResultCode(rawValue: rawValue) ?? RouteAnalysisCompletionResultCode.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.RouteAnalysisEndpointOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case transitGatewayArn = "TransitGatewayArn"
        case transitGatewayAttachmentArn = "TransitGatewayAttachmentArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let transitGatewayArn = transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
        if let transitGatewayAttachmentArn = transitGatewayAttachmentArn {
            try encodeContainer.encode(transitGatewayAttachmentArn, forKey: .transitGatewayAttachmentArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayAttachmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayAttachmentArn)
        transitGatewayAttachmentArn = transitGatewayAttachmentArnDecoded
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension NetworkManagerClientTypes.RouteAnalysisEndpointOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteAnalysisEndpointOptions(ipAddress: \(Swift.String(describing: ipAddress)), transitGatewayArn: \(Swift.String(describing: transitGatewayArn)), transitGatewayAttachmentArn: \(Swift.String(describing: transitGatewayAttachmentArn)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a source or a destination.
    public struct RouteAnalysisEndpointOptions: Swift.Equatable {
        /// The IP address.
        public var ipAddress: Swift.String?
        /// The ARN of the transit gateway.
        public var transitGatewayArn: Swift.String?
        /// The ARN of the transit gateway attachment.
        public var transitGatewayAttachmentArn: Swift.String?

        public init (
            ipAddress: Swift.String? = nil,
            transitGatewayArn: Swift.String? = nil,
            transitGatewayAttachmentArn: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.transitGatewayArn = transitGatewayArn
            self.transitGatewayAttachmentArn = transitGatewayAttachmentArn
        }
    }

}

extension NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case transitGatewayAttachmentArn = "TransitGatewayAttachmentArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let transitGatewayAttachmentArn = transitGatewayAttachmentArn {
            try encodeContainer.encode(transitGatewayAttachmentArn, forKey: .transitGatewayAttachmentArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayAttachmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayAttachmentArn)
        transitGatewayAttachmentArn = transitGatewayAttachmentArnDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteAnalysisEndpointOptionsSpecification(ipAddress: \(Swift.String(describing: ipAddress)), transitGatewayAttachmentArn: \(Swift.String(describing: transitGatewayAttachmentArn)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a source or a destination.
    public struct RouteAnalysisEndpointOptionsSpecification: Swift.Equatable {
        /// The IP address.
        public var ipAddress: Swift.String?
        /// The ARN of the transit gateway attachment.
        public var transitGatewayAttachmentArn: Swift.String?

        public init (
            ipAddress: Swift.String? = nil,
            transitGatewayAttachmentArn: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.transitGatewayAttachmentArn = transitGatewayAttachmentArn
        }
    }

}

extension NetworkManagerClientTypes.RouteAnalysisPath: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionStatus = "CompletionStatus"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionStatus = completionStatus {
            try encodeContainer.encode(completionStatus, forKey: .completionStatus)
        }
        if let path = path {
            var pathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .path)
            for pathcomponentlist0 in path {
                try pathContainer.encode(pathcomponentlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let completionStatusDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisCompletion.self, forKey: .completionStatus)
        completionStatus = completionStatusDecoded
        let pathContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.PathComponent?].self, forKey: .path)
        var pathDecoded0:[NetworkManagerClientTypes.PathComponent]? = nil
        if let pathContainer = pathContainer {
            pathDecoded0 = [NetworkManagerClientTypes.PathComponent]()
            for structure0 in pathContainer {
                if let structure0 = structure0 {
                    pathDecoded0?.append(structure0)
                }
            }
        }
        path = pathDecoded0
    }
}

extension NetworkManagerClientTypes.RouteAnalysisPath: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteAnalysisPath(completionStatus: \(Swift.String(describing: completionStatus)), path: \(Swift.String(describing: path)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a route analysis path.
    public struct RouteAnalysisPath: Swift.Equatable {
        /// The status of the analysis at completion.
        public var completionStatus: NetworkManagerClientTypes.RouteAnalysisCompletion?
        /// The route analysis path.
        public var path: [NetworkManagerClientTypes.PathComponent]?

        public init (
            completionStatus: NetworkManagerClientTypes.RouteAnalysisCompletion? = nil,
            path: [NetworkManagerClientTypes.PathComponent]? = nil
        )
        {
            self.completionStatus = completionStatus
            self.path = path
        }
    }

}

extension NetworkManagerClientTypes {
    public enum RouteAnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteAnalysisStatus] {
            return [
                .completed,
                .failed,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteAnalysisStatus(rawValue: rawValue) ?? RouteAnalysisStatus.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum RouteState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case blackhole
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteState] {
            return [
                .active,
                .blackhole,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .blackhole: return "BLACKHOLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteState(rawValue: rawValue) ?? RouteState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.RouteTableIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetworkSegmentEdge = "CoreNetworkSegmentEdge"
        case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreNetworkSegmentEdge = coreNetworkSegmentEdge {
            try encodeContainer.encode(coreNetworkSegmentEdge, forKey: .coreNetworkSegmentEdge)
        }
        if let transitGatewayRouteTableArn = transitGatewayRouteTableArn {
            try encodeContainer.encode(transitGatewayRouteTableArn, forKey: .transitGatewayRouteTableArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRouteTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayRouteTableArn)
        transitGatewayRouteTableArn = transitGatewayRouteTableArnDecoded
        let coreNetworkSegmentEdgeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier.self, forKey: .coreNetworkSegmentEdge)
        coreNetworkSegmentEdge = coreNetworkSegmentEdgeDecoded
    }
}

extension NetworkManagerClientTypes.RouteTableIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteTableIdentifier(coreNetworkSegmentEdge: \(Swift.String(describing: coreNetworkSegmentEdge)), transitGatewayRouteTableArn: \(Swift.String(describing: transitGatewayRouteTableArn)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a route table.
    public struct RouteTableIdentifier: Swift.Equatable {
        /// The segment edge in a core network.
        public var coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier?
        /// The ARN of the transit gateway route table.
        public var transitGatewayRouteTableArn: Swift.String?

        public init (
            coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier? = nil,
            transitGatewayRouteTableArn: Swift.String? = nil
        )
        {
            self.coreNetworkSegmentEdge = coreNetworkSegmentEdge
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum RouteTableType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case coreNetworkSegment
        case transitGatewayRouteTable
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTableType] {
            return [
                .coreNetworkSegment,
                .transitGatewayRouteTable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .coreNetworkSegment: return "CORE_NETWORK_SEGMENT"
            case .transitGatewayRouteTable: return "TRANSIT_GATEWAY_ROUTE_TABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteTableType(rawValue: rawValue) ?? RouteTableType.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum RouteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case propagated
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteType] {
            return [
                .propagated,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .propagated: return "PROPAGATED"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteType(rawValue: rawValue) ?? RouteType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(limitCode: \(Swift.String(describing: limitCode)), message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limitCode = output.limitCode
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.limitCode = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A service limit was exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The limit code.
    /// This member is required.
    public var limitCode: Swift.String?
    /// The error message.
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The resource type.
    public var resourceType: Swift.String?
    /// The service code.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        limitCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.limitCode = limitCode
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
    public let limitCode: Swift.String?
    public let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitCode = "LimitCode"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitCode)
        limitCode = limitCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension NetworkManagerClientTypes.Site: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case location = "Location"
        case siteArn = "SiteArn"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let siteArn = siteArn {
            try encodeContainer.encode(siteArn, forKey: .siteArn)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let siteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteArn)
        siteArn = siteArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.SiteState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.Site: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Site(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), siteArn: \(Swift.String(describing: siteArn)), siteId: \(Swift.String(describing: siteId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a site.
    public struct Site: Swift.Equatable {
        /// The date and time that the site was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the site.
        public var description: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The location of the site.
        public var location: NetworkManagerClientTypes.Location?
        /// The Amazon Resource Name (ARN) of the site.
        public var siteArn: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The state of the site.
        public var state: NetworkManagerClientTypes.SiteState?
        /// The tags for the site.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            location: NetworkManagerClientTypes.Location? = nil,
            siteArn: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.SiteState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.siteArn = siteArn
            self.siteId = siteId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    public enum SiteState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [SiteState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SiteState(rawValue: rawValue) ?? SiteState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.SiteToSiteVpnAttachment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
        case vpnConnectionArn = "VpnConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachment = attachment {
            try encodeContainer.encode(attachment, forKey: .attachment)
        }
        if let vpnConnectionArn = vpnConnectionArn {
            try encodeContainer.encode(vpnConnectionArn, forKey: .vpnConnectionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let vpnConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnConnectionArn)
        vpnConnectionArn = vpnConnectionArnDecoded
    }
}

extension NetworkManagerClientTypes.SiteToSiteVpnAttachment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SiteToSiteVpnAttachment(attachment: \(Swift.String(describing: attachment)), vpnConnectionArn: \(Swift.String(describing: vpnConnectionArn)))"}
}

extension NetworkManagerClientTypes {
    /// Creates a site-to-site VPN attachment.
    public struct SiteToSiteVpnAttachment: Swift.Equatable {
        /// Provides details about a site-to-site VPN attachment.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// The ARN of the site-to-site VPN attachment.
        public var vpnConnectionArn: Swift.String?

        public init (
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            vpnConnectionArn: Swift.String? = nil
        )
        {
            self.attachment = attachment
            self.vpnConnectionArn = vpnConnectionArn
        }
    }

}

public struct StartRouteAnalysisInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRouteAnalysisInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartRouteAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRouteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartRouteAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartRouteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRouteAnalysisOutputError>
}

extension StartRouteAnalysisInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartRouteAnalysisInput(destination: \(Swift.String(describing: destination)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), includeReturnPath: \(Swift.String(describing: includeReturnPath)), source: \(Swift.String(describing: source)), useMiddleboxes: \(Swift.String(describing: useMiddleboxes)))"}
}

extension StartRouteAnalysisInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case includeReturnPath = "IncludeReturnPath"
        case source = "Source"
        case useMiddleboxes = "UseMiddleboxes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if includeReturnPath != false {
            try encodeContainer.encode(includeReturnPath, forKey: .includeReturnPath)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if useMiddleboxes != false {
            try encodeContainer.encode(useMiddleboxes, forKey: .useMiddleboxes)
        }
    }
}

public struct StartRouteAnalysisInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRouteAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartRouteAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRouteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartRouteAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartRouteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRouteAnalysisOutputError>
}

public struct StartRouteAnalysisInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRouteAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartRouteAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRouteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartRouteAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartRouteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRouteAnalysisOutputError>
}

public struct StartRouteAnalysisInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRouteAnalysisInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartRouteAnalysisInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRouteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartRouteAnalysisInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartRouteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRouteAnalysisOutputError>
}

public struct StartRouteAnalysisInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRouteAnalysisInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartRouteAnalysisInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRouteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/route-analyses"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartRouteAnalysisInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartRouteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRouteAnalysisOutputError>
}

public struct StartRouteAnalysisInput: Swift.Equatable {
    /// The destination.
    /// This member is required.
    public var destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// Indicates whether to analyze the return path. The default is false.
    public var includeReturnPath: Swift.Bool
    /// The source from which traffic originates.
    /// This member is required.
    public var source: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?
    /// Indicates whether to include the location of middlebox appliances in the route analysis. The default is false.
    public var useMiddleboxes: Swift.Bool

    public init (
        destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification? = nil,
        globalNetworkId: Swift.String? = nil,
        includeReturnPath: Swift.Bool = false,
        source: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification? = nil,
        useMiddleboxes: Swift.Bool = false
    )
    {
        self.destination = destination
        self.globalNetworkId = globalNetworkId
        self.includeReturnPath = includeReturnPath
        self.source = source
        self.useMiddleboxes = useMiddleboxes
    }
}

struct StartRouteAnalysisInputBody: Swift.Equatable {
    public let source: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?
    public let destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?
    public let includeReturnPath: Swift.Bool
    public let useMiddleboxes: Swift.Bool
}

extension StartRouteAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case includeReturnPath = "IncludeReturnPath"
        case source = "Source"
        case useMiddleboxes = "UseMiddleboxes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification.self, forKey: .destination)
        destination = destinationDecoded
        let includeReturnPathDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeReturnPath)
        includeReturnPath = includeReturnPathDecoded
        let useMiddleboxesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useMiddleboxes)
        useMiddleboxes = useMiddleboxesDecoded
    }
}

extension StartRouteAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRouteAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartRouteAnalysisOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRouteAnalysisOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartRouteAnalysisOutputResponse(routeAnalysis: \(Swift.String(describing: routeAnalysis)))"}
}

extension StartRouteAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartRouteAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.routeAnalysis = output.routeAnalysis
        } else {
            self.routeAnalysis = nil
        }
    }
}

public struct StartRouteAnalysisOutputResponse: Swift.Equatable {
    /// The route analysis.
    public var routeAnalysis: NetworkManagerClientTypes.RouteAnalysis?

    public init (
        routeAnalysis: NetworkManagerClientTypes.RouteAnalysis? = nil
    )
    {
        self.routeAnalysis = routeAnalysis
    }
}

struct StartRouteAnalysisOutputResponseBody: Swift.Equatable {
    public let routeAnalysis: NetworkManagerClientTypes.RouteAnalysis?
}

extension StartRouteAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeAnalysis = "RouteAnalysis"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeAnalysisDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.RouteAnalysis.self, forKey: .routeAnalysis)
        routeAnalysis = routeAnalysisDecoded
    }
}

extension NetworkManagerClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NetworkManagerClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a tag.
    public struct Tag: Swift.Equatable {
        /// The tag key. Constraints: Maximum length of 128 characters.
        public var key: Swift.String?
        /// The tag value. Constraints: Maximum length of 256 characters.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to apply to the specified resource.
    /// This member is required.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Indicates when to retry the request.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let transitGatewayConnectPeerArn = transitGatewayConnectPeerArn {
            try encodeContainer.encode(transitGatewayConnectPeerArn, forKey: .transitGatewayConnectPeerArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayConnectPeerArn)
        transitGatewayConnectPeerArn = transitGatewayConnectPeerArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransitGatewayConnectPeerAssociation(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), state: \(Swift.String(describing: state)), transitGatewayConnectPeerArn: \(Swift.String(describing: transitGatewayConnectPeerArn)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a transit gateway Connect peer association.
    public struct TransitGatewayConnectPeerAssociation: Swift.Equatable {
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The state of the association.
        public var state: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState?
        /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
        public var transitGatewayConnectPeerArn: Swift.String?

        public init (
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState? = nil,
            transitGatewayConnectPeerArn: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum TransitGatewayConnectPeerAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitGatewayConnectPeerAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitGatewayConnectPeerAssociationState(rawValue: rawValue) ?? TransitGatewayConnectPeerAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetworkId = "GlobalNetworkId"
        case state = "State"
        case transitGatewayArn = "TransitGatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let transitGatewayArn = transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistrationStateReason.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransitGatewayRegistration(globalNetworkId: \(Swift.String(describing: globalNetworkId)), state: \(Swift.String(describing: state)), transitGatewayArn: \(Swift.String(describing: transitGatewayArn)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the registration of a transit gateway to a global network.
    public struct TransitGatewayRegistration: Swift.Equatable {
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the transit gateway registration.
        public var state: NetworkManagerClientTypes.TransitGatewayRegistrationStateReason?
        /// The Amazon Resource Name (ARN) of the transit gateway.
        public var transitGatewayArn: Swift.String?

        public init (
            globalNetworkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.TransitGatewayRegistrationStateReason? = nil,
            transitGatewayArn: Swift.String? = nil
        )
        {
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.transitGatewayArn = transitGatewayArn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum TransitGatewayRegistrationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitGatewayRegistrationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitGatewayRegistrationState(rawValue: rawValue) ?? TransitGatewayRegistrationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistrationStateReason: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistrationState.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistrationStateReason: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransitGatewayRegistrationStateReason(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the status of a transit gateway registration.
    public struct TransitGatewayRegistrationStateReason: Swift.Equatable {
        /// The code for the state reason.
        public var code: NetworkManagerClientTypes.TransitGatewayRegistrationState?
        /// The message for the state reason.
        public var message: Swift.String?

        public init (
            code: NetworkManagerClientTypes.TransitGatewayRegistrationState? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension NetworkManagerClientTypes {
    public enum TunnelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gre
        case sdkUnknown(Swift.String)

        public static var allCases: [TunnelProtocol] {
            return [
                .gre,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gre: return "GRE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TunnelProtocol(rawValue: rawValue) ?? TunnelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

extension UpdateConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionInput(connectedLinkId: \(Swift.String(describing: connectedLinkId)), connectionId: \(Swift.String(describing: connectionId)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension UpdateConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedLinkId = connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

public struct UpdateConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let connectionId = input.connectionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("connectionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections/\(connectionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInput: Swift.Equatable {
    /// The ID of the link for the second device in the connection.
    public var connectedLinkId: Swift.String?
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// A description of the connection. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link for the first device in the connection.
    public var linkId: Swift.String?

    public init (
        connectedLinkId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.connectedLinkId = connectedLinkId
        self.connectionId = connectionId
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct UpdateConnectionInputBody: Swift.Equatable {
    public let linkId: Swift.String?
    public let connectedLinkId: Swift.String?
    public let description: Swift.String?
}

extension UpdateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension UpdateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct UpdateConnectionOutputResponse: Swift.Equatable {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init (
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct UpdateConnectionOutputResponseBody: Swift.Equatable {
    public let connection: NetworkManagerClientTypes.Connection?
}

extension UpdateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct UpdateCoreNetworkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCoreNetworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCoreNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCoreNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCoreNetworkOutputError>
}

extension UpdateCoreNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCoreNetworkInput(coreNetworkId: \(Swift.String(describing: coreNetworkId)), description: \(Swift.String(describing: description)))"}
}

extension UpdateCoreNetworkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateCoreNetworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCoreNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCoreNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCoreNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCoreNetworkOutputError>
}

public struct UpdateCoreNetworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCoreNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCoreNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCoreNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCoreNetworkOutputError>
}

public struct UpdateCoreNetworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCoreNetworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateCoreNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCoreNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCoreNetworkOutputError>
}

public struct UpdateCoreNetworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCoreNetworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateCoreNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCoreNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreNetworkId = input.coreNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/core-networks/\(coreNetworkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCoreNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCoreNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCoreNetworkOutputError>
}

public struct UpdateCoreNetworkInput: Swift.Equatable {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The description of the update.
    public var description: Swift.String?

    public init (
        coreNetworkId: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.description = description
    }
}

struct UpdateCoreNetworkInputBody: Swift.Equatable {
    public let description: Swift.String?
}

extension UpdateCoreNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateCoreNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCoreNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCoreNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCoreNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCoreNetworkOutputResponse(coreNetwork: \(Swift.String(describing: coreNetwork)))"}
}

extension UpdateCoreNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateCoreNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreNetwork = output.coreNetwork
        } else {
            self.coreNetwork = nil
        }
    }
}

public struct UpdateCoreNetworkOutputResponse: Swift.Equatable {
    /// Returns information about a core network update.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init (
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

struct UpdateCoreNetworkOutputResponseBody: Swift.Equatable {
    public let coreNetwork: NetworkManagerClientTypes.CoreNetwork?
}

extension UpdateCoreNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreNetwork = "CoreNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CoreNetwork.self, forKey: .coreNetwork)
        coreNetwork = coreNetworkDecoded
    }
}

public struct UpdateDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceOutputError>
}

extension UpdateDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceInput(aWSLocation: \(Swift.String(describing: aWSLocation)), description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)))"}
}

extension UpdateDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSLocation = aWSLocation {
            try encodeContainer.encode(aWSLocation, forKey: .aWSLocation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }
}

public struct UpdateDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let deviceId = input.deviceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deviceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInput: Swift.Equatable {
    /// The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.
    public var aWSLocation: NetworkManagerClientTypes.AWSLocation?
    /// A description of the device. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// Describes a location.
    public var location: NetworkManagerClientTypes.Location?
    /// The model of the device. Constraints: Maximum length of 128 characters.
    public var model: Swift.String?
    /// The serial number of the device. Constraints: Maximum length of 128 characters.
    public var serialNumber: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The type of the device.
    public var type: Swift.String?
    /// The vendor of the device. Constraints: Maximum length of 128 characters.
    public var vendor: Swift.String?

    public init (
        aWSLocation: NetworkManagerClientTypes.AWSLocation? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        model: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        siteId: Swift.String? = nil,
        type: Swift.String? = nil,
        vendor: Swift.String? = nil
    )
    {
        self.aWSLocation = aWSLocation
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.type = type
        self.vendor = vendor
    }
}

struct UpdateDeviceInputBody: Swift.Equatable {
    public let aWSLocation: NetworkManagerClientTypes.AWSLocation?
    public let description: Swift.String?
    public let type: Swift.String?
    public let vendor: Swift.String?
    public let model: Swift.String?
    public let serialNumber: Swift.String?
    public let location: NetworkManagerClientTypes.Location?
    public let siteId: Swift.String?
}

extension UpdateDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case type = "Type"
        case vendor = "Vendor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aWSLocationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AWSLocation.self, forKey: .aWSLocation)
        aWSLocation = aWSLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
    }
}

extension UpdateDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceOutputResponse(device: \(Swift.String(describing: device)))"}
}

extension UpdateDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct UpdateDeviceOutputResponse: Swift.Equatable {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init (
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct UpdateDeviceOutputResponseBody: Swift.Equatable {
    public let device: NetworkManagerClientTypes.Device?
}

extension UpdateDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct UpdateGlobalNetworkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalNetworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalNetworkOutputError>
}

extension UpdateGlobalNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlobalNetworkInput(description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension UpdateGlobalNetworkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateGlobalNetworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalNetworkOutputError>
}

public struct UpdateGlobalNetworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalNetworkOutputError>
}

public struct UpdateGlobalNetworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalNetworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalNetworkOutputError>
}

public struct UpdateGlobalNetworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalNetworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalNetworkOutputError>
}

public struct UpdateGlobalNetworkInput: Swift.Equatable {
    /// A description of the global network. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of your global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
    }
}

struct UpdateGlobalNetworkInputBody: Swift.Equatable {
    public let description: Swift.String?
}

extension UpdateGlobalNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGlobalNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGlobalNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGlobalNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGlobalNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlobalNetworkOutputResponse(globalNetwork: \(Swift.String(describing: globalNetwork)))"}
}

extension UpdateGlobalNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct UpdateGlobalNetworkOutputResponse: Swift.Equatable {
    /// Information about the global network object.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init (
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct UpdateGlobalNetworkOutputResponseBody: Swift.Equatable {
    public let globalNetwork: NetworkManagerClientTypes.GlobalNetwork?
}

extension UpdateGlobalNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

public struct UpdateLinkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkOutputError>
}

extension UpdateLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLinkInput(bandwidth: \(Swift.String(describing: bandwidth)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), provider: \(Swift.String(describing: provider)), type: \(Swift.String(describing: type)))"}
}

extension UpdateLinkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct UpdateLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkOutputError>
}

public struct UpdateLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkOutputError>
}

public struct UpdateLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkOutputError>
}

public struct UpdateLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let linkId = input.linkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("linkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/links/\(linkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkOutputError>
}

public struct UpdateLinkInput: Swift.Equatable {
    /// The upload and download speed in Mbps.
    public var bandwidth: NetworkManagerClientTypes.Bandwidth?
    /// A description of the link. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The provider of the link. Constraints: Maximum length of 128 characters.
    public var provider: Swift.String?
    /// The type of the link. Constraints: Maximum length of 128 characters.
    public var type: Swift.String?

    public init (
        bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        provider: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.provider = provider
        self.type = type
    }
}

struct UpdateLinkInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let type: Swift.String?
    public let bandwidth: NetworkManagerClientTypes.Bandwidth?
    public let provider: Swift.String?
}

extension UpdateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
    }
}

extension UpdateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLinkOutputResponse(link: \(Swift.String(describing: link)))"}
}

extension UpdateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct UpdateLinkOutputResponse: Swift.Equatable {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init (
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

struct UpdateLinkOutputResponseBody: Swift.Equatable {
    public let link: NetworkManagerClientTypes.Link?
}

extension UpdateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case link = "Link"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Link.self, forKey: .link)
        link = linkDecoded
    }
}

public struct UpdateNetworkResourceMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkResourceMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNetworkResourceMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkResourceMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNetworkResourceMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkResourceMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkResourceMetadataOutputError>
}

extension UpdateNetworkResourceMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkResourceMetadataInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), metadata: \(Swift.String(describing: metadata)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension UpdateNetworkResourceMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, networkresourcemetadatamap0) in metadata {
                try metadataContainer.encode(networkresourcemetadatamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateNetworkResourceMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkResourceMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNetworkResourceMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkResourceMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNetworkResourceMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkResourceMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkResourceMetadataOutputError>
}

public struct UpdateNetworkResourceMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkResourceMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNetworkResourceMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkResourceMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNetworkResourceMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkResourceMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkResourceMetadataOutputError>
}

public struct UpdateNetworkResourceMetadataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkResourceMetadataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateNetworkResourceMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkResourceMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateNetworkResourceMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkResourceMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkResourceMetadataOutputError>
}

public struct UpdateNetworkResourceMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkResourceMetadataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateNetworkResourceMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkResourceMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resources/\(resourceArn.urlPercentEncoding())/metadata"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateNetworkResourceMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkResourceMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkResourceMetadataOutputError>
}

public struct UpdateNetworkResourceMetadataInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The resource metadata.
    /// This member is required.
    public var metadata: [Swift.String:Swift.String]?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.metadata = metadata
        self.resourceArn = resourceArn
    }
}

struct UpdateNetworkResourceMetadataInputBody: Swift.Equatable {
    public let metadata: [Swift.String:Swift.String]?
}

extension UpdateNetworkResourceMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, constrainedstring0) in metadataContainer {
                if let constrainedstring0 = constrainedstring0 {
                    metadataDecoded0?[key0] = constrainedstring0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension UpdateNetworkResourceMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkResourceMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNetworkResourceMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkResourceMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkResourceMetadataOutputResponse(metadata: \(Swift.String(describing: metadata)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension UpdateNetworkResourceMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateNetworkResourceMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.resourceArn = output.resourceArn
        } else {
            self.metadata = nil
            self.resourceArn = nil
        }
    }
}

public struct UpdateNetworkResourceMetadataOutputResponse: Swift.Equatable {
    /// The updated resource metadata.
    public var metadata: [Swift.String:Swift.String]?
    /// The ARN of the resource.
    public var resourceArn: Swift.String?

    public init (
        metadata: [Swift.String:Swift.String]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.metadata = metadata
        self.resourceArn = resourceArn
    }
}

struct UpdateNetworkResourceMetadataOutputResponseBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let metadata: [Swift.String:Swift.String]?
}

extension UpdateNetworkResourceMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, constrainedstring0) in metadataContainer {
                if let constrainedstring0 = constrainedstring0 {
                    metadataDecoded0?[key0] = constrainedstring0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

public struct UpdateSiteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

extension UpdateSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteInput(description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), siteId: \(Swift.String(describing: siteId)))"}
}

extension UpdateSiteInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }
}

public struct UpdateSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites/\(siteId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInput: Swift.Equatable {
    /// A description of your site. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The site location:
    ///
    /// * Address: The physical address of the site.
    ///
    /// * Latitude: The latitude of the site.
    ///
    /// * Longitude: The longitude of the site.
    public var location: NetworkManagerClientTypes.Location?
    /// The ID of your site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.siteId = siteId
    }
}

struct UpdateSiteInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let location: NetworkManagerClientTypes.Location?
}

extension UpdateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
    }
}

extension UpdateSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteOutputResponse(site: \(Swift.String(describing: site)))"}
}

extension UpdateSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct UpdateSiteOutputResponse: Swift.Equatable {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init (
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct UpdateSiteOutputResponseBody: Swift.Equatable {
    public let site: NetworkManagerClientTypes.Site?
}

extension UpdateSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

public struct UpdateVpcAttachmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVpcAttachmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVpcAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVpcAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVpcAttachmentOutputError>
}

extension UpdateVpcAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVpcAttachmentInput(addSubnetArns: \(Swift.String(describing: addSubnetArns)), attachmentId: \(Swift.String(describing: attachmentId)), options: \(Swift.String(describing: options)), removeSubnetArns: \(Swift.String(describing: removeSubnetArns)))"}
}

extension UpdateVpcAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addSubnetArns = "AddSubnetArns"
        case options = "Options"
        case removeSubnetArns = "RemoveSubnetArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addSubnetArns = addSubnetArns {
            var addSubnetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addSubnetArns)
            for subnetarnlist0 in addSubnetArns {
                try addSubnetArnsContainer.encode(subnetarnlist0)
            }
        }
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let removeSubnetArns = removeSubnetArns {
            var removeSubnetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeSubnetArns)
            for subnetarnlist0 in removeSubnetArns {
                try removeSubnetArnsContainer.encode(subnetarnlist0)
            }
        }
    }
}

public struct UpdateVpcAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVpcAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVpcAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVpcAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVpcAttachmentOutputError>
}

public struct UpdateVpcAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVpcAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVpcAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVpcAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVpcAttachmentOutputError>
}

public struct UpdateVpcAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVpcAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateVpcAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVpcAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVpcAttachmentOutputError>
}

public struct UpdateVpcAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVpcAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateVpcAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVpcAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let attachmentId = input.attachmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attachmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/vpc-attachments/\(attachmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVpcAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVpcAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVpcAttachmentOutputError>
}

public struct UpdateVpcAttachmentInput: Swift.Equatable {
    /// Adds a subnet ARN to the VPC attachment.
    public var addSubnetArns: [Swift.String]?
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?
    /// Additional options for updating the VPC attachment.
    public var options: NetworkManagerClientTypes.VpcOptions?
    /// Removes a subnet ARN from the attachment.
    public var removeSubnetArns: [Swift.String]?

    public init (
        addSubnetArns: [Swift.String]? = nil,
        attachmentId: Swift.String? = nil,
        options: NetworkManagerClientTypes.VpcOptions? = nil,
        removeSubnetArns: [Swift.String]? = nil
    )
    {
        self.addSubnetArns = addSubnetArns
        self.attachmentId = attachmentId
        self.options = options
        self.removeSubnetArns = removeSubnetArns
    }
}

struct UpdateVpcAttachmentInputBody: Swift.Equatable {
    public let addSubnetArns: [Swift.String]?
    public let removeSubnetArns: [Swift.String]?
    public let options: NetworkManagerClientTypes.VpcOptions?
}

extension UpdateVpcAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addSubnetArns = "AddSubnetArns"
        case options = "Options"
        case removeSubnetArns = "RemoveSubnetArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addSubnetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addSubnetArns)
        var addSubnetArnsDecoded0:[Swift.String]? = nil
        if let addSubnetArnsContainer = addSubnetArnsContainer {
            addSubnetArnsDecoded0 = [Swift.String]()
            for string0 in addSubnetArnsContainer {
                if let string0 = string0 {
                    addSubnetArnsDecoded0?.append(string0)
                }
            }
        }
        addSubnetArns = addSubnetArnsDecoded0
        let removeSubnetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeSubnetArns)
        var removeSubnetArnsDecoded0:[Swift.String]? = nil
        if let removeSubnetArnsContainer = removeSubnetArnsContainer {
            removeSubnetArnsDecoded0 = [Swift.String]()
            for string0 in removeSubnetArnsContainer {
                if let string0 = string0 {
                    removeSubnetArnsDecoded0?.append(string0)
                }
            }
        }
        removeSubnetArns = removeSubnetArnsDecoded0
        let optionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcOptions.self, forKey: .options)
        options = optionsDecoded
    }
}

extension UpdateVpcAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVpcAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVpcAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVpcAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVpcAttachmentOutputResponse(vpcAttachment: \(Swift.String(describing: vpcAttachment)))"}
}

extension UpdateVpcAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateVpcAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcAttachment = output.vpcAttachment
        } else {
            self.vpcAttachment = nil
        }
    }
}

public struct UpdateVpcAttachmentOutputResponse: Swift.Equatable {
    /// Describes the updated VPC attachment.
    public var vpcAttachment: NetworkManagerClientTypes.VpcAttachment?

    public init (
        vpcAttachment: NetworkManagerClientTypes.VpcAttachment? = nil
    )
    {
        self.vpcAttachment = vpcAttachment
    }
}

struct UpdateVpcAttachmentOutputResponseBody: Swift.Equatable {
    public let vpcAttachment: NetworkManagerClientTypes.VpcAttachment?
}

extension UpdateVpcAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcAttachment = "VpcAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcAttachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcAttachment.self, forKey: .vpcAttachment)
        vpcAttachment = vpcAttachmentDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(fields: \(Swift.String(describing: fields)), message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error, if applicable.
    public var fields: [NetworkManagerClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason for the error.
    public var reason: NetworkManagerClientTypes.ValidationExceptionReason?

    public init (
        fields: [NetworkManagerClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: NetworkManagerClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: NetworkManagerClientTypes.ValidationExceptionReason?
    public let fields: [NetworkManagerClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[NetworkManagerClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [NetworkManagerClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension NetworkManagerClientTypes.ValidationExceptionField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.ValidationExceptionField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationExceptionField(message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a validation exception for a field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message for the field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CannotParse"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .other: return "Other"
            case .unknownOperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.VpcAttachment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
        case options = "Options"
        case subnetArns = "SubnetArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachment = attachment {
            try encodeContainer.encode(attachment, forKey: .attachment)
        }
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let subnetArns = subnetArns {
            var subnetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetArns)
            for subnetarnlist0 in subnetArns {
                try subnetArnsContainer.encode(subnetarnlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let subnetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetArns)
        var subnetArnsDecoded0:[Swift.String]? = nil
        if let subnetArnsContainer = subnetArnsContainer {
            subnetArnsDecoded0 = [Swift.String]()
            for string0 in subnetArnsContainer {
                if let string0 = string0 {
                    subnetArnsDecoded0?.append(string0)
                }
            }
        }
        subnetArns = subnetArnsDecoded0
        let optionsDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.VpcOptions.self, forKey: .options)
        options = optionsDecoded
    }
}

extension NetworkManagerClientTypes.VpcAttachment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcAttachment(attachment: \(Swift.String(describing: attachment)), options: \(Swift.String(describing: options)), subnetArns: \(Swift.String(describing: subnetArns)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a VPC attachment.
    public struct VpcAttachment: Swift.Equatable {
        /// Provides details about the VPC attachment.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// Provides details about the VPC attachment.
        public var options: NetworkManagerClientTypes.VpcOptions?
        /// The subnet ARNs.
        public var subnetArns: [Swift.String]?

        public init (
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            options: NetworkManagerClientTypes.VpcOptions? = nil,
            subnetArns: [Swift.String]? = nil
        )
        {
            self.attachment = attachment
            self.options = options
            self.subnetArns = subnetArns
        }
    }

}

extension NetworkManagerClientTypes.VpcOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv6Support = "Ipv6Support"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if ipv6Support != false {
            try encodeContainer.encode(ipv6Support, forKey: .ipv6Support)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv6SupportDecoded = try containerValues.decode(Swift.Bool.self, forKey: .ipv6Support)
        ipv6Support = ipv6SupportDecoded
    }
}

extension NetworkManagerClientTypes.VpcOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcOptions(ipv6Support: \(Swift.String(describing: ipv6Support)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the VPC options.
    public struct VpcOptions: Swift.Equatable {
        /// Indicates whether IPv6 is supported.
        public var ipv6Support: Swift.Bool

        public init (
            ipv6Support: Swift.Bool = false
        )
        {
            self.ipv6Support = ipv6Support
        }
    }

}
