// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension NetworkManagerClientTypes.AWSLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetArn = "SubnetArn"
        case zone = "Zone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetArn = subnetArn {
            try encodeContainer.encode(subnetArn, forKey: .subnetArn)
        }
        if let zone = zone {
            try encodeContainer.encode(zone, forKey: .zone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zone)
        zone = zoneDecoded
        let subnetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetArn)
        subnetArn = subnetArnDecoded
    }
}

extension NetworkManagerClientTypes.AWSLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AWSLocation(subnetArn: \(Swift.String(describing: subnetArn)), zone: \(Swift.String(describing: zone)))"}
}

extension NetworkManagerClientTypes {
    /// Specifies a location in AWS.
    public struct AWSLocation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the subnet the device is located in.
        public var subnetArn: Swift.String?
        /// The Zone the device is located in. This can be the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
        public var zone: Swift.String?

        public init (
            subnetArn: Swift.String? = nil,
            zone: Swift.String? = nil
        )
        {
            self.subnetArn = subnetArn
            self.zone = zone
        }
    }

}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateCustomerGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomerGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomerGatewayOutputError>
}

extension AssociateCustomerGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateCustomerGatewayInput(customerGatewayArn: \(Swift.String(describing: customerGatewayArn)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension AssociateCustomerGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerGatewayArn = customerGatewayArn {
            try encodeContainer.encode(customerGatewayArn, forKey: .customerGatewayArn)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

public struct AssociateCustomerGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomerGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomerGatewayOutputError>
}

public struct AssociateCustomerGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomerGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomerGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomerGatewayOutputError>
}

public struct AssociateCustomerGatewayInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomerGatewayInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateCustomerGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateCustomerGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomerGatewayOutputError>
}

public struct AssociateCustomerGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomerGatewayInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateCustomerGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateCustomerGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomerGatewayOutputError>
}

public struct AssociateCustomerGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the customer gateway. For more information, see [Resources Defined by Amazon EC2](https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazonec2.html#amazonec2-resources-for-iam-policies).
    /// This member is required.
    public var customerGatewayArn: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?

    public init (
        customerGatewayArn: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct AssociateCustomerGatewayInputBody: Swift.Equatable {
    public let customerGatewayArn: Swift.String?
    public let deviceId: Swift.String?
    public let linkId: Swift.String?
}

extension AssociateCustomerGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerGatewayArn)
        customerGatewayArn = customerGatewayArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateCustomerGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCustomerGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateCustomerGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCustomerGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateCustomerGatewayOutputResponse(customerGatewayAssociation: \(Swift.String(describing: customerGatewayAssociation)))"}
}

extension AssociateCustomerGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateCustomerGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerGatewayAssociation = output.customerGatewayAssociation
        } else {
            self.customerGatewayAssociation = nil
        }
    }
}

public struct AssociateCustomerGatewayOutputResponse: Swift.Equatable {
    /// The customer gateway association.
    public var customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?

    public init (
        customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation? = nil
    )
    {
        self.customerGatewayAssociation = customerGatewayAssociation
    }
}

struct AssociateCustomerGatewayOutputResponseBody: Swift.Equatable {
    public let customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?
}

extension AssociateCustomerGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayAssociation = "CustomerGatewayAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CustomerGatewayAssociation.self, forKey: .customerGatewayAssociation)
        customerGatewayAssociation = customerGatewayAssociationDecoded
    }
}

public struct AssociateLinkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLinkOutputError>
}

extension AssociateLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateLinkInput(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension AssociateLinkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

public struct AssociateLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLinkOutputError>
}

public struct AssociateLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLinkOutputError>
}

public struct AssociateLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLinkOutputError>
}

public struct AssociateLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLinkOutputError>
}

public struct AssociateLinkInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct AssociateLinkInputBody: Swift.Equatable {
    public let deviceId: Swift.String?
    public let linkId: Swift.String?
}

extension AssociateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateLinkOutputResponse(linkAssociation: \(Swift.String(describing: linkAssociation)))"}
}

extension AssociateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkAssociation = output.linkAssociation
        } else {
            self.linkAssociation = nil
        }
    }
}

public struct AssociateLinkOutputResponse: Swift.Equatable {
    /// The link association.
    public var linkAssociation: NetworkManagerClientTypes.LinkAssociation?

    public init (
        linkAssociation: NetworkManagerClientTypes.LinkAssociation? = nil
    )
    {
        self.linkAssociation = linkAssociation
    }
}

struct AssociateLinkOutputResponseBody: Swift.Equatable {
    public let linkAssociation: NetworkManagerClientTypes.LinkAssociation?
}

extension AssociateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkAssociation = "LinkAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkAssociation.self, forKey: .linkAssociation)
        linkAssociation = linkAssociationDecoded
    }
}

public struct AssociateTransitGatewayConnectPeerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTransitGatewayConnectPeerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

extension AssociateTransitGatewayConnectPeerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTransitGatewayConnectPeerInput(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), transitGatewayConnectPeerArn: \(Swift.String(describing: transitGatewayConnectPeerArn)))"}
}

extension AssociateTransitGatewayConnectPeerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let transitGatewayConnectPeerArn = transitGatewayConnectPeerArn {
            try encodeContainer.encode(transitGatewayConnectPeerArn, forKey: .transitGatewayConnectPeerArn)
        }
    }
}

public struct AssociateTransitGatewayConnectPeerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTransitGatewayConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

public struct AssociateTransitGatewayConnectPeerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTransitGatewayConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTransitGatewayConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

public struct AssociateTransitGatewayConnectPeerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTransitGatewayConnectPeerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateTransitGatewayConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateTransitGatewayConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

public struct AssociateTransitGatewayConnectPeerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTransitGatewayConnectPeerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateTransitGatewayConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateTransitGatewayConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

public struct AssociateTransitGatewayConnectPeerInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Connect peer.
    /// This member is required.
    public var transitGatewayConnectPeerArn: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        transitGatewayConnectPeerArn: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

struct AssociateTransitGatewayConnectPeerInputBody: Swift.Equatable {
    public let transitGatewayConnectPeerArn: Swift.String?
    public let deviceId: Swift.String?
    public let linkId: Swift.String?
}

extension AssociateTransitGatewayConnectPeerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayConnectPeerArn)
        transitGatewayConnectPeerArn = transitGatewayConnectPeerArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateTransitGatewayConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTransitGatewayConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateTransitGatewayConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTransitGatewayConnectPeerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTransitGatewayConnectPeerOutputResponse(transitGatewayConnectPeerAssociation: \(Swift.String(describing: transitGatewayConnectPeerAssociation)))"}
}

extension AssociateTransitGatewayConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateTransitGatewayConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayConnectPeerAssociation = output.transitGatewayConnectPeerAssociation
        } else {
            self.transitGatewayConnectPeerAssociation = nil
        }
    }
}

public struct AssociateTransitGatewayConnectPeerOutputResponse: Swift.Equatable {
    /// The transit gateway Connect peer association.
    public var transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?

    public init (
        transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation? = nil
    )
    {
        self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
    }
}

struct AssociateTransitGatewayConnectPeerOutputResponseBody: Swift.Equatable {
    public let transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?
}

extension AssociateTransitGatewayConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation.self, forKey: .transitGatewayConnectPeerAssociation)
        transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociationDecoded
    }
}

extension NetworkManagerClientTypes.Bandwidth: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadSpeed = "DownloadSpeed"
        case uploadSpeed = "UploadSpeed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downloadSpeed = downloadSpeed {
            try encodeContainer.encode(downloadSpeed, forKey: .downloadSpeed)
        }
        if let uploadSpeed = uploadSpeed {
            try encodeContainer.encode(uploadSpeed, forKey: .uploadSpeed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadSpeedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uploadSpeed)
        uploadSpeed = uploadSpeedDecoded
        let downloadSpeedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downloadSpeed)
        downloadSpeed = downloadSpeedDecoded
    }
}

extension NetworkManagerClientTypes.Bandwidth: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Bandwidth(downloadSpeed: \(Swift.String(describing: downloadSpeed)), uploadSpeed: \(Swift.String(describing: uploadSpeed)))"}
}

extension NetworkManagerClientTypes {
    /// Describes bandwidth information.
    public struct Bandwidth: Swift.Equatable {
        /// Download speed in Mbps.
        public var downloadSpeed: Swift.Int?
        /// Upload speed in Mbps.
        public var uploadSpeed: Swift.Int?

        public init (
            downloadSpeed: Swift.Int? = nil,
            uploadSpeed: Swift.Int? = nil
        )
        {
            self.downloadSpeed = downloadSpeed
            self.uploadSpeed = uploadSpeed
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict processing the request. Updating or deleting the resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension NetworkManagerClientTypes.Connection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case connectionArn = "ConnectionArn"
        case connectionId = "ConnectionId"
        case createdAt = "CreatedAt"
        case description = "Description"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedDeviceId = connectedDeviceId {
            try encodeContainer.encode(connectedDeviceId, forKey: .connectedDeviceId)
        }
        if let connectedLinkId = connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let connectedDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedDeviceId)
        connectedDeviceId = connectedDeviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ConnectionState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.Connection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Connection(connectedDeviceId: \(Swift.String(describing: connectedDeviceId)), connectedLinkId: \(Swift.String(describing: connectedLinkId)), connectionArn: \(Swift.String(describing: connectionArn)), connectionId: \(Swift.String(describing: connectionId)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a connection.
    public struct Connection: Swift.Equatable {
        /// The ID of the second device in the connection.
        public var connectedDeviceId: Swift.String?
        /// The ID of the link for the second device in the connection.
        public var connectedLinkId: Swift.String?
        /// The Amazon Resource Name (ARN) of the connection.
        public var connectionArn: Swift.String?
        /// The ID of the connection.
        public var connectionId: Swift.String?
        /// The date and time that the connection was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the connection.
        public var description: Swift.String?
        /// The ID of the first device in the connection.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link for the first device in the connection.
        public var linkId: Swift.String?
        /// The state of the connection.
        public var state: NetworkManagerClientTypes.ConnectionState?
        /// The tags for the connection.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            connectedDeviceId: Swift.String? = nil,
            connectedLinkId: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.ConnectionState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.connectedDeviceId = connectedDeviceId
            self.connectedLinkId = connectedLinkId
            self.connectionArn = connectionArn
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.description = description
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
        }
    }
}

public struct CreateConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionInput(connectedDeviceId: \(Swift.String(describing: connectedDeviceId)), connectedLinkId: \(Swift.String(describing: connectedLinkId)), description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedDeviceId = connectedDeviceId {
            try encodeContainer.encode(connectedDeviceId, forKey: .connectedDeviceId)
        }
        if let connectedLinkId = connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Swift.Equatable {
    /// The ID of the second device in the connection.
    /// This member is required.
    public var connectedDeviceId: Swift.String?
    /// The ID of the link for the second device.
    public var connectedLinkId: Swift.String?
    /// A description of the connection. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the first device in the connection.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link for the first device.
    public var linkId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        connectedDeviceId: Swift.String? = nil,
        connectedLinkId: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.connectedDeviceId = connectedDeviceId
        self.connectedLinkId = connectedLinkId
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Swift.Equatable {
    public let deviceId: Swift.String?
    public let connectedDeviceId: Swift.String?
    public let linkId: Swift.String?
    public let connectedLinkId: Swift.String?
    public let description: Swift.String?
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let connectedDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedDeviceId)
        connectedDeviceId = connectedDeviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension CreateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Swift.Equatable {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init (
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct CreateConnectionOutputResponseBody: Swift.Equatable {
    public let connection: NetworkManagerClientTypes.Connection?
}

extension CreateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct CreateDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceOutputError>
}

extension CreateDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeviceInput(aWSLocation: \(Swift.String(describing: aWSLocation)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)))"}
}

extension CreateDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSLocation = aWSLocation {
            try encodeContainer.encode(aWSLocation, forKey: .aWSLocation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }
}

public struct CreateDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceOutputError>
}

public struct CreateDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceOutputError>
}

public struct CreateDeviceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceOutputError>
}

public struct CreateDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceOutputError>
}

public struct CreateDeviceInput: Swift.Equatable {
    /// The AWS location of the device.
    public var aWSLocation: NetworkManagerClientTypes.AWSLocation?
    /// A description of the device. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The location of the device.
    public var location: NetworkManagerClientTypes.Location?
    /// The model of the device. Length Constraints: Maximum length of 128 characters.
    public var model: Swift.String?
    /// The serial number of the device. Length Constraints: Maximum length of 128 characters.
    public var serialNumber: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The type of the device.
    public var type: Swift.String?
    /// The vendor of the device. Length Constraints: Maximum length of 128 characters.
    public var vendor: Swift.String?

    public init (
        aWSLocation: NetworkManagerClientTypes.AWSLocation? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        model: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        type: Swift.String? = nil,
        vendor: Swift.String? = nil
    )
    {
        self.aWSLocation = aWSLocation
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.tags = tags
        self.type = type
        self.vendor = vendor
    }
}

struct CreateDeviceInputBody: Swift.Equatable {
    public let aWSLocation: NetworkManagerClientTypes.AWSLocation?
    public let description: Swift.String?
    public let type: Swift.String?
    public let vendor: Swift.String?
    public let model: Swift.String?
    public let serialNumber: Swift.String?
    public let location: NetworkManagerClientTypes.Location?
    public let siteId: Swift.String?
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aWSLocationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AWSLocation.self, forKey: .aWSLocation)
        aWSLocation = aWSLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeviceOutputResponse(device: \(Swift.String(describing: device)))"}
}

extension CreateDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct CreateDeviceOutputResponse: Swift.Equatable {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init (
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct CreateDeviceOutputResponseBody: Swift.Equatable {
    public let device: NetworkManagerClientTypes.Device?
}

extension CreateDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct CreateGlobalNetworkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalNetworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalNetworkOutputError>
}

extension CreateGlobalNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlobalNetworkInput(description: \(Swift.String(describing: description)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateGlobalNetworkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateGlobalNetworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalNetworkOutputError>
}

public struct CreateGlobalNetworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalNetworkOutputError>
}

public struct CreateGlobalNetworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalNetworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalNetworkOutputError>
}

public struct CreateGlobalNetworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalNetworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/global-networks"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalNetworkOutputError>
}

public struct CreateGlobalNetworkInput: Swift.Equatable {
    /// A description of the global network. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.tags = tags
    }
}

struct CreateGlobalNetworkInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateGlobalNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGlobalNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGlobalNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGlobalNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGlobalNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlobalNetworkOutputResponse(globalNetwork: \(Swift.String(describing: globalNetwork)))"}
}

extension CreateGlobalNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct CreateGlobalNetworkOutputResponse: Swift.Equatable {
    /// Information about the global network object.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init (
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct CreateGlobalNetworkOutputResponseBody: Swift.Equatable {
    public let globalNetwork: NetworkManagerClientTypes.GlobalNetwork?
}

extension CreateGlobalNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

public struct CreateLinkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLinkOutputError>
}

extension CreateLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLinkInput(bandwidth: \(Swift.String(describing: bandwidth)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), provider: \(Swift.String(describing: provider)), siteId: \(Swift.String(describing: siteId)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateLinkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct CreateLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLinkOutputError>
}

public struct CreateLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLinkOutputError>
}

public struct CreateLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLinkOutputError>
}

public struct CreateLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/links"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLinkOutputError>
}

public struct CreateLinkInput: Swift.Equatable {
    /// The upload speed and download speed in Mbps.
    /// This member is required.
    public var bandwidth: NetworkManagerClientTypes.Bandwidth?
    /// A description of the link. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The provider of the link. Constraints: Cannot include the following characters: | \ ^ Length Constraints: Maximum length of 128 characters.
    public var provider: Swift.String?
    /// The ID of the site.
    /// This member is required.
    public var siteId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The type of the link. Constraints: Cannot include the following characters: | \ ^ Length Constraints: Maximum length of 128 characters.
    public var type: Swift.String?

    public init (
        bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        provider: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        type: Swift.String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.provider = provider
        self.siteId = siteId
        self.tags = tags
        self.type = type
    }
}

struct CreateLinkInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let type: Swift.String?
    public let bandwidth: NetworkManagerClientTypes.Bandwidth?
    public let provider: Swift.String?
    public let siteId: Swift.String?
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLinkOutputResponse(link: \(Swift.String(describing: link)))"}
}

extension CreateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct CreateLinkOutputResponse: Swift.Equatable {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init (
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

struct CreateLinkOutputResponseBody: Swift.Equatable {
    public let link: NetworkManagerClientTypes.Link?
}

extension CreateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case link = "Link"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Link.self, forKey: .link)
        link = linkDecoded
    }
}

public struct CreateSiteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

extension CreateSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSiteInput(description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSiteInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInput: Swift.Equatable {
    /// A description of your site. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.
    ///
    /// * Address: The physical address of the site.
    ///
    /// * Latitude: The latitude of the site.
    ///
    /// * Longitude: The longitude of the site.
    public var location: NetworkManagerClientTypes.Location?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.tags = tags
    }
}

struct CreateSiteInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let location: NetworkManagerClientTypes.Location?
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension CreateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSiteOutputResponse(site: \(Swift.String(describing: site)))"}
}

extension CreateSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct CreateSiteOutputResponse: Swift.Equatable {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init (
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct CreateSiteOutputResponseBody: Swift.Equatable {
    public let site: NetworkManagerClientTypes.Site?
}

extension CreateSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension NetworkManagerClientTypes.CustomerGatewayAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerGatewayArn = customerGatewayArn {
            try encodeContainer.encode(customerGatewayArn, forKey: .customerGatewayArn)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerGatewayArn)
        customerGatewayArn = customerGatewayArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CustomerGatewayAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes.CustomerGatewayAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerGatewayAssociation(customerGatewayArn: \(Swift.String(describing: customerGatewayArn)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), state: \(Swift.String(describing: state)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the association between a customer gateway, a device, and a link.
    public struct CustomerGatewayAssociation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the customer gateway.
        public var customerGatewayArn: Swift.String?
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The association state.
        public var state: NetworkManagerClientTypes.CustomerGatewayAssociationState?

        public init (
            customerGatewayArn: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.CustomerGatewayAssociationState? = nil
        )
        {
            self.customerGatewayArn = customerGatewayArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }
    }

}

extension NetworkManagerClientTypes {
    public enum CustomerGatewayAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerGatewayAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomerGatewayAssociationState(rawValue: rawValue) ?? CustomerGatewayAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension DeleteConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionInput(connectionId: \(Swift.String(describing: connectionId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension DeleteConnectionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let connectionId = input.connectionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("connectionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections/\(connectionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Swift.Equatable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        connectionId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
}

extension DeleteConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init (
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    public let connection: NetworkManagerClientTypes.Connection?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension DeleteDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDeviceInput(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension DeleteDeviceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let deviceId = input.deviceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deviceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteDeviceInputBody: Swift.Equatable {
}

extension DeleteDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDeviceOutputResponse(device: \(Swift.String(describing: device)))"}
}

extension DeleteDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct DeleteDeviceOutputResponse: Swift.Equatable {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init (
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct DeleteDeviceOutputResponseBody: Swift.Equatable {
    public let device: NetworkManagerClientTypes.Device?
}

extension DeleteDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

extension DeleteGlobalNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGlobalNetworkInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension DeleteGlobalNetworkInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteGlobalNetworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalNetworkOutputError>
}

public struct DeleteGlobalNetworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalNetworkOutputError>
}

public struct DeleteGlobalNetworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalNetworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalNetworkOutputError>
}

public struct DeleteGlobalNetworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalNetworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalNetworkOutputError>
}

public struct DeleteGlobalNetworkInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteGlobalNetworkInputBody: Swift.Equatable {
}

extension DeleteGlobalNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGlobalNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGlobalNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGlobalNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGlobalNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGlobalNetworkOutputResponse(globalNetwork: \(Swift.String(describing: globalNetwork)))"}
}

extension DeleteGlobalNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct DeleteGlobalNetworkOutputResponse: Swift.Equatable {
    /// Information about the global network.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init (
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct DeleteGlobalNetworkOutputResponseBody: Swift.Equatable {
    public let globalNetwork: NetworkManagerClientTypes.GlobalNetwork?
}

extension DeleteGlobalNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

extension DeleteLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLinkInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension DeleteLinkInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLinkOutputError>
}

public struct DeleteLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLinkOutputError>
}

public struct DeleteLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLinkOutputError>
}

public struct DeleteLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let linkId = input.linkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("linkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/links/\(linkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLinkOutputError>
}

public struct DeleteLinkInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct DeleteLinkInputBody: Swift.Equatable {
}

extension DeleteLinkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLinkOutputResponse(link: \(Swift.String(describing: link)))"}
}

extension DeleteLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct DeleteLinkOutputResponse: Swift.Equatable {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init (
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

struct DeleteLinkOutputResponseBody: Swift.Equatable {
    public let link: NetworkManagerClientTypes.Link?
}

extension DeleteLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case link = "Link"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Link.self, forKey: .link)
        link = linkDecoded
    }
}

extension DeleteSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSiteInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), siteId: \(Swift.String(describing: siteId)))"}
}

extension DeleteSiteInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites/\(siteId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.siteId = siteId
    }
}

struct DeleteSiteInputBody: Swift.Equatable {
}

extension DeleteSiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSiteOutputResponse(site: \(Swift.String(describing: site)))"}
}

extension DeleteSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct DeleteSiteOutputResponse: Swift.Equatable {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init (
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct DeleteSiteOutputResponseBody: Swift.Equatable {
    public let site: NetworkManagerClientTypes.Site?
}

extension DeleteSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension DeregisterTransitGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterTransitGatewayInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), transitGatewayArn: \(Swift.String(describing: transitGatewayArn)))"}
}

extension DeregisterTransitGatewayInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeregisterTransitGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTransitGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTransitGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTransitGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTransitGatewayOutputError>
}

public struct DeregisterTransitGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTransitGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTransitGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTransitGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTransitGatewayOutputError>
}

public struct DeregisterTransitGatewayInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTransitGatewayInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeregisterTransitGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterTransitGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTransitGatewayOutputError>
}

public struct DeregisterTransitGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTransitGatewayInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeregisterTransitGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let transitGatewayArn = input.transitGatewayArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("transitGatewayArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations/\(transitGatewayArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterTransitGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTransitGatewayOutputError>
}

public struct DeregisterTransitGatewayInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway.
    /// This member is required.
    public var transitGatewayArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        transitGatewayArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayArn = transitGatewayArn
    }
}

struct DeregisterTransitGatewayInputBody: Swift.Equatable {
}

extension DeregisterTransitGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterTransitGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTransitGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTransitGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTransitGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterTransitGatewayOutputResponse(transitGatewayRegistration: \(Swift.String(describing: transitGatewayRegistration)))"}
}

extension DeregisterTransitGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterTransitGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayRegistration = output.transitGatewayRegistration
        } else {
            self.transitGatewayRegistration = nil
        }
    }
}

public struct DeregisterTransitGatewayOutputResponse: Swift.Equatable {
    /// The transit gateway registration information.
    public var transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?

    public init (
        transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration? = nil
    )
    {
        self.transitGatewayRegistration = transitGatewayRegistration
    }
}

struct DeregisterTransitGatewayOutputResponseBody: Swift.Equatable {
    public let transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?
}

extension DeregisterTransitGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayRegistration = "TransitGatewayRegistration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistration.self, forKey: .transitGatewayRegistration)
        transitGatewayRegistration = transitGatewayRegistrationDecoded
    }
}

extension DescribeGlobalNetworksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGlobalNetworksInput(globalNetworkIds: \(Swift.String(describing: globalNetworkIds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeGlobalNetworksInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeGlobalNetworksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalNetworksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGlobalNetworksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGlobalNetworksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalNetworksOutputError>
}

public struct DescribeGlobalNetworksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalNetworksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGlobalNetworksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let globalNetworkIds = input.operationInput.globalNetworkIds {
            globalNetworkIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "globalNetworkIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGlobalNetworksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalNetworksOutputError>
}

public struct DescribeGlobalNetworksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalNetworksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeGlobalNetworksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGlobalNetworksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalNetworksOutputError>
}

public struct DescribeGlobalNetworksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalNetworksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeGlobalNetworksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/global-networks"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGlobalNetworksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalNetworksOutputError>
}

public struct DescribeGlobalNetworksInput: Swift.Equatable {
    /// The IDs of one or more global networks. The maximum is 10.
    public var globalNetworkIds: [Swift.String]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        globalNetworkIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.globalNetworkIds = globalNetworkIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeGlobalNetworksInputBody: Swift.Equatable {
}

extension DescribeGlobalNetworksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGlobalNetworksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGlobalNetworksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGlobalNetworksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGlobalNetworksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGlobalNetworksOutputResponse(globalNetworks: \(Swift.String(describing: globalNetworks)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeGlobalNetworksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGlobalNetworksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetworks = output.globalNetworks
            self.nextToken = output.nextToken
        } else {
            self.globalNetworks = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeGlobalNetworksOutputResponse: Swift.Equatable {
    /// Information about the global networks.
    public var globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.globalNetworks = globalNetworks
        self.nextToken = nextToken
    }
}

struct DescribeGlobalNetworksOutputResponseBody: Swift.Equatable {
    public let globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]?
    public let nextToken: Swift.String?
}

extension DescribeGlobalNetworksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetworks = "GlobalNetworks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworksContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.GlobalNetwork?].self, forKey: .globalNetworks)
        var globalNetworksDecoded0:[NetworkManagerClientTypes.GlobalNetwork]? = nil
        if let globalNetworksContainer = globalNetworksContainer {
            globalNetworksDecoded0 = [NetworkManagerClientTypes.GlobalNetwork]()
            for structure0 in globalNetworksContainer {
                if let structure0 = structure0 {
                    globalNetworksDecoded0?.append(structure0)
                }
            }
        }
        globalNetworks = globalNetworksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NetworkManagerClientTypes.Device: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSLocation = "AWSLocation"
        case createdAt = "CreatedAt"
        case description = "Description"
        case deviceArn = "DeviceArn"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSLocation = aWSLocation {
            try encodeContainer.encode(aWSLocation, forKey: .aWSLocation)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let aWSLocationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AWSLocation.self, forKey: .aWSLocation)
        aWSLocation = aWSLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.DeviceState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.Device: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Device(aWSLocation: \(Swift.String(describing: aWSLocation)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), deviceArn: \(Swift.String(describing: deviceArn)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a device.
    public struct Device: Swift.Equatable {
        /// The AWS location of the device.
        public var aWSLocation: NetworkManagerClientTypes.AWSLocation?
        /// The date and time that the site was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the device.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the device.
        public var deviceArn: Swift.String?
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The site location.
        public var location: NetworkManagerClientTypes.Location?
        /// The device model.
        public var model: Swift.String?
        /// The device serial number.
        public var serialNumber: Swift.String?
        /// The site ID.
        public var siteId: Swift.String?
        /// The device state.
        public var state: NetworkManagerClientTypes.DeviceState?
        /// The tags for the device.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The device type.
        public var type: Swift.String?
        /// The device vendor.
        public var vendor: Swift.String?

        public init (
            aWSLocation: NetworkManagerClientTypes.AWSLocation? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceArn: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            location: NetworkManagerClientTypes.Location? = nil,
            model: Swift.String? = nil,
            serialNumber: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.DeviceState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            type: Swift.String? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.aWSLocation = aWSLocation
            self.createdAt = createdAt
            self.description = description
            self.deviceArn = deviceArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.model = model
            self.serialNumber = serialNumber
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
            self.vendor = vendor
        }
    }

}

extension NetworkManagerClientTypes {
    public enum DeviceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceState(rawValue: rawValue) ?? DeviceState.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateCustomerGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateCustomerGatewayInput(customerGatewayArn: \(Swift.String(describing: customerGatewayArn)), globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension DisassociateCustomerGatewayInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateCustomerGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomerGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCustomerGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomerGatewayOutputError>
}

public struct DisassociateCustomerGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomerGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCustomerGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomerGatewayOutputError>
}

public struct DisassociateCustomerGatewayInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomerGatewayInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateCustomerGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateCustomerGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomerGatewayOutputError>
}

public struct DisassociateCustomerGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomerGatewayInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateCustomerGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let customerGatewayArn = input.customerGatewayArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("customerGatewayArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations/\(customerGatewayArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateCustomerGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomerGatewayOutputError>
}

public struct DisassociateCustomerGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the customer gateway. For more information, see [Resources Defined by Amazon EC2](https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazonec2.html#amazonec2-resources-for-iam-policies).
    /// This member is required.
    public var customerGatewayArn: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        customerGatewayArn: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.globalNetworkId = globalNetworkId
    }
}

struct DisassociateCustomerGatewayInputBody: Swift.Equatable {
}

extension DisassociateCustomerGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateCustomerGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCustomerGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateCustomerGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCustomerGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateCustomerGatewayOutputResponse(customerGatewayAssociation: \(Swift.String(describing: customerGatewayAssociation)))"}
}

extension DisassociateCustomerGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateCustomerGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerGatewayAssociation = output.customerGatewayAssociation
        } else {
            self.customerGatewayAssociation = nil
        }
    }
}

public struct DisassociateCustomerGatewayOutputResponse: Swift.Equatable {
    /// Information about the customer gateway association.
    public var customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?

    public init (
        customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation? = nil
    )
    {
        self.customerGatewayAssociation = customerGatewayAssociation
    }
}

struct DisassociateCustomerGatewayOutputResponseBody: Swift.Equatable {
    public let customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?
}

extension DisassociateCustomerGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayAssociation = "CustomerGatewayAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.CustomerGatewayAssociation.self, forKey: .customerGatewayAssociation)
        customerGatewayAssociation = customerGatewayAssociationDecoded
    }
}

extension DisassociateLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateLinkInput(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension DisassociateLinkInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLinkOutputError>
}

public struct DisassociateLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let deviceId = input.operationInput.deviceId {
            let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            input.builder.withQueryItem(deviceIdQueryItem)
        }
        if let linkId = input.operationInput.linkId {
            let linkIdQueryItem = ClientRuntime.URLQueryItem(name: "linkId".urlPercentEncoding(), value: Swift.String(linkId).urlPercentEncoding())
            input.builder.withQueryItem(linkIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLinkOutputError>
}

public struct DisassociateLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLinkOutputError>
}

public struct DisassociateLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLinkOutputError>
}

public struct DisassociateLinkInput: Swift.Equatable {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct DisassociateLinkInputBody: Swift.Equatable {
}

extension DisassociateLinkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateLinkOutputResponse(linkAssociation: \(Swift.String(describing: linkAssociation)))"}
}

extension DisassociateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkAssociation = output.linkAssociation
        } else {
            self.linkAssociation = nil
        }
    }
}

public struct DisassociateLinkOutputResponse: Swift.Equatable {
    /// Information about the link association.
    public var linkAssociation: NetworkManagerClientTypes.LinkAssociation?

    public init (
        linkAssociation: NetworkManagerClientTypes.LinkAssociation? = nil
    )
    {
        self.linkAssociation = linkAssociation
    }
}

struct DisassociateLinkOutputResponseBody: Swift.Equatable {
    public let linkAssociation: NetworkManagerClientTypes.LinkAssociation?
}

extension DisassociateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkAssociation = "LinkAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkAssociation.self, forKey: .linkAssociation)
        linkAssociation = linkAssociationDecoded
    }
}

extension DisassociateTransitGatewayConnectPeerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTransitGatewayConnectPeerInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), transitGatewayConnectPeerArn: \(Swift.String(describing: transitGatewayConnectPeerArn)))"}
}

extension DisassociateTransitGatewayConnectPeerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateTransitGatewayConnectPeerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTransitGatewayConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTransitGatewayConnectPeerOutputError>
}

public struct DisassociateTransitGatewayConnectPeerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTransitGatewayConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTransitGatewayConnectPeerOutputError>
}

public struct DisassociateTransitGatewayConnectPeerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTransitGatewayConnectPeerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateTransitGatewayConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateTransitGatewayConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTransitGatewayConnectPeerOutputError>
}

public struct DisassociateTransitGatewayConnectPeerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTransitGatewayConnectPeerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateTransitGatewayConnectPeerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let transitGatewayConnectPeerArn = input.transitGatewayConnectPeerArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("transitGatewayConnectPeerArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations/\(transitGatewayConnectPeerArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateTransitGatewayConnectPeerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTransitGatewayConnectPeerOutputError>
}

public struct DisassociateTransitGatewayConnectPeerInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
    /// This member is required.
    public var transitGatewayConnectPeerArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        transitGatewayConnectPeerArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

struct DisassociateTransitGatewayConnectPeerInputBody: Swift.Equatable {
}

extension DisassociateTransitGatewayConnectPeerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTransitGatewayConnectPeerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTransitGatewayConnectPeerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateTransitGatewayConnectPeerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTransitGatewayConnectPeerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTransitGatewayConnectPeerOutputResponse(transitGatewayConnectPeerAssociation: \(Swift.String(describing: transitGatewayConnectPeerAssociation)))"}
}

extension DisassociateTransitGatewayConnectPeerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateTransitGatewayConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayConnectPeerAssociation = output.transitGatewayConnectPeerAssociation
        } else {
            self.transitGatewayConnectPeerAssociation = nil
        }
    }
}

public struct DisassociateTransitGatewayConnectPeerOutputResponse: Swift.Equatable {
    /// The transit gateway Connect peer association.
    public var transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?

    public init (
        transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation? = nil
    )
    {
        self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
    }
}

struct DisassociateTransitGatewayConnectPeerOutputResponseBody: Swift.Equatable {
    public let transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?
}

extension DisassociateTransitGatewayConnectPeerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation.self, forKey: .transitGatewayConnectPeerAssociation)
        transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociationDecoded
    }
}

extension GetConnectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectionsInput(connectionIds: \(Swift.String(describing: connectionIds)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetConnectionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetConnectionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let deviceId = input.operationInput.deviceId {
            let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            input.builder.withQueryItem(deviceIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let connectionIds = input.operationInput.connectionIds {
            connectionIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "connectionIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetConnectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConnectionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetConnectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConnectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInput: Swift.Equatable {
    /// One or more connection IDs.
    public var connectionIds: [Swift.String]?
    /// The ID of the device.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connectionIds: [Swift.String]? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionIds = connectionIds
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetConnectionsInputBody: Swift.Equatable {
}

extension GetConnectionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectionsOutputResponse(connections: \(Swift.String(describing: connections)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
            self.nextToken = output.nextToken
        } else {
            self.connections = nil
            self.nextToken = nil
        }
    }
}

public struct GetConnectionsOutputResponse: Swift.Equatable {
    /// Information about the connections.
    public var connections: [NetworkManagerClientTypes.Connection]?
    /// The token to use for the next page of results.
    public var nextToken: Swift.String?

    public init (
        connections: [NetworkManagerClientTypes.Connection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

struct GetConnectionsOutputResponseBody: Swift.Equatable {
    public let connections: [NetworkManagerClientTypes.Connection]?
    public let nextToken: Swift.String?
}

extension GetConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[NetworkManagerClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [NetworkManagerClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCustomerGatewayAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCustomerGatewayAssociationsInput(customerGatewayArns: \(Swift.String(describing: customerGatewayArns)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetCustomerGatewayAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCustomerGatewayAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCustomerGatewayAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCustomerGatewayAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCustomerGatewayAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCustomerGatewayAssociationsOutputError>
}

public struct GetCustomerGatewayAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCustomerGatewayAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCustomerGatewayAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let customerGatewayArns = input.operationInput.customerGatewayArns {
            customerGatewayArns.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "customerGatewayArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCustomerGatewayAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCustomerGatewayAssociationsOutputError>
}

public struct GetCustomerGatewayAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCustomerGatewayAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCustomerGatewayAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCustomerGatewayAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCustomerGatewayAssociationsOutputError>
}

public struct GetCustomerGatewayAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCustomerGatewayAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCustomerGatewayAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCustomerGatewayAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCustomerGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCustomerGatewayAssociationsOutputError>
}

public struct GetCustomerGatewayAssociationsInput: Swift.Equatable {
    /// One or more customer gateway Amazon Resource Names (ARNs). For more information, see [Resources Defined by Amazon EC2](https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazonec2.html#amazonec2-resources-for-iam-policies). The maximum is 10.
    public var customerGatewayArns: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        customerGatewayArns: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerGatewayArns = customerGatewayArns
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCustomerGatewayAssociationsInputBody: Swift.Equatable {
}

extension GetCustomerGatewayAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCustomerGatewayAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCustomerGatewayAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCustomerGatewayAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCustomerGatewayAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCustomerGatewayAssociationsOutputResponse(customerGatewayAssociations: \(Swift.String(describing: customerGatewayAssociations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetCustomerGatewayAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCustomerGatewayAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerGatewayAssociations = output.customerGatewayAssociations
            self.nextToken = output.nextToken
        } else {
            self.customerGatewayAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct GetCustomerGatewayAssociationsOutputResponse: Swift.Equatable {
    /// The customer gateway associations.
    public var customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerGatewayAssociations = customerGatewayAssociations
        self.nextToken = nextToken
    }
}

struct GetCustomerGatewayAssociationsOutputResponseBody: Swift.Equatable {
    public let customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]?
    public let nextToken: Swift.String?
}

extension GetCustomerGatewayAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerGatewayAssociations = "CustomerGatewayAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.CustomerGatewayAssociation?].self, forKey: .customerGatewayAssociations)
        var customerGatewayAssociationsDecoded0:[NetworkManagerClientTypes.CustomerGatewayAssociation]? = nil
        if let customerGatewayAssociationsContainer = customerGatewayAssociationsContainer {
            customerGatewayAssociationsDecoded0 = [NetworkManagerClientTypes.CustomerGatewayAssociation]()
            for structure0 in customerGatewayAssociationsContainer {
                if let structure0 = structure0 {
                    customerGatewayAssociationsDecoded0?.append(structure0)
                }
            }
        }
        customerGatewayAssociations = customerGatewayAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDevicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicesInput(deviceIds: \(Swift.String(describing: deviceIds)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), siteId: \(Swift.String(describing: siteId)))"}
}

extension GetDevicesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDevicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesOutputError>
}

public struct GetDevicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let deviceIds = input.operationInput.deviceIds {
            deviceIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "deviceIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let siteId = input.operationInput.siteId {
            let siteIdQueryItem = ClientRuntime.URLQueryItem(name: "siteId".urlPercentEncoding(), value: Swift.String(siteId).urlPercentEncoding())
            input.builder.withQueryItem(siteIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesOutputError>
}

public struct GetDevicesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDevicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesOutputError>
}

public struct GetDevicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDevicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesOutputError>
}

public struct GetDevicesInput: Swift.Equatable {
    /// One or more device IDs. The maximum is 10.
    public var deviceIds: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?

    public init (
        deviceIds: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.siteId = siteId
    }
}

struct GetDevicesInputBody: Swift.Equatable {
}

extension GetDevicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicesOutputResponse(devices: \(Swift.String(describing: devices)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct GetDevicesOutputResponse: Swift.Equatable {
    /// The devices.
    public var devices: [NetworkManagerClientTypes.Device]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        devices: [NetworkManagerClientTypes.Device]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct GetDevicesOutputResponseBody: Swift.Equatable {
    public let devices: [NetworkManagerClientTypes.Device]?
    public let nextToken: Swift.String?
}

extension GetDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[NetworkManagerClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [NetworkManagerClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetLinkAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLinkAssociationsInput(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetLinkAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLinkAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinkAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinkAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAssociationsOutputError>
}

public struct GetLinkAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinkAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let deviceId = input.operationInput.deviceId {
            let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            input.builder.withQueryItem(deviceIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let linkId = input.operationInput.linkId {
            let linkIdQueryItem = ClientRuntime.URLQueryItem(name: "linkId".urlPercentEncoding(), value: Swift.String(linkId).urlPercentEncoding())
            input.builder.withQueryItem(linkIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinkAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAssociationsOutputError>
}

public struct GetLinkAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLinkAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLinkAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAssociationsOutputError>
}

public struct GetLinkAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLinkAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLinkAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAssociationsOutputError>
}

public struct GetLinkAssociationsInput: Swift.Equatable {
    /// The ID of the device.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetLinkAssociationsInputBody: Swift.Equatable {
}

extension GetLinkAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLinkAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLinkAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLinkAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLinkAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLinkAssociationsOutputResponse(linkAssociations: \(Swift.String(describing: linkAssociations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetLinkAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLinkAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkAssociations = output.linkAssociations
            self.nextToken = output.nextToken
        } else {
            self.linkAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct GetLinkAssociationsOutputResponse: Swift.Equatable {
    /// The link associations.
    public var linkAssociations: [NetworkManagerClientTypes.LinkAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        linkAssociations: [NetworkManagerClientTypes.LinkAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkAssociations = linkAssociations
        self.nextToken = nextToken
    }
}

struct GetLinkAssociationsOutputResponseBody: Swift.Equatable {
    public let linkAssociations: [NetworkManagerClientTypes.LinkAssociation]?
    public let nextToken: Swift.String?
}

extension GetLinkAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkAssociations = "LinkAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.LinkAssociation?].self, forKey: .linkAssociations)
        var linkAssociationsDecoded0:[NetworkManagerClientTypes.LinkAssociation]? = nil
        if let linkAssociationsContainer = linkAssociationsContainer {
            linkAssociationsDecoded0 = [NetworkManagerClientTypes.LinkAssociation]()
            for structure0 in linkAssociationsContainer {
                if let structure0 = structure0 {
                    linkAssociationsDecoded0?.append(structure0)
                }
            }
        }
        linkAssociations = linkAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetLinksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLinksInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkIds: \(Swift.String(describing: linkIds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), provider: \(Swift.String(describing: provider)), siteId: \(Swift.String(describing: siteId)), type: \(Swift.String(describing: type)))"}
}

extension GetLinksInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLinksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinksOutputError>
}

public struct GetLinksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let siteId = input.operationInput.siteId {
            let siteIdQueryItem = ClientRuntime.URLQueryItem(name: "siteId".urlPercentEncoding(), value: Swift.String(siteId).urlPercentEncoding())
            input.builder.withQueryItem(siteIdQueryItem)
        }
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let linkIds = input.operationInput.linkIds {
            linkIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "linkIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let provider = input.operationInput.provider {
            let providerQueryItem = ClientRuntime.URLQueryItem(name: "provider".urlPercentEncoding(), value: Swift.String(provider).urlPercentEncoding())
            input.builder.withQueryItem(providerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinksOutputError>
}

public struct GetLinksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLinksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLinksInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinksOutputError>
}

public struct GetLinksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLinksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/links"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLinksInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinksOutputError>
}

public struct GetLinksInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// One or more link IDs. The maximum is 10.
    public var linkIds: [Swift.String]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The link provider.
    public var provider: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The link type.
    public var type: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        linkIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        provider: Swift.String? = nil,
        siteId: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.linkIds = linkIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provider = provider
        self.siteId = siteId
        self.type = type
    }
}

struct GetLinksInputBody: Swift.Equatable {
}

extension GetLinksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLinksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLinksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLinksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLinksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLinksOutputResponse(links: \(Swift.String(describing: links)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetLinksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLinksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.links = output.links
            self.nextToken = output.nextToken
        } else {
            self.links = nil
            self.nextToken = nil
        }
    }
}

public struct GetLinksOutputResponse: Swift.Equatable {
    /// The links.
    public var links: [NetworkManagerClientTypes.Link]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        links: [NetworkManagerClientTypes.Link]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.links = links
        self.nextToken = nextToken
    }
}

struct GetLinksOutputResponseBody: Swift.Equatable {
    public let links: [NetworkManagerClientTypes.Link]?
    public let nextToken: Swift.String?
}

extension GetLinksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case links = "Links"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linksContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Link?].self, forKey: .links)
        var linksDecoded0:[NetworkManagerClientTypes.Link]? = nil
        if let linksContainer = linksContainer {
            linksDecoded0 = [NetworkManagerClientTypes.Link]()
            for structure0 in linksContainer {
                if let structure0 = structure0 {
                    linksDecoded0?.append(structure0)
                }
            }
        }
        links = linksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSitesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSitesInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), siteIds: \(Swift.String(describing: siteIds)))"}
}

extension GetSitesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSitesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSitesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSitesOutputError>
}

public struct GetSitesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSitesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let siteIds = input.operationInput.siteIds {
            siteIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "siteIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSitesOutputError>
}

public struct GetSitesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSitesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSitesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSitesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSitesOutputError>
}

public struct GetSitesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSitesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSitesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSitesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSitesOutputError>
}

public struct GetSitesInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// One or more site IDs. The maximum is 10.
    public var siteIds: [Swift.String]?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        siteIds: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.siteIds = siteIds
    }
}

struct GetSitesInputBody: Swift.Equatable {
}

extension GetSitesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSitesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSitesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSitesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sites: \(Swift.String(describing: sites)))"}
}

extension GetSitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sites = output.sites
        } else {
            self.nextToken = nil
            self.sites = nil
        }
    }
}

public struct GetSitesOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The sites.
    public var sites: [NetworkManagerClientTypes.Site]?

    public init (
        nextToken: Swift.String? = nil,
        sites: [NetworkManagerClientTypes.Site]? = nil
    )
    {
        self.nextToken = nextToken
        self.sites = sites
    }
}

struct GetSitesOutputResponseBody: Swift.Equatable {
    public let sites: [NetworkManagerClientTypes.Site]?
    public let nextToken: Swift.String?
}

extension GetSitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sites = "Sites"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sitesContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Site?].self, forKey: .sites)
        var sitesDecoded0:[NetworkManagerClientTypes.Site]? = nil
        if let sitesContainer = sitesContainer {
            sitesDecoded0 = [NetworkManagerClientTypes.Site]()
            for structure0 in sitesContainer {
                if let structure0 = structure0 {
                    sitesDecoded0?.append(structure0)
                }
            }
        }
        sites = sitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTransitGatewayConnectPeerAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTransitGatewayConnectPeerAssociationsInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), transitGatewayConnectPeerArns: \(Swift.String(describing: transitGatewayConnectPeerArns)))"}
}

extension GetTransitGatewayConnectPeerAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetTransitGatewayConnectPeerAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayConnectPeerAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayConnectPeerAssociationsOutputError>
}

public struct GetTransitGatewayConnectPeerAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayConnectPeerAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let transitGatewayConnectPeerArns = input.operationInput.transitGatewayConnectPeerArns {
            transitGatewayConnectPeerArns.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "transitGatewayConnectPeerArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayConnectPeerAssociationsOutputError>
}

public struct GetTransitGatewayConnectPeerAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayConnectPeerAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTransitGatewayConnectPeerAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTransitGatewayConnectPeerAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayConnectPeerAssociationsOutputError>
}

public struct GetTransitGatewayConnectPeerAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayConnectPeerAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTransitGatewayConnectPeerAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTransitGatewayConnectPeerAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayConnectPeerAssociationsOutputError>
}

public struct GetTransitGatewayConnectPeerAssociationsInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// One or more transit gateway Connect peer Amazon Resource Names (ARNs).
    public var transitGatewayConnectPeerArns: [Swift.String]?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        transitGatewayConnectPeerArns: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayConnectPeerArns = transitGatewayConnectPeerArns
    }
}

struct GetTransitGatewayConnectPeerAssociationsInputBody: Swift.Equatable {
}

extension GetTransitGatewayConnectPeerAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTransitGatewayConnectPeerAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTransitGatewayConnectPeerAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTransitGatewayConnectPeerAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTransitGatewayConnectPeerAssociationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), transitGatewayConnectPeerAssociations: \(Swift.String(describing: transitGatewayConnectPeerAssociations)))"}
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTransitGatewayConnectPeerAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.transitGatewayConnectPeerAssociations = output.transitGatewayConnectPeerAssociations
        } else {
            self.nextToken = nil
            self.transitGatewayConnectPeerAssociations = nil
        }
    }
}

public struct GetTransitGatewayConnectPeerAssociationsOutputResponse: Swift.Equatable {
    /// The token to use for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the transit gateway Connect peer associations.
    public var transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]?

    public init (
        nextToken: Swift.String? = nil,
        transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociations
    }
}

struct GetTransitGatewayConnectPeerAssociationsOutputResponseBody: Swift.Equatable {
    public let transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]?
    public let nextToken: Swift.String?
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case transitGatewayConnectPeerAssociations = "TransitGatewayConnectPeerAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?].self, forKey: .transitGatewayConnectPeerAssociations)
        var transitGatewayConnectPeerAssociationsDecoded0:[NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]? = nil
        if let transitGatewayConnectPeerAssociationsContainer = transitGatewayConnectPeerAssociationsContainer {
            transitGatewayConnectPeerAssociationsDecoded0 = [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]()
            for structure0 in transitGatewayConnectPeerAssociationsContainer {
                if let structure0 = structure0 {
                    transitGatewayConnectPeerAssociationsDecoded0?.append(structure0)
                }
            }
        }
        transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTransitGatewayRegistrationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTransitGatewayRegistrationsInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), transitGatewayArns: \(Swift.String(describing: transitGatewayArns)))"}
}

extension GetTransitGatewayRegistrationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetTransitGatewayRegistrationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayRegistrationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTransitGatewayRegistrationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTransitGatewayRegistrationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayRegistrationsOutputError>
}

public struct GetTransitGatewayRegistrationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayRegistrationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTransitGatewayRegistrationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let transitGatewayArns = input.operationInput.transitGatewayArns {
            transitGatewayArns.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "transitGatewayArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTransitGatewayRegistrationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayRegistrationsOutputError>
}

public struct GetTransitGatewayRegistrationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayRegistrationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTransitGatewayRegistrationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTransitGatewayRegistrationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayRegistrationsOutputError>
}

public struct GetTransitGatewayRegistrationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTransitGatewayRegistrationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTransitGatewayRegistrationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTransitGatewayRegistrationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTransitGatewayRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTransitGatewayRegistrationsOutputError>
}

public struct GetTransitGatewayRegistrationsInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.
    public var transitGatewayArns: [Swift.String]?

    public init (
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        transitGatewayArns: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayArns = transitGatewayArns
    }
}

struct GetTransitGatewayRegistrationsInputBody: Swift.Equatable {
}

extension GetTransitGatewayRegistrationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTransitGatewayRegistrationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTransitGatewayRegistrationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTransitGatewayRegistrationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTransitGatewayRegistrationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTransitGatewayRegistrationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), transitGatewayRegistrations: \(Swift.String(describing: transitGatewayRegistrations)))"}
}

extension GetTransitGatewayRegistrationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTransitGatewayRegistrationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.transitGatewayRegistrations = output.transitGatewayRegistrations
        } else {
            self.nextToken = nil
            self.transitGatewayRegistrations = nil
        }
    }
}

public struct GetTransitGatewayRegistrationsOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The transit gateway registrations.
    public var transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]?

    public init (
        nextToken: Swift.String? = nil,
        transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]? = nil
    )
    {
        self.nextToken = nextToken
        self.transitGatewayRegistrations = transitGatewayRegistrations
    }
}

struct GetTransitGatewayRegistrationsOutputResponseBody: Swift.Equatable {
    public let transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]?
    public let nextToken: Swift.String?
}

extension GetTransitGatewayRegistrationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case transitGatewayRegistrations = "TransitGatewayRegistrations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.TransitGatewayRegistration?].self, forKey: .transitGatewayRegistrations)
        var transitGatewayRegistrationsDecoded0:[NetworkManagerClientTypes.TransitGatewayRegistration]? = nil
        if let transitGatewayRegistrationsContainer = transitGatewayRegistrationsContainer {
            transitGatewayRegistrationsDecoded0 = [NetworkManagerClientTypes.TransitGatewayRegistration]()
            for structure0 in transitGatewayRegistrationsContainer {
                if let structure0 = structure0 {
                    transitGatewayRegistrationsDecoded0?.append(structure0)
                }
            }
        }
        transitGatewayRegistrations = transitGatewayRegistrationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NetworkManagerClientTypes.GlobalNetwork: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkArn = "GlobalNetworkArn"
        case globalNetworkId = "GlobalNetworkId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkArn = globalNetworkArn {
            try encodeContainer.encode(globalNetworkArn, forKey: .globalNetworkArn)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let globalNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkArn)
        globalNetworkArn = globalNetworkArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetworkState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.GlobalNetwork: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlobalNetwork(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), globalNetworkArn: \(Swift.String(describing: globalNetworkArn)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a global network.
    public struct GlobalNetwork: Swift.Equatable {
        /// The date and time that the global network was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the global network.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the global network.
        public var globalNetworkArn: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the global network.
        public var state: NetworkManagerClientTypes.GlobalNetworkState?
        /// The tags for the global network.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkArn: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.GlobalNetworkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkArn = globalNetworkArn
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    public enum GlobalNetworkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GlobalNetworkState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GlobalNetworkState(rawValue: rawValue) ?? GlobalNetworkState.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed due to an internal error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// Indicates when to retry the request.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.Link: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case linkArn = "LinkArn"
        case linkId = "LinkId"
        case provider = "Provider"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkArn = linkArn {
            try encodeContainer.encode(linkArn, forKey: .linkArn)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let linkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkArn)
        linkArn = linkArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.Link: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Link(bandwidth: \(Swift.String(describing: bandwidth)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkArn: \(Swift.String(describing: linkArn)), linkId: \(Swift.String(describing: linkId)), provider: \(Swift.String(describing: provider)), siteId: \(Swift.String(describing: siteId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a link.
    public struct Link: Swift.Equatable {
        /// The bandwidth for the link.
        public var bandwidth: NetworkManagerClientTypes.Bandwidth?
        /// The date and time that the link was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the link.
        public var description: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The Amazon Resource Name (ARN) of the link.
        public var linkArn: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The provider of the link.
        public var provider: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The state of the link.
        public var state: NetworkManagerClientTypes.LinkState?
        /// The tags for the link.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The type of the link.
        public var type: Swift.String?

        public init (
            bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkArn: Swift.String? = nil,
            linkId: Swift.String? = nil,
            provider: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.LinkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            type: Swift.String? = nil
        )
        {
            self.bandwidth = bandwidth
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.linkArn = linkArn
            self.linkId = linkId
            self.provider = provider
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes.LinkAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkAssociationState = "LinkAssociationState"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkAssociationState = linkAssociationState {
            try encodeContainer.encode(linkAssociationState.rawValue, forKey: .linkAssociationState)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let linkAssociationStateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.LinkAssociationState.self, forKey: .linkAssociationState)
        linkAssociationState = linkAssociationStateDecoded
    }
}

extension NetworkManagerClientTypes.LinkAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LinkAssociation(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkAssociationState: \(Swift.String(describing: linkAssociationState)), linkId: \(Swift.String(describing: linkId)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the association between a device and a link.
    public struct LinkAssociation: Swift.Equatable {
        /// The device ID for the link association.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the association.
        public var linkAssociationState: NetworkManagerClientTypes.LinkAssociationState?
        /// The ID of the link.
        public var linkId: Swift.String?

        public init (
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkAssociationState: NetworkManagerClientTypes.LinkAssociationState? = nil,
            linkId: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkAssociationState = linkAssociationState
            self.linkId = linkId
        }
    }

}

extension NetworkManagerClientTypes {
    public enum LinkAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [LinkAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LinkAssociationState(rawValue: rawValue) ?? LinkAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes {
    public enum LinkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LinkState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LinkState(rawValue: rawValue) ?? LinkState.sdkUnknown(rawValue)
        }
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tagList: \(Swift.String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags.
    public var tagList: [NetworkManagerClientTypes.Tag]?

    public init (
        tagList: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tagList: [NetworkManagerClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension NetworkManagerClientTypes.Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case latitude = "Latitude"
        case longitude = "Longitude"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let latitude = latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let latitudeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longitude)
        longitude = longitudeDecoded
    }
}

extension NetworkManagerClientTypes.Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension NetworkManagerClientTypes {
    /// Describes a location.
    public struct Location: Swift.Equatable {
        /// The physical address.
        public var address: Swift.String?
        /// The latitude.
        public var latitude: Swift.String?
        /// The longitude.
        public var longitude: Swift.String?

        public init (
            address: Swift.String? = nil,
            latitude: Swift.String? = nil,
            longitude: Swift.String? = nil
        )
        {
            self.address = address
            self.latitude = latitude
            self.longitude = longitude
        }
    }

}

public struct RegisterTransitGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTransitGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTransitGatewayOutputError>
}

extension RegisterTransitGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTransitGatewayInput(globalNetworkId: \(Swift.String(describing: globalNetworkId)), transitGatewayArn: \(Swift.String(describing: transitGatewayArn)))"}
}

extension RegisterTransitGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayArn = "TransitGatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transitGatewayArn = transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
    }
}

public struct RegisterTransitGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTransitGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTransitGatewayOutputError>
}

public struct RegisterTransitGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTransitGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTransitGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTransitGatewayOutputError>
}

public struct RegisterTransitGatewayInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTransitGatewayInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RegisterTransitGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterTransitGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTransitGatewayOutputError>
}

public struct RegisterTransitGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTransitGatewayInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RegisterTransitGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterTransitGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTransitGatewayOutputError>
}

public struct RegisterTransitGatewayInput: Swift.Equatable {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway. For more information, see [Resources Defined by Amazon EC2](https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazonec2.html#amazonec2-resources-for-iam-policies).
    /// This member is required.
    public var transitGatewayArn: Swift.String?

    public init (
        globalNetworkId: Swift.String? = nil,
        transitGatewayArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayArn = transitGatewayArn
    }
}

struct RegisterTransitGatewayInputBody: Swift.Equatable {
    public let transitGatewayArn: Swift.String?
}

extension RegisterTransitGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayArn = "TransitGatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
    }
}

extension RegisterTransitGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTransitGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTransitGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTransitGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTransitGatewayOutputResponse(transitGatewayRegistration: \(Swift.String(describing: transitGatewayRegistration)))"}
}

extension RegisterTransitGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterTransitGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transitGatewayRegistration = output.transitGatewayRegistration
        } else {
            self.transitGatewayRegistration = nil
        }
    }
}

public struct RegisterTransitGatewayOutputResponse: Swift.Equatable {
    /// Information about the transit gateway registration.
    public var transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?

    public init (
        transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration? = nil
    )
    {
        self.transitGatewayRegistration = transitGatewayRegistration
    }
}

struct RegisterTransitGatewayOutputResponseBody: Swift.Equatable {
    public let transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?
}

extension RegisterTransitGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitGatewayRegistration = "TransitGatewayRegistration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistration.self, forKey: .transitGatewayRegistration)
        transitGatewayRegistration = transitGatewayRegistrationDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(limitCode: \(Swift.String(describing: limitCode)), message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limitCode = output.limitCode
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.limitCode = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A service limit was exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The limit code.
    /// This member is required.
    public var limitCode: Swift.String?
    /// The error message.
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The resource type.
    public var resourceType: Swift.String?
    /// The service code.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        limitCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.limitCode = limitCode
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
    public let limitCode: Swift.String?
    public let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitCode = "LimitCode"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitCode)
        limitCode = limitCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension NetworkManagerClientTypes.Site: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case location = "Location"
        case siteArn = "SiteArn"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let siteArn = siteArn {
            try encodeContainer.encode(siteArn, forKey: .siteArn)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let siteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteArn)
        siteArn = siteArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.SiteState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkManagerClientTypes.Site: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Site(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), siteArn: \(Swift.String(describing: siteArn)), siteId: \(Swift.String(describing: siteId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a site.
    public struct Site: Swift.Equatable {
        /// The date and time that the site was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the site.
        public var description: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The location of the site.
        public var location: NetworkManagerClientTypes.Location?
        /// The Amazon Resource Name (ARN) of the site.
        public var siteArn: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The state of the site.
        public var state: NetworkManagerClientTypes.SiteState?
        /// The tags for the site.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            location: NetworkManagerClientTypes.Location? = nil,
            siteArn: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.SiteState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.siteArn = siteArn
            self.siteId = siteId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    public enum SiteState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [SiteState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SiteState(rawValue: rawValue) ?? SiteState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NetworkManagerClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a tag.
    public struct Tag: Swift.Equatable {
        /// The tag key. Length Constraints: Maximum length of 128 characters.
        public var key: Swift.String?
        /// The tag value. Length Constraints: Maximum length of 256 characters.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to apply to the specified resource.
    /// This member is required.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [NetworkManagerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[NetworkManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [NetworkManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Indicates when to retry the request.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let transitGatewayConnectPeerArn = transitGatewayConnectPeerArn {
            try encodeContainer.encode(transitGatewayConnectPeerArn, forKey: .transitGatewayConnectPeerArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayConnectPeerArn)
        transitGatewayConnectPeerArn = transitGatewayConnectPeerArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransitGatewayConnectPeerAssociation(deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), state: \(Swift.String(describing: state)), transitGatewayConnectPeerArn: \(Swift.String(describing: transitGatewayConnectPeerArn)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a transit gateway Connect peer association.
    public struct TransitGatewayConnectPeerAssociation: Swift.Equatable {
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The state of the association.
        public var state: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState?
        /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
        public var transitGatewayConnectPeerArn: Swift.String?

        public init (
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState? = nil,
            transitGatewayConnectPeerArn: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum TransitGatewayConnectPeerAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitGatewayConnectPeerAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitGatewayConnectPeerAssociationState(rawValue: rawValue) ?? TransitGatewayConnectPeerAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetworkId = "GlobalNetworkId"
        case state = "State"
        case transitGatewayArn = "TransitGatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let transitGatewayArn = transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistrationStateReason.self, forKey: .state)
        state = stateDecoded
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransitGatewayRegistration(globalNetworkId: \(Swift.String(describing: globalNetworkId)), state: \(Swift.String(describing: state)), transitGatewayArn: \(Swift.String(describing: transitGatewayArn)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the registration of a transit gateway to a global network.
    public struct TransitGatewayRegistration: Swift.Equatable {
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the transit gateway registration.
        public var state: NetworkManagerClientTypes.TransitGatewayRegistrationStateReason?
        /// The Amazon Resource Name (ARN) of the transit gateway.
        public var transitGatewayArn: Swift.String?

        public init (
            globalNetworkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.TransitGatewayRegistrationStateReason? = nil,
            transitGatewayArn: Swift.String? = nil
        )
        {
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.transitGatewayArn = transitGatewayArn
        }
    }

}

extension NetworkManagerClientTypes {
    public enum TransitGatewayRegistrationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitGatewayRegistrationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitGatewayRegistrationState(rawValue: rawValue) ?? TransitGatewayRegistrationState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistrationStateReason: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.TransitGatewayRegistrationState.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistrationStateReason: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransitGatewayRegistrationStateReason(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension NetworkManagerClientTypes {
    /// Describes the status of a transit gateway registration.
    public struct TransitGatewayRegistrationStateReason: Swift.Equatable {
        /// The code for the state reason.
        public var code: NetworkManagerClientTypes.TransitGatewayRegistrationState?
        /// The message for the state reason.
        public var message: Swift.String?

        public init (
            code: NetworkManagerClientTypes.TransitGatewayRegistrationState? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

extension UpdateConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionInput(connectedLinkId: \(Swift.String(describing: connectedLinkId)), connectionId: \(Swift.String(describing: connectionId)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)))"}
}

extension UpdateConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedLinkId = connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

public struct UpdateConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let connectionId = input.connectionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("connectionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections/\(connectionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInput: Swift.Equatable {
    /// The ID of the link for the second device in the connection.
    public var connectedLinkId: Swift.String?
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// A description of the connection. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link for the first device in the connection.
    public var linkId: Swift.String?

    public init (
        connectedLinkId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.connectedLinkId = connectedLinkId
        self.connectionId = connectionId
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct UpdateConnectionInputBody: Swift.Equatable {
    public let linkId: Swift.String?
    public let connectedLinkId: Swift.String?
    public let description: Swift.String?
}

extension UpdateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case linkId = "LinkId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension UpdateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct UpdateConnectionOutputResponse: Swift.Equatable {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init (
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct UpdateConnectionOutputResponseBody: Swift.Equatable {
    public let connection: NetworkManagerClientTypes.Connection?
}

extension UpdateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct UpdateDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceOutputError>
}

extension UpdateDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceInput(aWSLocation: \(Swift.String(describing: aWSLocation)), description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)))"}
}

extension UpdateDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSLocation = aWSLocation {
            try encodeContainer.encode(aWSLocation, forKey: .aWSLocation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }
}

public struct UpdateDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let deviceId = input.deviceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deviceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInput: Swift.Equatable {
    /// The AWS location of the device.
    public var aWSLocation: NetworkManagerClientTypes.AWSLocation?
    /// A description of the device. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// Describes a location.
    public var location: NetworkManagerClientTypes.Location?
    /// The model of the device. Length Constraints: Maximum length of 128 characters.
    public var model: Swift.String?
    /// The serial number of the device. Length Constraints: Maximum length of 128 characters.
    public var serialNumber: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The type of the device.
    public var type: Swift.String?
    /// The vendor of the device. Length Constraints: Maximum length of 128 characters.
    public var vendor: Swift.String?

    public init (
        aWSLocation: NetworkManagerClientTypes.AWSLocation? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        model: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        siteId: Swift.String? = nil,
        type: Swift.String? = nil,
        vendor: Swift.String? = nil
    )
    {
        self.aWSLocation = aWSLocation
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.type = type
        self.vendor = vendor
    }
}

struct UpdateDeviceInputBody: Swift.Equatable {
    public let aWSLocation: NetworkManagerClientTypes.AWSLocation?
    public let description: Swift.String?
    public let type: Swift.String?
    public let vendor: Swift.String?
    public let model: Swift.String?
    public let serialNumber: Swift.String?
    public let location: NetworkManagerClientTypes.Location?
    public let siteId: Swift.String?
}

extension UpdateDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case type = "Type"
        case vendor = "Vendor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aWSLocationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.AWSLocation.self, forKey: .aWSLocation)
        aWSLocation = aWSLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
    }
}

extension UpdateDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceOutputResponse(device: \(Swift.String(describing: device)))"}
}

extension UpdateDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct UpdateDeviceOutputResponse: Swift.Equatable {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init (
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct UpdateDeviceOutputResponseBody: Swift.Equatable {
    public let device: NetworkManagerClientTypes.Device?
}

extension UpdateDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct UpdateGlobalNetworkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalNetworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalNetworkOutputError>
}

extension UpdateGlobalNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlobalNetworkInput(description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)))"}
}

extension UpdateGlobalNetworkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateGlobalNetworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalNetworkOutputError>
}

public struct UpdateGlobalNetworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalNetworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalNetworkOutputError>
}

public struct UpdateGlobalNetworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalNetworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalNetworkOutputError>
}

public struct UpdateGlobalNetworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalNetworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateGlobalNetworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGlobalNetworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalNetworkOutputError>
}

public struct UpdateGlobalNetworkInput: Swift.Equatable {
    /// A description of the global network. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of your global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init (
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
    }
}

struct UpdateGlobalNetworkInputBody: Swift.Equatable {
    public let description: Swift.String?
}

extension UpdateGlobalNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGlobalNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGlobalNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGlobalNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGlobalNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlobalNetworkOutputResponse(globalNetwork: \(Swift.String(describing: globalNetwork)))"}
}

extension UpdateGlobalNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct UpdateGlobalNetworkOutputResponse: Swift.Equatable {
    /// Information about the global network object.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init (
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct UpdateGlobalNetworkOutputResponseBody: Swift.Equatable {
    public let globalNetwork: NetworkManagerClientTypes.GlobalNetwork?
}

extension UpdateGlobalNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

public struct UpdateLinkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkOutputError>
}

extension UpdateLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLinkInput(bandwidth: \(Swift.String(describing: bandwidth)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), linkId: \(Swift.String(describing: linkId)), provider: \(Swift.String(describing: provider)), type: \(Swift.String(describing: type)))"}
}

extension UpdateLinkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct UpdateLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkOutputError>
}

public struct UpdateLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkOutputError>
}

public struct UpdateLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkOutputError>
}

public struct UpdateLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let linkId = input.linkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("linkId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/links/\(linkId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkOutputError>
}

public struct UpdateLinkInput: Swift.Equatable {
    /// The upload and download speed in Mbps.
    public var bandwidth: NetworkManagerClientTypes.Bandwidth?
    /// A description of the link. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The provider of the link. Length Constraints: Maximum length of 128 characters.
    public var provider: Swift.String?
    /// The type of the link. Length Constraints: Maximum length of 128 characters.
    public var type: Swift.String?

    public init (
        bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        provider: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.provider = provider
        self.type = type
    }
}

struct UpdateLinkInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let type: Swift.String?
    public let bandwidth: NetworkManagerClientTypes.Bandwidth?
    public let provider: Swift.String?
}

extension UpdateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
    }
}

extension UpdateLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLinkOutputResponse(link: \(Swift.String(describing: link)))"}
}

extension UpdateLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct UpdateLinkOutputResponse: Swift.Equatable {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init (
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

struct UpdateLinkOutputResponseBody: Swift.Equatable {
    public let link: NetworkManagerClientTypes.Link?
}

extension UpdateLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case link = "Link"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Link.self, forKey: .link)
        link = linkDecoded
    }
}

public struct UpdateSiteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

extension UpdateSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteInput(description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), location: \(Swift.String(describing: location)), siteId: \(Swift.String(describing: siteId)))"}
}

extension UpdateSiteInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }
}

public struct UpdateSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let globalNetworkId = input.globalNetworkId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("globalNetworkId is nil and needs a value for the path of this operation"))))
        }
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites/\(siteId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInput: Swift.Equatable {
    /// A description of your site. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The site location:
    ///
    /// * Address: The physical address of the site.
    ///
    /// * Latitude: The latitude of the site.
    ///
    /// * Longitude: The longitude of the site.
    public var location: NetworkManagerClientTypes.Location?
    /// The ID of your site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.siteId = siteId
    }
}

struct UpdateSiteInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let location: NetworkManagerClientTypes.Location?
}

extension UpdateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case location = "Location"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Location.self, forKey: .location)
        location = locationDecoded
    }
}

extension UpdateSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteOutputResponse(site: \(Swift.String(describing: site)))"}
}

extension UpdateSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct UpdateSiteOutputResponse: Swift.Equatable {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init (
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct UpdateSiteOutputResponseBody: Swift.Equatable {
    public let site: NetworkManagerClientTypes.Site?
}

extension UpdateSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(fields: \(Swift.String(describing: fields)), message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error, if applicable.
    public var fields: [NetworkManagerClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason for the error.
    public var reason: NetworkManagerClientTypes.ValidationExceptionReason?

    public init (
        fields: [NetworkManagerClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: NetworkManagerClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: NetworkManagerClientTypes.ValidationExceptionReason?
    public let fields: [NetworkManagerClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(NetworkManagerClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([NetworkManagerClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[NetworkManagerClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [NetworkManagerClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension NetworkManagerClientTypes.ValidationExceptionField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkManagerClientTypes.ValidationExceptionField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationExceptionField(message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension NetworkManagerClientTypes {
    /// Describes a validation exception for a field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message for the field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension NetworkManagerClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CannotParse"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .other: return "Other"
            case .unknownOperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
