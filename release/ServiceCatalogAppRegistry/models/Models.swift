// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ServiceCatalogAppRegistryClientTypes.Application: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ServiceCatalogAppRegistryClientTypes.Application: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Application(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension ServiceCatalogAppRegistryClientTypes {
    /// <p>Represents a Service Catalog AppRegistry application that is the top-level node in a hierarchy of related
    ///        cloud resource abstractions.</p>
    public struct Application: Swift.Equatable {
        /// <p>The Amazon resource name (ARN) that specifies the application across services.</p>
        public let arn: Swift.String?
        /// <p>The ISO-8601 formatted timestamp of the moment when the application was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The description of the application.</p>
        public let description: Swift.String?
        /// <p>The identifier of the application.</p>
        public let id: Swift.String?
        /// <p> The ISO-8601 formatted timestamp of the moment when the application was last updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The name of the application. The name must be unique in the region in which you are creating the application.</p>
        public let name: Swift.String?
        /// <p>Key-value pairs you can use to associate with the application.</p>
        public let tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.tags = tags
        }
    }

}

extension ServiceCatalogAppRegistryClientTypes.ApplicationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes.ApplicationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationSummary(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), name: \(Swift.String(describing: name)))"}
}

extension ServiceCatalogAppRegistryClientTypes {
    /// <p>Summary of a Service Catalog AppRegistry application.</p>
    public struct ApplicationSummary: Swift.Equatable {
        /// <p>The Amazon resource name (ARN) that specifies the application across services.</p>
        public let arn: Swift.String?
        /// <p>The ISO-8601 formatted timestamp of the moment when the application was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The description of the application.</p>
        public let description: Swift.String?
        /// <p>The identifier of the application.</p>
        public let id: Swift.String?
        /// <p> The ISO-8601 formatted timestamp of the moment when the application was last updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The name of the application. The name must be unique in the region in which you are creating the application.</p>
        public let name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }
    }

}

extension AssociateAttributeGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateAttributeGroupInput(application: \(Swift.String(describing: application)), attributeGroup: \(Swift.String(describing: attributeGroup)))"}
}

extension AssociateAttributeGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AssociateAttributeGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAttributeGroupOutputError>
}

public struct AssociateAttributeGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAttributeGroupOutputError>
}

public struct AssociateAttributeGroupInput: Swift.Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: Swift.String?
    /// <p>The name or ID of the attribute group that holds the attributes to describe the application.</p>
    public let attributeGroup: Swift.String?

    public init (
        application: Swift.String? = nil,
        attributeGroup: Swift.String? = nil
    )
    {
        self.application = application
        self.attributeGroup = attributeGroup
    }
}

struct AssociateAttributeGroupInputBody: Swift.Equatable {
}

extension AssociateAttributeGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateAttributeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAttributeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAttributeGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAttributeGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateAttributeGroupOutputResponse(applicationArn: \(Swift.String(describing: applicationArn)), attributeGroupArn: \(Swift.String(describing: attributeGroupArn)))"}
}

extension AssociateAttributeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.attributeGroupArn = output.attributeGroupArn
        } else {
            self.applicationArn = nil
            self.attributeGroupArn = nil
        }
    }
}

public struct AssociateAttributeGroupOutputResponse: Swift.Equatable {
    /// <p>The Amazon resource name (ARN) of the application that was augmented with attributes.</p>
    public let applicationArn: Swift.String?
    /// <p>The Amazon resource name (ARN) of the attribute group that contains the application's new attributes.</p>
    public let attributeGroupArn: Swift.String?

    public init (
        applicationArn: Swift.String? = nil,
        attributeGroupArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.attributeGroupArn = attributeGroupArn
    }
}

struct AssociateAttributeGroupOutputResponseBody: Swift.Equatable {
    public let applicationArn: Swift.String?
    public let attributeGroupArn: Swift.String?
}

extension AssociateAttributeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case attributeGroupArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let attributeGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeGroupArn)
        attributeGroupArn = attributeGroupArnDecoded
    }
}

extension AssociateResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateResourceInput(application: \(Swift.String(describing: application)), resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension AssociateResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AssociateResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceOutputError>
}

public struct AssociateResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceOutputError>
}

public struct AssociateResourceInput: Swift.Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: Swift.String?
    /// <p>The name or ID of the resource of which the application will be associated.</p>
    public let resource: Swift.String?
    /// <p>The type of resource of which the application will be associated.</p>
    public let resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType?

    public init (
        application: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType? = nil
    )
    {
        self.application = application
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct AssociateResourceInputBody: Swift.Equatable {
}

extension AssociateResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateResourceOutputResponse(applicationArn: \(Swift.String(describing: applicationArn)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension AssociateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.resourceArn = output.resourceArn
        } else {
            self.applicationArn = nil
            self.resourceArn = nil
        }
    }
}

public struct AssociateResourceOutputResponse: Swift.Equatable {
    /// <p>The Amazon resource name (ARN) of the application that was augmented with attributes.</p>
    public let applicationArn: Swift.String?
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: Swift.String?

    public init (
        applicationArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.resourceArn = resourceArn
    }
}

struct AssociateResourceOutputResponseBody: Swift.Equatable {
    public let applicationArn: Swift.String?
    public let resourceArn: Swift.String?
}

extension AssociateResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes.AttributeGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ServiceCatalogAppRegistryClientTypes.AttributeGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttributeGroup(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension ServiceCatalogAppRegistryClientTypes {
    /// <p>Represents a Service Catalog AppRegistry attribute group that is rich metadata which describes an application and its components.</p>
    public struct AttributeGroup: Swift.Equatable {
        /// <p>The Amazon resource name (ARN) that specifies the attribute group across services.</p>
        public let arn: Swift.String?
        /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The description of the attribute group that the user provides.</p>
        public let description: Swift.String?
        /// <p>The globally unique attribute group identifier of the attribute group.</p>
        public let id: Swift.String?
        /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was last updated. This time is the same as the creationTime for a newly created attribute group.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The name of the attribute group.</p>
        public let name: Swift.String?
        /// <p>Key-value pairs you can use to associate with the attribute group.</p>
        public let tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.tags = tags
        }
    }

}

extension ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttributeGroupSummary(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), name: \(Swift.String(describing: name)))"}
}

extension ServiceCatalogAppRegistryClientTypes {
    /// <p>Summary of a Service Catalog AppRegistry attribute group.</p>
    public struct AttributeGroupSummary: Swift.Equatable {
        /// <p>The Amazon resource name (ARN) that specifies the attribute group across services.</p>
        public let arn: Swift.String?
        /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The description of the attribute group that the user provides.</p>
        public let description: Swift.String?
        /// <p>The globally unique attribute group identifier of the attribute group.</p>
        public let id: Swift.String?
        /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was last updated. This time is the same as the creationTime for a newly created attribute group.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The name of the attribute group.</p>
        public let name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was a conflict when processing the request (for example, a resource with the given name already
///       exists within the account).</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInput: Swift.Equatable {
    /// <p>A unique identifier that you provide to ensure idempotency. If you retry a request that
    ///       completed successfully using the same client token and the same parameters, the retry succeeds
    ///       without performing any further actions. If you retry a successful request using the same
    ///       client token, but one or more of the parameters are different, the retry fails.</p>
    public var clientToken: Swift.String?
    /// <p>The description of the application.</p>
    public let description: Swift.String?
    /// <p>The name of the application. The name must be unique in the region in which you are creating the application.</p>
    public let name: Swift.String?
    /// <p>Key-value pairs you can use to associate with the application.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationOutputResponse(application: \(Swift.String(describing: application)))"}
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// <p>Information about the application.</p>
    public let application: ServiceCatalogAppRegistryClientTypes.Application?

    public init (
        application: ServiceCatalogAppRegistryClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    public let application: ServiceCatalogAppRegistryClientTypes.Application?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

public struct CreateAttributeGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAttributeGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAttributeGroupOutputError>
}

extension CreateAttributeGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttributeGroupInput(attributes: \(Swift.String(describing: attributes)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAttributeGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case clientToken
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAttributeGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAttributeGroupOutputError>
}

public struct CreateAttributeGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAttributeGroupOutputError>
}

public struct CreateAttributeGroupInput: Swift.Equatable {
    /// <p>A JSON string in the form of nested key-value pairs that represent the attributes in the group and describes an application and its components.</p>
    public let attributes: Swift.String?
    /// <p>A unique identifier that you provide to ensure idempotency. If you retry a request that
    ///       completed successfully using the same client token and the same parameters, the retry succeeds
    ///       without performing any further actions. If you retry a successful request using the same
    ///       client token, but one or more of the parameters are different, the retry fails.</p>
    public var clientToken: Swift.String?
    /// <p>The description of the attribute group that the user provides.</p>
    public let description: Swift.String?
    /// <p>The name of the attribute group.</p>
    public let name: Swift.String?
    /// <p>Key-value pairs you can use to associate with the attribute group.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        attributes: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateAttributeGroupInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let attributes: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateAttributeGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case clientToken
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributes)
        attributes = attributesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAttributeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAttributeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAttributeGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAttributeGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttributeGroupOutputResponse(attributeGroup: \(Swift.String(describing: attributeGroup)))"}
}

extension CreateAttributeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroup = output.attributeGroup
        } else {
            self.attributeGroup = nil
        }
    }
}

public struct CreateAttributeGroupOutputResponse: Swift.Equatable {
    /// <p>Information about the attribute group.</p>
    public let attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup?

    public init (
        attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct CreateAttributeGroupOutputResponseBody: Swift.Equatable {
    public let attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup?
}

extension CreateAttributeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.AttributeGroup.self, forKey: .attributeGroup)
        attributeGroup = attributeGroupDecoded
    }
}

extension DeleteApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApplicationInput(application: \(Swift.String(describing: application)))"}
}

extension DeleteApplicationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: Swift.String?

    public init (
        application: Swift.String? = nil
    )
    {
        self.application = application
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApplicationOutputResponse(application: \(Swift.String(describing: application)))"}
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct DeleteApplicationOutputResponse: Swift.Equatable {
    /// <p>Information about the deleted application.</p>
    public let application: ServiceCatalogAppRegistryClientTypes.ApplicationSummary?

    public init (
        application: ServiceCatalogAppRegistryClientTypes.ApplicationSummary? = nil
    )
    {
        self.application = application
    }
}

struct DeleteApplicationOutputResponseBody: Swift.Equatable {
    public let application: ServiceCatalogAppRegistryClientTypes.ApplicationSummary?
}

extension DeleteApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.ApplicationSummary.self, forKey: .application)
        application = applicationDecoded
    }
}

extension DeleteAttributeGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAttributeGroupInput(attributeGroup: \(Swift.String(describing: attributeGroup)))"}
}

extension DeleteAttributeGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAttributeGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAttributeGroupOutputError>
}

public struct DeleteAttributeGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAttributeGroupOutputError>
}

public struct DeleteAttributeGroupInput: Swift.Equatable {
    /// <p>The name or ID of the attribute group that holds the attributes to describe the application.</p>
    public let attributeGroup: Swift.String?

    public init (
        attributeGroup: Swift.String? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct DeleteAttributeGroupInputBody: Swift.Equatable {
}

extension DeleteAttributeGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAttributeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAttributeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAttributeGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAttributeGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAttributeGroupOutputResponse(attributeGroup: \(Swift.String(describing: attributeGroup)))"}
}

extension DeleteAttributeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroup = output.attributeGroup
        } else {
            self.attributeGroup = nil
        }
    }
}

public struct DeleteAttributeGroupOutputResponse: Swift.Equatable {
    /// <p>Information about the deleted attribute group.</p>
    public let attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary?

    public init (
        attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct DeleteAttributeGroupOutputResponseBody: Swift.Equatable {
    public let attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary?
}

extension DeleteAttributeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary.self, forKey: .attributeGroup)
        attributeGroup = attributeGroupDecoded
    }
}

extension DisassociateAttributeGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateAttributeGroupInput(application: \(Swift.String(describing: application)), attributeGroup: \(Swift.String(describing: attributeGroup)))"}
}

extension DisassociateAttributeGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateAttributeGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateAttributeGroupOutputError>
}

public struct DisassociateAttributeGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateAttributeGroupOutputError>
}

public struct DisassociateAttributeGroupInput: Swift.Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: Swift.String?
    /// <p>The name or ID of the attribute group that holds the attributes to describe the application.</p>
    public let attributeGroup: Swift.String?

    public init (
        application: Swift.String? = nil,
        attributeGroup: Swift.String? = nil
    )
    {
        self.application = application
        self.attributeGroup = attributeGroup
    }
}

struct DisassociateAttributeGroupInputBody: Swift.Equatable {
}

extension DisassociateAttributeGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateAttributeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAttributeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateAttributeGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAttributeGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateAttributeGroupOutputResponse(applicationArn: \(Swift.String(describing: applicationArn)), attributeGroupArn: \(Swift.String(describing: attributeGroupArn)))"}
}

extension DisassociateAttributeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.attributeGroupArn = output.attributeGroupArn
        } else {
            self.applicationArn = nil
            self.attributeGroupArn = nil
        }
    }
}

public struct DisassociateAttributeGroupOutputResponse: Swift.Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the application.</p>
    public let applicationArn: Swift.String?
    /// <p>The Amazon resource name (ARN) that specifies the attribute group.</p>
    public let attributeGroupArn: Swift.String?

    public init (
        applicationArn: Swift.String? = nil,
        attributeGroupArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.attributeGroupArn = attributeGroupArn
    }
}

struct DisassociateAttributeGroupOutputResponseBody: Swift.Equatable {
    public let applicationArn: Swift.String?
    public let attributeGroupArn: Swift.String?
}

extension DisassociateAttributeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case attributeGroupArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let attributeGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeGroupArn)
        attributeGroupArn = attributeGroupArnDecoded
    }
}

extension DisassociateResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateResourceInput(application: \(Swift.String(describing: application)), resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension DisassociateResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceOutputError>
}

public struct DisassociateResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceOutputError>
}

public struct DisassociateResourceInput: Swift.Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: Swift.String?
    /// <p>The name or ID of the resource.</p>
    public let resource: Swift.String?
    /// <p>The type of the resource that is being disassociated.</p>
    public let resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType?

    public init (
        application: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType? = nil
    )
    {
        self.application = application
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct DisassociateResourceInputBody: Swift.Equatable {
}

extension DisassociateResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateResourceOutputResponse(applicationArn: \(Swift.String(describing: applicationArn)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension DisassociateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.resourceArn = output.resourceArn
        } else {
            self.applicationArn = nil
            self.resourceArn = nil
        }
    }
}

public struct DisassociateResourceOutputResponse: Swift.Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the application.</p>
    public let applicationArn: Swift.String?
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: Swift.String?

    public init (
        applicationArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.resourceArn = resourceArn
    }
}

struct DisassociateResourceOutputResponseBody: Swift.Equatable {
    public let applicationArn: Swift.String?
    public let resourceArn: Swift.String?
}

extension DisassociateResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApplicationInput(application: \(Swift.String(describing: application)))"}
}

extension GetApplicationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationOutputError>
}

public struct GetApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationOutputError>
}

public struct GetApplicationInput: Swift.Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: Swift.String?

    public init (
        application: Swift.String? = nil
    )
    {
        self.application = application
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApplicationOutputResponse(arn: \(Swift.String(describing: arn)), associatedResourceCount: \(Swift.String(describing: associatedResourceCount)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension GetApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associatedResourceCount = output.associatedResourceCount
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastUpdateTime = output.lastUpdateTime
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.associatedResourceCount = 0
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastUpdateTime = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetApplicationOutputResponse: Swift.Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the application across services.</p>
    public let arn: Swift.String?
    /// <p>The number of top-level resources that were registered as part of this application.</p>
    public let associatedResourceCount: Swift.Int
    /// <p>The ISO-8601 formatted timestamp of the moment when the application was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>The description of the application.</p>
    public let description: Swift.String?
    /// <p>The identifier of the application.</p>
    public let id: Swift.String?
    /// <p>The ISO-8601 formatted timestamp of the moment when the application was last updated.</p>
    public let lastUpdateTime: ClientRuntime.Date?
    /// <p>The name of the application. The name must be unique in the region in which you are creating the application.</p>
    public let name: Swift.String?
    /// <p>Key-value pairs associated with the application.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        associatedResourceCount: Swift.Int = 0,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.associatedResourceCount = associatedResourceCount
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.tags = tags
    }
}

struct GetApplicationOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let arn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lastUpdateTime: ClientRuntime.Date?
    public let associatedResourceCount: Swift.Int
    public let tags: [Swift.String:Swift.String]?
}

extension GetApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associatedResourceCount
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let associatedResourceCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .associatedResourceCount)
        associatedResourceCount = associatedResourceCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetAttributeGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAttributeGroupInput(attributeGroup: \(Swift.String(describing: attributeGroup)))"}
}

extension GetAttributeGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAttributeGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttributeGroupOutputError>
}

public struct GetAttributeGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttributeGroupOutputError>
}

public struct GetAttributeGroupInput: Swift.Equatable {
    /// <p>The name or ID of the attribute group that holds the attributes to describe the application.</p>
    public let attributeGroup: Swift.String?

    public init (
        attributeGroup: Swift.String? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct GetAttributeGroupInputBody: Swift.Equatable {
}

extension GetAttributeGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAttributeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAttributeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAttributeGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAttributeGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAttributeGroupOutputResponse(arn: \(Swift.String(describing: arn)), attributes: \(Swift.String(describing: attributes)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension GetAttributeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.attributes = output.attributes
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastUpdateTime = output.lastUpdateTime
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.attributes = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastUpdateTime = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetAttributeGroupOutputResponse: Swift.Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the attribute group across services.</p>
    public let arn: Swift.String?
    /// <p>A JSON string in the form of nested key-value pairs that represent the attributes in the group and describes an application and its components.</p>
    public let attributes: Swift.String?
    /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>The description of the attribute group that the user provides.</p>
    public let description: Swift.String?
    /// <p>The identifier of the attribute group.</p>
    public let id: Swift.String?
    /// <p>The ISO-8601 formatted timestamp of the moment the attribute group was last updated. This time is the same as the creationTime for a newly created attribute group.</p>
    public let lastUpdateTime: ClientRuntime.Date?
    /// <p>The name of the attribute group.</p>
    public let name: Swift.String?
    /// <p>Key-value pairs associated with the attribute group.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        attributes: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.attributes = attributes
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.tags = tags
    }
}

struct GetAttributeGroupOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let arn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let attributes: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let lastUpdateTime: ClientRuntime.Date?
    public let tags: [Swift.String:Swift.String]?
}

extension GetAttributeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case attributes
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributes)
        attributes = attributesDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is experiencing internal problems.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApplicationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListApplicationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInput: Swift.Equatable {
    /// <p>The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.</p>
    public let maxResults: Swift.Int
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationsOutputResponse(applications: \(Swift.String(describing: applications)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Swift.Equatable {
    /// <p>This list of applications.</p>
    public let applications: [ServiceCatalogAppRegistryClientTypes.ApplicationSummary]?
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: Swift.String?

    public init (
        applications: [ServiceCatalogAppRegistryClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    public let applications: [ServiceCatalogAppRegistryClientTypes.ApplicationSummary]?
    public let nextToken: Swift.String?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([ServiceCatalogAppRegistryClientTypes.ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[ServiceCatalogAppRegistryClientTypes.ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [ServiceCatalogAppRegistryClientTypes.ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedAttributeGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociatedAttributeGroupsInput(application: \(Swift.String(describing: application)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociatedAttributeGroupsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAssociatedAttributeGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedAttributeGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedAttributeGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedAttributeGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedAttributeGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedAttributeGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedAttributeGroupsOutputError>
}

public struct ListAssociatedAttributeGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedAttributeGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedAttributeGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedAttributeGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedAttributeGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedAttributeGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedAttributeGroupsOutputError>
}

public struct ListAssociatedAttributeGroupsInput: Swift.Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: Swift.String?
    /// <p>The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.</p>
    public let maxResults: Swift.Int
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: Swift.String?

    public init (
        application: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.application = application
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociatedAttributeGroupsInputBody: Swift.Equatable {
}

extension ListAssociatedAttributeGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssociatedAttributeGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedAttributeGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedAttributeGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedAttributeGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociatedAttributeGroupsOutputResponse(attributeGroups: \(Swift.String(describing: attributeGroups)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociatedAttributeGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociatedAttributeGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroups = output.attributeGroups
            self.nextToken = output.nextToken
        } else {
            self.attributeGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedAttributeGroupsOutputResponse: Swift.Equatable {
    /// <p>A list of attribute group IDs.</p>
    public let attributeGroups: [Swift.String]?
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: Swift.String?

    public init (
        attributeGroups: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributeGroups = attributeGroups
        self.nextToken = nextToken
    }
}

struct ListAssociatedAttributeGroupsOutputResponseBody: Swift.Equatable {
    public let attributeGroups: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListAssociatedAttributeGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroups
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeGroups)
        var attributeGroupsDecoded0:[Swift.String]? = nil
        if let attributeGroupsContainer = attributeGroupsContainer {
            attributeGroupsDecoded0 = [Swift.String]()
            for string0 in attributeGroupsContainer {
                if let string0 = string0 {
                    attributeGroupsDecoded0?.append(string0)
                }
            }
        }
        attributeGroups = attributeGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociatedResourcesInput(application: \(Swift.String(describing: application)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociatedResourcesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAssociatedResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedResourcesOutputError>
}

public struct ListAssociatedResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedResourcesOutputError>
}

public struct ListAssociatedResourcesInput: Swift.Equatable {
    /// <p>The name or ID of the application.</p>
    public let application: Swift.String?
    /// <p>The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.</p>
    public let maxResults: Swift.Int
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: Swift.String?

    public init (
        application: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.application = application
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociatedResourcesInputBody: Swift.Equatable {
}

extension ListAssociatedResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssociatedResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedResourcesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociatedResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resources: \(Swift.String(describing: resources)))"}
}

extension ListAssociatedResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociatedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListAssociatedResourcesOutputResponse: Swift.Equatable {
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: Swift.String?
    /// <p>Information about the resources.</p>
    public let resources: [ServiceCatalogAppRegistryClientTypes.ResourceInfo]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [ServiceCatalogAppRegistryClientTypes.ResourceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListAssociatedResourcesOutputResponseBody: Swift.Equatable {
    public let resources: [ServiceCatalogAppRegistryClientTypes.ResourceInfo]?
    public let nextToken: Swift.String?
}

extension ListAssociatedResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([ServiceCatalogAppRegistryClientTypes.ResourceInfo?].self, forKey: .resources)
        var resourcesDecoded0:[ServiceCatalogAppRegistryClientTypes.ResourceInfo]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [ServiceCatalogAppRegistryClientTypes.ResourceInfo]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAttributeGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAttributeGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAttributeGroupsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAttributeGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttributeGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttributeGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttributeGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttributeGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttributeGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttributeGroupsOutputError>
}

public struct ListAttributeGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttributeGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttributeGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttributeGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttributeGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttributeGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttributeGroupsOutputError>
}

public struct ListAttributeGroupsInput: Swift.Equatable {
    /// <p>The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.</p>
    public let maxResults: Swift.Int
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAttributeGroupsInputBody: Swift.Equatable {
}

extension ListAttributeGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAttributeGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttributeGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttributeGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttributeGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAttributeGroupsOutputResponse(attributeGroups: \(Swift.String(describing: attributeGroups)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAttributeGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAttributeGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroups = output.attributeGroups
            self.nextToken = output.nextToken
        } else {
            self.attributeGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttributeGroupsOutputResponse: Swift.Equatable {
    /// <p>This list of attribute groups.</p>
    public let attributeGroups: [ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary]?
    /// <p>The token to use to get the next page of results after a previous API call. </p>
    public let nextToken: Swift.String?

    public init (
        attributeGroups: [ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributeGroups = attributeGroups
        self.nextToken = nextToken
    }
}

struct ListAttributeGroupsOutputResponseBody: Swift.Equatable {
    public let attributeGroups: [ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary]?
    public let nextToken: Swift.String?
}

extension ListAttributeGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroups
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupsContainer = try containerValues.decodeIfPresent([ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary?].self, forKey: .attributeGroups)
        var attributeGroupsDecoded0:[ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary]? = nil
        if let attributeGroupsContainer = attributeGroupsContainer {
            attributeGroupsDecoded0 = [ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary]()
            for structure0 in attributeGroupsContainer {
                if let structure0 = structure0 {
                    attributeGroupsDecoded0?.append(structure0)
                }
            }
        }
        attributeGroups = attributeGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>The tags on the resource.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ServiceCatalogAppRegistryClientTypes.ResourceInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes.ResourceInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInfo(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)))"}
}

extension ServiceCatalogAppRegistryClientTypes {
    /// <p>Information about the resource.</p>
    public struct ResourceInfo: Swift.Equatable {
        /// <p>The Amazon resource name (ARN) that specifies the resource across services.</p>
        public let arn: Swift.String?
        /// <p>The name of the resource.</p>
        public let name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cfnStack
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .cfnStack,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cfnStack: return "CFN_STACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of resources per account has been reached.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    public enum SyncAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noAction
        case startSync
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncAction] {
            return [
                .noAction,
                .startSync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noAction: return "NO_ACTION"
            case .startSync: return "START_SYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncAction(rawValue: rawValue) ?? SyncAction.sdkUnknown(rawValue)
        }
    }
}

extension SyncResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SyncResourceInput(resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension SyncResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct SyncResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SyncResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SyncResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SyncResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SyncResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SyncResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SyncResourceOutputError>
}

public struct SyncResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SyncResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SyncResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SyncResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SyncResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SyncResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SyncResourceOutputError>
}

public struct SyncResourceInput: Swift.Equatable {
    /// <p>An entity you can work with and specify with a name or ID. Examples include an Amazon EC2 instance, an AWS CloudFormation stack, or an Amazon S3 bucket.</p>
    public let resource: Swift.String?
    /// <p>The type of resource of which the application will be associated.</p>
    public let resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType?

    public init (
        resource: Swift.String? = nil,
        resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType? = nil
    )
    {
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct SyncResourceInputBody: Swift.Equatable {
}

extension SyncResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SyncResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SyncResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SyncResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SyncResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SyncResourceOutputResponse(actionTaken: \(Swift.String(describing: actionTaken)), applicationArn: \(Swift.String(describing: applicationArn)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension SyncResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SyncResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionTaken = output.actionTaken
            self.applicationArn = output.applicationArn
            self.resourceArn = output.resourceArn
        } else {
            self.actionTaken = nil
            self.applicationArn = nil
            self.resourceArn = nil
        }
    }
}

public struct SyncResourceOutputResponse: Swift.Equatable {
    /// <p>The results of the output if an application is associated with an ARN value, which could be <code>syncStarted</code> or None.</p>
    public let actionTaken: ServiceCatalogAppRegistryClientTypes.SyncAction?
    /// <p>The Amazon resource name (ARN) that specifies the application.</p>
    public let applicationArn: Swift.String?
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: Swift.String?

    public init (
        actionTaken: ServiceCatalogAppRegistryClientTypes.SyncAction? = nil,
        applicationArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.actionTaken = actionTaken
        self.applicationArn = applicationArn
        self.resourceArn = resourceArn
    }
}

struct SyncResourceOutputResponseBody: Swift.Equatable {
    public let applicationArn: Swift.String?
    public let resourceArn: Swift.String?
    public let actionTaken: ServiceCatalogAppRegistryClientTypes.SyncAction?
}

extension SyncResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTaken
        case applicationArn
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let actionTakenDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.SyncAction.self, forKey: .actionTaken)
        actionTaken = actionTakenDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: Swift.String?
    /// <p>The new or modified tags for the resource.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The Amazon resource name (ARN) that specifies the resource.</p>
    public let resourceArn: Swift.String?
    /// <p>A list of the tag keys to remove from the specified resource.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationInput(application: \(Swift.String(describing: application)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)))"}
}

extension UpdateApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// <p>The name or ID of the application that will be updated.</p>
    public let application: Swift.String?
    /// <p>The new description of the application.</p>
    public let description: Swift.String?
    /// <p>The new name of the application. The name must be unique in the region in which you are updating the application.</p>
    public let name: Swift.String?

    public init (
        application: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.application = application
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationOutputResponse(application: \(Swift.String(describing: application)))"}
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {
    /// <p>The updated information of the application.</p>
    public let application: ServiceCatalogAppRegistryClientTypes.Application?

    public init (
        application: ServiceCatalogAppRegistryClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct UpdateApplicationOutputResponseBody: Swift.Equatable {
    public let application: ServiceCatalogAppRegistryClientTypes.Application?
}

extension UpdateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

public struct UpdateAttributeGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAttributeGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAttributeGroupOutputError>
}

extension UpdateAttributeGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAttributeGroupInput(attributeGroup: \(Swift.String(describing: attributeGroup)), attributes: \(Swift.String(describing: attributes)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)))"}
}

extension UpdateAttributeGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAttributeGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAttributeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAttributeGroupOutputError>
}

public struct UpdateAttributeGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAttributeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAttributeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAttributeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAttributeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAttributeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAttributeGroupOutputError>
}

public struct UpdateAttributeGroupInput: Swift.Equatable {
    /// <p>The name or ID of the attribute group that holds the attributes to describe the application.</p>
    public let attributeGroup: Swift.String?
    /// <p>A JSON string in the form of nested key-value pairs that represent the attributes in the group and describes an application and its components.</p>
    public let attributes: Swift.String?
    /// <p>The description of the attribute group that the user provides.</p>
    public let description: Swift.String?
    /// <p>The new name of the attribute group. The name must be unique in the region in which you are
    ///        updating the attribute group.</p>
    public let name: Swift.String?

    public init (
        attributeGroup: Swift.String? = nil,
        attributes: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.attributeGroup = attributeGroup
        self.attributes = attributes
        self.description = description
        self.name = name
    }
}

struct UpdateAttributeGroupInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let attributes: Swift.String?
}

extension UpdateAttributeGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension UpdateAttributeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAttributeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAttributeGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAttributeGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAttributeGroupOutputResponse(attributeGroup: \(Swift.String(describing: attributeGroup)))"}
}

extension UpdateAttributeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAttributeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroup = output.attributeGroup
        } else {
            self.attributeGroup = nil
        }
    }
}

public struct UpdateAttributeGroupOutputResponse: Swift.Equatable {
    /// <p>The updated information of the attribute group.</p>
    public let attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup?

    public init (
        attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct UpdateAttributeGroupOutputResponseBody: Swift.Equatable {
    public let attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup?
}

extension UpdateAttributeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.AttributeGroup.self, forKey: .attributeGroup)
        attributeGroup = attributeGroupDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has invalid or missing parameters.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
