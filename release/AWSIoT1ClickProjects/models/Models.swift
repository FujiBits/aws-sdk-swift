// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateDeviceWithPlacementInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDeviceWithPlacementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDeviceWithPlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDeviceWithPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDeviceWithPlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDeviceWithPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDeviceWithPlacementOutputError>
}

extension AssociateDeviceWithPlacementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateDeviceWithPlacementInput(deviceId: \(Swift.String(describing: deviceId)), deviceTemplateName: \(Swift.String(describing: deviceTemplateName)), placementName: \(Swift.String(describing: placementName)), projectName: \(Swift.String(describing: projectName)))"}
}

extension AssociateDeviceWithPlacementInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
    }
}

public struct AssociateDeviceWithPlacementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDeviceWithPlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDeviceWithPlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDeviceWithPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDeviceWithPlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDeviceWithPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDeviceWithPlacementOutputError>
}

public struct AssociateDeviceWithPlacementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDeviceWithPlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDeviceWithPlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDeviceWithPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDeviceWithPlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDeviceWithPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDeviceWithPlacementOutputError>
}

public struct AssociateDeviceWithPlacementInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDeviceWithPlacementInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateDeviceWithPlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDeviceWithPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateDeviceWithPlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDeviceWithPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDeviceWithPlacementOutputError>
}

public struct AssociateDeviceWithPlacementInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDeviceWithPlacementInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateDeviceWithPlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDeviceWithPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        guard let placementName = input.placementName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("placementName is nil and needs a value for the path of this operation"))))
        }
        guard let deviceTemplateName = input.deviceTemplateName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deviceTemplateName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())/devices/\(deviceTemplateName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateDeviceWithPlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDeviceWithPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDeviceWithPlacementOutputError>
}

public struct AssociateDeviceWithPlacementInput: Swift.Equatable {
    /// The ID of the physical device to be associated with the given placement in the project.
    ///       Note that a mandatory 4 character prefix is required for all deviceId
    ///       values.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The device template name to associate with the device ID.
    /// This member is required.
    public var deviceTemplateName: Swift.String?
    /// The name of the placement in which to associate the device.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project containing the placement in which to associate the device.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        deviceTemplateName: Swift.String? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.deviceTemplateName = deviceTemplateName
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct AssociateDeviceWithPlacementInputBody: Swift.Equatable {
    public let deviceId: Swift.String?
}

extension AssociateDeviceWithPlacementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension AssociateDeviceWithPlacementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDeviceWithPlacementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDeviceWithPlacementOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDeviceWithPlacementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateDeviceWithPlacementOutputResponse()"}
}

extension AssociateDeviceWithPlacementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDeviceWithPlacementOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateDeviceWithPlacementOutputResponseBody: Swift.Equatable {
}

extension AssociateDeviceWithPlacementOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreatePlacementInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlacementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlacementOutputError>
}

extension CreatePlacementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePlacementInput(attributes: \(Swift.String(describing: attributes)), placementName: \(Swift.String(describing: placementName)), projectName: \(Swift.String(describing: projectName)))"}
}

extension CreatePlacementInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case placementName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, placementattributemap0) in attributes {
                try attributesContainer.encode(placementattributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let placementName = placementName {
            try encodeContainer.encode(placementName, forKey: .placementName)
        }
    }
}

public struct CreatePlacementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlacementOutputError>
}

public struct CreatePlacementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlacementOutputError>
}

public struct CreatePlacementInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlacementInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreatePlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlacementOutputError>
}

public struct CreatePlacementInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlacementInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreatePlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())/placements"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlacementOutputError>
}

public struct CreatePlacementInput: Swift.Equatable {
    /// Optional user-defined key/value pairs providing contextual data (such as location or
    ///       function) for the placement.
    public var attributes: [Swift.String:Swift.String]?
    /// The name of the placement to be created.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project in which to create the placement.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct CreatePlacementInputBody: Swift.Equatable {
    public let placementName: Swift.String?
    public let attributes: [Swift.String:Swift.String]?
}

extension CreatePlacementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case placementName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementName)
        placementName = placementNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CreatePlacementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePlacementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePlacementOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlacementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePlacementOutputResponse()"}
}

extension CreatePlacementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreatePlacementOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreatePlacementOutputResponseBody: Swift.Equatable {
}

extension CreatePlacementOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(description: \(Swift.String(describing: description)), placementTemplate: \(Swift.String(describing: placementTemplate)), projectName: \(Swift.String(describing: projectName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case placementTemplate
        case projectName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let placementTemplate = placementTemplate {
            try encodeContainer.encode(placementTemplate, forKey: .placementTemplate)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/projects"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInput: Swift.Equatable {
    /// An optional description for the project.
    public var description: Swift.String?
    /// The schema defining the placement to be created. A placement template defines placement
    ///       default attributes and device templates. You cannot add or remove device templates after the
    ///       project has been created. However, you can update callbackOverrides for the
    ///       device templates using the UpdateProject API.
    public var placementTemplate: Iot1ClickProjectsClientTypes.PlacementTemplate?
    /// The name of the project to create.
    /// This member is required.
    public var projectName: Swift.String?
    /// Optional tags (metadata key/value pairs) to be associated with the project. For example,
    ///         { {"key1": "value1", "key2": "value2"} }. For more information, see <a href="https://aws.amazon.com/answers/account-management/aws-tagging-strategies/">AWS Tagging
    ///         Strategies.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        placementTemplate: Iot1ClickProjectsClientTypes.PlacementTemplate? = nil,
        projectName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.placementTemplate = placementTemplate
        self.projectName = projectName
        self.tags = tags
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    public let projectName: Swift.String?
    public let description: Swift.String?
    public let placementTemplate: Iot1ClickProjectsClientTypes.PlacementTemplate?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case placementTemplate
        case projectName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let placementTemplateDecoded = try containerValues.decodeIfPresent(Iot1ClickProjectsClientTypes.PlacementTemplate.self, forKey: .placementTemplate)
        placementTemplate = placementTemplateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectOutputResponse()"}
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateProjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
}

extension CreateProjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePlacementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePlacementInput(placementName: \(Swift.String(describing: placementName)), projectName: \(Swift.String(describing: projectName)))"}
}

extension DeletePlacementInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePlacementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlacementOutputError>
}

public struct DeletePlacementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlacementOutputError>
}

public struct DeletePlacementInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlacementInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeletePlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlacementOutputError>
}

public struct DeletePlacementInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlacementInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeletePlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        guard let placementName = input.placementName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("placementName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlacementOutputError>
}

public struct DeletePlacementInput: Swift.Equatable {
    /// The name of the empty placement to delete.
    /// This member is required.
    public var placementName: Swift.String?
    /// The project containing the empty placement to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct DeletePlacementInputBody: Swift.Equatable {
}

extension DeletePlacementInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePlacementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePlacementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlacementOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlacementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePlacementOutputResponse()"}
}

extension DeletePlacementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlacementOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePlacementOutputResponseBody: Swift.Equatable {
}

extension DeletePlacementOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectInput(projectName: \(Swift.String(describing: projectName)))"}
}

extension DeleteProjectInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInput: Swift.Equatable {
    /// The name of the empty project to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectOutputResponse()"}
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProjectOutputResponseBody: Swift.Equatable {
}

extension DeleteProjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePlacementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePlacementInput(placementName: \(Swift.String(describing: placementName)), projectName: \(Swift.String(describing: projectName)))"}
}

extension DescribePlacementInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribePlacementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePlacementOutputError>
}

public struct DescribePlacementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePlacementOutputError>
}

public struct DescribePlacementInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePlacementInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribePlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePlacementOutputError>
}

public struct DescribePlacementInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePlacementInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribePlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        guard let placementName = input.placementName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("placementName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePlacementOutputError>
}

public struct DescribePlacementInput: Swift.Equatable {
    /// The name of the placement within a project.
    /// This member is required.
    public var placementName: Swift.String?
    /// The project containing the placement to be described.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct DescribePlacementInputBody: Swift.Equatable {
}

extension DescribePlacementInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePlacementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePlacementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePlacementOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePlacementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePlacementOutputResponse(placement: \(Swift.String(describing: placement)))"}
}

extension DescribePlacementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePlacementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.placement = output.placement
        } else {
            self.placement = nil
        }
    }
}

public struct DescribePlacementOutputResponse: Swift.Equatable {
    /// An object describing the placement.
    /// This member is required.
    public var placement: Iot1ClickProjectsClientTypes.PlacementDescription?

    public init (
        placement: Iot1ClickProjectsClientTypes.PlacementDescription? = nil
    )
    {
        self.placement = placement
    }
}

struct DescribePlacementOutputResponseBody: Swift.Equatable {
    public let placement: Iot1ClickProjectsClientTypes.PlacementDescription?
}

extension DescribePlacementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case placement
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placementDecoded = try containerValues.decodeIfPresent(Iot1ClickProjectsClientTypes.PlacementDescription.self, forKey: .placement)
        placement = placementDecoded
    }
}

extension DescribeProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectInput(projectName: \(Swift.String(describing: projectName)))"}
}

extension DescribeProjectInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The name of the project to be described.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectOutputResponse(project: \(Swift.String(describing: project)))"}
}

extension DescribeProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Swift.Equatable {
    /// An object describing the project.
    /// This member is required.
    public var project: Iot1ClickProjectsClientTypes.ProjectDescription?

    public init (
        project: Iot1ClickProjectsClientTypes.ProjectDescription? = nil
    )
    {
        self.project = project
    }
}

struct DescribeProjectOutputResponseBody: Swift.Equatable {
    public let project: Iot1ClickProjectsClientTypes.ProjectDescription?
}

extension DescribeProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(Iot1ClickProjectsClientTypes.ProjectDescription.self, forKey: .project)
        project = projectDecoded
    }
}

extension Iot1ClickProjectsClientTypes.DeviceTemplate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callbackOverrides
        case deviceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callbackOverrides = callbackOverrides {
            var callbackOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .callbackOverrides)
            for (dictKey0, devicecallbackoverridemap0) in callbackOverrides {
                try callbackOverridesContainer.encode(devicecallbackoverridemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let callbackOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .callbackOverrides)
        var callbackOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let callbackOverridesContainer = callbackOverridesContainer {
            callbackOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, devicecallbackvalue0) in callbackOverridesContainer {
                if let devicecallbackvalue0 = devicecallbackvalue0 {
                    callbackOverridesDecoded0?[key0] = devicecallbackvalue0
                }
            }
        }
        callbackOverrides = callbackOverridesDecoded0
    }
}

extension Iot1ClickProjectsClientTypes.DeviceTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceTemplate(callbackOverrides: \(Swift.String(describing: callbackOverrides)), deviceType: \(Swift.String(describing: deviceType)))"}
}

extension Iot1ClickProjectsClientTypes {
    /// An object representing a device for a placement template (see PlacementTemplate).
    public struct DeviceTemplate: Swift.Equatable {
        /// An optional Lambda function to invoke instead of the default Lambda function provided by
        ///       the placement template.
        public var callbackOverrides: [Swift.String:Swift.String]?
        /// The device type, which currently must be "button".
        public var deviceType: Swift.String?

        public init (
            callbackOverrides: [Swift.String:Swift.String]? = nil,
            deviceType: Swift.String? = nil
        )
        {
            self.callbackOverrides = callbackOverrides
            self.deviceType = deviceType
        }
    }

}

extension DisassociateDeviceFromPlacementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateDeviceFromPlacementInput(deviceTemplateName: \(Swift.String(describing: deviceTemplateName)), placementName: \(Swift.String(describing: placementName)), projectName: \(Swift.String(describing: projectName)))"}
}

extension DisassociateDeviceFromPlacementInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateDeviceFromPlacementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDeviceFromPlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDeviceFromPlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDeviceFromPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDeviceFromPlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDeviceFromPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDeviceFromPlacementOutputError>
}

public struct DisassociateDeviceFromPlacementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDeviceFromPlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDeviceFromPlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDeviceFromPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDeviceFromPlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDeviceFromPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDeviceFromPlacementOutputError>
}

public struct DisassociateDeviceFromPlacementInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDeviceFromPlacementInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateDeviceFromPlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDeviceFromPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateDeviceFromPlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDeviceFromPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDeviceFromPlacementOutputError>
}

public struct DisassociateDeviceFromPlacementInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDeviceFromPlacementInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateDeviceFromPlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDeviceFromPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        guard let placementName = input.placementName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("placementName is nil and needs a value for the path of this operation"))))
        }
        guard let deviceTemplateName = input.deviceTemplateName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deviceTemplateName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())/devices/\(deviceTemplateName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateDeviceFromPlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDeviceFromPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDeviceFromPlacementOutputError>
}

public struct DisassociateDeviceFromPlacementInput: Swift.Equatable {
    /// The device ID that should be removed from the placement.
    /// This member is required.
    public var deviceTemplateName: Swift.String?
    /// The name of the placement that the device should be removed from.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project that contains the placement.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        deviceTemplateName: Swift.String? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.deviceTemplateName = deviceTemplateName
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct DisassociateDeviceFromPlacementInputBody: Swift.Equatable {
}

extension DisassociateDeviceFromPlacementInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateDeviceFromPlacementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDeviceFromPlacementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDeviceFromPlacementOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDeviceFromPlacementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateDeviceFromPlacementOutputResponse()"}
}

extension DisassociateDeviceFromPlacementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDeviceFromPlacementOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateDeviceFromPlacementOutputResponseBody: Swift.Equatable {
}

extension DisassociateDeviceFromPlacementOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDevicesInPlacementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicesInPlacementInput(placementName: \(Swift.String(describing: placementName)), projectName: \(Swift.String(describing: projectName)))"}
}

extension GetDevicesInPlacementInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDevicesInPlacementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInPlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicesInPlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesInPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicesInPlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesInPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesInPlacementOutputError>
}

public struct GetDevicesInPlacementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInPlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicesInPlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesInPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicesInPlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesInPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesInPlacementOutputError>
}

public struct GetDevicesInPlacementInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInPlacementInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDevicesInPlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesInPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicesInPlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesInPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesInPlacementOutputError>
}

public struct GetDevicesInPlacementInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicesInPlacementInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDevicesInPlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicesInPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        guard let placementName = input.placementName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("placementName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())/devices"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicesInPlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicesInPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicesInPlacementOutputError>
}

public struct GetDevicesInPlacementInput: Swift.Equatable {
    /// The name of the placement to get the devices from.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project containing the placement.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct GetDevicesInPlacementInputBody: Swift.Equatable {
}

extension GetDevicesInPlacementInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDevicesInPlacementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicesInPlacementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicesInPlacementOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicesInPlacementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicesInPlacementOutputResponse(devices: \(Swift.String(describing: devices)))"}
}

extension GetDevicesInPlacementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDevicesInPlacementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
        } else {
            self.devices = nil
        }
    }
}

public struct GetDevicesInPlacementOutputResponse: Swift.Equatable {
    /// An object containing the devices (zero or more) within the placement.
    /// This member is required.
    public var devices: [Swift.String:Swift.String]?

    public init (
        devices: [Swift.String:Swift.String]? = nil
    )
    {
        self.devices = devices
    }
}

struct GetDevicesInPlacementOutputResponseBody: Swift.Equatable {
    public let devices: [Swift.String:Swift.String]?
}

extension GetDevicesInPlacementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .devices)
        var devicesDecoded0: [Swift.String:Swift.String]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [Swift.String:Swift.String]()
            for (key0, deviceid0) in devicesContainer {
                if let deviceid0 = deviceid0 {
                    devicesDecoded0?[key0] = deviceid0
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension InternalFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailureException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var code: Swift.String?
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var code: Swift.String?
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPlacementsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlacementsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectName: \(Swift.String(describing: projectName)))"}
}

extension ListPlacementsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPlacementsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlacementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlacementsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlacementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlacementsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlacementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlacementsOutputError>
}

public struct ListPlacementsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlacementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlacementsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlacementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlacementsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlacementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlacementsOutputError>
}

public struct ListPlacementsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlacementsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPlacementsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlacementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPlacementsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlacementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlacementsOutputError>
}

public struct ListPlacementsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlacementsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPlacementsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlacementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())/placements"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPlacementsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlacementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlacementsOutputError>
}

public struct ListPlacementsInput: Swift.Equatable {
    /// The maximum number of results to return per request. If not set, a default value of 100 is
    ///       used.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The project containing the placements to be listed.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

struct ListPlacementsInputBody: Swift.Equatable {
}

extension ListPlacementsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPlacementsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPlacementsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlacementsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlacementsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlacementsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), placements: \(Swift.String(describing: placements)))"}
}

extension ListPlacementsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPlacementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.placements = output.placements
        } else {
            self.nextToken = nil
            self.placements = nil
        }
    }
}

public struct ListPlacementsOutputResponse: Swift.Equatable {
    /// The token used to retrieve the next set of results - will be effectively empty if there
    ///       are no further results.
    public var nextToken: Swift.String?
    /// An object listing the requested placements.
    /// This member is required.
    public var placements: [Iot1ClickProjectsClientTypes.PlacementSummary]?

    public init (
        nextToken: Swift.String? = nil,
        placements: [Iot1ClickProjectsClientTypes.PlacementSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.placements = placements
    }
}

struct ListPlacementsOutputResponseBody: Swift.Equatable {
    public let placements: [Iot1ClickProjectsClientTypes.PlacementSummary]?
    public let nextToken: Swift.String?
}

extension ListPlacementsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case placements
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placementsContainer = try containerValues.decodeIfPresent([Iot1ClickProjectsClientTypes.PlacementSummary?].self, forKey: .placements)
        var placementsDecoded0:[Iot1ClickProjectsClientTypes.PlacementSummary]? = nil
        if let placementsContainer = placementsContainer {
            placementsDecoded0 = [Iot1ClickProjectsClientTypes.PlacementSummary]()
            for structure0 in placementsContainer {
                if let structure0 = structure0 {
                    placementsDecoded0?.append(structure0)
                }
            }
        }
        placements = placementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListProjectsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProjectsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListProjectsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProjectsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListProjectsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/projects"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProjectsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum number of results to return per request. If not set, a default value of 100 is
    ///       used.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), projects: \(Swift.String(describing: projects)))"}
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Swift.Equatable {
    /// The token used to retrieve the next set of results - will be effectively empty if there
    ///       are no further results.
    public var nextToken: Swift.String?
    /// An object containing the list of projects.
    /// This member is required.
    public var projects: [Iot1ClickProjectsClientTypes.ProjectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [Iot1ClickProjectsClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    public let projects: [Iot1ClickProjectsClientTypes.ProjectSummary]?
    public let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([Iot1ClickProjectsClientTypes.ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[Iot1ClickProjectsClientTypes.ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [Iot1ClickProjectsClientTypes.ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource whose tags you want to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags (metadata key/value pairs) which you have assigned to the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Iot1ClickProjectsClientTypes.PlacementDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case createdDate
        case placementName
        case projectName
        case updatedDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, placementattributemap0) in attributes {
                try attributesContainer.encode(placementattributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let placementName = placementName {
            try encodeContainer.encode(placementName, forKey: .placementName)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let updatedDate = updatedDate {
            try encodeContainer.encode(updatedDate.timeIntervalSince1970, forKey: .updatedDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let placementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementName)
        placementName = placementNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
    }
}

extension Iot1ClickProjectsClientTypes.PlacementDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlacementDescription(attributes: \(Swift.String(describing: attributes)), createdDate: \(Swift.String(describing: createdDate)), placementName: \(Swift.String(describing: placementName)), projectName: \(Swift.String(describing: projectName)), updatedDate: \(Swift.String(describing: updatedDate)))"}
}

extension Iot1ClickProjectsClientTypes {
    /// An object describing a project's placement.
    public struct PlacementDescription: Swift.Equatable {
        /// The user-defined attributes associated with the placement.
        /// This member is required.
        public var attributes: [Swift.String:Swift.String]?
        /// The date when the placement was initially created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The name of the placement.
        /// This member is required.
        public var placementName: Swift.String?
        /// The name of the project containing the placement.
        /// This member is required.
        public var projectName: Swift.String?
        /// The date when the placement was last updated, in UNIX epoch time format. If the placement
        ///       was not updated, then createdDate and updatedDate are the
        ///       same.
        /// This member is required.
        public var updatedDate: ClientRuntime.Date?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            createdDate: ClientRuntime.Date? = nil,
            placementName: Swift.String? = nil,
            projectName: Swift.String? = nil,
            updatedDate: ClientRuntime.Date? = nil
        )
        {
            self.attributes = attributes
            self.createdDate = createdDate
            self.placementName = placementName
            self.projectName = projectName
            self.updatedDate = updatedDate
        }
    }

}

extension Iot1ClickProjectsClientTypes.PlacementSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case placementName
        case projectName
        case updatedDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let placementName = placementName {
            try encodeContainer.encode(placementName, forKey: .placementName)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let updatedDate = updatedDate {
            try encodeContainer.encode(updatedDate.timeIntervalSince1970, forKey: .updatedDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let placementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementName)
        placementName = placementNameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
    }
}

extension Iot1ClickProjectsClientTypes.PlacementSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlacementSummary(createdDate: \(Swift.String(describing: createdDate)), placementName: \(Swift.String(describing: placementName)), projectName: \(Swift.String(describing: projectName)), updatedDate: \(Swift.String(describing: updatedDate)))"}
}

extension Iot1ClickProjectsClientTypes {
    /// An object providing summary information for a particular placement.
    public struct PlacementSummary: Swift.Equatable {
        /// The date when the placement was originally created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The name of the placement being summarized.
        /// This member is required.
        public var placementName: Swift.String?
        /// The name of the project containing the placement.
        /// This member is required.
        public var projectName: Swift.String?
        /// The date when the placement was last updated, in UNIX epoch time format. If the placement
        ///       was not updated, then createdDate and updatedDate are the
        ///       same.
        /// This member is required.
        public var updatedDate: ClientRuntime.Date?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            placementName: Swift.String? = nil,
            projectName: Swift.String? = nil,
            updatedDate: ClientRuntime.Date? = nil
        )
        {
            self.createdDate = createdDate
            self.placementName = placementName
            self.projectName = projectName
            self.updatedDate = updatedDate
        }
    }

}

extension Iot1ClickProjectsClientTypes.PlacementTemplate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAttributes
        case deviceTemplates
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAttributes = defaultAttributes {
            var defaultAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultAttributes)
            for (dictKey0, defaultplacementattributemap0) in defaultAttributes {
                try defaultAttributesContainer.encode(defaultplacementattributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let deviceTemplates = deviceTemplates {
            var deviceTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .deviceTemplates)
            for (dictKey0, devicetemplatemap0) in deviceTemplates {
                try deviceTemplatesContainer.encode(devicetemplatemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultAttributes)
        var defaultAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultAttributesContainer = defaultAttributesContainer {
            defaultAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributedefaultvalue0) in defaultAttributesContainer {
                if let attributedefaultvalue0 = attributedefaultvalue0 {
                    defaultAttributesDecoded0?[key0] = attributedefaultvalue0
                }
            }
        }
        defaultAttributes = defaultAttributesDecoded0
        let deviceTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Iot1ClickProjectsClientTypes.DeviceTemplate?].self, forKey: .deviceTemplates)
        var deviceTemplatesDecoded0: [Swift.String:Iot1ClickProjectsClientTypes.DeviceTemplate]? = nil
        if let deviceTemplatesContainer = deviceTemplatesContainer {
            deviceTemplatesDecoded0 = [Swift.String:Iot1ClickProjectsClientTypes.DeviceTemplate]()
            for (key0, devicetemplate0) in deviceTemplatesContainer {
                if let devicetemplate0 = devicetemplate0 {
                    deviceTemplatesDecoded0?[key0] = devicetemplate0
                }
            }
        }
        deviceTemplates = deviceTemplatesDecoded0
    }
}

extension Iot1ClickProjectsClientTypes.PlacementTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlacementTemplate(defaultAttributes: \(Swift.String(describing: defaultAttributes)), deviceTemplates: \(Swift.String(describing: deviceTemplates)))"}
}

extension Iot1ClickProjectsClientTypes {
    /// An object defining the template for a placement.
    public struct PlacementTemplate: Swift.Equatable {
        /// The default attributes (key/value pairs) to be applied to all placements using this
        ///       template.
        public var defaultAttributes: [Swift.String:Swift.String]?
        /// An object specifying the DeviceTemplate for all placements using this
        ///         (PlacementTemplate) template.
        public var deviceTemplates: [Swift.String:Iot1ClickProjectsClientTypes.DeviceTemplate]?

        public init (
            defaultAttributes: [Swift.String:Swift.String]? = nil,
            deviceTemplates: [Swift.String:Iot1ClickProjectsClientTypes.DeviceTemplate]? = nil
        )
        {
            self.defaultAttributes = defaultAttributes
            self.deviceTemplates = deviceTemplates
        }
    }

}

extension Iot1ClickProjectsClientTypes.ProjectDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case description
        case placementTemplate
        case projectName
        case tags
        case updatedDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let placementTemplate = placementTemplate {
            try encodeContainer.encode(placementTemplate, forKey: .placementTemplate)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedDate = updatedDate {
            try encodeContainer.encode(updatedDate.timeIntervalSince1970, forKey: .updatedDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
        let placementTemplateDecoded = try containerValues.decodeIfPresent(Iot1ClickProjectsClientTypes.PlacementTemplate.self, forKey: .placementTemplate)
        placementTemplate = placementTemplateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Iot1ClickProjectsClientTypes.ProjectDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectDescription(arn: \(Swift.String(describing: arn)), createdDate: \(Swift.String(describing: createdDate)), description: \(Swift.String(describing: description)), placementTemplate: \(Swift.String(describing: placementTemplate)), projectName: \(Swift.String(describing: projectName)), tags: \(Swift.String(describing: tags)), updatedDate: \(Swift.String(describing: updatedDate)))"}
}

extension Iot1ClickProjectsClientTypes {
    /// An object providing detailed information for a particular project associated with an AWS
    ///       account and region.
    public struct ProjectDescription: Swift.Equatable {
        /// The ARN of the project.
        public var arn: Swift.String?
        /// The date when the project was originally created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The description of the project.
        public var description: Swift.String?
        /// An object describing the project's placement specifications.
        public var placementTemplate: Iot1ClickProjectsClientTypes.PlacementTemplate?
        /// The name of the project for which to obtain information from.
        /// This member is required.
        public var projectName: Swift.String?
        /// The tags (metadata key/value pairs) associated with the project.
        public var tags: [Swift.String:Swift.String]?
        /// The date when the project was last updated, in UNIX epoch time format. If the project was
        ///       not updated, then createdDate and updatedDate are the same.
        /// This member is required.
        public var updatedDate: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            placementTemplate: Iot1ClickProjectsClientTypes.PlacementTemplate? = nil,
            projectName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.placementTemplate = placementTemplate
            self.projectName = projectName
            self.tags = tags
            self.updatedDate = updatedDate
        }
    }

}

extension Iot1ClickProjectsClientTypes.ProjectSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case projectName
        case tags
        case updatedDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedDate = updatedDate {
            try encodeContainer.encode(updatedDate.timeIntervalSince1970, forKey: .updatedDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Iot1ClickProjectsClientTypes.ProjectSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectSummary(arn: \(Swift.String(describing: arn)), createdDate: \(Swift.String(describing: createdDate)), projectName: \(Swift.String(describing: projectName)), tags: \(Swift.String(describing: tags)), updatedDate: \(Swift.String(describing: updatedDate)))"}
}

extension Iot1ClickProjectsClientTypes {
    /// An object providing summary information for a particular project for an associated AWS
    ///       account and region.
    public struct ProjectSummary: Swift.Equatable {
        /// The ARN of the project.
        public var arn: Swift.String?
        /// The date when the project was originally created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The name of the project being summarized.
        /// This member is required.
        public var projectName: Swift.String?
        /// The tags (metadata key/value pairs) associated with the project.
        public var tags: [Swift.String:Swift.String]?
        /// The date when the project was last updated, in UNIX epoch time format. If the project was
        ///       not updated, then createdDate and updatedDate are the same.
        /// This member is required.
        public var updatedDate: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            projectName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.projectName = projectName
            self.tags = tags
            self.updatedDate = updatedDate
        }
    }

}

extension ResourceConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceConflictException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ResourceConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var code: Swift.String?
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var code: Swift.String?
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resouce for which tag(s) should be added or modified.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modifying tag(s) for the resource. See <a href="https://docs.aws.amazon.com/iot-1-click/latest/developerguide/1click-appendix.html#1click-limits">AWS IoT 1-Click Service Limits for the maximum number of tags allowed per
    ///       resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var code: Swift.String?
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource whose tag you want to remove.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of those tags which you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdatePlacementInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePlacementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePlacementOutputError>
}

extension UpdatePlacementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePlacementInput(attributes: \(Swift.String(describing: attributes)), placementName: \(Swift.String(describing: placementName)), projectName: \(Swift.String(describing: projectName)))"}
}

extension UpdatePlacementInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, placementattributemap0) in attributes {
                try attributesContainer.encode(placementattributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdatePlacementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePlacementOutputError>
}

public struct UpdatePlacementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePlacementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePlacementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePlacementOutputError>
}

public struct UpdatePlacementInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePlacementInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdatePlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePlacementOutputError>
}

public struct UpdatePlacementInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePlacementInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdatePlacementInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        guard let placementName = input.placementName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("placementName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePlacementInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePlacementOutputError>
}

public struct UpdatePlacementInput: Swift.Equatable {
    /// The user-defined object of attributes used to update the placement. The maximum number of
    ///       key/value pairs is 50.
    public var attributes: [Swift.String:Swift.String]?
    /// The name of the placement to update.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project containing the placement to be updated.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct UpdatePlacementInputBody: Swift.Equatable {
    public let attributes: [Swift.String:Swift.String]?
}

extension UpdatePlacementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension UpdatePlacementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePlacementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePlacementOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePlacementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePlacementOutputResponse()"}
}

extension UpdatePlacementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePlacementOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdatePlacementOutputResponseBody: Swift.Equatable {
}

extension UpdatePlacementOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(description: \(Swift.String(describing: description)), placementTemplate: \(Swift.String(describing: placementTemplate)), projectName: \(Swift.String(describing: projectName)))"}
}

extension UpdateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case placementTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let placementTemplate = placementTemplate {
            try encodeContainer.encode(placementTemplate, forKey: .placementTemplate)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectName = input.projectName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInput: Swift.Equatable {
    /// An optional user-defined description for the project.
    public var description: Swift.String?
    /// An object defining the project update. Once a project has been created, you cannot add
    ///       device template names to the project. However, for a given placementTemplate, you
    ///       can update the associated callbackOverrides for the device definition using this
    ///       API.
    public var placementTemplate: Iot1ClickProjectsClientTypes.PlacementTemplate?
    /// The name of the project to be updated.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        description: Swift.String? = nil,
        placementTemplate: Iot1ClickProjectsClientTypes.PlacementTemplate? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.description = description
        self.placementTemplate = placementTemplate
        self.projectName = projectName
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let placementTemplate: Iot1ClickProjectsClientTypes.PlacementTemplate?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case placementTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let placementTemplateDecoded = try containerValues.decodeIfPresent(Iot1ClickProjectsClientTypes.PlacementTemplate.self, forKey: .placementTemplate)
        placementTemplate = placementTemplateDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectOutputResponse()"}
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateProjectOutputResponseBody: Swift.Equatable {
}

extension UpdateProjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}
