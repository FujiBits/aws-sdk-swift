// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have required permissions to access the requested resource.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Resource type that caused the exception
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceType: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct AssociateMemberAccountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateMemberAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateMemberAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateMemberAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateMemberAccountOutputError>
}

extension AssociateMemberAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateMemberAccountInput(memberAccountId: \(Swift.String(describing: memberAccountId)))"}
}

extension AssociateMemberAccountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

public struct AssociateMemberAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateMemberAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateMemberAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateMemberAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateMemberAccountOutputError>
}

public struct AssociateMemberAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateMemberAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateMemberAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateMemberAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateMemberAccountOutputError>
}

public struct AssociateMemberAccountInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateMemberAccountInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateMemberAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateMemberAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateMemberAccountOutputError>
}

public struct AssociateMemberAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateMemberAccountInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateMemberAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateMemberAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateMemberAccountOutputError>
}

public struct AssociateMemberAccountInput: Swift.Equatable {
    /// The ID of the AWS account that you want to associate with Amazon Macie Classic as a member account.
    /// This member is required.
    public var memberAccountId: Swift.String?

    public init (
        memberAccountId: Swift.String? = nil
    )
    {
        self.memberAccountId = memberAccountId
    }
}

struct AssociateMemberAccountInputBody: Swift.Equatable {
    public let memberAccountId: Swift.String?
}

extension AssociateMemberAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
    }
}

extension AssociateMemberAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateMemberAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateMemberAccountOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateMemberAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateMemberAccountOutputResponse()"}
}

extension AssociateMemberAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateMemberAccountOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateMemberAccountOutputResponseBody: Swift.Equatable {
}

extension AssociateMemberAccountOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociateS3ResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateS3ResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateS3ResourcesOutputError>
}

extension AssociateS3ResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateS3ResourcesInput(memberAccountId: \(Swift.String(describing: memberAccountId)), s3Resources: \(Swift.String(describing: s3Resources)))"}
}

extension AssociateS3ResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
        case s3Resources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let s3Resources = s3Resources {
            var s3ResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Resources)
            for s3resourcesclassification0 in s3Resources {
                try s3ResourcesContainer.encode(s3resourcesclassification0)
            }
        }
    }
}

public struct AssociateS3ResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateS3ResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateS3ResourcesOutputError>
}

public struct AssociateS3ResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateS3ResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateS3ResourcesOutputError>
}

public struct AssociateS3ResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateS3ResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateS3ResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateS3ResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateS3ResourcesOutputError>
}

public struct AssociateS3ResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateS3ResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateS3ResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateS3ResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateS3ResourcesOutputError>
}

public struct AssociateS3ResourcesInput: Swift.Equatable {
    /// The ID of the Amazon Macie Classic member account whose resources you want to associate with Macie Classic.
    public var memberAccountId: Swift.String?
    /// The S3 resources that you want to associate with Amazon Macie Classic for monitoring and data classification.
    /// This member is required.
    public var s3Resources: [MacieClientTypes.S3ResourceClassification]?

    public init (
        memberAccountId: Swift.String? = nil,
        s3Resources: [MacieClientTypes.S3ResourceClassification]? = nil
    )
    {
        self.memberAccountId = memberAccountId
        self.s3Resources = s3Resources
    }
}

struct AssociateS3ResourcesInputBody: Swift.Equatable {
    public let memberAccountId: Swift.String?
    public let s3Resources: [MacieClientTypes.S3ResourceClassification]?
}

extension AssociateS3ResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
        case s3Resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let s3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.S3ResourceClassification?].self, forKey: .s3Resources)
        var s3ResourcesDecoded0:[MacieClientTypes.S3ResourceClassification]? = nil
        if let s3ResourcesContainer = s3ResourcesContainer {
            s3ResourcesDecoded0 = [MacieClientTypes.S3ResourceClassification]()
            for structure0 in s3ResourcesContainer {
                if let structure0 = structure0 {
                    s3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        s3Resources = s3ResourcesDecoded0
    }
}

extension AssociateS3ResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateS3ResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateS3ResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateS3ResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateS3ResourcesOutputResponse(failedS3Resources: \(Swift.String(describing: failedS3Resources)))"}
}

extension AssociateS3ResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateS3ResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedS3Resources = output.failedS3Resources
        } else {
            self.failedS3Resources = nil
        }
    }
}

public struct AssociateS3ResourcesOutputResponse: Swift.Equatable {
    /// S3 resources that couldn't be associated with Amazon Macie Classic. An error code and an error message are provided for each failed item.
    public var failedS3Resources: [MacieClientTypes.FailedS3Resource]?

    public init (
        failedS3Resources: [MacieClientTypes.FailedS3Resource]? = nil
    )
    {
        self.failedS3Resources = failedS3Resources
    }
}

struct AssociateS3ResourcesOutputResponseBody: Swift.Equatable {
    public let failedS3Resources: [MacieClientTypes.FailedS3Resource]?
}

extension AssociateS3ResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedS3Resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedS3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.FailedS3Resource?].self, forKey: .failedS3Resources)
        var failedS3ResourcesDecoded0:[MacieClientTypes.FailedS3Resource]? = nil
        if let failedS3ResourcesContainer = failedS3ResourcesContainer {
            failedS3ResourcesDecoded0 = [MacieClientTypes.FailedS3Resource]()
            for structure0 in failedS3ResourcesContainer {
                if let structure0 = structure0 {
                    failedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedS3Resources = failedS3ResourcesDecoded0
    }
}

extension MacieClientTypes.ClassificationType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuous
        case oneTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let continuous = continuous {
            try encodeContainer.encode(continuous.rawValue, forKey: .continuous)
        }
        if let oneTime = oneTime {
            try encodeContainer.encode(oneTime.rawValue, forKey: .oneTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oneTimeDecoded = try containerValues.decodeIfPresent(MacieClientTypes.S3OneTimeClassificationType.self, forKey: .oneTime)
        oneTime = oneTimeDecoded
        let continuousDecoded = try containerValues.decodeIfPresent(MacieClientTypes.S3ContinuousClassificationType.self, forKey: .continuous)
        continuous = continuousDecoded
    }
}

extension MacieClientTypes.ClassificationType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClassificationType(continuous: \(Swift.String(describing: continuous)), oneTime: \(Swift.String(describing: oneTime)))"}
}

extension MacieClientTypes {
    /// The classification type that Amazon Macie Classic applies to the associated S3 resources.
    public struct ClassificationType: Swift.Equatable {
        /// A continuous classification of the objects that are added to a specified S3 bucket. Amazon Macie Classic begins performing continuous classification after a bucket is successfully associated with Macie Classic.
        /// This member is required.
        public var continuous: MacieClientTypes.S3ContinuousClassificationType?
        /// A one-time classification of all of the existing objects in a specified S3 bucket.
        /// This member is required.
        public var oneTime: MacieClientTypes.S3OneTimeClassificationType?

        public init (
            continuous: MacieClientTypes.S3ContinuousClassificationType? = nil,
            oneTime: MacieClientTypes.S3OneTimeClassificationType? = nil
        )
        {
            self.continuous = continuous
            self.oneTime = oneTime
        }
    }

}

extension MacieClientTypes.ClassificationTypeUpdate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuous
        case oneTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let continuous = continuous {
            try encodeContainer.encode(continuous.rawValue, forKey: .continuous)
        }
        if let oneTime = oneTime {
            try encodeContainer.encode(oneTime.rawValue, forKey: .oneTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oneTimeDecoded = try containerValues.decodeIfPresent(MacieClientTypes.S3OneTimeClassificationType.self, forKey: .oneTime)
        oneTime = oneTimeDecoded
        let continuousDecoded = try containerValues.decodeIfPresent(MacieClientTypes.S3ContinuousClassificationType.self, forKey: .continuous)
        continuous = continuousDecoded
    }
}

extension MacieClientTypes.ClassificationTypeUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClassificationTypeUpdate(continuous: \(Swift.String(describing: continuous)), oneTime: \(Swift.String(describing: oneTime)))"}
}

extension MacieClientTypes {
    /// The classification type that Amazon Macie Classic applies to the associated S3 resources. At least one of the classification types (oneTime or continuous) must be specified.
    public struct ClassificationTypeUpdate: Swift.Equatable {
        /// A continuous classification of the objects that are added to a specified S3 bucket. Amazon Macie Classic begins performing continuous classification after a bucket is successfully associated with Macie Classic.
        public var continuous: MacieClientTypes.S3ContinuousClassificationType?
        /// A one-time classification of all of the existing objects in a specified S3 bucket.
        public var oneTime: MacieClientTypes.S3OneTimeClassificationType?

        public init (
            continuous: MacieClientTypes.S3ContinuousClassificationType? = nil,
            oneTime: MacieClientTypes.S3OneTimeClassificationType? = nil
        )
        {
            self.continuous = continuous
            self.oneTime = oneTime
        }
    }

}

public struct DisassociateMemberAccountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMemberAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateMemberAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateMemberAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMemberAccountOutputError>
}

extension DisassociateMemberAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateMemberAccountInput(memberAccountId: \(Swift.String(describing: memberAccountId)))"}
}

extension DisassociateMemberAccountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

public struct DisassociateMemberAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMemberAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateMemberAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateMemberAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMemberAccountOutputError>
}

public struct DisassociateMemberAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMemberAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateMemberAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateMemberAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMemberAccountOutputError>
}

public struct DisassociateMemberAccountInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMemberAccountInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateMemberAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateMemberAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMemberAccountOutputError>
}

public struct DisassociateMemberAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMemberAccountInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateMemberAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateMemberAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMemberAccountOutputError>
}

public struct DisassociateMemberAccountInput: Swift.Equatable {
    /// The ID of the member account that you want to remove from Amazon Macie Classic.
    /// This member is required.
    public var memberAccountId: Swift.String?

    public init (
        memberAccountId: Swift.String? = nil
    )
    {
        self.memberAccountId = memberAccountId
    }
}

struct DisassociateMemberAccountInputBody: Swift.Equatable {
    public let memberAccountId: Swift.String?
}

extension DisassociateMemberAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
    }
}

extension DisassociateMemberAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMemberAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMemberAccountOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMemberAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateMemberAccountOutputResponse()"}
}

extension DisassociateMemberAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMemberAccountOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateMemberAccountOutputResponseBody: Swift.Equatable {
}

extension DisassociateMemberAccountOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateS3ResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateS3ResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateS3ResourcesOutputError>
}

extension DisassociateS3ResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateS3ResourcesInput(associatedS3Resources: \(Swift.String(describing: associatedS3Resources)), memberAccountId: \(Swift.String(describing: memberAccountId)))"}
}

extension DisassociateS3ResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedS3Resources
        case memberAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedS3Resources = associatedS3Resources {
            var associatedS3ResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedS3Resources)
            for s3resources0 in associatedS3Resources {
                try associatedS3ResourcesContainer.encode(s3resources0)
            }
        }
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

public struct DisassociateS3ResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateS3ResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateS3ResourcesOutputError>
}

public struct DisassociateS3ResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateS3ResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateS3ResourcesOutputError>
}

public struct DisassociateS3ResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateS3ResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateS3ResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateS3ResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateS3ResourcesOutputError>
}

public struct DisassociateS3ResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateS3ResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateS3ResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateS3ResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateS3ResourcesOutputError>
}

public struct DisassociateS3ResourcesInput: Swift.Equatable {
    /// The S3 resources (buckets or prefixes) that you want to remove from being monitored and classified by Amazon Macie Classic.
    /// This member is required.
    public var associatedS3Resources: [MacieClientTypes.S3Resource]?
    /// The ID of the Amazon Macie Classic member account whose resources you want to remove from being monitored by Macie Classic.
    public var memberAccountId: Swift.String?

    public init (
        associatedS3Resources: [MacieClientTypes.S3Resource]? = nil,
        memberAccountId: Swift.String? = nil
    )
    {
        self.associatedS3Resources = associatedS3Resources
        self.memberAccountId = memberAccountId
    }
}

struct DisassociateS3ResourcesInputBody: Swift.Equatable {
    public let memberAccountId: Swift.String?
    public let associatedS3Resources: [MacieClientTypes.S3Resource]?
}

extension DisassociateS3ResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedS3Resources
        case memberAccountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let associatedS3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.S3Resource?].self, forKey: .associatedS3Resources)
        var associatedS3ResourcesDecoded0:[MacieClientTypes.S3Resource]? = nil
        if let associatedS3ResourcesContainer = associatedS3ResourcesContainer {
            associatedS3ResourcesDecoded0 = [MacieClientTypes.S3Resource]()
            for structure0 in associatedS3ResourcesContainer {
                if let structure0 = structure0 {
                    associatedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        associatedS3Resources = associatedS3ResourcesDecoded0
    }
}

extension DisassociateS3ResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateS3ResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateS3ResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateS3ResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateS3ResourcesOutputResponse(failedS3Resources: \(Swift.String(describing: failedS3Resources)))"}
}

extension DisassociateS3ResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateS3ResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedS3Resources = output.failedS3Resources
        } else {
            self.failedS3Resources = nil
        }
    }
}

public struct DisassociateS3ResourcesOutputResponse: Swift.Equatable {
    /// S3 resources that couldn't be removed from being monitored and classified by Amazon Macie Classic. An error code and an error message are provided for each failed item.
    public var failedS3Resources: [MacieClientTypes.FailedS3Resource]?

    public init (
        failedS3Resources: [MacieClientTypes.FailedS3Resource]? = nil
    )
    {
        self.failedS3Resources = failedS3Resources
    }
}

struct DisassociateS3ResourcesOutputResponseBody: Swift.Equatable {
    public let failedS3Resources: [MacieClientTypes.FailedS3Resource]?
}

extension DisassociateS3ResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedS3Resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedS3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.FailedS3Resource?].self, forKey: .failedS3Resources)
        var failedS3ResourcesDecoded0:[MacieClientTypes.FailedS3Resource]? = nil
        if let failedS3ResourcesContainer = failedS3ResourcesContainer {
            failedS3ResourcesDecoded0 = [MacieClientTypes.FailedS3Resource]()
            for structure0 in failedS3ResourcesContainer {
                if let structure0 = structure0 {
                    failedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedS3Resources = failedS3ResourcesDecoded0
    }
}

extension MacieClientTypes.FailedS3Resource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case failedItem
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let failedItem = failedItem {
            try encodeContainer.encode(failedItem, forKey: .failedItem)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedItemDecoded = try containerValues.decodeIfPresent(MacieClientTypes.S3Resource.self, forKey: .failedItem)
        failedItem = failedItemDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension MacieClientTypes.FailedS3Resource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailedS3Resource(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), failedItem: \(Swift.String(describing: failedItem)))"}
}

extension MacieClientTypes {
    /// Includes details about the failed S3 resources.
    public struct FailedS3Resource: Swift.Equatable {
        /// The status code of a failed item.
        public var errorCode: Swift.String?
        /// The error message of a failed item.
        public var errorMessage: Swift.String?
        /// The failed S3 resources.
        public var failedItem: MacieClientTypes.S3Resource?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            failedItem: MacieClientTypes.S3Resource? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.failedItem = failedItem
        }
    }

}

extension InternalException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension InternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Internal server error.
public struct InternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Error code for the exception
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInputException(errorCode: \(Swift.String(describing: errorCode)), fieldName: \(Swift.String(describing: fieldName)), message: \(Swift.String(describing: message)))"}
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.fieldName = output.fieldName
            self.message = output.message
        } else {
            self.errorCode = nil
            self.fieldName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because an invalid or out-of-range value was supplied for an input parameter.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error code for the exception
    public var errorCode: Swift.String?
    /// Field that has invalid input
    public var fieldName: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
    public let fieldName: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case fieldName
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.errorCode = nil
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current AWS account limits. The error code describes the limit exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error code for the exception
    public var errorCode: Swift.String?
    public var message: Swift.String?
    /// Resource type that caused the exception
    public var resourceType: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
    public let resourceType: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct ListMemberAccountsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMemberAccountsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMemberAccountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMemberAccountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMemberAccountsOutputError>
}

extension ListMemberAccountsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMemberAccountsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMemberAccountsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListMemberAccountsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMemberAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMemberAccountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMemberAccountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMemberAccountsOutputError>
}

public struct ListMemberAccountsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMemberAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMemberAccountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMemberAccountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMemberAccountsOutputError>
}

public struct ListMemberAccountsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMemberAccountsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMemberAccountsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMemberAccountsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMemberAccountsOutputError>
}

public struct ListMemberAccountsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMemberAccountsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMemberAccountsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMemberAccountsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMemberAccountsOutputError>
}

public struct ListMemberAccountsInput: Swift.Equatable {
    /// Use this parameter to indicate the maximum number of items that you want in the response. The default value is 250.
    public var maxResults: Swift.Int?
    /// Use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListMemberAccounts action. Subsequent calls to the action fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListMemberAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMemberAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMemberAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMemberAccountsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMemberAccountsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMemberAccountsOutputResponse(memberAccounts: \(Swift.String(describing: memberAccounts)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMemberAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMemberAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberAccounts = output.memberAccounts
            self.nextToken = output.nextToken
        } else {
            self.memberAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListMemberAccountsOutputResponse: Swift.Equatable {
    /// A list of the Amazon Macie Classic member accounts returned by the action. The current Macie Classic administrator account is also included in this list.
    public var memberAccounts: [MacieClientTypes.MemberAccount]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        memberAccounts: [MacieClientTypes.MemberAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.memberAccounts = memberAccounts
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsOutputResponseBody: Swift.Equatable {
    public let memberAccounts: [MacieClientTypes.MemberAccount]?
    public let nextToken: Swift.String?
}

extension ListMemberAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccounts
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountsContainer = try containerValues.decodeIfPresent([MacieClientTypes.MemberAccount?].self, forKey: .memberAccounts)
        var memberAccountsDecoded0:[MacieClientTypes.MemberAccount]? = nil
        if let memberAccountsContainer = memberAccountsContainer {
            memberAccountsDecoded0 = [MacieClientTypes.MemberAccount]()
            for structure0 in memberAccountsContainer {
                if let structure0 = structure0 {
                    memberAccountsDecoded0?.append(structure0)
                }
            }
        }
        memberAccounts = memberAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListS3ResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListS3ResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListS3ResourcesOutputError>
}

extension ListS3ResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListS3ResourcesInput(maxResults: \(Swift.String(describing: maxResults)), memberAccountId: \(Swift.String(describing: memberAccountId)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListS3ResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case memberAccountId
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListS3ResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListS3ResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListS3ResourcesOutputError>
}

public struct ListS3ResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListS3ResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListS3ResourcesOutputError>
}

public struct ListS3ResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListS3ResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListS3ResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListS3ResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListS3ResourcesOutputError>
}

public struct ListS3ResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListS3ResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListS3ResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListS3ResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListS3ResourcesOutputError>
}

public struct ListS3ResourcesInput: Swift.Equatable {
    /// Use this parameter to indicate the maximum number of items that you want in the response. The default value is 250.
    public var maxResults: Swift.Int?
    /// The Amazon Macie Classic member account ID whose associated S3 resources you want to list.
    public var memberAccountId: Swift.String?
    /// Use this parameter when paginating results. Set its value to null on your first call to the ListS3Resources action. Subsequent calls to the action fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        memberAccountId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.memberAccountId = memberAccountId
        self.nextToken = nextToken
    }
}

struct ListS3ResourcesInputBody: Swift.Equatable {
    public let memberAccountId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListS3ResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case memberAccountId
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListS3ResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListS3ResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListS3ResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListS3ResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListS3ResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), s3Resources: \(Swift.String(describing: s3Resources)))"}
}

extension ListS3ResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListS3ResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.s3Resources = output.s3Resources
        } else {
            self.nextToken = nil
            self.s3Resources = nil
        }
    }
}

public struct ListS3ResourcesOutputResponse: Swift.Equatable {
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of the associated S3 resources returned by the action.
    public var s3Resources: [MacieClientTypes.S3ResourceClassification]?

    public init (
        nextToken: Swift.String? = nil,
        s3Resources: [MacieClientTypes.S3ResourceClassification]? = nil
    )
    {
        self.nextToken = nextToken
        self.s3Resources = s3Resources
    }
}

struct ListS3ResourcesOutputResponseBody: Swift.Equatable {
    public let s3Resources: [MacieClientTypes.S3ResourceClassification]?
    public let nextToken: Swift.String?
}

extension ListS3ResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case s3Resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.S3ResourceClassification?].self, forKey: .s3Resources)
        var s3ResourcesDecoded0:[MacieClientTypes.S3ResourceClassification]? = nil
        if let s3ResourcesContainer = s3ResourcesContainer {
            s3ResourcesDecoded0 = [MacieClientTypes.S3ResourceClassification]()
            for structure0 in s3ResourcesContainer {
                if let structure0 = structure0 {
                    s3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        s3Resources = s3ResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MacieClientTypes.MemberAccount: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension MacieClientTypes.MemberAccount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MemberAccount(accountId: \(Swift.String(describing: accountId)))"}
}

extension MacieClientTypes {
    /// Contains information about the Amazon Macie Classic member account.
    public struct MemberAccount: Swift.Equatable {
        /// The AWS account ID of the Amazon Macie Classic member account.
        public var accountId: Swift.String?

        public init (
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }

}

extension MacieClientTypes {
    public enum S3ContinuousClassificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ContinuousClassificationType] {
            return [
                .full,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ContinuousClassificationType(rawValue: rawValue) ?? S3ContinuousClassificationType.sdkUnknown(rawValue)
        }
    }
}

extension MacieClientTypes {
    public enum S3OneTimeClassificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [S3OneTimeClassificationType] {
            return [
                .full,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3OneTimeClassificationType(rawValue: rawValue) ?? S3OneTimeClassificationType.sdkUnknown(rawValue)
        }
    }
}

extension MacieClientTypes.S3Resource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension MacieClientTypes.S3Resource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Resource(bucketName: \(Swift.String(describing: bucketName)), prefix: \(Swift.String(describing: `prefix`)))"}
}

extension MacieClientTypes {
    /// Contains information about the S3 resource. This data type is used as a request parameter in the DisassociateS3Resources action and can be used as a response parameter in the AssociateS3Resources and UpdateS3Resources actions.
    public struct S3Resource: Swift.Equatable {
        /// The prefix of the S3 bucket.
        public var `prefix`: Swift.String?
        /// The name of the S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?

        public init (
            `prefix`: Swift.String? = nil,
            bucketName: Swift.String? = nil
        )
        {
            self.`prefix` = `prefix`
            self.bucketName = bucketName
        }
    }

}

extension MacieClientTypes.S3ResourceClassification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case classificationType
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let classificationType = classificationType {
            try encodeContainer.encode(classificationType, forKey: .classificationType)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let classificationTypeDecoded = try containerValues.decodeIfPresent(MacieClientTypes.ClassificationType.self, forKey: .classificationType)
        classificationType = classificationTypeDecoded
    }
}

extension MacieClientTypes.S3ResourceClassification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3ResourceClassification(bucketName: \(Swift.String(describing: bucketName)), classificationType: \(Swift.String(describing: classificationType)), prefix: \(Swift.String(describing: `prefix`)))"}
}

extension MacieClientTypes {
    /// The S3 resources that you want to associate with Amazon Macie Classic for monitoring and data classification. This data type is used as a request parameter in the AssociateS3Resources action and a response parameter in the ListS3Resources action.
    public struct S3ResourceClassification: Swift.Equatable {
        /// The prefix of the S3 bucket that you want to associate with Amazon Macie Classic.
        public var `prefix`: Swift.String?
        /// The name of the S3 bucket that you want to associate with Amazon Macie Classic.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The classification type that you want to specify for the resource associated with Amazon Macie Classic.
        /// This member is required.
        public var classificationType: MacieClientTypes.ClassificationType?

        public init (
            `prefix`: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            classificationType: MacieClientTypes.ClassificationType? = nil
        )
        {
            self.`prefix` = `prefix`
            self.bucketName = bucketName
            self.classificationType = classificationType
        }
    }

}

extension MacieClientTypes.S3ResourceClassificationUpdate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case classificationTypeUpdate
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let classificationTypeUpdate = classificationTypeUpdate {
            try encodeContainer.encode(classificationTypeUpdate, forKey: .classificationTypeUpdate)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let classificationTypeUpdateDecoded = try containerValues.decodeIfPresent(MacieClientTypes.ClassificationTypeUpdate.self, forKey: .classificationTypeUpdate)
        classificationTypeUpdate = classificationTypeUpdateDecoded
    }
}

extension MacieClientTypes.S3ResourceClassificationUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3ResourceClassificationUpdate(bucketName: \(Swift.String(describing: bucketName)), classificationTypeUpdate: \(Swift.String(describing: classificationTypeUpdate)), prefix: \(Swift.String(describing: `prefix`)))"}
}

extension MacieClientTypes {
    /// The S3 resources whose classification types you want to update. This data type is used as a request parameter in the UpdateS3Resources action.
    public struct S3ResourceClassificationUpdate: Swift.Equatable {
        /// The prefix of the S3 bucket whose classification types you want to update.
        public var `prefix`: Swift.String?
        /// The name of the S3 bucket whose classification types you want to update.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The classification type that you want to update for the resource associated with Amazon Macie Classic.
        /// This member is required.
        public var classificationTypeUpdate: MacieClientTypes.ClassificationTypeUpdate?

        public init (
            `prefix`: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            classificationTypeUpdate: MacieClientTypes.ClassificationTypeUpdate? = nil
        )
        {
            self.`prefix` = `prefix`
            self.bucketName = bucketName
            self.classificationTypeUpdate = classificationTypeUpdate
        }
    }

}

public struct UpdateS3ResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateS3ResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateS3ResourcesOutputError>
}

extension UpdateS3ResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateS3ResourcesInput(memberAccountId: \(Swift.String(describing: memberAccountId)), s3ResourcesUpdate: \(Swift.String(describing: s3ResourcesUpdate)))"}
}

extension UpdateS3ResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
        case s3ResourcesUpdate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let s3ResourcesUpdate = s3ResourcesUpdate {
            var s3ResourcesUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3ResourcesUpdate)
            for s3resourcesclassificationupdate0 in s3ResourcesUpdate {
                try s3ResourcesUpdateContainer.encode(s3resourcesclassificationupdate0)
            }
        }
    }
}

public struct UpdateS3ResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateS3ResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateS3ResourcesOutputError>
}

public struct UpdateS3ResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateS3ResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateS3ResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateS3ResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateS3ResourcesOutputError>
}

public struct UpdateS3ResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateS3ResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateS3ResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateS3ResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateS3ResourcesOutputError>
}

public struct UpdateS3ResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateS3ResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateS3ResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateS3ResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateS3ResourcesOutputError>
}

public struct UpdateS3ResourcesInput: Swift.Equatable {
    /// The AWS ID of the Amazon Macie Classic member account whose S3 resources' classification types you want to update.
    public var memberAccountId: Swift.String?
    /// The S3 resources whose classification types you want to update.
    /// This member is required.
    public var s3ResourcesUpdate: [MacieClientTypes.S3ResourceClassificationUpdate]?

    public init (
        memberAccountId: Swift.String? = nil,
        s3ResourcesUpdate: [MacieClientTypes.S3ResourceClassificationUpdate]? = nil
    )
    {
        self.memberAccountId = memberAccountId
        self.s3ResourcesUpdate = s3ResourcesUpdate
    }
}

struct UpdateS3ResourcesInputBody: Swift.Equatable {
    public let memberAccountId: Swift.String?
    public let s3ResourcesUpdate: [MacieClientTypes.S3ResourceClassificationUpdate]?
}

extension UpdateS3ResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
        case s3ResourcesUpdate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let s3ResourcesUpdateContainer = try containerValues.decodeIfPresent([MacieClientTypes.S3ResourceClassificationUpdate?].self, forKey: .s3ResourcesUpdate)
        var s3ResourcesUpdateDecoded0:[MacieClientTypes.S3ResourceClassificationUpdate]? = nil
        if let s3ResourcesUpdateContainer = s3ResourcesUpdateContainer {
            s3ResourcesUpdateDecoded0 = [MacieClientTypes.S3ResourceClassificationUpdate]()
            for structure0 in s3ResourcesUpdateContainer {
                if let structure0 = structure0 {
                    s3ResourcesUpdateDecoded0?.append(structure0)
                }
            }
        }
        s3ResourcesUpdate = s3ResourcesUpdateDecoded0
    }
}

extension UpdateS3ResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateS3ResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateS3ResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateS3ResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateS3ResourcesOutputResponse(failedS3Resources: \(Swift.String(describing: failedS3Resources)))"}
}

extension UpdateS3ResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateS3ResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedS3Resources = output.failedS3Resources
        } else {
            self.failedS3Resources = nil
        }
    }
}

public struct UpdateS3ResourcesOutputResponse: Swift.Equatable {
    /// The S3 resources whose classification types can't be updated. An error code and an error message are provided for each failed item.
    public var failedS3Resources: [MacieClientTypes.FailedS3Resource]?

    public init (
        failedS3Resources: [MacieClientTypes.FailedS3Resource]? = nil
    )
    {
        self.failedS3Resources = failedS3Resources
    }
}

struct UpdateS3ResourcesOutputResponseBody: Swift.Equatable {
    public let failedS3Resources: [MacieClientTypes.FailedS3Resource]?
}

extension UpdateS3ResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedS3Resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedS3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.FailedS3Resource?].self, forKey: .failedS3Resources)
        var failedS3ResourcesDecoded0:[MacieClientTypes.FailedS3Resource]? = nil
        if let failedS3ResourcesContainer = failedS3ResourcesContainer {
            failedS3ResourcesDecoded0 = [MacieClientTypes.FailedS3Resource]()
            for structure0 in failedS3ResourcesContainer {
                if let structure0 = structure0 {
                    failedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedS3Resources = failedS3ResourcesDecoded0
    }
}
