// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension IoTSecureTunnelingClient {
    /// Closes a tunnel identified by the unique tunnel id. When a CloseTunnel
    /// 			request is received, we close the WebSocket connections between the client and proxy
    /// 			server so no data can be transmitted.
    func closeTunnel(input: CloseTunnelInput) async throws -> CloseTunnelOutputResponse
    {
        typealias closeTunnelContinuation = CheckedContinuation<CloseTunnelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: closeTunnelContinuation) in
            closeTunnel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about a tunnel identified by the unique tunnel id.
    func describeTunnel(input: DescribeTunnelInput) async throws -> DescribeTunnelOutputResponse
    {
        typealias describeTunnelContinuation = CheckedContinuation<DescribeTunnelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeTunnelContinuation) in
            describeTunnel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the tags for the specified resource.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List all tunnels for an AWS account. Tunnels are listed by creation time in
    /// 			descending order, newer tunnels will be listed before older tunnels.
    func listTunnels(input: ListTunnelsInput) async throws -> ListTunnelsOutputResponse
    {
        typealias listTunnelsContinuation = CheckedContinuation<ListTunnelsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTunnelsContinuation) in
            listTunnels(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new tunnel, and returns two client access tokens for clients to use to
    /// 			connect to the AWS IoT Secure Tunneling proxy server.
    func openTunnel(input: OpenTunnelInput) async throws -> OpenTunnelOutputResponse
    {
        typealias openTunnelContinuation = CheckedContinuation<OpenTunnelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: openTunnelContinuation) in
            openTunnel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// A resource tag.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a tag from a resource.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
