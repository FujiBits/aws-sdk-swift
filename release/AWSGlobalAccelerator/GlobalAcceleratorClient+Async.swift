// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension GlobalAcceleratorClient {
    /// Associate a virtual private cloud (VPC) subnet endpoint with your custom routing accelerator.
    /// 	        The listener port range must be large enough to support the number of IP addresses that can be
    /// 		specified in your subnet. The number of ports required is: subnet size times the number
    /// 		of ports per destination EC2 instances. For example, a subnet defined as /24 requires a listener
    /// 		port range of at least 255 ports.
    /// 	        Note: You must have enough remaining listener ports available to
    /// 		map to the subnet ports, or the call will fail with a LimitExceededException.
    /// 	        By default, all destinations in a subnet in a custom routing accelerator cannot receive traffic. To enable all
    /// 			destinations to receive traffic, or to specify individual port mappings that can receive
    /// 			traffic, see the <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/API_AllowCustomRoutingTraffic.html">
    /// 				AllowCustomRoutingTraffic operation.
    func addCustomRoutingEndpoints(input: AddCustomRoutingEndpointsInput) async throws -> AddCustomRoutingEndpointsOutputResponse
    {
        typealias addCustomRoutingEndpointsContinuation = CheckedContinuation<AddCustomRoutingEndpointsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: addCustomRoutingEndpointsContinuation) in
            addCustomRoutingEndpoints(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Advertises an IPv4 address range that is provisioned for use with your AWS resources
    /// 			through bring your own IP addresses (BYOIP). It can take a few minutes before traffic to
    /// 			the specified addresses starts routing to AWS because of propagation delays.
    /// 		       To stop advertising the BYOIP address range, use <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/WithdrawByoipCidr.html">
    /// 			WithdrawByoipCidr.
    /// 		       For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
    /// 			IP Addresses (BYOIP) in the AWS Global Accelerator Developer Guide.
    func advertiseByoipCidr(input: AdvertiseByoipCidrInput) async throws -> AdvertiseByoipCidrOutputResponse
    {
        typealias advertiseByoipCidrContinuation = CheckedContinuation<AdvertiseByoipCidrOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: advertiseByoipCidrContinuation) in
            advertiseByoipCidr(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Specify the Amazon EC2 instance (destination) IP addresses and ports for a VPC subnet endpoint that can receive traffic
    /// 			for a custom routing accelerator. You can allow traffic to all destinations in the subnet endpoint, or allow traffic to a
    /// 			specified list of destination IP addresses and ports in the subnet. Note that you cannot specify IP addresses or ports
    /// 			outside of the range that you configured for the endpoint group.
    /// 		       After you make changes, you can verify that the updates are complete by checking the status of your
    /// 			accelerator: the status changes from IN_PROGRESS to DEPLOYED.
    func allowCustomRoutingTraffic(input: AllowCustomRoutingTrafficInput) async throws -> AllowCustomRoutingTrafficOutputResponse
    {
        typealias allowCustomRoutingTrafficContinuation = CheckedContinuation<AllowCustomRoutingTrafficOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: allowCustomRoutingTrafficContinuation) in
            allowCustomRoutingTraffic(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create an accelerator. An accelerator includes one or more listeners that process inbound connections and direct traffic
    /// 			to one or more endpoint groups, each of which includes endpoints, such as Network Load Balancers. 	
    /// 		
    /// 			         Global Accelerator is a global service that supports endpoints in multiple AWS Regions but you must specify the
    /// 				US West (Oregon) Region to create or update accelerators.
    /// 		
    func createAccelerator(input: CreateAcceleratorInput) async throws -> CreateAcceleratorOutputResponse
    {
        typealias createAcceleratorContinuation = CheckedContinuation<CreateAcceleratorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createAcceleratorContinuation) in
            createAccelerator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create a custom routing accelerator. A custom routing accelerator directs traffic to one of possibly thousands
    /// 		of Amazon EC2 instance destinations running in a single or multiple virtual private clouds (VPC) subnet endpoints.
    /// 	        Be aware that, by default, all destination EC2 instances in a VPC subnet endpoint cannot receive
    /// 			traffic. To enable all destinations to receive traffic, or to specify individual port
    /// 			mappings that can receive traffic, see the <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/API_AllowCustomRoutingTraffic.html">
    /// 				AllowCustomRoutingTraffic operation.
    /// 	
    /// 		          Global Accelerator is a global service that supports endpoints in multiple AWS Regions but you must specify the
    /// 			US West (Oregon) Region to create or update accelerators.
    /// 	
    func createCustomRoutingAccelerator(input: CreateCustomRoutingAcceleratorInput) async throws -> CreateCustomRoutingAcceleratorOutputResponse
    {
        typealias createCustomRoutingAcceleratorContinuation = CheckedContinuation<CreateCustomRoutingAcceleratorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCustomRoutingAcceleratorContinuation) in
            createCustomRoutingAccelerator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create an endpoint group for the specified listener for a custom routing accelerator.
    /// 		An endpoint group is a collection of endpoints in one AWS
    /// 		Region.
    func createCustomRoutingEndpointGroup(input: CreateCustomRoutingEndpointGroupInput) async throws -> CreateCustomRoutingEndpointGroupOutputResponse
    {
        typealias createCustomRoutingEndpointGroupContinuation = CheckedContinuation<CreateCustomRoutingEndpointGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCustomRoutingEndpointGroupContinuation) in
            createCustomRoutingEndpointGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create a listener to process inbound connections from clients to a custom routing accelerator.
    /// 			Connections arrive to assigned static IP addresses on the port range that you specify.
    func createCustomRoutingListener(input: CreateCustomRoutingListenerInput) async throws -> CreateCustomRoutingListenerOutputResponse
    {
        typealias createCustomRoutingListenerContinuation = CheckedContinuation<CreateCustomRoutingListenerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCustomRoutingListenerContinuation) in
            createCustomRoutingListener(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create an endpoint group for the specified listener. An endpoint group is a collection of endpoints in one AWS
    /// 			Region. A resource must be valid and active when you add it as an endpoint.
    func createEndpointGroup(input: CreateEndpointGroupInput) async throws -> CreateEndpointGroupOutputResponse
    {
        typealias createEndpointGroupContinuation = CheckedContinuation<CreateEndpointGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createEndpointGroupContinuation) in
            createEndpointGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create a listener to process inbound connections from clients to an accelerator. Connections arrive to assigned static
    /// 			IP addresses on a port, port range, or list of port ranges that you specify.
    func createListener(input: CreateListenerInput) async throws -> CreateListenerOutputResponse
    {
        typealias createListenerContinuation = CheckedContinuation<CreateListenerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createListenerContinuation) in
            createListener(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete an accelerator. Before you can delete an accelerator, you must disable it and remove all dependent resources
    /// 			(listeners and endpoint groups). To disable the accelerator, update the accelerator to set Enabled to false.
    /// 		
    ///             When you create an accelerator, by default, Global Accelerator provides you with a set of two static IP addresses.
    /// 			Alternatively, you can bring your own IP address ranges to Global Accelerator and assign IP addresses from those ranges.
    /// 		
    /// 		          The IP addresses are assigned to your accelerator for as long as it exists, even if you disable the accelerator and
    /// 			it no longer accepts or routes traffic. However, when you delete an accelerator, you lose the
    /// 			static IP addresses that are assigned to the accelerator, so you can no longer route traffic by using them.
    /// 			As a best practice, ensure that you have permissions in place to avoid inadvertently deleting accelerators. You
    /// 			can use IAM policies with Global Accelerator to limit the users who have permissions to delete an accelerator. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/auth-and-access-control.html">Authentication and Access Control in
    /// 			the AWS Global Accelerator Developer Guide.
    ///
    func deleteAccelerator(input: DeleteAcceleratorInput) async throws -> DeleteAcceleratorOutputResponse
    {
        typealias deleteAcceleratorContinuation = CheckedContinuation<DeleteAcceleratorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteAcceleratorContinuation) in
            deleteAccelerator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete a custom routing accelerator. Before you can delete an accelerator, you must disable it and remove all dependent resources
    /// 		(listeners and endpoint groups). To disable the accelerator, update the accelerator to set Enabled to false.
    /// 	
    ///             When you create a custom routing accelerator, by default, Global Accelerator provides you with a set of two static IP addresses.
    /// 	
    /// 		          The IP
    /// 			addresses are assigned to your accelerator for as long as it exists, even if you disable the accelerator and
    /// 			it no longer accepts or routes traffic. However, when you delete an accelerator, you lose the
    /// 			static IP addresses that are assigned to the accelerator, so you can no longer route traffic by using them.
    /// 			As a best practice, ensure that you have permissions in place to avoid inadvertently deleting accelerators. You
    /// 			can use IAM policies with Global Accelerator to limit the users who have permissions to delete an accelerator. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/auth-and-access-control.html">Authentication and Access Control in
    /// 			the AWS Global Accelerator Developer Guide.
    ///
    func deleteCustomRoutingAccelerator(input: DeleteCustomRoutingAcceleratorInput) async throws -> DeleteCustomRoutingAcceleratorOutputResponse
    {
        typealias deleteCustomRoutingAcceleratorContinuation = CheckedContinuation<DeleteCustomRoutingAcceleratorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteCustomRoutingAcceleratorContinuation) in
            deleteCustomRoutingAccelerator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete an endpoint group from a listener for a custom routing accelerator.
    func deleteCustomRoutingEndpointGroup(input: DeleteCustomRoutingEndpointGroupInput) async throws -> DeleteCustomRoutingEndpointGroupOutputResponse
    {
        typealias deleteCustomRoutingEndpointGroupContinuation = CheckedContinuation<DeleteCustomRoutingEndpointGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteCustomRoutingEndpointGroupContinuation) in
            deleteCustomRoutingEndpointGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete a listener for a custom routing accelerator.
    func deleteCustomRoutingListener(input: DeleteCustomRoutingListenerInput) async throws -> DeleteCustomRoutingListenerOutputResponse
    {
        typealias deleteCustomRoutingListenerContinuation = CheckedContinuation<DeleteCustomRoutingListenerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteCustomRoutingListenerContinuation) in
            deleteCustomRoutingListener(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete an endpoint group from a listener.
    func deleteEndpointGroup(input: DeleteEndpointGroupInput) async throws -> DeleteEndpointGroupOutputResponse
    {
        typealias deleteEndpointGroupContinuation = CheckedContinuation<DeleteEndpointGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteEndpointGroupContinuation) in
            deleteEndpointGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete a listener from an accelerator.
    func deleteListener(input: DeleteListenerInput) async throws -> DeleteListenerOutputResponse
    {
        typealias deleteListenerContinuation = CheckedContinuation<DeleteListenerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteListenerContinuation) in
            deleteListener(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Specify the Amazon EC2 instance (destination) IP addresses and ports for a VPC subnet endpoint that cannot receive traffic
    /// 			for a custom routing accelerator. You can deny traffic to all destinations in the VPC endpoint, or deny traffic to a
    /// 			specified list of destination IP addresses and ports. Note that you cannot specify IP addresses
    /// 			or ports outside of the range that you configured for the endpoint group.
    /// 		       After you make changes, you can verify that the updates are complete by checking the status of your
    /// 			accelerator: the status changes from IN_PROGRESS to DEPLOYED.
    func denyCustomRoutingTraffic(input: DenyCustomRoutingTrafficInput) async throws -> DenyCustomRoutingTrafficOutputResponse
    {
        typealias denyCustomRoutingTrafficContinuation = CheckedContinuation<DenyCustomRoutingTrafficOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: denyCustomRoutingTrafficContinuation) in
            denyCustomRoutingTraffic(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Releases the specified address range that you provisioned to use with your AWS resources
    /// 			through bring your own IP addresses (BYOIP) and deletes the corresponding address pool.
    /// 		       Before you can release an address range, you must stop advertising it by using <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/WithdrawByoipCidr.html">WithdrawByoipCidr and you must not have
    /// 			any accelerators that are using static IP addresses allocated from its address range.
    /// 		
    /// 		       For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
    /// 			IP Addresses (BYOIP) in the AWS Global Accelerator Developer Guide.
    func deprovisionByoipCidr(input: DeprovisionByoipCidrInput) async throws -> DeprovisionByoipCidrOutputResponse
    {
        typealias deprovisionByoipCidrContinuation = CheckedContinuation<DeprovisionByoipCidrOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deprovisionByoipCidrContinuation) in
            deprovisionByoipCidr(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describe an accelerator.
    func describeAccelerator(input: DescribeAcceleratorInput) async throws -> DescribeAcceleratorOutputResponse
    {
        typealias describeAcceleratorContinuation = CheckedContinuation<DescribeAcceleratorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeAcceleratorContinuation) in
            describeAccelerator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describe the attributes of an accelerator.
    /// 		
    func describeAcceleratorAttributes(input: DescribeAcceleratorAttributesInput) async throws -> DescribeAcceleratorAttributesOutputResponse
    {
        typealias describeAcceleratorAttributesContinuation = CheckedContinuation<DescribeAcceleratorAttributesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeAcceleratorAttributesContinuation) in
            describeAcceleratorAttributes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describe a custom routing accelerator.
    func describeCustomRoutingAccelerator(input: DescribeCustomRoutingAcceleratorInput) async throws -> DescribeCustomRoutingAcceleratorOutputResponse
    {
        typealias describeCustomRoutingAcceleratorContinuation = CheckedContinuation<DescribeCustomRoutingAcceleratorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeCustomRoutingAcceleratorContinuation) in
            describeCustomRoutingAccelerator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describe the attributes of a custom routing accelerator.
    func describeCustomRoutingAcceleratorAttributes(input: DescribeCustomRoutingAcceleratorAttributesInput) async throws -> DescribeCustomRoutingAcceleratorAttributesOutputResponse
    {
        typealias describeCustomRoutingAcceleratorAttributesContinuation = CheckedContinuation<DescribeCustomRoutingAcceleratorAttributesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeCustomRoutingAcceleratorAttributesContinuation) in
            describeCustomRoutingAcceleratorAttributes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describe an endpoint group for a custom routing accelerator.
    func describeCustomRoutingEndpointGroup(input: DescribeCustomRoutingEndpointGroupInput) async throws -> DescribeCustomRoutingEndpointGroupOutputResponse
    {
        typealias describeCustomRoutingEndpointGroupContinuation = CheckedContinuation<DescribeCustomRoutingEndpointGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeCustomRoutingEndpointGroupContinuation) in
            describeCustomRoutingEndpointGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// The description of a listener for a custom routing accelerator.
    func describeCustomRoutingListener(input: DescribeCustomRoutingListenerInput) async throws -> DescribeCustomRoutingListenerOutputResponse
    {
        typealias describeCustomRoutingListenerContinuation = CheckedContinuation<DescribeCustomRoutingListenerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeCustomRoutingListenerContinuation) in
            describeCustomRoutingListener(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describe an endpoint group.
    func describeEndpointGroup(input: DescribeEndpointGroupInput) async throws -> DescribeEndpointGroupOutputResponse
    {
        typealias describeEndpointGroupContinuation = CheckedContinuation<DescribeEndpointGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeEndpointGroupContinuation) in
            describeEndpointGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describe a listener.
    func describeListener(input: DescribeListenerInput) async throws -> DescribeListenerOutputResponse
    {
        typealias describeListenerContinuation = CheckedContinuation<DescribeListenerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeListenerContinuation) in
            describeListener(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the accelerators for an AWS account.
    func listAccelerators(input: ListAcceleratorsInput) async throws -> ListAcceleratorsOutputResponse
    {
        typealias listAcceleratorsContinuation = CheckedContinuation<ListAcceleratorsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listAcceleratorsContinuation) in
            listAccelerators(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the IP address ranges that were specified in calls to <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/ProvisionByoipCidr.html">ProvisionByoipCidr, including
    /// 			the current state and a history of state changes.
    func listByoipCidrs(input: ListByoipCidrsInput) async throws -> ListByoipCidrsOutputResponse
    {
        typealias listByoipCidrsContinuation = CheckedContinuation<ListByoipCidrsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listByoipCidrsContinuation) in
            listByoipCidrs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the custom routing accelerators for an AWS account.
    func listCustomRoutingAccelerators(input: ListCustomRoutingAcceleratorsInput) async throws -> ListCustomRoutingAcceleratorsOutputResponse
    {
        typealias listCustomRoutingAcceleratorsContinuation = CheckedContinuation<ListCustomRoutingAcceleratorsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCustomRoutingAcceleratorsContinuation) in
            listCustomRoutingAccelerators(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the endpoint groups that are associated with a listener for a custom routing accelerator.
    func listCustomRoutingEndpointGroups(input: ListCustomRoutingEndpointGroupsInput) async throws -> ListCustomRoutingEndpointGroupsOutputResponse
    {
        typealias listCustomRoutingEndpointGroupsContinuation = CheckedContinuation<ListCustomRoutingEndpointGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCustomRoutingEndpointGroupsContinuation) in
            listCustomRoutingEndpointGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the listeners for a custom routing accelerator.
    func listCustomRoutingListeners(input: ListCustomRoutingListenersInput) async throws -> ListCustomRoutingListenersOutputResponse
    {
        typealias listCustomRoutingListenersContinuation = CheckedContinuation<ListCustomRoutingListenersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCustomRoutingListenersContinuation) in
            listCustomRoutingListeners(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Provides a complete mapping from the public accelerator IP address and port to destination EC2 instance
    /// 		IP addresses and ports in the virtual public cloud (VPC) subnet endpoint for a custom routing accelerator.
    /// 		For each subnet endpoint that you add, Global Accelerator creates a new static port mapping for the accelerator. The port
    /// 		mappings don't change after Global Accelerator generates them, so you can retrieve and cache the full mapping on your servers.
    /// 	        If you remove a subnet from your accelerator, Global Accelerator removes (reclaims) the port mappings. If you add a subnet to
    /// 		your accelerator, Global Accelerator creates new port mappings (the existing ones don't change). If you add or remove EC2 instances
    /// 		in your subnet, the port mappings don't change, because the mappings are created when you add the subnet to Global Accelerator.
    /// 	        The mappings also include a flag for each destination denoting which destination IP addresses and
    /// 		ports are allowed or denied traffic.
    func listCustomRoutingPortMappings(input: ListCustomRoutingPortMappingsInput) async throws -> ListCustomRoutingPortMappingsOutputResponse
    {
        typealias listCustomRoutingPortMappingsContinuation = CheckedContinuation<ListCustomRoutingPortMappingsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCustomRoutingPortMappingsContinuation) in
            listCustomRoutingPortMappings(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the port mappings for a specific EC2 instance (destination) in a VPC subnet endpoint. The
    /// 			response is the mappings for one destination IP address. This is useful when your subnet endpoint has mappings that
    /// 			span multiple custom routing accelerators in your account, or for scenarios where you only want to
    /// 			list the port mappings for a specific destination instance.
    func listCustomRoutingPortMappingsByDestination(input: ListCustomRoutingPortMappingsByDestinationInput) async throws -> ListCustomRoutingPortMappingsByDestinationOutputResponse
    {
        typealias listCustomRoutingPortMappingsByDestinationContinuation = CheckedContinuation<ListCustomRoutingPortMappingsByDestinationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCustomRoutingPortMappingsByDestinationContinuation) in
            listCustomRoutingPortMappingsByDestination(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the endpoint groups that are associated with a listener.
    func listEndpointGroups(input: ListEndpointGroupsInput) async throws -> ListEndpointGroupsOutputResponse
    {
        typealias listEndpointGroupsContinuation = CheckedContinuation<ListEndpointGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listEndpointGroupsContinuation) in
            listEndpointGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the listeners for an accelerator.
    func listListeners(input: ListListenersInput) async throws -> ListListenersOutputResponse
    {
        typealias listListenersContinuation = CheckedContinuation<ListListenersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listListenersContinuation) in
            listListeners(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List all tags for an accelerator.
    /// 		       For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html">Tagging
    /// 			in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Provisions an IP address range to use with your AWS resources through bring your own IP
    /// 			addresses (BYOIP) and creates a corresponding address pool. After the address range is provisioned,
    /// 			it is ready to be advertised using <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/AdvertiseByoipCidr.html">
    /// 			AdvertiseByoipCidr.
    /// 		       For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
    /// 			IP Addresses (BYOIP) in the AWS Global Accelerator Developer Guide.
    func provisionByoipCidr(input: ProvisionByoipCidrInput) async throws -> ProvisionByoipCidrOutputResponse
    {
        typealias provisionByoipCidrContinuation = CheckedContinuation<ProvisionByoipCidrOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: provisionByoipCidrContinuation) in
            provisionByoipCidr(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Remove endpoints from a custom routing accelerator.
    func removeCustomRoutingEndpoints(input: RemoveCustomRoutingEndpointsInput) async throws -> RemoveCustomRoutingEndpointsOutputResponse
    {
        typealias removeCustomRoutingEndpointsContinuation = CheckedContinuation<RemoveCustomRoutingEndpointsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: removeCustomRoutingEndpointsContinuation) in
            removeCustomRoutingEndpoints(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Add tags to an accelerator resource.
    /// 		       For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html">Tagging
    /// 			in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Remove tags from a Global Accelerator resource. When you specify a tag key, the action removes both that key and its associated value.
    /// 			The operation succeeds even if you attempt to remove tags from an accelerator that was already removed.
    /// 		       For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html">Tagging
    /// 			in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update an accelerator.
    /// 		
    /// 		
    /// 			         Global Accelerator is a global service that supports endpoints in multiple AWS Regions but you must specify the
    /// 				US West (Oregon) Region to create or update accelerators.
    /// 		
    func updateAccelerator(input: UpdateAcceleratorInput) async throws -> UpdateAcceleratorOutputResponse
    {
        typealias updateAcceleratorContinuation = CheckedContinuation<UpdateAcceleratorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateAcceleratorContinuation) in
            updateAccelerator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update the attributes for an accelerator.
    func updateAcceleratorAttributes(input: UpdateAcceleratorAttributesInput) async throws -> UpdateAcceleratorAttributesOutputResponse
    {
        typealias updateAcceleratorAttributesContinuation = CheckedContinuation<UpdateAcceleratorAttributesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateAcceleratorAttributesContinuation) in
            updateAcceleratorAttributes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update a custom routing accelerator.
    func updateCustomRoutingAccelerator(input: UpdateCustomRoutingAcceleratorInput) async throws -> UpdateCustomRoutingAcceleratorOutputResponse
    {
        typealias updateCustomRoutingAcceleratorContinuation = CheckedContinuation<UpdateCustomRoutingAcceleratorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCustomRoutingAcceleratorContinuation) in
            updateCustomRoutingAccelerator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update the attributes for a custom routing accelerator.
    func updateCustomRoutingAcceleratorAttributes(input: UpdateCustomRoutingAcceleratorAttributesInput) async throws -> UpdateCustomRoutingAcceleratorAttributesOutputResponse
    {
        typealias updateCustomRoutingAcceleratorAttributesContinuation = CheckedContinuation<UpdateCustomRoutingAcceleratorAttributesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCustomRoutingAcceleratorAttributesContinuation) in
            updateCustomRoutingAcceleratorAttributes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update a listener for a custom routing accelerator.
    func updateCustomRoutingListener(input: UpdateCustomRoutingListenerInput) async throws -> UpdateCustomRoutingListenerOutputResponse
    {
        typealias updateCustomRoutingListenerContinuation = CheckedContinuation<UpdateCustomRoutingListenerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCustomRoutingListenerContinuation) in
            updateCustomRoutingListener(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update an endpoint group. A resource must be valid and active when you add it as an endpoint.
    func updateEndpointGroup(input: UpdateEndpointGroupInput) async throws -> UpdateEndpointGroupOutputResponse
    {
        typealias updateEndpointGroupContinuation = CheckedContinuation<UpdateEndpointGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateEndpointGroupContinuation) in
            updateEndpointGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update a listener.
    func updateListener(input: UpdateListenerInput) async throws -> UpdateListenerOutputResponse
    {
        typealias updateListenerContinuation = CheckedContinuation<UpdateListenerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateListenerContinuation) in
            updateListener(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Stops advertising an address range that is provisioned as an address pool.
    /// 			You can perform this operation at most once every 10 seconds, even if you specify different address
    /// 			ranges each time.
    /// 		       It can take a few minutes before traffic to the specified addresses stops routing to AWS because of
    /// 			propagation delays.
    /// 		       For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
    /// 			IP Addresses (BYOIP) in the AWS Global Accelerator Developer Guide.
    func withdrawByoipCidr(input: WithdrawByoipCidrInput) async throws -> WithdrawByoipCidrOutputResponse
    {
        typealias withdrawByoipCidrContinuation = CheckedContinuation<WithdrawByoipCidrOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: withdrawByoipCidrContinuation) in
            withdrawByoipCidr(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
