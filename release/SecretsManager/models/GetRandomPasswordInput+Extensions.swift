// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

public struct GetRandomPasswordInputHeadersMiddleware: Middleware {
    public let id: String = "GetRandomPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRandomPasswordOutputError>
}

public struct GetRandomPasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRandomPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRandomPasswordOutputError>
}

public struct GetRandomPasswordInputBodyMiddleware: Middleware {
    public let id: String = "GetRandomPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRandomPasswordOutputError>
}

extension GetRandomPasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludeCharacters = "ExcludeCharacters"
        case excludeLowercase = "ExcludeLowercase"
        case excludeNumbers = "ExcludeNumbers"
        case excludePunctuation = "ExcludePunctuation"
        case excludeUppercase = "ExcludeUppercase"
        case includeSpace = "IncludeSpace"
        case passwordLength = "PasswordLength"
        case requireEachIncludedType = "RequireEachIncludedType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeCharacters = excludeCharacters {
            try encodeContainer.encode(excludeCharacters, forKey: .excludeCharacters)
        }
        if excludeLowercase != false {
            try encodeContainer.encode(excludeLowercase, forKey: .excludeLowercase)
        }
        if excludeNumbers != false {
            try encodeContainer.encode(excludeNumbers, forKey: .excludeNumbers)
        }
        if excludePunctuation != false {
            try encodeContainer.encode(excludePunctuation, forKey: .excludePunctuation)
        }
        if excludeUppercase != false {
            try encodeContainer.encode(excludeUppercase, forKey: .excludeUppercase)
        }
        if includeSpace != false {
            try encodeContainer.encode(includeSpace, forKey: .includeSpace)
        }
        if passwordLength != 0 {
            try encodeContainer.encode(passwordLength, forKey: .passwordLength)
        }
        if requireEachIncludedType != false {
            try encodeContainer.encode(requireEachIncludedType, forKey: .requireEachIncludedType)
        }
    }
}
