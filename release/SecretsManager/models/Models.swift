// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct CancelRotateSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelRotateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelRotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelRotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelRotateSecretOutputError>
}

extension CancelRotateSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelRotateSecretInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension CancelRotateSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct CancelRotateSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelRotateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelRotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelRotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelRotateSecretOutputError>
}

public struct CancelRotateSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelRotateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelRotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelRotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelRotateSecretOutputError>
}

public struct CancelRotateSecretInput: Swift.Equatable {
    /// <p>Specifies the secret to cancel a rotation request. You can specify either the Amazon
    ///       Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct CancelRotateSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension CancelRotateSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension CancelRotateSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelRotateSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelRotateSecretOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelRotateSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelRotateSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), versionId: \(Swift.String(describing: versionId)))"}
}

extension CancelRotateSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelRotateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
        }
    }
}

public struct CancelRotateSecretOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret for which rotation was canceled.</p>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret for which rotation was canceled.</p>
    public let name: Swift.String?
    /// <p>The unique identifier of the version of the secret created during the rotation. This
    ///       version might not be complete, and should be evaluated for possible deletion. At the very
    ///       least, you should remove the <code>VersionStage</code> value <code>AWSPENDING</code> to enable this
    ///       version to be deleted. Failing to clean up a cancelled rotation can block you from
    ///       successfully starting future rotations.</p>
    public let versionId: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
    }
}

struct CancelRotateSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
}

extension CancelRotateSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

public struct CreateSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSecretOutputError>
}

extension CreateSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSecretInput(addReplicaRegions: \(Swift.String(describing: addReplicaRegions)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), forceOverwriteReplicaSecret: \(Swift.String(describing: forceOverwriteReplicaSecret)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), name: \(Swift.String(describing: name)), secretBinary: \(Swift.String(describing: secretBinary)), secretString: \(Swift.String(describing: secretString)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case secretBinary = "SecretBinary"
        case secretString = "SecretString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addReplicaRegions = addReplicaRegions {
            var addReplicaRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addReplicaRegions)
            for addreplicaregionlisttype0 in addReplicaRegions {
                try addReplicaRegionsContainer.encode(addreplicaregionlisttype0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if forceOverwriteReplicaSecret != false {
            try encodeContainer.encode(forceOverwriteReplicaSecret, forKey: .forceOverwriteReplicaSecret)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let secretBinary = secretBinary {
            try encodeContainer.encode(secretBinary.base64EncodedString(), forKey: .secretBinary)
        }
        if let secretString = secretString {
            try encodeContainer.encode(secretString, forKey: .secretString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglisttype0 in tags {
                try tagsContainer.encode(taglisttype0)
            }
        }
    }
}

public struct CreateSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSecretOutputError>
}

public struct CreateSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSecretOutputError>
}

public struct CreateSecretInput: Swift.Equatable {
    /// <p>(Optional) Add a list of regions to replicate secrets. Secrets Manager replicates the KMSKeyID objects to the list of regions specified in
    ///       the parameter.</p>
    public let addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]?
    /// <p>(Optional) If you include <code>SecretString</code> or <code>SecretBinary</code>, then an
    ///       initial version is created as part of the secret, and this parameter specifies a unique
    ///       identifier for the new version. </p>
    ///          <note>
    ///             <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    ///         leave this parameter empty. The CLI or SDK generates a random UUID for you and includes it
    ///         as the value for this parameter in the request. If you don't use the SDK and instead
    ///         generate a raw HTTP request to the Secrets Manager service endpoint, then you must generate a
    ///           <code>ClientRequestToken</code> yourself for the new version and include the value in the
    ///         request.</p>
    ///          </note>
    ///          <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
    ///       creation of duplicate versions if there are failures and retries during a rotation. We
    ///       recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    ///       ensure uniqueness of your versions within the specified secret. </p>
    ///          <ul>
    ///             <li>
    ///                <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    ///           of the secret then a new version of the secret is created. </p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and the version <code>SecretString</code>
    ///           and <code>SecretBinary</code> values are the same as those in the request, then the
    ///           request is ignored.</p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and that version's
    ///             <code>SecretString</code> and <code>SecretBinary</code> values are different from those
    ///           in the request, then the request fails because you cannot modify an existing version.
    ///           Instead, use <a>PutSecretValue</a> to create a new version.</p>
    ///             </li>
    ///          </ul>
    ///          <p>This value becomes the <code>VersionId</code> of the new version.</p>
    public var clientRequestToken: Swift.String?
    /// <p>(Optional) Specifies a user-provided description of the secret.</p>
    public let description: Swift.String?
    /// <p>(Optional) If set, the replication overwrites a secret with the same name in the
    ///       destination region.</p>
    public let forceOverwriteReplicaSecret: Swift.Bool
    /// <p>(Optional) Specifies the ARN, Key ID, or alias of the AWS KMS customer master key (CMK) to
    ///       be used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values in the
    ///       versions stored in this secret.</p>
    ///          <p>You can specify any of the supported ways to identify a AWS KMS key ID. If you need to
    ///       reference a CMK in a different account, you can use only the key ARN or the alias ARN.</p>
    ///          <p>If you don't specify this value, then Secrets Manager defaults to using the AWS account's
    ///       default CMK (the one named <code>aws/secretsmanager</code>). If a AWS KMS CMK with that name doesn't yet
    ///       exist, then Secrets Manager creates it for you automatically the first time it needs to encrypt a
    ///       version's <code>SecretString</code> or <code>SecretBinary</code> fields.</p>
    ///          <important>
    ///             <p>You can use the account default CMK to encrypt and decrypt only if you call this
    ///         operation using credentials from the same account that owns the secret. If the secret
    ///         resides in a different account, then you must create a custom CMK and specify the ARN in
    ///         this field. </p>
    ///          </important>
    public let kmsKeyId: Swift.String?
    /// <p>Specifies the friendly name of the new secret.</p>
    ///          <p>The secret name must be ASCII letters, digits, or the following characters :
    ///       /_+=.@-</p>
    ///          <note>
    ///             <p>Do not end your secret name with a hyphen followed by six characters. If you do so, you
    ///         risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager
    ///         automatically adds a hyphen and six random characters at the end of the ARN.</p>
    ///          </note>
    public let name: Swift.String?
    /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
    ///       the secret. To use this parameter in the command-line tools, we recommend that you store your
    ///       binary data in a file and then use the appropriate technique for your tool to pass the
    ///       contents of the file as a parameter.</p>
    ///          <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
    ///       both. They cannot both be empty.</p>
    ///          <p>This parameter is not available using the Secrets Manager console. It can be accessed only by
    ///       using the AWS CLI or one of the AWS SDKs.</p>
    public let secretBinary: ClientRuntime.Data?
    /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
    ///       the secret.</p>
    ///          <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
    ///       both. They cannot both be empty.</p>
    ///          <p>If you create a secret by using the Secrets Manager console then Secrets Manager puts the protected
    ///       secret text in only the <code>SecretString</code> parameter. The Secrets Manager console stores the
    ///       information as a JSON structure of key/value pairs that the Lambda rotation function knows how
    ///       to parse.</p>
    ///          <p>For storing multiple values, we recommend that you use a JSON text string argument and
    ///       specify key/value pairs. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    ///          <p>
    ///             <code>{"username":"bob","password":"abc123xyz456"}</code>
    ///          </p>
    ///          <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
    public let secretString: Swift.String?
    /// <p>(Optional) Specifies a list of user-defined tags that are attached to the secret. Each tag
    ///       is a "Key" and "Value" pair of strings. This operation only appends tags to the existing list
    ///       of tags. To remove tags, you must use <a>UntagResource</a>.</p>
    ///          <important>
    ///             <ul>
    ///                <li>
    ///                   <p>Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag
    ///             from one with key "abc".</p>
    ///                </li>
    ///                <li>
    ///                   <p>If you check tags in IAM policy <code>Condition</code> elements as part of your
    ///             security strategy, then adding or removing a tag can change permissions. If the
    ///             successful completion of this operation would result in you losing your permissions for
    ///             this secret, then this operation is blocked and returns an <code>Access Denied</code>
    ///             error.</p>
    ///                </li>
    ///             </ul>
    ///          </important>
    ///          <p>This parameter requires a JSON text string argument. For information on how to format a
    ///       JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    ///          <p>
    ///             <code>[{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]</code>
    ///          </p>
    ///          <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
    ///             <p>The following basic restrictions apply to tags:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Maximum number of tags per secret—50</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length—127 Unicode characters in UTF-8</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length—255 Unicode characters in UTF-8</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use the <code>aws:</code> prefix in your tag names or values because AWS reserves it
    ///             for AWS use. You can't edit or delete tag names or values with this
    ///               prefix. Tags with this prefix do not count against your tags per secret limit.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you use your tagging schema across multiple services and resources,
    ///               remember other services might have restrictions on allowed characters. Generally
    ///               allowed characters: letters, spaces, and numbers representable in UTF-8, plus the
    ///               following special characters: + - = . _ : / @.</p>
    ///             </li>
    ///          </ul>
    public let tags: [SecretsManagerClientTypes.Tag]?

    public init (
        addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]? = nil,
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        forceOverwriteReplicaSecret: Swift.Bool = false,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        secretBinary: ClientRuntime.Data? = nil,
        secretString: Swift.String? = nil,
        tags: [SecretsManagerClientTypes.Tag]? = nil
    )
    {
        self.addReplicaRegions = addReplicaRegions
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.forceOverwriteReplicaSecret = forceOverwriteReplicaSecret
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.secretBinary = secretBinary
        self.secretString = secretString
        self.tags = tags
    }
}

struct CreateSecretInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let clientRequestToken: Swift.String?
    public let description: Swift.String?
    public let kmsKeyId: Swift.String?
    public let secretBinary: ClientRuntime.Data?
    public let secretString: Swift.String?
    public let tags: [SecretsManagerClientTypes.Tag]?
    public let addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]?
    public let forceOverwriteReplicaSecret: Swift.Bool
}

extension CreateSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case secretBinary = "SecretBinary"
        case secretString = "SecretString"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretString)
        secretString = secretStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecretsManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecretsManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let addReplicaRegionsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicaRegionType?].self, forKey: .addReplicaRegions)
        var addReplicaRegionsDecoded0:[SecretsManagerClientTypes.ReplicaRegionType]? = nil
        if let addReplicaRegionsContainer = addReplicaRegionsContainer {
            addReplicaRegionsDecoded0 = [SecretsManagerClientTypes.ReplicaRegionType]()
            for structure0 in addReplicaRegionsContainer {
                if let structure0 = structure0 {
                    addReplicaRegionsDecoded0?.append(structure0)
                }
            }
        }
        addReplicaRegions = addReplicaRegionsDecoded0
        let forceOverwriteReplicaSecretDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceOverwriteReplicaSecret)
        forceOverwriteReplicaSecret = forceOverwriteReplicaSecretDecoded
    }
}

extension CreateSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionFailure" : self = .encryptionFailure(try EncryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSecretOutputError: Swift.Error, Swift.Equatable {
    case encryptionFailure(EncryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), replicationStatus: \(Swift.String(describing: replicationStatus)), versionId: \(Swift.String(describing: versionId)))"}
}

extension CreateSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.replicationStatus = output.replicationStatus
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.replicationStatus = nil
            self.versionId = nil
        }
    }
}

public struct CreateSecretOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the secret that you just created.</p>
    ///          <note>
    ///             <p>Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    ///         you initially create a secret. This affects only the ARN and not the actual friendly name.
    ///         This ensures that if you create a new secret with the same name as an old secret that you
    ///         previously deleted, then users with access to the old secret <i>don't</i>
    ///         automatically get access to the new secret because the ARNs are different.</p>
    ///          </note>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret that you just created.</p>
    public let name: Swift.String?
    /// <p>Describes a list of replication status objects as <code>InProgress</code>, <code>Failed</code> or <code>InSync</code>.</p>
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
    /// <p>The unique identifier associated with the version of the secret you just created.</p>
    public let versionId: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.replicationStatus = replicationStatus
        self.versionId = versionId
    }
}

struct CreateSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
}

extension CreateSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case replicationStatus = "ReplicationStatus"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[SecretsManagerClientTypes.ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [SecretsManagerClientTypes.ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension DecryptionFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecryptionFailure(message: \(Swift.String(describing: message)))"}
}

extension DecryptionFailure: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DecryptionFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Secrets Manager can't decrypt the protected secret text using the provided KMS key. </p>
public struct DecryptionFailure: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DecryptionFailureBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DecryptionFailureBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteResourcePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourcePolicyOutputError>
}

extension DeleteResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourcePolicyInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension DeleteResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct DeleteResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// <p>Specifies the secret that you want to delete the attached resource-based policy for. You
    ///       can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourcePolicyOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret that the resource-based policy was deleted for.</p>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret that the resource-based policy was deleted for.</p>
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct DeleteResourcePolicyOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
}

extension DeleteResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct DeleteSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSecretOutputError>
}

extension DeleteSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSecretInput(forceDeleteWithoutRecovery: \(Swift.String(describing: forceDeleteWithoutRecovery)), recoveryWindowInDays: \(Swift.String(describing: recoveryWindowInDays)), secretId: \(Swift.String(describing: secretId)))"}
}

extension DeleteSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceDeleteWithoutRecovery = "ForceDeleteWithoutRecovery"
        case recoveryWindowInDays = "RecoveryWindowInDays"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if forceDeleteWithoutRecovery != false {
            try encodeContainer.encode(forceDeleteWithoutRecovery, forKey: .forceDeleteWithoutRecovery)
        }
        if recoveryWindowInDays != 0 {
            try encodeContainer.encode(recoveryWindowInDays, forKey: .recoveryWindowInDays)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct DeleteSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSecretOutputError>
}

public struct DeleteSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSecretOutputError>
}

public struct DeleteSecretInput: Swift.Equatable {
    /// <p>(Optional) Specifies that the secret is to be deleted without any recovery window. You
    ///       can't use both this parameter and the <code>RecoveryWindowInDays</code> parameter in the same
    ///       API call.</p>
    ///          <p>An asynchronous background process performs the actual deletion, so there can be a short
    ///       delay before the operation completes. If you write code to delete and then immediately
    ///       recreate a secret with the same name, ensure that your code includes appropriate back off and
    ///       retry logic.</p>
    ///          <important>
    ///             <p>Use this parameter with caution. This parameter causes the operation to skip the normal
    ///         waiting period before the permanent deletion that AWS would normally impose with the
    ///           <code>RecoveryWindowInDays</code> parameter. If you delete a secret with the
    ///           <code>ForceDeleteWithouRecovery</code> parameter, then you have no opportunity to recover
    ///         the secret. You lose the secret permanently.</p>
    ///          </important>
    ///          <important>
    ///             <p>If you use this parameter and include a previously deleted or nonexistent secret, the
    ///         operation does not return the error <code>ResourceNotFoundException</code> in order to
    ///         correctly handle retries.</p>
    ///          </important>
    public let forceDeleteWithoutRecovery: Swift.Bool
    /// <p>(Optional) Specifies the number of days that Secrets Manager waits before Secrets Manager can delete the
    ///       secret. You can't use both this parameter and the <code>ForceDeleteWithoutRecovery</code>
    ///       parameter in the same API call.</p>
    ///          <p>This value can range from 7 to 30 days with a default value of 30.</p>
    public let recoveryWindowInDays: Swift.Int
    /// <p>Specifies the secret to delete. You can specify either the Amazon Resource Name (ARN) or
    ///       the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?

    public init (
        forceDeleteWithoutRecovery: Swift.Bool = false,
        recoveryWindowInDays: Swift.Int = 0,
        secretId: Swift.String? = nil
    )
    {
        self.forceDeleteWithoutRecovery = forceDeleteWithoutRecovery
        self.recoveryWindowInDays = recoveryWindowInDays
        self.secretId = secretId
    }
}

struct DeleteSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let recoveryWindowInDays: Swift.Int
    public let forceDeleteWithoutRecovery: Swift.Bool
}

extension DeleteSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceDeleteWithoutRecovery = "ForceDeleteWithoutRecovery"
        case recoveryWindowInDays = "RecoveryWindowInDays"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let recoveryWindowInDaysDecoded = try containerValues.decode(Swift.Int.self, forKey: .recoveryWindowInDays)
        recoveryWindowInDays = recoveryWindowInDaysDecoded
        let forceDeleteWithoutRecoveryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceDeleteWithoutRecovery)
        forceDeleteWithoutRecovery = forceDeleteWithoutRecoveryDecoded
    }
}

extension DeleteSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSecretOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), deletionDate: \(Swift.String(describing: deletionDate)), name: \(Swift.String(describing: name)))"}
}

extension DeleteSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.deletionDate = output.deletionDate
            self.name = output.name
        } else {
            self.aRN = nil
            self.deletionDate = nil
            self.name = nil
        }
    }
}

public struct DeleteSecretOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret that is now scheduled for deletion.</p>
    public let aRN: Swift.String?
    /// <p>The date and time after which this secret can be deleted by Secrets Manager and can no longer be
    ///       restored. This value is the date and time of the delete request plus the number of days
    ///       specified in <code>RecoveryWindowInDays</code>.</p>
    public let deletionDate: ClientRuntime.Date?
    /// <p>The friendly name of the secret currently scheduled for deletion.</p>
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        deletionDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.deletionDate = deletionDate
        self.name = name
    }
}

struct DeleteSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let deletionDate: ClientRuntime.Date?
}

extension DeleteSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case deletionDate = "DeletionDate"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
    }
}

public struct DescribeSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSecretOutputError>
}

extension DescribeSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSecretInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension DescribeSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct DescribeSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSecretOutputError>
}

public struct DescribeSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSecretOutputError>
}

public struct DescribeSecretInput: Swift.Equatable {
    /// <p>The identifier of the secret whose details you want to retrieve. You can specify either
    ///       the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct DescribeSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension DescribeSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension DescribeSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSecretOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), createdDate: \(Swift.String(describing: createdDate)), deletedDate: \(Swift.String(describing: deletedDate)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastAccessedDate: \(Swift.String(describing: lastAccessedDate)), lastChangedDate: \(Swift.String(describing: lastChangedDate)), lastRotatedDate: \(Swift.String(describing: lastRotatedDate)), name: \(Swift.String(describing: name)), owningService: \(Swift.String(describing: owningService)), primaryRegion: \(Swift.String(describing: primaryRegion)), replicationStatus: \(Swift.String(describing: replicationStatus)), rotationEnabled: \(Swift.String(describing: rotationEnabled)), rotationLambdaARN: \(Swift.String(describing: rotationLambdaARN)), rotationRules: \(Swift.String(describing: rotationRules)), tags: \(Swift.String(describing: tags)), versionIdsToStages: \(Swift.String(describing: versionIdsToStages)))"}
}

extension DescribeSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.createdDate = output.createdDate
            self.deletedDate = output.deletedDate
            self.description = output.description
            self.kmsKeyId = output.kmsKeyId
            self.lastAccessedDate = output.lastAccessedDate
            self.lastChangedDate = output.lastChangedDate
            self.lastRotatedDate = output.lastRotatedDate
            self.name = output.name
            self.owningService = output.owningService
            self.primaryRegion = output.primaryRegion
            self.replicationStatus = output.replicationStatus
            self.rotationEnabled = output.rotationEnabled
            self.rotationLambdaARN = output.rotationLambdaARN
            self.rotationRules = output.rotationRules
            self.tags = output.tags
            self.versionIdsToStages = output.versionIdsToStages
        } else {
            self.aRN = nil
            self.createdDate = nil
            self.deletedDate = nil
            self.description = nil
            self.kmsKeyId = nil
            self.lastAccessedDate = nil
            self.lastChangedDate = nil
            self.lastRotatedDate = nil
            self.name = nil
            self.owningService = nil
            self.primaryRegion = nil
            self.replicationStatus = nil
            self.rotationEnabled = false
            self.rotationLambdaARN = nil
            self.rotationRules = nil
            self.tags = nil
            self.versionIdsToStages = nil
        }
    }
}

public struct DescribeSecretOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret.</p>
    public let aRN: Swift.String?
    /// <p>The date you created the secret.</p>
    public let createdDate: ClientRuntime.Date?
    /// <p>This value exists if the secret is scheduled for deletion. Some time after the specified
    ///       date and time, Secrets Manager deletes the secret and all of its versions.</p>
    ///          <p>If a secret is scheduled for deletion, then its details, including the encrypted secret
    ///       information, is not accessible. To cancel a scheduled deletion and restore access, use <a>RestoreSecret</a>.</p>
    public let deletedDate: ClientRuntime.Date?
    /// <p>The user-provided description of the secret.</p>
    public let description: Swift.String?
    /// <p>The ARN or alias of the AWS KMS customer master key (CMK) that's used to encrypt the
    ///         <code>SecretString</code> or <code>SecretBinary</code> fields in each version of the secret.
    ///       If you don't provide a key, then Secrets Manager defaults to encrypting the secret fields with the
    ///       default AWS KMS CMK (the one named <code>awssecretsmanager</code>) for this account.</p>
    public let kmsKeyId: Swift.String?
    /// <p>The last date that this secret was accessed. This value is truncated to midnight of the
    ///       date and therefore shows only the date, not the time.</p>
    public let lastAccessedDate: ClientRuntime.Date?
    /// <p>The last date and time that this secret was modified in any way.</p>
    public let lastChangedDate: ClientRuntime.Date?
    /// <p>The last date and time that the rotation process for this secret was invoked.</p>
    ///          <p>The most recent date and time that the Secrets Manager rotation process successfully
    ///       completed. If the secret doesn't rotate, Secrets Manager returns a null value.</p>
    public let lastRotatedDate: ClientRuntime.Date?
    /// <p>The user-provided friendly name of the secret.</p>
    public let name: Swift.String?
    /// <p>Returns the name of the service that created this secret.</p>
    public let owningService: Swift.String?
    /// <p>Specifies the primary region for secret replication. </p>
    public let primaryRegion: Swift.String?
    /// <p>Describes a list of replication status objects as <code>InProgress</code>, <code>Failed</code> or <code>InSync</code>.<code>P</code>
    ///          </p>
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
    /// <p>Specifies whether automatic rotation is enabled for this secret.</p>
    ///          <p>To enable rotation, use <a>RotateSecret</a> with
    ///         <code>AutomaticallyRotateAfterDays</code> set to a value greater than 0. To disable
    ///       rotation, use <a>CancelRotateSecret</a>.</p>
    public let rotationEnabled: Swift.Bool
    /// <p>The ARN of a Lambda function that's invoked by Secrets Manager to rotate the
    ///       secret either automatically per the schedule or manually by a call to
    ///         <code>RotateSecret</code>.</p>
    public let rotationLambdaARN: Swift.String?
    /// <p>A structure with the rotation configuration for this secret.</p>
    public let rotationRules: SecretsManagerClientTypes.RotationRulesType?
    /// <p>The list of user-defined tags that are associated with the secret. To add tags to a
    ///       secret, use <a>TagResource</a>. To remove tags, use <a>UntagResource</a>.</p>
    public let tags: [SecretsManagerClientTypes.Tag]?
    /// <p>A list of all of the currently assigned <code>VersionStage</code> staging labels and the
    ///         <code>VersionId</code> that each is attached to. Staging labels are used to keep track of
    ///       the different versions during the rotation process.</p>
    ///          <note>
    ///             <p>A version that does not have any staging labels attached is considered deprecated and
    ///         subject to deletion. Such versions are not included in this list.</p>
    ///          </note>
    public let versionIdsToStages: [Swift.String:[Swift.String]]?

    public init (
        aRN: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deletedDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lastAccessedDate: ClientRuntime.Date? = nil,
        lastChangedDate: ClientRuntime.Date? = nil,
        lastRotatedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        owningService: Swift.String? = nil,
        primaryRegion: Swift.String? = nil,
        replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]? = nil,
        rotationEnabled: Swift.Bool = false,
        rotationLambdaARN: Swift.String? = nil,
        rotationRules: SecretsManagerClientTypes.RotationRulesType? = nil,
        tags: [SecretsManagerClientTypes.Tag]? = nil,
        versionIdsToStages: [Swift.String:[Swift.String]]? = nil
    )
    {
        self.aRN = aRN
        self.createdDate = createdDate
        self.deletedDate = deletedDate
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.lastAccessedDate = lastAccessedDate
        self.lastChangedDate = lastChangedDate
        self.lastRotatedDate = lastRotatedDate
        self.name = name
        self.owningService = owningService
        self.primaryRegion = primaryRegion
        self.replicationStatus = replicationStatus
        self.rotationEnabled = rotationEnabled
        self.rotationLambdaARN = rotationLambdaARN
        self.rotationRules = rotationRules
        self.tags = tags
        self.versionIdsToStages = versionIdsToStages
    }
}

struct DescribeSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let kmsKeyId: Swift.String?
    public let rotationEnabled: Swift.Bool
    public let rotationLambdaARN: Swift.String?
    public let rotationRules: SecretsManagerClientTypes.RotationRulesType?
    public let lastRotatedDate: ClientRuntime.Date?
    public let lastChangedDate: ClientRuntime.Date?
    public let lastAccessedDate: ClientRuntime.Date?
    public let deletedDate: ClientRuntime.Date?
    public let tags: [SecretsManagerClientTypes.Tag]?
    public let versionIdsToStages: [Swift.String:[Swift.String]]?
    public let owningService: Swift.String?
    public let createdDate: ClientRuntime.Date?
    public let primaryRegion: Swift.String?
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
}

extension DescribeSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case createdDate = "CreatedDate"
        case deletedDate = "DeletedDate"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case lastAccessedDate = "LastAccessedDate"
        case lastChangedDate = "LastChangedDate"
        case lastRotatedDate = "LastRotatedDate"
        case name = "Name"
        case owningService = "OwningService"
        case primaryRegion = "PrimaryRegion"
        case replicationStatus = "ReplicationStatus"
        case rotationEnabled = "RotationEnabled"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case tags = "Tags"
        case versionIdsToStages = "VersionIdsToStages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let rotationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .rotationEnabled)
        rotationEnabled = rotationEnabledDecoded
        let rotationLambdaARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationLambdaARN)
        rotationLambdaARN = rotationLambdaARNDecoded
        let rotationRulesDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.RotationRulesType.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
        let lastRotatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastRotatedDate)
        lastRotatedDate = lastRotatedDateDecoded
        let lastChangedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastChangedDate)
        lastChangedDate = lastChangedDateDecoded
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
        let deletedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletedDate)
        deletedDate = deletedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecretsManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecretsManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionIdsToStagesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .versionIdsToStages)
        var versionIdsToStagesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let versionIdsToStagesContainer = versionIdsToStagesContainer {
            versionIdsToStagesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, secretversionstagestype0) in versionIdsToStagesContainer {
                var secretversionstagestype0Decoded0: [Swift.String]? = nil
                if let secretversionstagestype0 = secretversionstagestype0 {
                    secretversionstagestype0Decoded0 = [Swift.String]()
                    for string1 in secretversionstagestype0 {
                        if let string1 = string1 {
                            secretversionstagestype0Decoded0?.append(string1)
                        }
                    }
                }
                versionIdsToStagesDecoded0?[key0] = secretversionstagestype0Decoded0
            }
        }
        versionIdsToStages = versionIdsToStagesDecoded0
        let owningServiceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningService)
        owningService = owningServiceDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let primaryRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryRegion)
        primaryRegion = primaryRegionDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[SecretsManagerClientTypes.ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [SecretsManagerClientTypes.ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension EncryptionFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionFailure(message: \(Swift.String(describing: message)))"}
}

extension EncryptionFailure: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EncryptionFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Secrets Manager can't encrypt the protected secret text using the provided KMS key. Check that the
///       customer master key (CMK) is available, enabled, and not in an invalid state. For more
///       information, see <a href="http://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
///         Customer Master Key</a>.</p>
public struct EncryptionFailure: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionFailureBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EncryptionFailureBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecretsManagerClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervaluesstringlist0 in values {
                try valuesContainer.encode(filtervaluesstringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.FilterNameStringType.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SecretsManagerClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SecretsManagerClientTypes {
    /// <p>Allows you to add filters when you use the search function in Secrets Manager.</p>
    public struct Filter: Swift.Equatable {
        /// <p>Filters your list of secrets by a specific key.</p>
        public let key: SecretsManagerClientTypes.FilterNameStringType?
        /// <p>Filters your list of secrets by a specific value.</p>
        ///          <p>You can prefix your search value with an exclamation mark (<code>!</code>) in order to perform negation filters. </p>
        public let values: [Swift.String]?

        public init (
            key: SecretsManagerClientTypes.FilterNameStringType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SecretsManagerClientTypes {
    public enum FilterNameStringType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case description
        case name
        case primaryRegion
        case tagKey
        case tagValue
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterNameStringType] {
            return [
                .all,
                .description,
                .name,
                .primaryRegion,
                .tagKey,
                .tagValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .description: return "description"
            case .name: return "name"
            case .primaryRegion: return "primary-region"
            case .tagKey: return "tag-key"
            case .tagValue: return "tag-value"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterNameStringType(rawValue: rawValue) ?? FilterNameStringType.sdkUnknown(rawValue)
        }
    }
}

public struct GetRandomPasswordInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRandomPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRandomPasswordOutputError>
}

extension GetRandomPasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRandomPasswordInput(excludeCharacters: \(Swift.String(describing: excludeCharacters)), excludeLowercase: \(Swift.String(describing: excludeLowercase)), excludeNumbers: \(Swift.String(describing: excludeNumbers)), excludePunctuation: \(Swift.String(describing: excludePunctuation)), excludeUppercase: \(Swift.String(describing: excludeUppercase)), includeSpace: \(Swift.String(describing: includeSpace)), passwordLength: \(Swift.String(describing: passwordLength)), requireEachIncludedType: \(Swift.String(describing: requireEachIncludedType)))"}
}

extension GetRandomPasswordInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludeCharacters = "ExcludeCharacters"
        case excludeLowercase = "ExcludeLowercase"
        case excludeNumbers = "ExcludeNumbers"
        case excludePunctuation = "ExcludePunctuation"
        case excludeUppercase = "ExcludeUppercase"
        case includeSpace = "IncludeSpace"
        case passwordLength = "PasswordLength"
        case requireEachIncludedType = "RequireEachIncludedType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeCharacters = excludeCharacters {
            try encodeContainer.encode(excludeCharacters, forKey: .excludeCharacters)
        }
        if excludeLowercase != false {
            try encodeContainer.encode(excludeLowercase, forKey: .excludeLowercase)
        }
        if excludeNumbers != false {
            try encodeContainer.encode(excludeNumbers, forKey: .excludeNumbers)
        }
        if excludePunctuation != false {
            try encodeContainer.encode(excludePunctuation, forKey: .excludePunctuation)
        }
        if excludeUppercase != false {
            try encodeContainer.encode(excludeUppercase, forKey: .excludeUppercase)
        }
        if includeSpace != false {
            try encodeContainer.encode(includeSpace, forKey: .includeSpace)
        }
        if passwordLength != 0 {
            try encodeContainer.encode(passwordLength, forKey: .passwordLength)
        }
        if requireEachIncludedType != false {
            try encodeContainer.encode(requireEachIncludedType, forKey: .requireEachIncludedType)
        }
    }
}

public struct GetRandomPasswordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRandomPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRandomPasswordOutputError>
}

public struct GetRandomPasswordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRandomPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRandomPasswordOutputError>
}

public struct GetRandomPasswordInput: Swift.Equatable {
    /// <p>A string that includes characters that should not be included in the generated password.
    ///       The default is that all characters from the included sets can be used.</p>
    public let excludeCharacters: Swift.String?
    /// <p>Specifies that the generated password should not include lowercase letters. The default if
    ///       you do not include this switch parameter is that lowercase letters can be included.</p>
    public let excludeLowercase: Swift.Bool
    /// <p>Specifies that the generated password should not include digits. The default if you do not
    ///       include this switch parameter is that digits can be included.</p>
    public let excludeNumbers: Swift.Bool
    /// <p>Specifies that the generated password should not include punctuation characters. The
    ///       default if you do not include this switch parameter is that punctuation characters can be
    ///       included.</p>
    ///          <p>The following are the punctuation characters that <i>can</i> be included in
    ///       the generated password if you don't explicitly exclude them with
    ///         <code>ExcludeCharacters</code> or <code>ExcludePunctuation</code>:</p>
    ///          <p>
    ///             <code>! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | }
    ///       ~</code>
    ///          </p>
    public let excludePunctuation: Swift.Bool
    /// <p>Specifies that the generated password should not include uppercase letters. The default if
    ///       you do not include this switch parameter is that uppercase letters can be included.</p>
    public let excludeUppercase: Swift.Bool
    /// <p>Specifies that the generated password can include the space character. The default if you
    ///       do not include this switch parameter is that the space character is not included.</p>
    public let includeSpace: Swift.Bool
    /// <p>The desired length of the generated password. The default value if you do not include this
    ///       parameter is 32 characters.</p>
    public let passwordLength: Swift.Int
    /// <p>A boolean value that specifies whether the generated password must include at least one of
    ///       every allowed character type. The default value is <code>True</code> and the operation
    ///       requires at least one of every character type.</p>
    public let requireEachIncludedType: Swift.Bool

    public init (
        excludeCharacters: Swift.String? = nil,
        excludeLowercase: Swift.Bool = false,
        excludeNumbers: Swift.Bool = false,
        excludePunctuation: Swift.Bool = false,
        excludeUppercase: Swift.Bool = false,
        includeSpace: Swift.Bool = false,
        passwordLength: Swift.Int = 0,
        requireEachIncludedType: Swift.Bool = false
    )
    {
        self.excludeCharacters = excludeCharacters
        self.excludeLowercase = excludeLowercase
        self.excludeNumbers = excludeNumbers
        self.excludePunctuation = excludePunctuation
        self.excludeUppercase = excludeUppercase
        self.includeSpace = includeSpace
        self.passwordLength = passwordLength
        self.requireEachIncludedType = requireEachIncludedType
    }
}

struct GetRandomPasswordInputBody: Swift.Equatable {
    public let passwordLength: Swift.Int
    public let excludeCharacters: Swift.String?
    public let excludeNumbers: Swift.Bool
    public let excludePunctuation: Swift.Bool
    public let excludeUppercase: Swift.Bool
    public let excludeLowercase: Swift.Bool
    public let includeSpace: Swift.Bool
    public let requireEachIncludedType: Swift.Bool
}

extension GetRandomPasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludeCharacters = "ExcludeCharacters"
        case excludeLowercase = "ExcludeLowercase"
        case excludeNumbers = "ExcludeNumbers"
        case excludePunctuation = "ExcludePunctuation"
        case excludeUppercase = "ExcludeUppercase"
        case includeSpace = "IncludeSpace"
        case passwordLength = "PasswordLength"
        case requireEachIncludedType = "RequireEachIncludedType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let passwordLengthDecoded = try containerValues.decode(Swift.Int.self, forKey: .passwordLength)
        passwordLength = passwordLengthDecoded
        let excludeCharactersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .excludeCharacters)
        excludeCharacters = excludeCharactersDecoded
        let excludeNumbersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludeNumbers)
        excludeNumbers = excludeNumbersDecoded
        let excludePunctuationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludePunctuation)
        excludePunctuation = excludePunctuationDecoded
        let excludeUppercaseDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludeUppercase)
        excludeUppercase = excludeUppercaseDecoded
        let excludeLowercaseDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludeLowercase)
        excludeLowercase = excludeLowercaseDecoded
        let includeSpaceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeSpace)
        includeSpace = includeSpaceDecoded
        let requireEachIncludedTypeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requireEachIncludedType)
        requireEachIncludedType = requireEachIncludedTypeDecoded
    }
}

extension GetRandomPasswordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRandomPasswordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRandomPasswordOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRandomPasswordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRandomPasswordOutputResponse(randomPassword: \(Swift.String(describing: randomPassword)))"}
}

extension GetRandomPasswordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRandomPasswordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.randomPassword = output.randomPassword
        } else {
            self.randomPassword = nil
        }
    }
}

public struct GetRandomPasswordOutputResponse: Swift.Equatable {
    /// <p>A string with the generated password.</p>
    public let randomPassword: Swift.String?

    public init (
        randomPassword: Swift.String? = nil
    )
    {
        self.randomPassword = randomPassword
    }
}

struct GetRandomPasswordOutputResponseBody: Swift.Equatable {
    public let randomPassword: Swift.String?
}

extension GetRandomPasswordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case randomPassword = "RandomPassword"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let randomPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomPassword)
        randomPassword = randomPasswordDecoded
    }
}

public struct GetResourcePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePolicyOutputError>
}

extension GetResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePolicyInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension GetResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct GetResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// <p>Specifies the secret that you want to retrieve the attached resource-based policy for. You
    ///       can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension GetResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension GetResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePolicyOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), resourcePolicy: \(Swift.String(describing: resourcePolicy)))"}
}

extension GetResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.resourcePolicy = output.resourcePolicy
        } else {
            self.aRN = nil
            self.name = nil
            self.resourcePolicy = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret that the resource-based policy was retrieved for.</p>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret that the resource-based policy was retrieved for.</p>
    public let name: Swift.String?
    /// <p>A JSON-formatted string that describes the permissions that are associated with the
    ///       attached secret. These permissions are combined with any permissions that are associated with
    ///       the user or role that attempts to access this secret. The combined permissions specify who can
    ///       access the secret and what actions they can perform. For more information, see <a href="http://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html">Authentication and Access Control for
    ///         AWS Secrets Manager</a> in the <i>AWS Secrets Manager User Guide</i>.</p>
    public let resourcePolicy: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.resourcePolicy = resourcePolicy
    }
}

struct GetResourcePolicyOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let resourcePolicy: Swift.String?
}

extension GetResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case resourcePolicy = "ResourcePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

public struct GetSecretValueInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSecretValueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSecretValueOutputError>
}

extension GetSecretValueInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSecretValueInput(secretId: \(Swift.String(describing: secretId)), versionId: \(Swift.String(describing: versionId)), versionStage: \(Swift.String(describing: versionStage)))"}
}

extension GetSecretValueInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case versionId = "VersionId"
        case versionStage = "VersionStage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
        if let versionStage = versionStage {
            try encodeContainer.encode(versionStage, forKey: .versionStage)
        }
    }
}

public struct GetSecretValueInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSecretValueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSecretValueOutputError>
}

public struct GetSecretValueInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSecretValueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSecretValueOutputError>
}

public struct GetSecretValueInput: Swift.Equatable {
    /// <p>Specifies the secret containing the version that you want to retrieve. You can specify
    ///       either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?
    /// <p>Specifies the unique identifier of the version of the secret that you want to retrieve. If
    ///       you specify both this parameter and <code>VersionStage</code>,  the two parameters must refer
    ///       to the same secret version. If you don't specify either a <code>VersionStage</code> or
    ///         <code>VersionId</code> then the default is to perform the operation on the version with the
    ///         <code>VersionStage</code> value of <code>AWSCURRENT</code>.</p>
    ///          <p>This value is typically a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value with
    ///       32 hexadecimal digits.</p>
    public let versionId: Swift.String?
    /// <p>Specifies the secret version that you want to retrieve by the staging label attached to
    ///       the version.</p>
    ///          <p>Staging labels are used to keep track of different versions during the rotation process.
    ///       If you specify both this parameter and <code>VersionId</code>,  the two parameters must refer
    ///       to the same secret version . If you don't specify either a <code>VersionStage</code> or
    ///         <code>VersionId</code>, then the default is to perform the operation on the version with the
    ///         <code>VersionStage</code> value of <code>AWSCURRENT</code>.</p>
    public let versionStage: Swift.String?

    public init (
        secretId: Swift.String? = nil,
        versionId: Swift.String? = nil,
        versionStage: Swift.String? = nil
    )
    {
        self.secretId = secretId
        self.versionId = versionId
        self.versionStage = versionStage
    }
}

struct GetSecretValueInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let versionId: Swift.String?
    public let versionStage: Swift.String?
}

extension GetSecretValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case versionId = "VersionId"
        case versionStage = "VersionStage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let versionStageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionStage)
        versionStage = versionStageDecoded
    }
}

extension GetSecretValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSecretValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DecryptionFailure" : self = .decryptionFailure(try DecryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSecretValueOutputError: Swift.Error, Swift.Equatable {
    case decryptionFailure(DecryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSecretValueOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSecretValueOutputResponse(aRN: \(Swift.String(describing: aRN)), createdDate: \(Swift.String(describing: createdDate)), name: \(Swift.String(describing: name)), secretBinary: \(Swift.String(describing: secretBinary)), secretString: \(Swift.String(describing: secretString)), versionId: \(Swift.String(describing: versionId)), versionStages: \(Swift.String(describing: versionStages)))"}
}

extension GetSecretValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSecretValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.createdDate = output.createdDate
            self.name = output.name
            self.secretBinary = output.secretBinary
            self.secretString = output.secretString
            self.versionId = output.versionId
            self.versionStages = output.versionStages
        } else {
            self.aRN = nil
            self.createdDate = nil
            self.name = nil
            self.secretBinary = nil
            self.secretString = nil
            self.versionId = nil
            self.versionStages = nil
        }
    }
}

public struct GetSecretValueOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret.</p>
    public let aRN: Swift.String?
    /// <p>The date and time that this version of the secret was created.</p>
    public let createdDate: ClientRuntime.Date?
    /// <p>The friendly name of the secret.</p>
    public let name: Swift.String?
    /// <p>The decrypted part of the protected secret information that was originally provided as
    ///       binary data in the form of a byte array. The response parameter represents the binary data as
    ///       a <a href="https://tools.ietf.org/html/rfc4648#section-4">base64-encoded</a>
    ///       string.</p>
    ///          <p>This parameter is not used if the secret is created by the Secrets Manager console.</p>
    ///          <p>If you store custom information in this field of the secret, then you must code your
    ///       Lambda rotation function to parse and interpret whatever you store in the
    ///         <code>SecretString</code> or <code>SecretBinary</code> fields.</p>
    public let secretBinary: ClientRuntime.Data?
    /// <p>The decrypted part of the protected secret information that was originally provided as a
    ///       string.</p>
    ///          <p>If you create this secret by using the Secrets Manager console then only the
    ///         <code>SecretString</code> parameter contains data. Secrets Manager stores the information as a
    ///       JSON structure of key/value pairs that the Lambda rotation function knows how to parse.</p>
    ///          <p>If you store custom information in the secret by using the <a>CreateSecret</a>,
    ///         <a>UpdateSecret</a>, or <a>PutSecretValue</a> API operations instead
    ///       of the Secrets Manager console, or by using the <b>Other secret type</b> in
    ///       the console, then you must code your Lambda rotation function to parse and interpret those
    ///       values.</p>
    public let secretString: Swift.String?
    /// <p>The unique identifier of this version of the secret.</p>
    public let versionId: Swift.String?
    /// <p>A list of all of the staging labels currently attached to this version of the
    ///       secret.</p>
    public let versionStages: [Swift.String]?

    public init (
        aRN: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        secretBinary: ClientRuntime.Data? = nil,
        secretString: Swift.String? = nil,
        versionId: Swift.String? = nil,
        versionStages: [Swift.String]? = nil
    )
    {
        self.aRN = aRN
        self.createdDate = createdDate
        self.name = name
        self.secretBinary = secretBinary
        self.secretString = secretString
        self.versionId = versionId
        self.versionStages = versionStages
    }
}

struct GetSecretValueOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
    public let secretBinary: ClientRuntime.Data?
    public let secretString: Swift.String?
    public let versionStages: [Swift.String]?
    public let createdDate: ClientRuntime.Date?
}

extension GetSecretValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case createdDate = "CreatedDate"
        case name = "Name"
        case secretBinary = "SecretBinary"
        case secretString = "SecretString"
        case versionId = "VersionId"
        case versionStages = "VersionStages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretString)
        secretString = secretStringDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[Swift.String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [Swift.String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension InternalServiceError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServiceError(message: \(Swift.String(describing: message)))"}
}

extension InternalServiceError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred on the server side.</p>
public struct InternalServiceError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You provided an invalid <code>NextToken</code> value.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You provided an invalid value for a parameter.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You provided a parameter value that is not valid for the current state of the
///       resource.</p>
///          <p>Possible causes:</p>
///          <ul>
///             <li>
///                <p>You tried to perform the operation on a secret that's currently marked deleted.</p>
///             </li>
///             <li>
///                <p>You tried to enable rotation on a secret that doesn't already have a Lambda function
///           ARN configured and you didn't include such an ARN as a parameter in this call. </p>
///             </li>
///          </ul>
public struct InvalidRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because it would exceed one of the Secrets Manager internal limits.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListSecretVersionIdsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretVersionIdsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretVersionIdsOutputError>
}

extension ListSecretVersionIdsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSecretVersionIdsInput(includeDeprecated: \(Swift.String(describing: includeDeprecated)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), secretId: \(Swift.String(describing: secretId)))"}
}

extension ListSecretVersionIdsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeDeprecated = "IncludeDeprecated"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if includeDeprecated != false {
            try encodeContainer.encode(includeDeprecated, forKey: .includeDeprecated)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct ListSecretVersionIdsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretVersionIdsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretVersionIdsOutputError>
}

public struct ListSecretVersionIdsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretVersionIdsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretVersionIdsOutputError>
}

public struct ListSecretVersionIdsInput: Swift.Equatable {
    /// <p>(Optional) Specifies that you want the results to include versions that do not have any
    ///       staging labels attached to them. Such versions are considered deprecated and are subject to
    ///       deletion by Secrets Manager as needed.</p>
    public let includeDeprecated: Swift.Bool
    /// <p>(Optional) Limits the number of results you want to include in
    ///     the response. If you don't include this parameter, it defaults to a value that's
    ///     specific to the operation. If additional items exist beyond the maximum you specify, the
    ///     <code>NextToken</code> response element is present and has a value (isn't null). Include
    ///     that value as the <code>NextToken</code> request parameter in the next call to the operation to
    ///     get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
    ///     even when there are more results available. You should check <code>NextToken</code> after every
    ///     operation to ensure that you receive all of the results.</p>
    public let maxResults: Swift.Int
    /// <p>(Optional) Use this parameter in a request if you receive a
    ///     <code>NextToken</code> response in a previous request indicating there's more
    ///     output available. In a subsequent call, set it to the value of the previous call
    ///     <code>NextToken</code> response to indicate where the output should continue from.</p>
    public let nextToken: Swift.String?
    /// <p>The identifier for the secret containing the versions you want to list. You can specify
    ///       either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?

    public init (
        includeDeprecated: Swift.Bool = false,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        secretId: Swift.String? = nil
    )
    {
        self.includeDeprecated = includeDeprecated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.secretId = secretId
    }
}

struct ListSecretVersionIdsInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
    public let includeDeprecated: Swift.Bool
}

extension ListSecretVersionIdsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeDeprecated = "IncludeDeprecated"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let includeDeprecatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeDeprecated)
        includeDeprecated = includeDeprecatedDecoded
    }
}

extension ListSecretVersionIdsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecretVersionIdsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecretVersionIdsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecretVersionIdsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSecretVersionIdsOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), versions: \(Swift.String(describing: versions)))"}
}

extension ListSecretVersionIdsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecretVersionIdsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.aRN = nil
            self.name = nil
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListSecretVersionIdsOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) for the secret.</p>
    ///          <note>
    ///             <p>Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    ///         you initially create a secret. This affects only the ARN and not the actual friendly name.
    ///         This ensures that if you create a new secret with the same name as an old secret that you
    ///         previously deleted, then users with access to the old secret <i>don't</i>
    ///         automatically get access to the new secret because the ARNs are different.</p>
    ///          </note>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret.</p>
    public let name: Swift.String?
    /// <p>If present in the response, this value indicates that
    ///     there's more output available than included in the current response. This can
    ///     occur even when the response includes no values at all, such as when you ask for a filtered view
    ///     of a very long list. Use this value in the <code>NextToken</code> request parameter in a
    ///     subsequent call to the operation to continue processing and get the next part of the output. You
    ///     should repeat this until the <code>NextToken</code> response element comes back empty (as
    ///     <code>null</code>).</p>
    public let nextToken: Swift.String?
    /// <p>The list of the currently available versions of the specified secret.</p>
    public let versions: [SecretsManagerClientTypes.SecretVersionsListEntry]?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        versions: [SecretsManagerClientTypes.SecretVersionsListEntry]? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListSecretVersionIdsOutputResponseBody: Swift.Equatable {
    public let versions: [SecretsManagerClientTypes.SecretVersionsListEntry]?
    public let nextToken: Swift.String?
    public let aRN: Swift.String?
    public let name: Swift.String?
}

extension ListSecretVersionIdsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.SecretVersionsListEntry?].self, forKey: .versions)
        var versionsDecoded0:[SecretsManagerClientTypes.SecretVersionsListEntry]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [SecretsManagerClientTypes.SecretVersionsListEntry]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct ListSecretsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretsOutputError>
}

extension ListSecretsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSecretsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sortOrder: \(Swift.String(describing: sortOrder)))"}
}

extension ListSecretsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterslisttype0 in filters {
                try filtersContainer.encode(filterslisttype0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListSecretsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretsOutputError>
}

public struct ListSecretsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretsOutputError>
}

public struct ListSecretsInput: Swift.Equatable {
    /// <p>Lists the secret request filters.</p>
    public let filters: [SecretsManagerClientTypes.Filter]?
    /// <p>(Optional) Limits the number of results you want to include in
    ///     the response. If you don't include this parameter, it defaults to a value that's
    ///     specific to the operation. If additional items exist beyond the maximum you specify, the
    ///     <code>NextToken</code> response element is present and has a value (isn't null). Include
    ///     that value as the <code>NextToken</code> request parameter in the next call to the operation to
    ///     get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
    ///     even when there are more results available. You should check <code>NextToken</code> after every
    ///     operation to ensure that you receive all of the results.</p>
    public let maxResults: Swift.Int
    /// <p>(Optional) Use this parameter in a request if you receive a
    ///     <code>NextToken</code> response in a previous request indicating there's more
    ///     output available. In a subsequent call, set it to the value of the previous call
    ///     <code>NextToken</code> response to indicate where the output should continue from.</p>
    public let nextToken: Swift.String?
    /// <p>Lists secrets in the requested order. </p>
    public let sortOrder: SecretsManagerClientTypes.SortOrderType?

    public init (
        filters: [SecretsManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sortOrder: SecretsManagerClientTypes.SortOrderType? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListSecretsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
    public let filters: [SecretsManagerClientTypes.Filter]?
    public let sortOrder: SecretsManagerClientTypes.SortOrderType?
}

extension ListSecretsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[SecretsManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SecretsManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListSecretsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecretsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecretsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecretsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSecretsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), secretList: \(Swift.String(describing: secretList)))"}
}

extension ListSecretsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecretsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.secretList = output.secretList
        } else {
            self.nextToken = nil
            self.secretList = nil
        }
    }
}

public struct ListSecretsOutputResponse: Swift.Equatable {
    /// <p>If present in the response, this value indicates that
    ///     there's more output available than included in the current response. This can
    ///     occur even when the response includes no values at all, such as when you ask for a filtered view
    ///     of a very long list. Use this value in the <code>NextToken</code> request parameter in a
    ///     subsequent call to the operation to continue processing and get the next part of the output. You
    ///     should repeat this until the <code>NextToken</code> response element comes back empty (as
    ///     <code>null</code>).</p>
    public let nextToken: Swift.String?
    /// <p>A list of the secrets in the account.</p>
    public let secretList: [SecretsManagerClientTypes.SecretListEntry]?

    public init (
        nextToken: Swift.String? = nil,
        secretList: [SecretsManagerClientTypes.SecretListEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.secretList = secretList
    }
}

struct ListSecretsOutputResponseBody: Swift.Equatable {
    public let secretList: [SecretsManagerClientTypes.SecretListEntry]?
    public let nextToken: Swift.String?
}

extension ListSecretsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case secretList = "SecretList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretListContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.SecretListEntry?].self, forKey: .secretList)
        var secretListDecoded0:[SecretsManagerClientTypes.SecretListEntry]? = nil
        if let secretListContainer = secretListContainer {
            secretListDecoded0 = [SecretsManagerClientTypes.SecretListEntry]()
            for structure0 in secretListContainer {
                if let structure0 = structure0 {
                    secretListDecoded0?.append(structure0)
                }
            }
        }
        secretList = secretListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MalformedPolicyDocumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MalformedPolicyDocumentException(message: \(Swift.String(describing: message)))"}
}

extension MalformedPolicyDocumentException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MalformedPolicyDocumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You provided a resource-based policy with syntax errors.</p>
public struct MalformedPolicyDocumentException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MalformedPolicyDocumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionNotMetException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreconditionNotMetException(message: \(Swift.String(describing: message)))"}
}

extension PreconditionNotMetException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreconditionNotMetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because you did not complete all the prerequisite steps.</p>
public struct PreconditionNotMetException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionNotMetExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PreconditionNotMetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PublicPolicyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicPolicyException(message: \(Swift.String(describing: message)))"}
}

extension PublicPolicyException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublicPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The BlockPublicPolicy parameter is set to true and the resource policy did not prevent broad access to the secret.</p>
public struct PublicPolicyException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PublicPolicyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PublicPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutResourcePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

extension PutResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutResourcePolicyInput(blockPublicPolicy: \(Swift.String(describing: blockPublicPolicy)), resourcePolicy: \(Swift.String(describing: resourcePolicy)), secretId: \(Swift.String(describing: secretId)))"}
}

extension PutResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicPolicy = "BlockPublicPolicy"
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockPublicPolicy != false {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if let resourcePolicy = resourcePolicy {
            try encodeContainer.encode(resourcePolicy, forKey: .resourcePolicy)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct PutResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// <p>(Optional) If you set the parameter, <code>BlockPublicPolicy</code> to true, then you
    ///       block resource-based policies that allow broad access to the secret.</p>
    public let blockPublicPolicy: Swift.Bool
    /// <p>A JSON-formatted string constructed according to the grammar and syntax for an AWS
    ///       resource-based policy. The policy in the string identifies who can access or manage this
    ///       secret and its versions. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
    ///         JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    public let resourcePolicy: Swift.String?
    /// <p>Specifies the secret that you want to attach the resource-based policy. You can specify
    ///       either the ARN or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?

    public init (
        blockPublicPolicy: Swift.Bool = false,
        resourcePolicy: Swift.String? = nil,
        secretId: Swift.String? = nil
    )
    {
        self.blockPublicPolicy = blockPublicPolicy
        self.resourcePolicy = resourcePolicy
        self.secretId = secretId
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let resourcePolicy: Swift.String?
    public let blockPublicPolicy: Swift.Bool
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicPolicy = "BlockPublicPolicy"
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
        let blockPublicPolicyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
    }
}

extension PutResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicPolicyException" : self = .publicPolicyException(try PublicPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case publicPolicyException(PublicPolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutResourcePolicyOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension PutResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret retrieved by the resource-based policy.</p>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret retrieved by the resource-based policy.</p>
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct PutResourcePolicyOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
}

extension PutResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct PutSecretValueInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSecretValueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSecretValueOutputError>
}

extension PutSecretValueInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSecretValueInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), secretBinary: \(Swift.String(describing: secretBinary)), secretId: \(Swift.String(describing: secretId)), secretString: \(Swift.String(describing: secretString)), versionStages: \(Swift.String(describing: versionStages)))"}
}

extension PutSecretValueInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
        case versionStages = "VersionStages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let secretBinary = secretBinary {
            try encodeContainer.encode(secretBinary.base64EncodedString(), forKey: .secretBinary)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let secretString = secretString {
            try encodeContainer.encode(secretString, forKey: .secretString)
        }
        if let versionStages = versionStages {
            var versionStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versionStages)
            for secretversionstagestype0 in versionStages {
                try versionStagesContainer.encode(secretversionstagestype0)
            }
        }
    }
}

public struct PutSecretValueInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSecretValueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSecretValueOutputError>
}

public struct PutSecretValueInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSecretValueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSecretValueOutputError>
}

public struct PutSecretValueInput: Swift.Equatable {
    /// <p>(Optional) Specifies a unique identifier for the new version of the secret. </p>
    ///          <note>
    ///             <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    ///         leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    ///         in the request. If you don't use the SDK and instead generate a raw HTTP request to the
    ///         Secrets Manager service endpoint, then you must generate a <code>ClientRequestToken</code> yourself
    ///         for new versions and include that value in the request. </p>
    ///          </note>
    ///          <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
    ///       creation of duplicate versions if there are failures and retries during the Lambda rotation
    ///       function's processing. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    ///       ensure uniqueness within the specified secret. </p>
    ///          <ul>
    ///             <li>
    ///                <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    ///           of the secret then a new version of the secret is created. </p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and that version's
    ///             <code>SecretString</code> or <code>SecretBinary</code> values are the same as those in
    ///           the request then the request is ignored (the operation is idempotent). </p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and the version of the
    ///             <code>SecretString</code> and <code>SecretBinary</code> values are different from those
    ///           in the request then the request fails because you cannot modify an existing secret
    ///           version. You can only create new versions to store new secret values.</p>
    ///             </li>
    ///          </ul>
    ///          <p>This value becomes the <code>VersionId</code> of the new version.</p>
    public var clientRequestToken: Swift.String?
    /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
    ///       the secret. To use this parameter in the command-line tools, we recommend that you store your
    ///       binary data in a file and then use the appropriate technique for your tool to pass the
    ///       contents of the file as a parameter. Either <code>SecretBinary</code> or
    ///         <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
    ///
    ///          <p>This parameter is not accessible if the secret using the Secrets Manager console.</p>
    ///          <p></p>
    public let secretBinary: ClientRuntime.Data?
    /// <p>Specifies the secret to which you want to add a new version. You can specify either the
    ///       Amazon Resource Name (ARN) or the friendly name of the secret. The secret must already
    ///       exist.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?
    /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
    ///       the secret. Either <code>SecretString</code> or <code>SecretBinary</code> must have a value,
    ///       but not both. They cannot both be empty.</p>
    ///
    ///          <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
    ///       protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
    ///       stores the information as a JSON structure of key/value pairs that the default Lambda rotation
    ///       function knows how to parse.</p>
    ///          <p>For storing multiple values, we recommend that you use a JSON text string argument and
    ///       specify key/value pairs. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    ///          <p> For example:</p>
    ///          <p>
    ///             <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
    ///          </p>
    ///          <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text.</p>
    public let secretString: Swift.String?
    /// <p>(Optional) Specifies a list of staging labels that are attached to this version of the
    ///       secret. These staging labels are used to track the versions through the rotation process by
    ///       the Lambda rotation function.</p>
    ///          <p>A staging label must be unique to a single version of the secret. If you specify a staging
    ///       label that's already associated with a different version of the same secret then that staging
    ///       label is automatically removed from the other version and attached to this version.</p>
    ///          <p>If you do not specify a value for <code>VersionStages</code> then Secrets Manager automatically
    ///       moves the staging label <code>AWSCURRENT</code> to this new version.</p>
    public let versionStages: [Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        secretBinary: ClientRuntime.Data? = nil,
        secretId: Swift.String? = nil,
        secretString: Swift.String? = nil,
        versionStages: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.secretBinary = secretBinary
        self.secretId = secretId
        self.secretString = secretString
        self.versionStages = versionStages
    }
}

struct PutSecretValueInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let secretBinary: ClientRuntime.Data?
    public let secretString: Swift.String?
    public let versionStages: [Swift.String]?
}

extension PutSecretValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
        case versionStages = "VersionStages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretString)
        secretString = secretStringDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[Swift.String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [Swift.String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
    }
}

extension PutSecretValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSecretValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionFailure" : self = .encryptionFailure(try EncryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSecretValueOutputError: Swift.Error, Swift.Equatable {
    case encryptionFailure(EncryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSecretValueOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSecretValueOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), versionId: \(Swift.String(describing: versionId)), versionStages: \(Swift.String(describing: versionStages)))"}
}

extension PutSecretValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutSecretValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
            self.versionStages = output.versionStages
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
            self.versionStages = nil
        }
    }
}

public struct PutSecretValueOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) for the secret for which you just created a version.</p>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret for which you just created or updated a version.</p>
    public let name: Swift.String?
    /// <p>The unique identifier of the version of the secret you just created or updated.</p>
    public let versionId: Swift.String?
    /// <p>The list of staging labels that are currently attached to this version of the secret.
    ///       Staging labels are used to track a version as it progresses through the secret rotation
    ///       process.</p>
    public let versionStages: [Swift.String]?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        versionId: Swift.String? = nil,
        versionStages: [Swift.String]? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
        self.versionStages = versionStages
    }
}

struct PutSecretValueOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
    public let versionStages: [Swift.String]?
}

extension PutSecretValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
        case versionStages = "VersionStages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[Swift.String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [Swift.String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
    }
}

public struct RemoveRegionsFromReplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRegionsFromReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRegionsFromReplicationOutputError>
}

extension RemoveRegionsFromReplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveRegionsFromReplicationInput(removeReplicaRegions: \(Swift.String(describing: removeReplicaRegions)), secretId: \(Swift.String(describing: secretId)))"}
}

extension RemoveRegionsFromReplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case removeReplicaRegions = "RemoveReplicaRegions"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let removeReplicaRegions = removeReplicaRegions {
            var removeReplicaRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeReplicaRegions)
            for removereplicaregionlisttype0 in removeReplicaRegions {
                try removeReplicaRegionsContainer.encode(removereplicaregionlisttype0)
            }
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct RemoveRegionsFromReplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRegionsFromReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRegionsFromReplicationOutputError>
}

public struct RemoveRegionsFromReplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRegionsFromReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRegionsFromReplicationOutputError>
}

public struct RemoveRegionsFromReplicationInput: Swift.Equatable {
    /// <p>Remove replication from specific Regions.</p>
    public let removeReplicaRegions: [Swift.String]?
    /// <p>Remove a secret by <code>SecretId</code> from replica Regions.</p>
    public let secretId: Swift.String?

    public init (
        removeReplicaRegions: [Swift.String]? = nil,
        secretId: Swift.String? = nil
    )
    {
        self.removeReplicaRegions = removeReplicaRegions
        self.secretId = secretId
    }
}

struct RemoveRegionsFromReplicationInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let removeReplicaRegions: [Swift.String]?
}

extension RemoveRegionsFromReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case removeReplicaRegions = "RemoveReplicaRegions"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let removeReplicaRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeReplicaRegions)
        var removeReplicaRegionsDecoded0:[Swift.String]? = nil
        if let removeReplicaRegionsContainer = removeReplicaRegionsContainer {
            removeReplicaRegionsDecoded0 = [Swift.String]()
            for string0 in removeReplicaRegionsContainer {
                if let string0 = string0 {
                    removeReplicaRegionsDecoded0?.append(string0)
                }
            }
        }
        removeReplicaRegions = removeReplicaRegionsDecoded0
    }
}

extension RemoveRegionsFromReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveRegionsFromReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRegionsFromReplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRegionsFromReplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveRegionsFromReplicationOutputResponse(aRN: \(Swift.String(describing: aRN)), replicationStatus: \(Swift.String(describing: replicationStatus)))"}
}

extension RemoveRegionsFromReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveRegionsFromReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.replicationStatus = output.replicationStatus
        } else {
            self.aRN = nil
            self.replicationStatus = nil
        }
    }
}

public struct RemoveRegionsFromReplicationOutputResponse: Swift.Equatable {
    /// <p>The secret <code>ARN</code> removed from replication regions.</p>
    public let aRN: Swift.String?
    /// <p>Describes the remaining replication status after you remove regions from the replication list.</p>
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?

    public init (
        aRN: Swift.String? = nil,
        replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]? = nil
    )
    {
        self.aRN = aRN
        self.replicationStatus = replicationStatus
    }
}

struct RemoveRegionsFromReplicationOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
}

extension RemoveRegionsFromReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case replicationStatus = "ReplicationStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[SecretsManagerClientTypes.ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [SecretsManagerClientTypes.ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension SecretsManagerClientTypes.ReplicaRegionType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SecretsManagerClientTypes.ReplicaRegionType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicaRegionType(kmsKeyId: \(Swift.String(describing: kmsKeyId)), region: \(Swift.String(describing: region)))"}
}

extension SecretsManagerClientTypes {
    /// <p>(Optional) Custom type consisting of a <code>Region</code> (required) and the <code>KmsKeyId</code> which can be an <code>ARN</code>, <code>Key ID</code>, or <code>Alias</code>.</p>
    public struct ReplicaRegionType: Swift.Equatable {
        /// <p>Can be an <code>ARN</code>, <code>Key ID</code>, or <code>Alias</code>. </p>
        public let kmsKeyId: Swift.String?
        /// <p>Describes a single instance of Region objects.</p>
        public let region: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.region = region
        }
    }

}

public struct ReplicateSecretToRegionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReplicateSecretToRegionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReplicateSecretToRegionsOutputError>
}

extension ReplicateSecretToRegionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicateSecretToRegionsInput(addReplicaRegions: \(Swift.String(describing: addReplicaRegions)), forceOverwriteReplicaSecret: \(Swift.String(describing: forceOverwriteReplicaSecret)), secretId: \(Swift.String(describing: secretId)))"}
}

extension ReplicateSecretToRegionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addReplicaRegions = addReplicaRegions {
            var addReplicaRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addReplicaRegions)
            for addreplicaregionlisttype0 in addReplicaRegions {
                try addReplicaRegionsContainer.encode(addreplicaregionlisttype0)
            }
        }
        if forceOverwriteReplicaSecret != false {
            try encodeContainer.encode(forceOverwriteReplicaSecret, forKey: .forceOverwriteReplicaSecret)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct ReplicateSecretToRegionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReplicateSecretToRegionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReplicateSecretToRegionsOutputError>
}

public struct ReplicateSecretToRegionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReplicateSecretToRegionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReplicateSecretToRegionsOutputError>
}

public struct ReplicateSecretToRegionsInput: Swift.Equatable {
    /// <p>Add Regions to replicate the secret.</p>
    public let addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]?
    /// <p>(Optional) If set, Secrets Manager replication overwrites a secret with the same name in the
    ///       destination region.</p>
    public let forceOverwriteReplicaSecret: Swift.Bool
    /// <p>Use the <code>Secret Id</code> to replicate a secret to regions.</p>
    public let secretId: Swift.String?

    public init (
        addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]? = nil,
        forceOverwriteReplicaSecret: Swift.Bool = false,
        secretId: Swift.String? = nil
    )
    {
        self.addReplicaRegions = addReplicaRegions
        self.forceOverwriteReplicaSecret = forceOverwriteReplicaSecret
        self.secretId = secretId
    }
}

struct ReplicateSecretToRegionsInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]?
    public let forceOverwriteReplicaSecret: Swift.Bool
}

extension ReplicateSecretToRegionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let addReplicaRegionsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicaRegionType?].self, forKey: .addReplicaRegions)
        var addReplicaRegionsDecoded0:[SecretsManagerClientTypes.ReplicaRegionType]? = nil
        if let addReplicaRegionsContainer = addReplicaRegionsContainer {
            addReplicaRegionsDecoded0 = [SecretsManagerClientTypes.ReplicaRegionType]()
            for structure0 in addReplicaRegionsContainer {
                if let structure0 = structure0 {
                    addReplicaRegionsDecoded0?.append(structure0)
                }
            }
        }
        addReplicaRegions = addReplicaRegionsDecoded0
        let forceOverwriteReplicaSecretDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceOverwriteReplicaSecret)
        forceOverwriteReplicaSecret = forceOverwriteReplicaSecretDecoded
    }
}

extension ReplicateSecretToRegionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReplicateSecretToRegionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReplicateSecretToRegionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReplicateSecretToRegionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicateSecretToRegionsOutputResponse(aRN: \(Swift.String(describing: aRN)), replicationStatus: \(Swift.String(describing: replicationStatus)))"}
}

extension ReplicateSecretToRegionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReplicateSecretToRegionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.replicationStatus = output.replicationStatus
        } else {
            self.aRN = nil
            self.replicationStatus = nil
        }
    }
}

public struct ReplicateSecretToRegionsOutputResponse: Swift.Equatable {
    /// <p>Replicate a secret based on the <code>ReplicaRegionType</code>> consisting of a
    ///       Region(required) and a KMSKeyId (optional) which can be the ARN, KeyID, or Alias. </p>
    public let aRN: Swift.String?
    /// <p>Describes the secret replication status as <code>PENDING</code>, <code>SUCCESS</code> or <code>FAIL</code>.</p>
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?

    public init (
        aRN: Swift.String? = nil,
        replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]? = nil
    )
    {
        self.aRN = aRN
        self.replicationStatus = replicationStatus
    }
}

struct ReplicateSecretToRegionsOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
}

extension ReplicateSecretToRegionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case replicationStatus = "ReplicationStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[SecretsManagerClientTypes.ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [SecretsManagerClientTypes.ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension SecretsManagerClientTypes.ReplicationStatusType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case lastAccessedDate = "LastAccessedDate"
        case region = "Region"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastAccessedDate = lastAccessedDate {
            try encodeContainer.encode(lastAccessedDate.timeIntervalSince1970, forKey: .lastAccessedDate)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
    }
}

extension SecretsManagerClientTypes.ReplicationStatusType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationStatusType(kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastAccessedDate: \(Swift.String(describing: lastAccessedDate)), region: \(Swift.String(describing: region)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension SecretsManagerClientTypes {
    /// <p>A replication object consisting of a <code>RegionReplicationStatus</code> object and includes a Region, KMSKeyId, status, and status message.</p>
    public struct ReplicationStatusType: Swift.Equatable {
        /// <p>Can be an <code>ARN</code>, <code>Key ID</code>, or <code>Alias</code>. </p>
        public let kmsKeyId: Swift.String?
        /// <p>The date that you last accessed the secret in the Region. </p>
        public let lastAccessedDate: ClientRuntime.Date?
        /// <p>The Region where replication occurs.</p>
        public let region: Swift.String?
        /// <p>The status can be <code>InProgress</code>, <code>Failed</code>, or <code>InSync</code>.</p>
        public let status: SecretsManagerClientTypes.StatusType?
        /// <p>Status message such as "<i>Secret with this name already exists in this
        ///         region</i>".</p>
        public let statusMessage: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            lastAccessedDate: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            status: SecretsManagerClientTypes.StatusType? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.lastAccessedDate = lastAccessedDate
            self.region = region
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension ResourceExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceExistsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource with the ID you requested already exists.</p>
public struct ResourceExistsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We can't find the resource that you asked for.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestoreSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreSecretOutputError>
}

extension RestoreSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreSecretInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension RestoreSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct RestoreSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreSecretOutputError>
}

public struct RestoreSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreSecretOutputError>
}

public struct RestoreSecretInput: Swift.Equatable {
    /// <p>Specifies the secret that you want to restore from a previously scheduled deletion. You
    ///       can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct RestoreSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension RestoreSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension RestoreSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreSecretOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension RestoreSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct RestoreSecretOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret that was restored.</p>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret that was restored.</p>
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct RestoreSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
}

extension RestoreSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct RotateSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateSecretOutputError>
}

extension RotateSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateSecretInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), rotationLambdaARN: \(Swift.String(describing: rotationLambdaARN)), rotationRules: \(Swift.String(describing: rotationRules)), secretId: \(Swift.String(describing: secretId)))"}
}

extension RotateSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rotationLambdaARN = rotationLambdaARN {
            try encodeContainer.encode(rotationLambdaARN, forKey: .rotationLambdaARN)
        }
        if let rotationRules = rotationRules {
            try encodeContainer.encode(rotationRules, forKey: .rotationRules)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct RotateSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateSecretOutputError>
}

public struct RotateSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateSecretOutputError>
}

public struct RotateSecretInput: Swift.Equatable {
    /// <p>(Optional) Specifies a unique identifier for the new version of the secret that helps
    ///       ensure idempotency. </p>
    ///          <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    ///       leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    ///       in the request for this parameter. If you don't use the SDK and instead generate a raw HTTP
    ///       request to the Secrets Manager service endpoint, then you must generate a
    ///         <code>ClientRequestToken</code> yourself for new versions and include that value in the
    ///       request.</p>
    ///          <p>You only need to specify your own value if you implement your own retry logic and want to
    ///       ensure that a given secret is not created twice. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    ///       ensure uniqueness within the specified secret. </p>
    ///          <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
    ///       there are failures and retries during the function's processing. This value becomes the
    ///         <code>VersionId</code> of the new version.</p>
    public var clientRequestToken: Swift.String?
    /// <p>(Optional) Specifies the ARN of the Lambda function that can rotate the secret.</p>
    public let rotationLambdaARN: Swift.String?
    /// <p>A structure that defines the rotation configuration for this secret.</p>
    public let rotationRules: SecretsManagerClientTypes.RotationRulesType?
    /// <p>Specifies the secret that you want to rotate. You can specify either the Amazon Resource
    ///       Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        rotationLambdaARN: Swift.String? = nil,
        rotationRules: SecretsManagerClientTypes.RotationRulesType? = nil,
        secretId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rotationLambdaARN = rotationLambdaARN
        self.rotationRules = rotationRules
        self.secretId = secretId
    }
}

struct RotateSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let rotationLambdaARN: Swift.String?
    public let rotationRules: SecretsManagerClientTypes.RotationRulesType?
}

extension RotateSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let rotationLambdaARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationLambdaARN)
        rotationLambdaARN = rotationLambdaARNDecoded
        let rotationRulesDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.RotationRulesType.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
    }
}

extension RotateSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RotateSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RotateSecretOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RotateSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), versionId: \(Swift.String(describing: versionId)))"}
}

extension RotateSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RotateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
        }
    }
}

public struct RotateSecretOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret.</p>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret.</p>
    public let name: Swift.String?
    /// <p>The ID of the new version of the secret created by the rotation started by this
    ///       request.</p>
    public let versionId: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
    }
}

struct RotateSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
}

extension RotateSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension SecretsManagerClientTypes.RotationRulesType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticallyAfterDays = "AutomaticallyAfterDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if automaticallyAfterDays != 0 {
            try encodeContainer.encode(automaticallyAfterDays, forKey: .automaticallyAfterDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticallyAfterDaysDecoded = try containerValues.decode(Swift.Int.self, forKey: .automaticallyAfterDays)
        automaticallyAfterDays = automaticallyAfterDaysDecoded
    }
}

extension SecretsManagerClientTypes.RotationRulesType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotationRulesType(automaticallyAfterDays: \(Swift.String(describing: automaticallyAfterDays)))"}
}

extension SecretsManagerClientTypes {
    /// <p>A structure that defines the rotation configuration for the secret.</p>
    public struct RotationRulesType: Swift.Equatable {
        /// <p>Specifies the number of days between automatic scheduled rotations of the secret.</p>
        ///          <p>Secrets Manager schedules the next rotation when the previous
        ///     one is complete. Secrets Manager schedules the date by adding the rotation interval (number of days) to the
        ///     actual date of the last rotation. The service chooses the hour within that 24-hour date window
        ///     randomly. The minute is also chosen somewhat randomly, but weighted towards the top of the hour
        ///     and influenced by a variety of factors that help distribute load.</p>
        public let automaticallyAfterDays: Swift.Int

        public init (
            automaticallyAfterDays: Swift.Int = 0
        )
        {
            self.automaticallyAfterDays = automaticallyAfterDays
        }
    }

}

extension SecretsManagerClientTypes.SecretListEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case createdDate = "CreatedDate"
        case deletedDate = "DeletedDate"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case lastAccessedDate = "LastAccessedDate"
        case lastChangedDate = "LastChangedDate"
        case lastRotatedDate = "LastRotatedDate"
        case name = "Name"
        case owningService = "OwningService"
        case primaryRegion = "PrimaryRegion"
        case rotationEnabled = "RotationEnabled"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case secretVersionsToStages = "SecretVersionsToStages"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let deletedDate = deletedDate {
            try encodeContainer.encode(deletedDate.timeIntervalSince1970, forKey: .deletedDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastAccessedDate = lastAccessedDate {
            try encodeContainer.encode(lastAccessedDate.timeIntervalSince1970, forKey: .lastAccessedDate)
        }
        if let lastChangedDate = lastChangedDate {
            try encodeContainer.encode(lastChangedDate.timeIntervalSince1970, forKey: .lastChangedDate)
        }
        if let lastRotatedDate = lastRotatedDate {
            try encodeContainer.encode(lastRotatedDate.timeIntervalSince1970, forKey: .lastRotatedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningService = owningService {
            try encodeContainer.encode(owningService, forKey: .owningService)
        }
        if let primaryRegion = primaryRegion {
            try encodeContainer.encode(primaryRegion, forKey: .primaryRegion)
        }
        if rotationEnabled != false {
            try encodeContainer.encode(rotationEnabled, forKey: .rotationEnabled)
        }
        if let rotationLambdaARN = rotationLambdaARN {
            try encodeContainer.encode(rotationLambdaARN, forKey: .rotationLambdaARN)
        }
        if let rotationRules = rotationRules {
            try encodeContainer.encode(rotationRules, forKey: .rotationRules)
        }
        if let secretVersionsToStages = secretVersionsToStages {
            var secretVersionsToStagesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .secretVersionsToStages)
            for (dictKey0, secretversionstostagesmaptype0) in secretVersionsToStages {
                try secretVersionsToStagesContainer.encode(secretversionstostagesmaptype0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglisttype0 in tags {
                try tagsContainer.encode(taglisttype0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let rotationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .rotationEnabled)
        rotationEnabled = rotationEnabledDecoded
        let rotationLambdaARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationLambdaARN)
        rotationLambdaARN = rotationLambdaARNDecoded
        let rotationRulesDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.RotationRulesType.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
        let lastRotatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastRotatedDate)
        lastRotatedDate = lastRotatedDateDecoded
        let lastChangedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastChangedDate)
        lastChangedDate = lastChangedDateDecoded
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
        let deletedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletedDate)
        deletedDate = deletedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecretsManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecretsManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let secretVersionsToStagesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .secretVersionsToStages)
        var secretVersionsToStagesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let secretVersionsToStagesContainer = secretVersionsToStagesContainer {
            secretVersionsToStagesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, secretversionstagestype0) in secretVersionsToStagesContainer {
                var secretversionstagestype0Decoded0: [Swift.String]? = nil
                if let secretversionstagestype0 = secretversionstagestype0 {
                    secretversionstagestype0Decoded0 = [Swift.String]()
                    for string1 in secretversionstagestype0 {
                        if let string1 = string1 {
                            secretversionstagestype0Decoded0?.append(string1)
                        }
                    }
                }
                secretVersionsToStagesDecoded0?[key0] = secretversionstagestype0Decoded0
            }
        }
        secretVersionsToStages = secretVersionsToStagesDecoded0
        let owningServiceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningService)
        owningService = owningServiceDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let primaryRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryRegion)
        primaryRegion = primaryRegionDecoded
    }
}

extension SecretsManagerClientTypes.SecretListEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecretListEntry(aRN: \(Swift.String(describing: aRN)), createdDate: \(Swift.String(describing: createdDate)), deletedDate: \(Swift.String(describing: deletedDate)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastAccessedDate: \(Swift.String(describing: lastAccessedDate)), lastChangedDate: \(Swift.String(describing: lastChangedDate)), lastRotatedDate: \(Swift.String(describing: lastRotatedDate)), name: \(Swift.String(describing: name)), owningService: \(Swift.String(describing: owningService)), primaryRegion: \(Swift.String(describing: primaryRegion)), rotationEnabled: \(Swift.String(describing: rotationEnabled)), rotationLambdaARN: \(Swift.String(describing: rotationLambdaARN)), rotationRules: \(Swift.String(describing: rotationRules)), secretVersionsToStages: \(Swift.String(describing: secretVersionsToStages)), tags: \(Swift.String(describing: tags)))"}
}

extension SecretsManagerClientTypes {
    /// <p>A structure that contains the details about a secret. It does not include the encrypted
    ///         <code>SecretString</code> and <code>SecretBinary</code> values. To get those values, use the
    ///         <a>GetSecretValue</a> operation.</p>
    public struct SecretListEntry: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the secret.</p>
        ///          <p>For more information about ARNs in Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_iam-permissions.html#iam-resources">Policy Resources</a> in the
        ///     <i>AWS Secrets Manager User Guide</i>.</p>
        public let aRN: Swift.String?
        /// <p>The date and time when a secret was created.</p>
        public let createdDate: ClientRuntime.Date?
        /// <p>The date and time the deletion of the secret occurred. Not present on active secrets. The
        ///       secret can be recovered until the number of days in the recovery window has passed, as
        ///       specified in the <code>RecoveryWindowInDays</code> parameter of the <a>DeleteSecret</a> operation.</p>
        public let deletedDate: ClientRuntime.Date?
        /// <p>The user-provided description of the secret.</p>
        public let description: Swift.String?
        /// <p>The ARN or alias of the AWS KMS customer master key (CMK) used to encrypt the
        ///         <code>SecretString</code> and <code>SecretBinary</code> fields in each version of the
        ///       secret. If you don't provide a key, then Secrets Manager defaults to encrypting the secret fields with
        ///       the default KMS CMK, the key named <code>awssecretsmanager</code>, for this account.</p>
        public let kmsKeyId: Swift.String?
        /// <p>The last date that this secret was accessed. This value is truncated to midnight of the
        ///       date and therefore shows only the date, not the time.</p>
        public let lastAccessedDate: ClientRuntime.Date?
        /// <p>The last date and time that this secret was modified in any way.</p>
        public let lastChangedDate: ClientRuntime.Date?
        /// <p>The most recent date and time that the Secrets Manager rotation process was successfully completed. This value is null if the secret hasn't ever rotated.</p>
        public let lastRotatedDate: ClientRuntime.Date?
        /// <p>The friendly name of the secret. You can use forward slashes in the name to represent a
        ///       path hierarchy. For example, <code>/prod/databases/dbserver1</code> could represent the secret
        ///       for a server named <code>dbserver1</code> in the folder <code>databases</code> in the folder
        ///         <code>prod</code>. </p>
        public let name: Swift.String?
        /// <p>Returns the name of the service that created the secret.</p>
        public let owningService: Swift.String?
        /// <p>The Region where Secrets Manager originated the secret.</p>
        public let primaryRegion: Swift.String?
        /// <p>Indicates whether automatic, scheduled rotation is enabled for this secret.</p>
        public let rotationEnabled: Swift.Bool
        /// <p>The ARN of an AWS Lambda function invoked by Secrets Manager to rotate and expire the
        ///       secret either automatically per the schedule or manually by a call to <a>RotateSecret</a>.</p>
        public let rotationLambdaARN: Swift.String?
        /// <p>A structure that defines the rotation configuration for the secret.</p>
        public let rotationRules: SecretsManagerClientTypes.RotationRulesType?
        /// <p>A list of all of the currently assigned <code>SecretVersionStage</code> staging labels and
        ///       the <code>SecretVersionId</code> attached to each one. Staging labels are used to keep
        ///       track of the different versions during the rotation process.</p>
        ///          <note>
        ///             <p>A version that does not have any <code>SecretVersionStage</code> is considered
        ///         deprecated and subject to deletion. Such versions are not included in this list.</p>
        ///          </note>
        public let secretVersionsToStages: [Swift.String:[Swift.String]]?
        /// <p>The list of user-defined tags associated with the secret. To add tags to a
        ///       secret, use <a>TagResource</a>. To remove tags, use <a>UntagResource</a>.</p>
        public let tags: [SecretsManagerClientTypes.Tag]?

        public init (
            aRN: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            deletedDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            lastAccessedDate: ClientRuntime.Date? = nil,
            lastChangedDate: ClientRuntime.Date? = nil,
            lastRotatedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owningService: Swift.String? = nil,
            primaryRegion: Swift.String? = nil,
            rotationEnabled: Swift.Bool = false,
            rotationLambdaARN: Swift.String? = nil,
            rotationRules: SecretsManagerClientTypes.RotationRulesType? = nil,
            secretVersionsToStages: [Swift.String:[Swift.String]]? = nil,
            tags: [SecretsManagerClientTypes.Tag]? = nil
        )
        {
            self.aRN = aRN
            self.createdDate = createdDate
            self.deletedDate = deletedDate
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.lastAccessedDate = lastAccessedDate
            self.lastChangedDate = lastChangedDate
            self.lastRotatedDate = lastRotatedDate
            self.name = name
            self.owningService = owningService
            self.primaryRegion = primaryRegion
            self.rotationEnabled = rotationEnabled
            self.rotationLambdaARN = rotationLambdaARN
            self.rotationRules = rotationRules
            self.secretVersionsToStages = secretVersionsToStages
            self.tags = tags
        }
    }

}

extension SecretsManagerClientTypes.SecretVersionsListEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case lastAccessedDate = "LastAccessedDate"
        case versionId = "VersionId"
        case versionStages = "VersionStages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let lastAccessedDate = lastAccessedDate {
            try encodeContainer.encode(lastAccessedDate.timeIntervalSince1970, forKey: .lastAccessedDate)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
        if let versionStages = versionStages {
            var versionStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versionStages)
            for secretversionstagestype0 in versionStages {
                try versionStagesContainer.encode(secretversionstagestype0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[Swift.String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [Swift.String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SecretsManagerClientTypes.SecretVersionsListEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecretVersionsListEntry(createdDate: \(Swift.String(describing: createdDate)), lastAccessedDate: \(Swift.String(describing: lastAccessedDate)), versionId: \(Swift.String(describing: versionId)), versionStages: \(Swift.String(describing: versionStages)))"}
}

extension SecretsManagerClientTypes {
    /// <p>A structure that contains information about one version of a secret.</p>
    public struct SecretVersionsListEntry: Swift.Equatable {
        /// <p>The date and time this version of the secret was created.</p>
        public let createdDate: ClientRuntime.Date?
        /// <p>The date that this version of the secret was last accessed. Note that the resolution of
        ///       this field is at the date level and does not include the time.</p>
        public let lastAccessedDate: ClientRuntime.Date?
        /// <p>The unique version identifier of this version of the secret.</p>
        public let versionId: Swift.String?
        /// <p>An array of staging labels that are currently associated with this version of the
        ///       secret.</p>
        public let versionStages: [Swift.String]?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            lastAccessedDate: ClientRuntime.Date? = nil,
            versionId: Swift.String? = nil,
            versionStages: [Swift.String]? = nil
        )
        {
            self.createdDate = createdDate
            self.lastAccessedDate = lastAccessedDate
            self.versionId = versionId
            self.versionStages = versionStages
        }
    }

}

extension SecretsManagerClientTypes {
    public enum SortOrderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrderType] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "asc"
            case .desc: return "desc"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrderType(rawValue: rawValue) ?? SortOrderType.sdkUnknown(rawValue)
        }
    }
}

extension SecretsManagerClientTypes {
    public enum StatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case insync
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusType] {
            return [
                .failed,
                .inprogress,
                .insync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .insync: return "InSync"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusType(rawValue: rawValue) ?? StatusType.sdkUnknown(rawValue)
        }
    }
}

public struct StopReplicationToReplicaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopReplicationToReplicaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopReplicationToReplicaOutputError>
}

extension StopReplicationToReplicaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopReplicationToReplicaInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension StopReplicationToReplicaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct StopReplicationToReplicaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopReplicationToReplicaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopReplicationToReplicaOutputError>
}

public struct StopReplicationToReplicaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopReplicationToReplicaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopReplicationToReplicaOutputError>
}

public struct StopReplicationToReplicaInput: Swift.Equatable {
    /// <p>Response to <code>StopReplicationToReplica</code> of a secret, based on the <code>SecretId</code>.</p>
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct StopReplicationToReplicaInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension StopReplicationToReplicaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension StopReplicationToReplicaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopReplicationToReplicaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopReplicationToReplicaOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopReplicationToReplicaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopReplicationToReplicaOutputResponse(aRN: \(Swift.String(describing: aRN)))"}
}

extension StopReplicationToReplicaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopReplicationToReplicaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
        } else {
            self.aRN = nil
        }
    }
}

public struct StopReplicationToReplicaOutputResponse: Swift.Equatable {
    /// <p>Response <code>StopReplicationToReplica</code> of a secret, based on the <code>ARN,</code>.</p>
    public let aRN: Swift.String?

    public init (
        aRN: Swift.String? = nil
    )
    {
        self.aRN = aRN
    }
}

struct StopReplicationToReplicaOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
}

extension StopReplicationToReplicaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension SecretsManagerClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecretsManagerClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SecretsManagerClientTypes {
    /// <p>A structure that contains information about a tag.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The key identifier, or name, of the tag.</p>
        public let key: Swift.String?
        /// <p>The string value associated with the key of the tag.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(secretId: \(Swift.String(describing: secretId)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglisttype0 in tags {
                try tagsContainer.encode(taglisttype0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The identifier for the secret that you want to attach tags to. You can specify either the
    ///       Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?
    /// <p>The tags to attach to the secret. Each element in the list consists of a <code>Key</code>
    ///       and a <code>Value</code>.</p>
    ///          <p>This parameter to the API requires a JSON text string argument. For information on how to
    ///       format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>. For the
    ///       AWS CLI, you can also use the syntax: <code>--Tags Key="Key1",Value="Value1"
    ///         Key="Key2",Value="Value2"[,…]</code>
    ///          </p>
    public let tags: [SecretsManagerClientTypes.Tag]?

    public init (
        secretId: Swift.String? = nil,
        tags: [SecretsManagerClientTypes.Tag]? = nil
    )
    {
        self.secretId = secretId
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let tags: [SecretsManagerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecretsManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecretsManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(secretId: \(Swift.String(describing: secretId)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylisttype0 in tagKeys {
                try tagKeysContainer.encode(tagkeylisttype0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The identifier for the secret that you want to remove tags from. You can specify either
    ///       the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?
    /// <p>A list of tag key names to remove from the secret. You don't specify the value. Both the
    ///       key and its associated value are removed.</p>
    ///          <p>This parameter to the API requires a JSON text string argument. For information on how to
    ///       format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    public let tagKeys: [Swift.String]?

    public init (
        secretId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.secretId = secretId
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretOutputError>
}

extension UpdateSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSecretInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), secretBinary: \(Swift.String(describing: secretBinary)), secretId: \(Swift.String(describing: secretId)), secretString: \(Swift.String(describing: secretString)))"}
}

extension UpdateSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let secretBinary = secretBinary {
            try encodeContainer.encode(secretBinary.base64EncodedString(), forKey: .secretBinary)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let secretString = secretString {
            try encodeContainer.encode(secretString, forKey: .secretString)
        }
    }
}

public struct UpdateSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretOutputError>
}

public struct UpdateSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretOutputError>
}

public struct UpdateSecretInput: Swift.Equatable {
    /// <p>(Optional) If you want to add a new version to the secret, this parameter specifies a
    ///       unique identifier for the new version that helps ensure idempotency. </p>
    ///          <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    ///       leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    ///       in the request. If you don't use the SDK and instead generate a raw HTTP request to the Secrets Manager
    ///       service endpoint, then you must generate a <code>ClientRequestToken</code> yourself for new
    ///       versions and include that value in the request.</p>
    ///          <p>You typically only need to interact with this value if you implement your own retry logic
    ///       and want to ensure that a given secret is not created twice. We recommend that you generate a
    ///         <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a>
    ///       value to ensure uniqueness within the specified secret. </p>
    ///          <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
    ///       there are failures and retries during the Lambda rotation function's processing.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    ///           of the secret then a new version of the secret is created. </p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and that version's
    ///             <code>SecretString</code> and <code>SecretBinary</code> values are the same as those in
    ///           the request then the request is ignored (the operation is idempotent). </p>
    ///             </li>
    ///             <li>
    ///                <p>If a version with this value already exists and that version's
    ///             <code>SecretString</code> and <code>SecretBinary</code> values are different from the
    ///           request then an error occurs because you cannot modify an existing secret value.</p>
    ///             </li>
    ///          </ul>
    ///          <p>This value becomes the <code>VersionId</code> of the new version.</p>
    public var clientRequestToken: Swift.String?
    /// <p>(Optional) Specifies an updated user-provided description of the secret.</p>
    public let description: Swift.String?
    /// <p>(Optional) Specifies an updated ARN or alias of the AWS KMS customer master key (CMK) to be
    ///       used to encrypt the protected text in new versions of this secret.</p>
    ///          <important>
    ///             <p>You can only use the account's default CMK to encrypt and decrypt if you call this
    ///         operation using credentials from the same account that owns the secret. If the secret is in
    ///         a different account, then you must create a custom CMK and provide the ARN of that CMK in
    ///         this field. The user making the call must have permissions to both the secret and the CMK in
    ///         their respective accounts.</p>
    ///          </important>
    public let kmsKeyId: Swift.String?
    /// <p>(Optional) Specifies updated binary data that you want to encrypt and store in the new
    ///       version of the secret. To use this parameter in the command-line tools, we recommend that you
    ///       store your binary data in a file and then use the appropriate technique for your tool to pass
    ///       the contents of the file as a parameter. Either <code>SecretBinary</code> or
    ///         <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
    ///          <p>This parameter is not accessible using the Secrets Manager console.</p>
    public let secretBinary: ClientRuntime.Data?
    /// <p>Specifies the secret that you want to modify or to which you want to add a new version.
    ///       You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    ///       secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?
    /// <p>(Optional) Specifies updated text data that you want to encrypt and store in this new
    ///       version of the secret. Either <code>SecretBinary</code> or <code>SecretString</code> must have
    ///       a value, but not both. They cannot both be empty.</p>
    ///          <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
    ///       protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
    ///       stores the information as a JSON structure of key/value pairs that the default Lambda rotation
    ///       function knows how to parse.</p>
    ///          <p>For storing multiple values, we recommend that you use a JSON text string argument and
    ///       specify key/value pairs. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    ///          <p>
    ///             <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
    ///          </p>
    ///          <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text. You can
    ///       also 'escape' the double quote character in the embedded JSON text by prefacing each with a
    ///       backslash. For example, the following string is surrounded by double-quotes. All of the
    ///       embedded double quotes are escaped:</p>
    ///          <p>
    ///             <code>"[{\"username\":\"bob\"},{\"password\":\"abc123xyz456\"}]"</code>
    ///          </p>
    public let secretString: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        secretBinary: ClientRuntime.Data? = nil,
        secretId: Swift.String? = nil,
        secretString: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.secretBinary = secretBinary
        self.secretId = secretId
        self.secretString = secretString
    }
}

struct UpdateSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let description: Swift.String?
    public let kmsKeyId: Swift.String?
    public let secretBinary: ClientRuntime.Data?
    public let secretString: Swift.String?
}

extension UpdateSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretString)
        secretString = secretStringDecoded
    }
}

extension UpdateSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionFailure" : self = .encryptionFailure(try EncryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSecretOutputError: Swift.Error, Swift.Equatable {
    case encryptionFailure(EncryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), versionId: \(Swift.String(describing: versionId)))"}
}

extension UpdateSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
        }
    }
}

public struct UpdateSecretOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret that was updated.</p>
    ///          <note>
    ///             <p>Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    ///         you initially create a secret. This affects only the ARN and not the actual friendly name.
    ///         This ensures that if you create a new secret with the same name as an old secret that you
    ///         previously deleted, then users with access to the old secret <i>don't</i>
    ///         automatically get access to the new secret because the ARNs are different.</p>
    ///          </note>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret that was updated.</p>
    public let name: Swift.String?
    /// <p>If a new version of the secret was created by this operation, then <code>VersionId</code>
    ///       contains the unique identifier of the new version.</p>
    public let versionId: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
    }
}

struct UpdateSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
}

extension UpdateSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

public struct UpdateSecretVersionStageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretVersionStageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretVersionStageOutputError>
}

extension UpdateSecretVersionStageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSecretVersionStageInput(moveToVersionId: \(Swift.String(describing: moveToVersionId)), removeFromVersionId: \(Swift.String(describing: removeFromVersionId)), secretId: \(Swift.String(describing: secretId)), versionStage: \(Swift.String(describing: versionStage)))"}
}

extension UpdateSecretVersionStageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moveToVersionId = "MoveToVersionId"
        case removeFromVersionId = "RemoveFromVersionId"
        case secretId = "SecretId"
        case versionStage = "VersionStage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let moveToVersionId = moveToVersionId {
            try encodeContainer.encode(moveToVersionId, forKey: .moveToVersionId)
        }
        if let removeFromVersionId = removeFromVersionId {
            try encodeContainer.encode(removeFromVersionId, forKey: .removeFromVersionId)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let versionStage = versionStage {
            try encodeContainer.encode(versionStage, forKey: .versionStage)
        }
    }
}

public struct UpdateSecretVersionStageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretVersionStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretVersionStageOutputError>
}

public struct UpdateSecretVersionStageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretVersionStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretVersionStageOutputError>
}

public struct UpdateSecretVersionStageInput: Swift.Equatable {
    /// <p>(Optional) The secret version ID that you want to add the staging label. If you want to
    ///       remove a label from a version, then do not specify this parameter.</p>
    ///          <p>If the staging label is already attached to a different version of the secret, then you
    ///       must also specify the <code>RemoveFromVersionId</code> parameter. </p>
    public let moveToVersionId: Swift.String?
    /// <p>Specifies the secret version ID of the version that the staging label is to be removed
    ///       from. If the staging label you are trying to attach to one version is already attached to a
    ///       different version, then you must include this parameter and specify the version that the label
    ///       is to be removed from. If the label is attached and you either do not specify this parameter,
    ///       or the version ID does not match, then the operation fails.</p>
    public let removeFromVersionId: Swift.String?
    /// <p>Specifies the secret with the version with the list of staging labels you want to modify.
    ///       You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    ///       secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?
    /// <p>The staging label to add to this version.</p>
    public let versionStage: Swift.String?

    public init (
        moveToVersionId: Swift.String? = nil,
        removeFromVersionId: Swift.String? = nil,
        secretId: Swift.String? = nil,
        versionStage: Swift.String? = nil
    )
    {
        self.moveToVersionId = moveToVersionId
        self.removeFromVersionId = removeFromVersionId
        self.secretId = secretId
        self.versionStage = versionStage
    }
}

struct UpdateSecretVersionStageInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let versionStage: Swift.String?
    public let removeFromVersionId: Swift.String?
    public let moveToVersionId: Swift.String?
}

extension UpdateSecretVersionStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moveToVersionId = "MoveToVersionId"
        case removeFromVersionId = "RemoveFromVersionId"
        case secretId = "SecretId"
        case versionStage = "VersionStage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let versionStageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionStage)
        versionStage = versionStageDecoded
        let removeFromVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .removeFromVersionId)
        removeFromVersionId = removeFromVersionIdDecoded
        let moveToVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .moveToVersionId)
        moveToVersionId = moveToVersionIdDecoded
    }
}

extension UpdateSecretVersionStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecretVersionStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSecretVersionStageOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecretVersionStageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSecretVersionStageOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension UpdateSecretVersionStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSecretVersionStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct UpdateSecretVersionStageOutputResponse: Swift.Equatable {
    /// <p>The ARN of the secret with the modified staging label.</p>
    public let aRN: Swift.String?
    /// <p>The friendly name of the secret with the modified staging label.</p>
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct UpdateSecretVersionStageOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
}

extension UpdateSecretVersionStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct ValidateResourcePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidateResourcePolicyOutputError>
}

extension ValidateResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateResourcePolicyInput(resourcePolicy: \(Swift.String(describing: resourcePolicy)), secretId: \(Swift.String(describing: secretId)))"}
}

extension ValidateResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourcePolicy = resourcePolicy {
            try encodeContainer.encode(resourcePolicy, forKey: .resourcePolicy)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct ValidateResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidateResourcePolicyOutputError>
}

public struct ValidateResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidateResourcePolicyOutputError>
}

public struct ValidateResourcePolicyInput: Swift.Equatable {
    /// <p>A JSON-formatted string constructed according to the grammar and syntax for an AWS
    ///       resource-based policy. The policy in the string identifies who can access or manage this
    ///       secret and its versions. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
    ///         JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.publi</p>
    public let resourcePolicy: Swift.String?
    /// <p> (Optional) The identifier of the secret with the resource-based policy you want to
    ///       validate. You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    ///       secret.</p>
    ///          <note>
    ///             <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.</p>
    ///             <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    ///         </note>
    public let secretId: Swift.String?

    public init (
        resourcePolicy: Swift.String? = nil,
        secretId: Swift.String? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
        self.secretId = secretId
    }
}

struct ValidateResourcePolicyInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let resourcePolicy: Swift.String?
}

extension ValidateResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

extension ValidateResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidateResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateResourcePolicyOutputResponse(policyValidationPassed: \(Swift.String(describing: policyValidationPassed)), validationErrors: \(Swift.String(describing: validationErrors)))"}
}

extension ValidateResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidateResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyValidationPassed = output.policyValidationPassed
            self.validationErrors = output.validationErrors
        } else {
            self.policyValidationPassed = false
            self.validationErrors = nil
        }
    }
}

public struct ValidateResourcePolicyOutputResponse: Swift.Equatable {
    /// <p>Returns a message stating that your Reource Policy passed validation. </p>
    public let policyValidationPassed: Swift.Bool
    /// <p>Returns an error message if your policy doesn't pass validatation.</p>
    public let validationErrors: [SecretsManagerClientTypes.ValidationErrorsEntry]?

    public init (
        policyValidationPassed: Swift.Bool = false,
        validationErrors: [SecretsManagerClientTypes.ValidationErrorsEntry]? = nil
    )
    {
        self.policyValidationPassed = policyValidationPassed
        self.validationErrors = validationErrors
    }
}

struct ValidateResourcePolicyOutputResponseBody: Swift.Equatable {
    public let policyValidationPassed: Swift.Bool
    public let validationErrors: [SecretsManagerClientTypes.ValidationErrorsEntry]?
}

extension ValidateResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyValidationPassed = "PolicyValidationPassed"
        case validationErrors = "ValidationErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyValidationPassedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .policyValidationPassed)
        policyValidationPassed = policyValidationPassedDecoded
        let validationErrorsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ValidationErrorsEntry?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[SecretsManagerClientTypes.ValidationErrorsEntry]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [SecretsManagerClientTypes.ValidationErrorsEntry]()
            for structure0 in validationErrorsContainer {
                if let structure0 = structure0 {
                    validationErrorsDecoded0?.append(structure0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
    }
}

extension SecretsManagerClientTypes.ValidationErrorsEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName = "CheckName"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension SecretsManagerClientTypes.ValidationErrorsEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationErrorsEntry(checkName: \(Swift.String(describing: checkName)), errorMessage: \(Swift.String(describing: errorMessage)))"}
}

extension SecretsManagerClientTypes {
    /// <p>Displays errors that occurred during validation of the resource policy.</p>
    public struct ValidationErrorsEntry: Swift.Equatable {
        /// <p>Checks the name of the policy.</p>
        public let checkName: Swift.String?
        /// <p>Displays error messages if validation encounters problems during validation of the resource policy.</p>
        public let errorMessage: Swift.String?

        public init (
            checkName: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.checkName = checkName
            self.errorMessage = errorMessage
        }
    }

}
