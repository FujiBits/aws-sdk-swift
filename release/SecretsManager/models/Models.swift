// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct CancelRotateSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelRotateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelRotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelRotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelRotateSecretOutputError>
}

extension CancelRotateSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelRotateSecretInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension CancelRotateSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct CancelRotateSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelRotateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelRotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelRotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelRotateSecretOutputError>
}

public struct CancelRotateSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelRotateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelRotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelRotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelRotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelRotateSecretOutputError>
}

public struct CancelRotateSecretInput: Swift.Equatable {
    /// Specifies the secret to cancel a rotation request. You can specify either the Amazon
    ///       Resource Name (ARN) or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct CancelRotateSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension CancelRotateSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension CancelRotateSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelRotateSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelRotateSecretOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelRotateSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelRotateSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), versionId: \(Swift.String(describing: versionId)))"}
}

extension CancelRotateSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelRotateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
        }
    }
}

public struct CancelRotateSecretOutputResponse: Swift.Equatable {
    /// The ARN of the secret for which rotation was canceled.
    public let aRN: Swift.String?
    /// The friendly name of the secret for which rotation was canceled.
    public let name: Swift.String?
    /// The unique identifier of the version of the secret created during the rotation. This
    ///       version might not be complete, and should be evaluated for possible deletion. At the very
    ///       least, you should remove the VersionStage value AWSPENDING to enable this
    ///       version to be deleted. Failing to clean up a cancelled rotation can block you from
    ///       successfully starting future rotations.
    public let versionId: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
    }
}

struct CancelRotateSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
}

extension CancelRotateSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

public struct CreateSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSecretOutputError>
}

extension CreateSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSecretInput(addReplicaRegions: \(Swift.String(describing: addReplicaRegions)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), forceOverwriteReplicaSecret: \(Swift.String(describing: forceOverwriteReplicaSecret)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), name: \(Swift.String(describing: name)), secretBinary: \(Swift.String(describing: secretBinary)), secretString: \(Swift.String(describing: secretString)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case secretBinary = "SecretBinary"
        case secretString = "SecretString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addReplicaRegions = addReplicaRegions {
            var addReplicaRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addReplicaRegions)
            for addreplicaregionlisttype0 in addReplicaRegions {
                try addReplicaRegionsContainer.encode(addreplicaregionlisttype0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if forceOverwriteReplicaSecret != false {
            try encodeContainer.encode(forceOverwriteReplicaSecret, forKey: .forceOverwriteReplicaSecret)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let secretBinary = secretBinary {
            try encodeContainer.encode(secretBinary.base64EncodedString(), forKey: .secretBinary)
        }
        if let secretString = secretString {
            try encodeContainer.encode(secretString, forKey: .secretString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglisttype0 in tags {
                try tagsContainer.encode(taglisttype0)
            }
        }
    }
}

public struct CreateSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSecretOutputError>
}

public struct CreateSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSecretOutputError>
}

public struct CreateSecretInput: Swift.Equatable {
    /// (Optional) Add a list of regions to replicate secrets. Secrets Manager replicates the KMSKeyID objects to the list of regions specified in
    ///       the parameter.
    public let addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]?
    /// (Optional) If you include SecretString or SecretBinary, then an
    ///       initial version is created as part of the secret, and this parameter specifies a unique
    ///       identifier for the new version.
    ///
    ///             If you use the Amazon Web Services CLI or one of the Amazon Web Services SDK to call this operation, then you can
    ///         leave this parameter empty. The CLI or SDK generates a random UUID for you and includes it
    ///         as the value for this parameter in the request. If you don't use the SDK and instead
    ///         generate a raw HTTP request to the Secrets Manager service endpoint, then you must generate a
    ///           ClientRequestToken yourself for the new version and include the value in the
    ///         request.
    ///
    ///          This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
    ///       creation of duplicate versions if there are failures and retries during a rotation. We
    ///       recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type value to
    ///       ensure uniqueness of your versions within the specified secret.
    ///
    ///
    ///                If the ClientRequestToken value isn't already associated with a version
    ///           of the secret then a new version of the secret is created.
    ///
    ///
    ///                If a version with this value already exists and the version SecretString
    ///           and SecretBinary values are the same as those in the request, then the
    ///           request is ignored.
    ///
    ///
    ///                If a version with this value already exists and that version's
    ///             SecretString and SecretBinary values are different from those
    ///           in the request, then the request fails because you cannot modify an existing version.
    ///           Instead, use PutSecretValue to create a new version.
    ///
    ///
    ///          This value becomes the VersionId of the new version.
    public var clientRequestToken: Swift.String?
    /// (Optional) Specifies a user-provided description of the secret.
    public let description: Swift.String?
    /// (Optional) If set, the replication overwrites a secret with the same name in the
    ///       destination region.
    public let forceOverwriteReplicaSecret: Swift.Bool
    /// (Optional) Specifies the ARN, Key ID, or alias of the Amazon Web Services KMS customer master key (CMK) to
    ///       be used to encrypt the SecretString or SecretBinary values in the
    ///       versions stored in this secret.
    ///          You can specify any of the supported ways to identify a Amazon Web Services KMS key ID. If you need to
    ///       reference a CMK in a different account, you can use only the key ARN or the alias ARN.
    ///          If you don't specify this value, then Secrets Manager defaults to using the Amazon Web Services account's
    ///       default CMK (the one named aws/secretsmanager). If a Amazon Web Services KMS CMK with that name doesn't yet
    ///       exist, then Secrets Manager creates it for you automatically the first time it needs to encrypt a
    ///       version's SecretString or SecretBinary fields.
    ///
    ///             You can use the account default CMK to encrypt and decrypt only if you call this
    ///         operation using credentials from the same account that owns the secret. If the secret
    ///         resides in a different account, then you must create a custom CMK and specify the ARN in
    ///         this field.
    ///
    public let kmsKeyId: Swift.String?
    /// Specifies the friendly name of the new secret.
    ///          The secret name must be ASCII letters, digits, or the following characters :
    ///       /_+=.@-
    ///
    ///             Do not end your secret name with a hyphen followed by six characters. If you do so, you
    ///         risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager
    ///         automatically adds a hyphen and six random characters at the end of the ARN.
    ///
    /// This member is required.
    public let name: Swift.String?
    /// (Optional) Specifies binary data that you want to encrypt and store in the new version of
    ///       the secret. To use this parameter in the command-line tools, we recommend that you store your
    ///       binary data in a file and then use the appropriate technique for your tool to pass the
    ///       contents of the file as a parameter.
    ///          Either SecretString or SecretBinary must have a value, but not
    ///       both. They cannot both be empty.
    ///          This parameter is not available using the Secrets Manager console. It can be accessed only by
    ///       using the Amazon Web Services CLI or one of the Amazon Web Services SDKs.
    public let secretBinary: ClientRuntime.Data?
    /// (Optional) Specifies text data that you want to encrypt and store in this new version of
    ///       the secret.
    ///          Either SecretString or SecretBinary must have a value, but not
    ///       both. They cannot both be empty.
    ///          If you create a secret by using the Secrets Manager console then Secrets Manager puts the protected
    ///       secret text in only the SecretString parameter. The Secrets Manager console stores the
    ///       information as a JSON structure of key/value pairs that the Lambda rotation function knows how
    ///       to parse.
    ///          For storing multiple values, we recommend that you use a JSON text string argument and
    ///       specify key/value pairs. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters in the CLI User Guide. For example:
    ///
    ///             {"username":"bob","password":"abc123xyz456"}
    ///
    ///          If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text.
    public let secretString: Swift.String?
    /// (Optional) Specifies a list of user-defined tags that are attached to the secret. Each tag
    ///       is a "Key" and "Value" pair of strings. This operation only appends tags to the existing list
    ///       of tags. To remove tags, you must use UntagResource.
    ///
    ///
    ///
    ///                   Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag
    ///             from one with key "abc".
    ///
    ///
    ///                   If you check tags in IAM policy Condition elements as part of your
    ///             security strategy, then adding or removing a tag can change permissions. If the
    ///             successful completion of this operation would result in you losing your permissions for
    ///             this secret, then this operation is blocked and returns an Access Denied
    ///             error.
    ///
    ///
    ///
    ///          This parameter requires a JSON text string argument. For information on how to format a
    ///       JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters in the CLI User Guide. For example:
    ///
    ///             [{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]
    ///
    ///          If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text.
    ///             The following basic restrictions apply to tags:
    ///
    ///
    ///                Maximum number of tags per secret—50
    ///
    ///
    ///                Maximum key length—127 Unicode characters in UTF-8
    ///
    ///
    ///                Maximum value length—255 Unicode characters in UTF-8
    ///
    ///
    ///                Tag keys and values are case sensitive.
    ///
    ///
    ///                Do not use the aws: prefix in your tag names or values because Amazon Web Services reserves it
    ///             for Amazon Web Services use. You can't edit or delete tag names or values with this
    ///               prefix. Tags with this prefix do not count against your tags per secret limit.
    ///
    ///
    ///                If you use your tagging schema across multiple services and resources,
    ///               remember other services might have restrictions on allowed characters. Generally
    ///               allowed characters: letters, spaces, and numbers representable in UTF-8, plus the
    ///               following special characters: + - = . _ : / @.
    ///
    ///
    public let tags: [SecretsManagerClientTypes.Tag]?

    public init (
        addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]? = nil,
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        forceOverwriteReplicaSecret: Swift.Bool = false,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        secretBinary: ClientRuntime.Data? = nil,
        secretString: Swift.String? = nil,
        tags: [SecretsManagerClientTypes.Tag]? = nil
    )
    {
        self.addReplicaRegions = addReplicaRegions
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.forceOverwriteReplicaSecret = forceOverwriteReplicaSecret
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.secretBinary = secretBinary
        self.secretString = secretString
        self.tags = tags
    }
}

struct CreateSecretInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let clientRequestToken: Swift.String?
    public let description: Swift.String?
    public let kmsKeyId: Swift.String?
    public let secretBinary: ClientRuntime.Data?
    public let secretString: Swift.String?
    public let tags: [SecretsManagerClientTypes.Tag]?
    public let addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]?
    public let forceOverwriteReplicaSecret: Swift.Bool
}

extension CreateSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case secretBinary = "SecretBinary"
        case secretString = "SecretString"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretString)
        secretString = secretStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecretsManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecretsManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let addReplicaRegionsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicaRegionType?].self, forKey: .addReplicaRegions)
        var addReplicaRegionsDecoded0:[SecretsManagerClientTypes.ReplicaRegionType]? = nil
        if let addReplicaRegionsContainer = addReplicaRegionsContainer {
            addReplicaRegionsDecoded0 = [SecretsManagerClientTypes.ReplicaRegionType]()
            for structure0 in addReplicaRegionsContainer {
                if let structure0 = structure0 {
                    addReplicaRegionsDecoded0?.append(structure0)
                }
            }
        }
        addReplicaRegions = addReplicaRegionsDecoded0
        let forceOverwriteReplicaSecretDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceOverwriteReplicaSecret)
        forceOverwriteReplicaSecret = forceOverwriteReplicaSecretDecoded
    }
}

extension CreateSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionFailure" : self = .encryptionFailure(try EncryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSecretOutputError: Swift.Error, Swift.Equatable {
    case encryptionFailure(EncryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), replicationStatus: \(Swift.String(describing: replicationStatus)), versionId: \(Swift.String(describing: versionId)))"}
}

extension CreateSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.replicationStatus = output.replicationStatus
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.replicationStatus = nil
            self.versionId = nil
        }
    }
}

public struct CreateSecretOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the secret that you just created.
    ///
    ///             Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    ///         you initially create a secret. This affects only the ARN and not the actual friendly name.
    ///         This ensures that if you create a new secret with the same name as an old secret that you
    ///         previously deleted, then users with access to the old secret don't
    ///         automatically get access to the new secret because the ARNs are different.
    ///
    public let aRN: Swift.String?
    /// The friendly name of the secret that you just created.
    public let name: Swift.String?
    /// Describes a list of replication status objects as InProgress, Failed or InSync.
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
    /// The unique identifier associated with the version of the secret you just created.
    public let versionId: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.replicationStatus = replicationStatus
        self.versionId = versionId
    }
}

struct CreateSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
}

extension CreateSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case replicationStatus = "ReplicationStatus"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[SecretsManagerClientTypes.ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [SecretsManagerClientTypes.ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension DecryptionFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecryptionFailure(message: \(Swift.String(describing: message)))"}
}

extension DecryptionFailure {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DecryptionFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Secrets Manager can't decrypt the protected secret text using the provided KMS key.
public struct DecryptionFailure: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DecryptionFailureBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DecryptionFailureBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteResourcePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourcePolicyOutputError>
}

extension DeleteResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourcePolicyInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension DeleteResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct DeleteResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// Specifies the secret that you want to delete the attached resource-based policy for. You
    ///       can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourcePolicyOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {
    /// The ARN of the secret that the resource-based policy was deleted for.
    public let aRN: Swift.String?
    /// The friendly name of the secret that the resource-based policy was deleted for.
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct DeleteResourcePolicyOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
}

extension DeleteResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct DeleteSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSecretOutputError>
}

extension DeleteSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSecretInput(forceDeleteWithoutRecovery: \(Swift.String(describing: forceDeleteWithoutRecovery)), recoveryWindowInDays: \(Swift.String(describing: recoveryWindowInDays)), secretId: \(Swift.String(describing: secretId)))"}
}

extension DeleteSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceDeleteWithoutRecovery = "ForceDeleteWithoutRecovery"
        case recoveryWindowInDays = "RecoveryWindowInDays"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if forceDeleteWithoutRecovery != false {
            try encodeContainer.encode(forceDeleteWithoutRecovery, forKey: .forceDeleteWithoutRecovery)
        }
        if recoveryWindowInDays != 0 {
            try encodeContainer.encode(recoveryWindowInDays, forKey: .recoveryWindowInDays)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct DeleteSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSecretOutputError>
}

public struct DeleteSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSecretOutputError>
}

public struct DeleteSecretInput: Swift.Equatable {
    /// (Optional) Specifies that the secret is to be deleted without any recovery window. You
    ///       can't use both this parameter and the RecoveryWindowInDays parameter in the same
    ///       API call.
    ///          An asynchronous background process performs the actual deletion, so there can be a short
    ///       delay before the operation completes. If you write code to delete and then immediately
    ///       recreate a secret with the same name, ensure that your code includes appropriate back off and
    ///       retry logic.
    ///
    ///             Use this parameter with caution. This parameter causes the operation to skip the normal
    ///         waiting period before the permanent deletion that Amazon Web Services would normally impose with the
    ///           RecoveryWindowInDays parameter. If you delete a secret with the
    ///           ForceDeleteWithouRecovery parameter, then you have no opportunity to recover
    ///         the secret. You lose the secret permanently.
    ///
    ///
    ///             If you use this parameter and include a previously deleted or nonexistent secret, the
    ///         operation does not return the error ResourceNotFoundException in order to
    ///         correctly handle retries.
    ///
    public let forceDeleteWithoutRecovery: Swift.Bool
    /// (Optional) Specifies the number of days that Secrets Manager waits before Secrets Manager can delete the
    ///       secret. You can't use both this parameter and the ForceDeleteWithoutRecovery
    ///       parameter in the same API call.
    ///          This value can range from 7 to 30 days with a default value of 30.
    public let recoveryWindowInDays: Swift.Int
    /// Specifies the secret to delete. You can specify either the Amazon Resource Name (ARN) or
    ///       the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        forceDeleteWithoutRecovery: Swift.Bool = false,
        recoveryWindowInDays: Swift.Int = 0,
        secretId: Swift.String? = nil
    )
    {
        self.forceDeleteWithoutRecovery = forceDeleteWithoutRecovery
        self.recoveryWindowInDays = recoveryWindowInDays
        self.secretId = secretId
    }
}

struct DeleteSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let recoveryWindowInDays: Swift.Int
    public let forceDeleteWithoutRecovery: Swift.Bool
}

extension DeleteSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceDeleteWithoutRecovery = "ForceDeleteWithoutRecovery"
        case recoveryWindowInDays = "RecoveryWindowInDays"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let recoveryWindowInDaysDecoded = try containerValues.decode(Swift.Int.self, forKey: .recoveryWindowInDays)
        recoveryWindowInDays = recoveryWindowInDaysDecoded
        let forceDeleteWithoutRecoveryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceDeleteWithoutRecovery)
        forceDeleteWithoutRecovery = forceDeleteWithoutRecoveryDecoded
    }
}

extension DeleteSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSecretOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), deletionDate: \(Swift.String(describing: deletionDate)), name: \(Swift.String(describing: name)))"}
}

extension DeleteSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.deletionDate = output.deletionDate
            self.name = output.name
        } else {
            self.aRN = nil
            self.deletionDate = nil
            self.name = nil
        }
    }
}

public struct DeleteSecretOutputResponse: Swift.Equatable {
    /// The ARN of the secret that is now scheduled for deletion.
    public let aRN: Swift.String?
    /// The date and time after which this secret can be deleted by Secrets Manager and can no longer be
    ///       restored. This value is the date and time of the delete request plus the number of days
    ///       specified in RecoveryWindowInDays.
    public let deletionDate: ClientRuntime.Date?
    /// The friendly name of the secret currently scheduled for deletion.
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        deletionDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.deletionDate = deletionDate
        self.name = name
    }
}

struct DeleteSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let deletionDate: ClientRuntime.Date?
}

extension DeleteSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case deletionDate = "DeletionDate"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
    }
}

public struct DescribeSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSecretOutputError>
}

extension DescribeSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSecretInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension DescribeSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct DescribeSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSecretOutputError>
}

public struct DescribeSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSecretOutputError>
}

public struct DescribeSecretInput: Swift.Equatable {
    /// The identifier of the secret whose details you want to retrieve. You can specify either
    ///       the Amazon Resource Name (ARN) or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct DescribeSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension DescribeSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension DescribeSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSecretOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), createdDate: \(Swift.String(describing: createdDate)), deletedDate: \(Swift.String(describing: deletedDate)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastAccessedDate: \(Swift.String(describing: lastAccessedDate)), lastChangedDate: \(Swift.String(describing: lastChangedDate)), lastRotatedDate: \(Swift.String(describing: lastRotatedDate)), name: \(Swift.String(describing: name)), owningService: \(Swift.String(describing: owningService)), primaryRegion: \(Swift.String(describing: primaryRegion)), replicationStatus: \(Swift.String(describing: replicationStatus)), rotationEnabled: \(Swift.String(describing: rotationEnabled)), rotationLambdaARN: \(Swift.String(describing: rotationLambdaARN)), rotationRules: \(Swift.String(describing: rotationRules)), tags: \(Swift.String(describing: tags)), versionIdsToStages: \(Swift.String(describing: versionIdsToStages)))"}
}

extension DescribeSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.createdDate = output.createdDate
            self.deletedDate = output.deletedDate
            self.description = output.description
            self.kmsKeyId = output.kmsKeyId
            self.lastAccessedDate = output.lastAccessedDate
            self.lastChangedDate = output.lastChangedDate
            self.lastRotatedDate = output.lastRotatedDate
            self.name = output.name
            self.owningService = output.owningService
            self.primaryRegion = output.primaryRegion
            self.replicationStatus = output.replicationStatus
            self.rotationEnabled = output.rotationEnabled
            self.rotationLambdaARN = output.rotationLambdaARN
            self.rotationRules = output.rotationRules
            self.tags = output.tags
            self.versionIdsToStages = output.versionIdsToStages
        } else {
            self.aRN = nil
            self.createdDate = nil
            self.deletedDate = nil
            self.description = nil
            self.kmsKeyId = nil
            self.lastAccessedDate = nil
            self.lastChangedDate = nil
            self.lastRotatedDate = nil
            self.name = nil
            self.owningService = nil
            self.primaryRegion = nil
            self.replicationStatus = nil
            self.rotationEnabled = false
            self.rotationLambdaARN = nil
            self.rotationRules = nil
            self.tags = nil
            self.versionIdsToStages = nil
        }
    }
}

public struct DescribeSecretOutputResponse: Swift.Equatable {
    /// The ARN of the secret.
    public let aRN: Swift.String?
    /// The date you created the secret.
    public let createdDate: ClientRuntime.Date?
    /// This value exists if the secret is scheduled for deletion. Some time after the specified
    ///       date and time, Secrets Manager deletes the secret and all of its versions.
    ///          If a secret is scheduled for deletion, then its details, including the encrypted secret
    ///       information, is not accessible. To cancel a scheduled deletion and restore access, use RestoreSecret.
    public let deletedDate: ClientRuntime.Date?
    /// The user-provided description of the secret.
    public let description: Swift.String?
    /// The ARN or alias of the Amazon Web Services KMS customer master key (CMK) that's used to encrypt the
    ///         SecretString or SecretBinary fields in each version of the secret.
    ///       If you don't provide a key, then Secrets Manager defaults to encrypting the secret fields with the
    ///       default Amazon Web Services KMS CMK (the one named awssecretsmanager) for this account.
    public let kmsKeyId: Swift.String?
    /// The last date that this secret was accessed. This value is truncated to midnight of the
    ///       date and therefore shows only the date, not the time.
    public let lastAccessedDate: ClientRuntime.Date?
    /// The last date and time that this secret was modified in any way.
    public let lastChangedDate: ClientRuntime.Date?
    /// The last date and time that the rotation process for this secret was invoked.
    ///          The most recent date and time that the Secrets Manager rotation process successfully
    ///       completed. If the secret doesn't rotate, Secrets Manager returns a null value.
    public let lastRotatedDate: ClientRuntime.Date?
    /// The user-provided friendly name of the secret.
    public let name: Swift.String?
    /// Returns the name of the service that created this secret.
    public let owningService: Swift.String?
    /// Specifies the primary region for secret replication.
    public let primaryRegion: Swift.String?
    /// Describes a list of replication status objects as InProgress, Failed or InSync.P
    ///
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
    /// Specifies whether automatic rotation is enabled for this secret.
    ///          To enable rotation, use RotateSecret with
    ///         AutomaticallyRotateAfterDays set to a value greater than 0. To disable
    ///       rotation, use CancelRotateSecret.
    public let rotationEnabled: Swift.Bool
    /// The ARN of a Lambda function that's invoked by Secrets Manager to rotate the
    ///       secret either automatically per the schedule or manually by a call to
    ///         RotateSecret.
    public let rotationLambdaARN: Swift.String?
    /// A structure with the rotation configuration for this secret.
    public let rotationRules: SecretsManagerClientTypes.RotationRulesType?
    /// The list of user-defined tags that are associated with the secret. To add tags to a
    ///       secret, use TagResource. To remove tags, use UntagResource.
    public let tags: [SecretsManagerClientTypes.Tag]?
    /// A list of all of the currently assigned VersionStage staging labels and the
    ///         VersionId that each is attached to. Staging labels are used to keep track of
    ///       the different versions during the rotation process.
    ///
    ///             A version that does not have any staging labels attached is considered deprecated and
    ///         subject to deletion. Such versions are not included in this list.
    ///
    public let versionIdsToStages: [Swift.String:[Swift.String]]?

    public init (
        aRN: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deletedDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lastAccessedDate: ClientRuntime.Date? = nil,
        lastChangedDate: ClientRuntime.Date? = nil,
        lastRotatedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        owningService: Swift.String? = nil,
        primaryRegion: Swift.String? = nil,
        replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]? = nil,
        rotationEnabled: Swift.Bool = false,
        rotationLambdaARN: Swift.String? = nil,
        rotationRules: SecretsManagerClientTypes.RotationRulesType? = nil,
        tags: [SecretsManagerClientTypes.Tag]? = nil,
        versionIdsToStages: [Swift.String:[Swift.String]]? = nil
    )
    {
        self.aRN = aRN
        self.createdDate = createdDate
        self.deletedDate = deletedDate
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.lastAccessedDate = lastAccessedDate
        self.lastChangedDate = lastChangedDate
        self.lastRotatedDate = lastRotatedDate
        self.name = name
        self.owningService = owningService
        self.primaryRegion = primaryRegion
        self.replicationStatus = replicationStatus
        self.rotationEnabled = rotationEnabled
        self.rotationLambdaARN = rotationLambdaARN
        self.rotationRules = rotationRules
        self.tags = tags
        self.versionIdsToStages = versionIdsToStages
    }
}

struct DescribeSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let kmsKeyId: Swift.String?
    public let rotationEnabled: Swift.Bool
    public let rotationLambdaARN: Swift.String?
    public let rotationRules: SecretsManagerClientTypes.RotationRulesType?
    public let lastRotatedDate: ClientRuntime.Date?
    public let lastChangedDate: ClientRuntime.Date?
    public let lastAccessedDate: ClientRuntime.Date?
    public let deletedDate: ClientRuntime.Date?
    public let tags: [SecretsManagerClientTypes.Tag]?
    public let versionIdsToStages: [Swift.String:[Swift.String]]?
    public let owningService: Swift.String?
    public let createdDate: ClientRuntime.Date?
    public let primaryRegion: Swift.String?
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
}

extension DescribeSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case createdDate = "CreatedDate"
        case deletedDate = "DeletedDate"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case lastAccessedDate = "LastAccessedDate"
        case lastChangedDate = "LastChangedDate"
        case lastRotatedDate = "LastRotatedDate"
        case name = "Name"
        case owningService = "OwningService"
        case primaryRegion = "PrimaryRegion"
        case replicationStatus = "ReplicationStatus"
        case rotationEnabled = "RotationEnabled"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case tags = "Tags"
        case versionIdsToStages = "VersionIdsToStages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let rotationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .rotationEnabled)
        rotationEnabled = rotationEnabledDecoded
        let rotationLambdaARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationLambdaARN)
        rotationLambdaARN = rotationLambdaARNDecoded
        let rotationRulesDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.RotationRulesType.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
        let lastRotatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastRotatedDate)
        lastRotatedDate = lastRotatedDateDecoded
        let lastChangedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastChangedDate)
        lastChangedDate = lastChangedDateDecoded
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
        let deletedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletedDate)
        deletedDate = deletedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecretsManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecretsManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionIdsToStagesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .versionIdsToStages)
        var versionIdsToStagesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let versionIdsToStagesContainer = versionIdsToStagesContainer {
            versionIdsToStagesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, secretversionstagestype0) in versionIdsToStagesContainer {
                var secretversionstagestype0Decoded0: [Swift.String]? = nil
                if let secretversionstagestype0 = secretversionstagestype0 {
                    secretversionstagestype0Decoded0 = [Swift.String]()
                    for string1 in secretversionstagestype0 {
                        if let string1 = string1 {
                            secretversionstagestype0Decoded0?.append(string1)
                        }
                    }
                }
                versionIdsToStagesDecoded0?[key0] = secretversionstagestype0Decoded0
            }
        }
        versionIdsToStages = versionIdsToStagesDecoded0
        let owningServiceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningService)
        owningService = owningServiceDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let primaryRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryRegion)
        primaryRegion = primaryRegionDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[SecretsManagerClientTypes.ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [SecretsManagerClientTypes.ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension EncryptionFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionFailure(message: \(Swift.String(describing: message)))"}
}

extension EncryptionFailure {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EncryptionFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Secrets Manager can't encrypt the protected secret text using the provided KMS key. Check that the
///       customer master key (CMK) is available, enabled, and not in an invalid state. For more
///       information, see <a href="http://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
///         Customer Master Key.
public struct EncryptionFailure: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionFailureBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EncryptionFailureBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecretsManagerClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervaluesstringlist0 in values {
                try valuesContainer.encode(filtervaluesstringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.FilterNameStringType.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SecretsManagerClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension SecretsManagerClientTypes {
    /// Allows you to add filters when you use the search function in Secrets Manager.
    public struct Filter: Swift.Equatable {
        /// Filters your list of secrets by a specific key.
        public let key: SecretsManagerClientTypes.FilterNameStringType?
        /// Filters your list of secrets by a specific value.
        ///          You can prefix your search value with an exclamation mark (!) in order to perform negation filters.
        public let values: [Swift.String]?

        public init (
            key: SecretsManagerClientTypes.FilterNameStringType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SecretsManagerClientTypes {
    public enum FilterNameStringType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case description
        case name
        case primaryRegion
        case tagKey
        case tagValue
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterNameStringType] {
            return [
                .all,
                .description,
                .name,
                .primaryRegion,
                .tagKey,
                .tagValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .description: return "description"
            case .name: return "name"
            case .primaryRegion: return "primary-region"
            case .tagKey: return "tag-key"
            case .tagValue: return "tag-value"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterNameStringType(rawValue: rawValue) ?? FilterNameStringType.sdkUnknown(rawValue)
        }
    }
}

public struct GetRandomPasswordInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRandomPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRandomPasswordOutputError>
}

extension GetRandomPasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRandomPasswordInput(excludeCharacters: \(Swift.String(describing: excludeCharacters)), excludeLowercase: \(Swift.String(describing: excludeLowercase)), excludeNumbers: \(Swift.String(describing: excludeNumbers)), excludePunctuation: \(Swift.String(describing: excludePunctuation)), excludeUppercase: \(Swift.String(describing: excludeUppercase)), includeSpace: \(Swift.String(describing: includeSpace)), passwordLength: \(Swift.String(describing: passwordLength)), requireEachIncludedType: \(Swift.String(describing: requireEachIncludedType)))"}
}

extension GetRandomPasswordInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludeCharacters = "ExcludeCharacters"
        case excludeLowercase = "ExcludeLowercase"
        case excludeNumbers = "ExcludeNumbers"
        case excludePunctuation = "ExcludePunctuation"
        case excludeUppercase = "ExcludeUppercase"
        case includeSpace = "IncludeSpace"
        case passwordLength = "PasswordLength"
        case requireEachIncludedType = "RequireEachIncludedType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeCharacters = excludeCharacters {
            try encodeContainer.encode(excludeCharacters, forKey: .excludeCharacters)
        }
        if excludeLowercase != false {
            try encodeContainer.encode(excludeLowercase, forKey: .excludeLowercase)
        }
        if excludeNumbers != false {
            try encodeContainer.encode(excludeNumbers, forKey: .excludeNumbers)
        }
        if excludePunctuation != false {
            try encodeContainer.encode(excludePunctuation, forKey: .excludePunctuation)
        }
        if excludeUppercase != false {
            try encodeContainer.encode(excludeUppercase, forKey: .excludeUppercase)
        }
        if includeSpace != false {
            try encodeContainer.encode(includeSpace, forKey: .includeSpace)
        }
        if passwordLength != 0 {
            try encodeContainer.encode(passwordLength, forKey: .passwordLength)
        }
        if requireEachIncludedType != false {
            try encodeContainer.encode(requireEachIncludedType, forKey: .requireEachIncludedType)
        }
    }
}

public struct GetRandomPasswordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRandomPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRandomPasswordOutputError>
}

public struct GetRandomPasswordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRandomPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRandomPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRandomPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRandomPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRandomPasswordOutputError>
}

public struct GetRandomPasswordInput: Swift.Equatable {
    /// A string that includes characters that should not be included in the generated password.
    ///       The default is that all characters from the included sets can be used.
    public let excludeCharacters: Swift.String?
    /// Specifies that the generated password should not include lowercase letters. The default if
    ///       you do not include this switch parameter is that lowercase letters can be included.
    public let excludeLowercase: Swift.Bool
    /// Specifies that the generated password should not include digits. The default if you do not
    ///       include this switch parameter is that digits can be included.
    public let excludeNumbers: Swift.Bool
    /// Specifies that the generated password should not include punctuation characters. The
    ///       default if you do not include this switch parameter is that punctuation characters can be
    ///       included.
    ///          The following are the punctuation characters that can be included in
    ///       the generated password if you don't explicitly exclude them with
    ///         ExcludeCharacters or ExcludePunctuation:
    ///
    ///             ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | }
    ///       ~
    ///
    public let excludePunctuation: Swift.Bool
    /// Specifies that the generated password should not include uppercase letters. The default if
    ///       you do not include this switch parameter is that uppercase letters can be included.
    public let excludeUppercase: Swift.Bool
    /// Specifies that the generated password can include the space character. The default if you
    ///       do not include this switch parameter is that the space character is not included.
    public let includeSpace: Swift.Bool
    /// The desired length of the generated password. The default value if you do not include this
    ///       parameter is 32 characters.
    public let passwordLength: Swift.Int
    /// A boolean value that specifies whether the generated password must include at least one of
    ///       every allowed character type. The default value is True and the operation
    ///       requires at least one of every character type.
    public let requireEachIncludedType: Swift.Bool

    public init (
        excludeCharacters: Swift.String? = nil,
        excludeLowercase: Swift.Bool = false,
        excludeNumbers: Swift.Bool = false,
        excludePunctuation: Swift.Bool = false,
        excludeUppercase: Swift.Bool = false,
        includeSpace: Swift.Bool = false,
        passwordLength: Swift.Int = 0,
        requireEachIncludedType: Swift.Bool = false
    )
    {
        self.excludeCharacters = excludeCharacters
        self.excludeLowercase = excludeLowercase
        self.excludeNumbers = excludeNumbers
        self.excludePunctuation = excludePunctuation
        self.excludeUppercase = excludeUppercase
        self.includeSpace = includeSpace
        self.passwordLength = passwordLength
        self.requireEachIncludedType = requireEachIncludedType
    }
}

struct GetRandomPasswordInputBody: Swift.Equatable {
    public let passwordLength: Swift.Int
    public let excludeCharacters: Swift.String?
    public let excludeNumbers: Swift.Bool
    public let excludePunctuation: Swift.Bool
    public let excludeUppercase: Swift.Bool
    public let excludeLowercase: Swift.Bool
    public let includeSpace: Swift.Bool
    public let requireEachIncludedType: Swift.Bool
}

extension GetRandomPasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludeCharacters = "ExcludeCharacters"
        case excludeLowercase = "ExcludeLowercase"
        case excludeNumbers = "ExcludeNumbers"
        case excludePunctuation = "ExcludePunctuation"
        case excludeUppercase = "ExcludeUppercase"
        case includeSpace = "IncludeSpace"
        case passwordLength = "PasswordLength"
        case requireEachIncludedType = "RequireEachIncludedType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let passwordLengthDecoded = try containerValues.decode(Swift.Int.self, forKey: .passwordLength)
        passwordLength = passwordLengthDecoded
        let excludeCharactersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .excludeCharacters)
        excludeCharacters = excludeCharactersDecoded
        let excludeNumbersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludeNumbers)
        excludeNumbers = excludeNumbersDecoded
        let excludePunctuationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludePunctuation)
        excludePunctuation = excludePunctuationDecoded
        let excludeUppercaseDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludeUppercase)
        excludeUppercase = excludeUppercaseDecoded
        let excludeLowercaseDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludeLowercase)
        excludeLowercase = excludeLowercaseDecoded
        let includeSpaceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeSpace)
        includeSpace = includeSpaceDecoded
        let requireEachIncludedTypeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requireEachIncludedType)
        requireEachIncludedType = requireEachIncludedTypeDecoded
    }
}

extension GetRandomPasswordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRandomPasswordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRandomPasswordOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRandomPasswordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRandomPasswordOutputResponse(randomPassword: \(Swift.String(describing: randomPassword)))"}
}

extension GetRandomPasswordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRandomPasswordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.randomPassword = output.randomPassword
        } else {
            self.randomPassword = nil
        }
    }
}

public struct GetRandomPasswordOutputResponse: Swift.Equatable {
    /// A string with the generated password.
    public let randomPassword: Swift.String?

    public init (
        randomPassword: Swift.String? = nil
    )
    {
        self.randomPassword = randomPassword
    }
}

struct GetRandomPasswordOutputResponseBody: Swift.Equatable {
    public let randomPassword: Swift.String?
}

extension GetRandomPasswordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case randomPassword = "RandomPassword"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let randomPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomPassword)
        randomPassword = randomPasswordDecoded
    }
}

public struct GetResourcePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePolicyOutputError>
}

extension GetResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePolicyInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension GetResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct GetResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// Specifies the secret that you want to retrieve the attached resource-based policy for. You
    ///       can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension GetResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension GetResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePolicyOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), resourcePolicy: \(Swift.String(describing: resourcePolicy)))"}
}

extension GetResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.resourcePolicy = output.resourcePolicy
        } else {
            self.aRN = nil
            self.name = nil
            self.resourcePolicy = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Swift.Equatable {
    /// The ARN of the secret that the resource-based policy was retrieved for.
    public let aRN: Swift.String?
    /// The friendly name of the secret that the resource-based policy was retrieved for.
    public let name: Swift.String?
    /// A JSON-formatted string that describes the permissions that are associated with the
    ///       attached secret. These permissions are combined with any permissions that are associated with
    ///       the user or role that attempts to access this secret. The combined permissions specify who can
    ///       access the secret and what actions they can perform. For more information, see <a href="http://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html">Authentication and Access Control for
    ///         Amazon Web Services Secrets Manager in the Amazon Web Services Secrets Manager User Guide.
    public let resourcePolicy: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.resourcePolicy = resourcePolicy
    }
}

struct GetResourcePolicyOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let resourcePolicy: Swift.String?
}

extension GetResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case resourcePolicy = "ResourcePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

public struct GetSecretValueInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSecretValueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSecretValueOutputError>
}

extension GetSecretValueInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSecretValueInput(secretId: \(Swift.String(describing: secretId)), versionId: \(Swift.String(describing: versionId)), versionStage: \(Swift.String(describing: versionStage)))"}
}

extension GetSecretValueInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case versionId = "VersionId"
        case versionStage = "VersionStage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
        if let versionStage = versionStage {
            try encodeContainer.encode(versionStage, forKey: .versionStage)
        }
    }
}

public struct GetSecretValueInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSecretValueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSecretValueOutputError>
}

public struct GetSecretValueInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSecretValueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSecretValueOutputError>
}

public struct GetSecretValueInput: Swift.Equatable {
    /// Specifies the secret containing the version that you want to retrieve. You can specify
    ///       either the Amazon Resource Name (ARN) or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?
    /// Specifies the unique identifier of the version of the secret that you want to retrieve. If
    ///       you specify both this parameter and VersionStage,  the two parameters must refer
    ///       to the same secret version. If you don't specify either a VersionStage or
    ///         VersionId then the default is to perform the operation on the version with the
    ///         VersionStage value of AWSCURRENT.
    ///          This value is typically a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type value with
    ///       32 hexadecimal digits.
    public let versionId: Swift.String?
    /// Specifies the secret version that you want to retrieve by the staging label attached to
    ///       the version.
    ///          Staging labels are used to keep track of different versions during the rotation process.
    ///       If you specify both this parameter and VersionId,  the two parameters must refer
    ///       to the same secret version . If you don't specify either a VersionStage or
    ///         VersionId, then the default is to perform the operation on the version with the
    ///         VersionStage value of AWSCURRENT.
    public let versionStage: Swift.String?

    public init (
        secretId: Swift.String? = nil,
        versionId: Swift.String? = nil,
        versionStage: Swift.String? = nil
    )
    {
        self.secretId = secretId
        self.versionId = versionId
        self.versionStage = versionStage
    }
}

struct GetSecretValueInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let versionId: Swift.String?
    public let versionStage: Swift.String?
}

extension GetSecretValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case versionId = "VersionId"
        case versionStage = "VersionStage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let versionStageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionStage)
        versionStage = versionStageDecoded
    }
}

extension GetSecretValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSecretValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DecryptionFailure" : self = .decryptionFailure(try DecryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSecretValueOutputError: Swift.Error, Swift.Equatable {
    case decryptionFailure(DecryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSecretValueOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSecretValueOutputResponse(aRN: \(Swift.String(describing: aRN)), createdDate: \(Swift.String(describing: createdDate)), name: \(Swift.String(describing: name)), secretBinary: \(Swift.String(describing: secretBinary)), secretString: \(Swift.String(describing: secretString)), versionId: \(Swift.String(describing: versionId)), versionStages: \(Swift.String(describing: versionStages)))"}
}

extension GetSecretValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSecretValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.createdDate = output.createdDate
            self.name = output.name
            self.secretBinary = output.secretBinary
            self.secretString = output.secretString
            self.versionId = output.versionId
            self.versionStages = output.versionStages
        } else {
            self.aRN = nil
            self.createdDate = nil
            self.name = nil
            self.secretBinary = nil
            self.secretString = nil
            self.versionId = nil
            self.versionStages = nil
        }
    }
}

public struct GetSecretValueOutputResponse: Swift.Equatable {
    /// The ARN of the secret.
    public let aRN: Swift.String?
    /// The date and time that this version of the secret was created.
    public let createdDate: ClientRuntime.Date?
    /// The friendly name of the secret.
    public let name: Swift.String?
    /// The decrypted part of the protected secret information that was originally provided as
    ///       binary data in the form of a byte array. The response parameter represents the binary data as
    ///       a <a href="https://tools.ietf.org/html/rfc4648#section-4">base64-encoded
    ///       string.
    ///          This parameter is not used if the secret is created by the Secrets Manager console.
    ///          If you store custom information in this field of the secret, then you must code your
    ///       Lambda rotation function to parse and interpret whatever you store in the
    ///         SecretString or SecretBinary fields.
    public let secretBinary: ClientRuntime.Data?
    /// The decrypted part of the protected secret information that was originally provided as a
    ///       string.
    ///          If you create this secret by using the Secrets Manager console then only the
    ///         SecretString parameter contains data. Secrets Manager stores the information as a
    ///       JSON structure of key/value pairs that the Lambda rotation function knows how to parse.
    ///          If you store custom information in the secret by using the CreateSecret,
    ///         UpdateSecret, or PutSecretValue API operations instead
    ///       of the Secrets Manager console, or by using the Other secret type in
    ///       the console, then you must code your Lambda rotation function to parse and interpret those
    ///       values.
    public let secretString: Swift.String?
    /// The unique identifier of this version of the secret.
    public let versionId: Swift.String?
    /// A list of all of the staging labels currently attached to this version of the
    ///       secret.
    public let versionStages: [Swift.String]?

    public init (
        aRN: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        secretBinary: ClientRuntime.Data? = nil,
        secretString: Swift.String? = nil,
        versionId: Swift.String? = nil,
        versionStages: [Swift.String]? = nil
    )
    {
        self.aRN = aRN
        self.createdDate = createdDate
        self.name = name
        self.secretBinary = secretBinary
        self.secretString = secretString
        self.versionId = versionId
        self.versionStages = versionStages
    }
}

struct GetSecretValueOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
    public let secretBinary: ClientRuntime.Data?
    public let secretString: Swift.String?
    public let versionStages: [Swift.String]?
    public let createdDate: ClientRuntime.Date?
}

extension GetSecretValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case createdDate = "CreatedDate"
        case name = "Name"
        case secretBinary = "SecretBinary"
        case secretString = "SecretString"
        case versionId = "VersionId"
        case versionStages = "VersionStages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretString)
        secretString = secretStringDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[Swift.String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [Swift.String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension InternalServiceError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServiceError(message: \(Swift.String(describing: message)))"}
}

extension InternalServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred on the server side.
public struct InternalServiceError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You provided an invalid NextToken value.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You provided an invalid value for a parameter.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You provided a parameter value that is not valid for the current state of the
///       resource.
///          Possible causes:
///
///
///                You tried to perform the operation on a secret that's currently marked deleted.
///
///
///                You tried to enable rotation on a secret that doesn't already have a Lambda function
///           ARN configured and you didn't include such an ARN as a parameter in this call.
///
///
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because it would exceed one of the Secrets Manager internal limits.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListSecretVersionIdsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretVersionIdsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretVersionIdsOutputError>
}

extension ListSecretVersionIdsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSecretVersionIdsInput(includeDeprecated: \(Swift.String(describing: includeDeprecated)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), secretId: \(Swift.String(describing: secretId)))"}
}

extension ListSecretVersionIdsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeDeprecated = "IncludeDeprecated"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if includeDeprecated != false {
            try encodeContainer.encode(includeDeprecated, forKey: .includeDeprecated)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct ListSecretVersionIdsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretVersionIdsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretVersionIdsOutputError>
}

public struct ListSecretVersionIdsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretVersionIdsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretVersionIdsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretVersionIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretVersionIdsOutputError>
}

public struct ListSecretVersionIdsInput: Swift.Equatable {
    /// (Optional) Specifies that you want the results to include versions that do not have any
    ///       staging labels attached to them. Such versions are considered deprecated and are subject to
    ///       deletion by Secrets Manager as needed.
    public let includeDeprecated: Swift.Bool
    /// (Optional) Limits the number of results you want to include in
    ///     the response. If you don't include this parameter, it defaults to a value that's
    ///     specific to the operation. If additional items exist beyond the maximum you specify, the
    ///     NextToken response element is present and has a value (isn't null). Include
    ///     that value as the NextToken request parameter in the next call to the operation to
    ///     get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
    ///     even when there are more results available. You should check NextToken after every
    ///     operation to ensure that you receive all of the results.
    public let maxResults: Swift.Int
    /// (Optional) Use this parameter in a request if you receive a
    ///     NextToken response in a previous request indicating there's more
    ///     output available. In a subsequent call, set it to the value of the previous call
    ///     NextToken response to indicate where the output should continue from.
    public let nextToken: Swift.String?
    /// The identifier for the secret containing the versions you want to list. You can specify
    ///       either the Amazon Resource Name (ARN) or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        includeDeprecated: Swift.Bool = false,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        secretId: Swift.String? = nil
    )
    {
        self.includeDeprecated = includeDeprecated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.secretId = secretId
    }
}

struct ListSecretVersionIdsInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
    public let includeDeprecated: Swift.Bool
}

extension ListSecretVersionIdsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeDeprecated = "IncludeDeprecated"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let includeDeprecatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeDeprecated)
        includeDeprecated = includeDeprecatedDecoded
    }
}

extension ListSecretVersionIdsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecretVersionIdsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecretVersionIdsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecretVersionIdsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSecretVersionIdsOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), versions: \(Swift.String(describing: versions)))"}
}

extension ListSecretVersionIdsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecretVersionIdsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.aRN = nil
            self.name = nil
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListSecretVersionIdsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the secret.
    ///
    ///             Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    ///         you initially create a secret. This affects only the ARN and not the actual friendly name.
    ///         This ensures that if you create a new secret with the same name as an old secret that you
    ///         previously deleted, then users with access to the old secret don't
    ///         automatically get access to the new secret because the ARNs are different.
    ///
    public let aRN: Swift.String?
    /// The friendly name of the secret.
    public let name: Swift.String?
    /// If present in the response, this value indicates that
    ///     there's more output available than included in the current response. This can
    ///     occur even when the response includes no values at all, such as when you ask for a filtered view
    ///     of a very long list. Use this value in the NextToken request parameter in a
    ///     subsequent call to the operation to continue processing and get the next part of the output. You
    ///     should repeat this until the NextToken response element comes back empty (as
    ///     null).
    public let nextToken: Swift.String?
    /// The list of the currently available versions of the specified secret.
    public let versions: [SecretsManagerClientTypes.SecretVersionsListEntry]?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        versions: [SecretsManagerClientTypes.SecretVersionsListEntry]? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListSecretVersionIdsOutputResponseBody: Swift.Equatable {
    public let versions: [SecretsManagerClientTypes.SecretVersionsListEntry]?
    public let nextToken: Swift.String?
    public let aRN: Swift.String?
    public let name: Swift.String?
}

extension ListSecretVersionIdsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.SecretVersionsListEntry?].self, forKey: .versions)
        var versionsDecoded0:[SecretsManagerClientTypes.SecretVersionsListEntry]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [SecretsManagerClientTypes.SecretVersionsListEntry]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct ListSecretsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretsOutputError>
}

extension ListSecretsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSecretsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sortOrder: \(Swift.String(describing: sortOrder)))"}
}

extension ListSecretsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterslisttype0 in filters {
                try filtersContainer.encode(filterslisttype0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListSecretsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretsOutputError>
}

public struct ListSecretsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecretsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecretsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecretsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecretsOutputError>
}

public struct ListSecretsInput: Swift.Equatable {
    /// Lists the secret request filters.
    public let filters: [SecretsManagerClientTypes.Filter]?
    /// (Optional) Limits the number of results you want to include in
    ///     the response. If you don't include this parameter, it defaults to a value that's
    ///     specific to the operation. If additional items exist beyond the maximum you specify, the
    ///     NextToken response element is present and has a value (isn't null). Include
    ///     that value as the NextToken request parameter in the next call to the operation to
    ///     get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
    ///     even when there are more results available. You should check NextToken after every
    ///     operation to ensure that you receive all of the results.
    public let maxResults: Swift.Int
    /// (Optional) Use this parameter in a request if you receive a
    ///     NextToken response in a previous request indicating there's more
    ///     output available. In a subsequent call, set it to the value of the previous call
    ///     NextToken response to indicate where the output should continue from.
    public let nextToken: Swift.String?
    /// Lists secrets in the requested order.
    public let sortOrder: SecretsManagerClientTypes.SortOrderType?

    public init (
        filters: [SecretsManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sortOrder: SecretsManagerClientTypes.SortOrderType? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListSecretsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
    public let filters: [SecretsManagerClientTypes.Filter]?
    public let sortOrder: SecretsManagerClientTypes.SortOrderType?
}

extension ListSecretsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[SecretsManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SecretsManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListSecretsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecretsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecretsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecretsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSecretsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), secretList: \(Swift.String(describing: secretList)))"}
}

extension ListSecretsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecretsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.secretList = output.secretList
        } else {
            self.nextToken = nil
            self.secretList = nil
        }
    }
}

public struct ListSecretsOutputResponse: Swift.Equatable {
    /// If present in the response, this value indicates that
    ///     there's more output available than included in the current response. This can
    ///     occur even when the response includes no values at all, such as when you ask for a filtered view
    ///     of a very long list. Use this value in the NextToken request parameter in a
    ///     subsequent call to the operation to continue processing and get the next part of the output. You
    ///     should repeat this until the NextToken response element comes back empty (as
    ///     null).
    public let nextToken: Swift.String?
    /// A list of the secrets in the account.
    public let secretList: [SecretsManagerClientTypes.SecretListEntry]?

    public init (
        nextToken: Swift.String? = nil,
        secretList: [SecretsManagerClientTypes.SecretListEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.secretList = secretList
    }
}

struct ListSecretsOutputResponseBody: Swift.Equatable {
    public let secretList: [SecretsManagerClientTypes.SecretListEntry]?
    public let nextToken: Swift.String?
}

extension ListSecretsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case secretList = "SecretList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretListContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.SecretListEntry?].self, forKey: .secretList)
        var secretListDecoded0:[SecretsManagerClientTypes.SecretListEntry]? = nil
        if let secretListContainer = secretListContainer {
            secretListDecoded0 = [SecretsManagerClientTypes.SecretListEntry]()
            for structure0 in secretListContainer {
                if let structure0 = structure0 {
                    secretListDecoded0?.append(structure0)
                }
            }
        }
        secretList = secretListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MalformedPolicyDocumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MalformedPolicyDocumentException(message: \(Swift.String(describing: message)))"}
}

extension MalformedPolicyDocumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MalformedPolicyDocumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You provided a resource-based policy with syntax errors.
public struct MalformedPolicyDocumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MalformedPolicyDocumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionNotMetException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreconditionNotMetException(message: \(Swift.String(describing: message)))"}
}

extension PreconditionNotMetException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreconditionNotMetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because you did not complete all the prerequisite steps.
public struct PreconditionNotMetException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionNotMetExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PreconditionNotMetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PublicPolicyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicPolicyException(message: \(Swift.String(describing: message)))"}
}

extension PublicPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublicPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The BlockPublicPolicy parameter is set to true and the resource policy did not prevent broad access to the secret.
public struct PublicPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PublicPolicyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PublicPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutResourcePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

extension PutResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutResourcePolicyInput(blockPublicPolicy: \(Swift.String(describing: blockPublicPolicy)), resourcePolicy: \(Swift.String(describing: resourcePolicy)), secretId: \(Swift.String(describing: secretId)))"}
}

extension PutResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicPolicy = "BlockPublicPolicy"
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockPublicPolicy != false {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if let resourcePolicy = resourcePolicy {
            try encodeContainer.encode(resourcePolicy, forKey: .resourcePolicy)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct PutResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// (Optional) If you set the parameter, BlockPublicPolicy to true, then you
    ///       block resource-based policies that allow broad access to the secret.
    public let blockPublicPolicy: Swift.Bool
    /// A JSON-formatted string constructed according to the grammar and syntax for an Amazon Web Services
    ///       resource-based policy. The policy in the string identifies who can access or manage this
    ///       secret and its versions. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
    ///         JSON for Parameters in the CLI User Guide.
    /// This member is required.
    public let resourcePolicy: Swift.String?
    /// Specifies the secret that you want to attach the resource-based policy. You can specify
    ///       either the ARN or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        blockPublicPolicy: Swift.Bool = false,
        resourcePolicy: Swift.String? = nil,
        secretId: Swift.String? = nil
    )
    {
        self.blockPublicPolicy = blockPublicPolicy
        self.resourcePolicy = resourcePolicy
        self.secretId = secretId
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let resourcePolicy: Swift.String?
    public let blockPublicPolicy: Swift.Bool
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicPolicy = "BlockPublicPolicy"
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
        let blockPublicPolicyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
    }
}

extension PutResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicPolicyException" : self = .publicPolicyException(try PublicPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case publicPolicyException(PublicPolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutResourcePolicyOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension PutResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Swift.Equatable {
    /// The ARN of the secret retrieved by the resource-based policy.
    public let aRN: Swift.String?
    /// The friendly name of the secret retrieved by the resource-based policy.
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct PutResourcePolicyOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
}

extension PutResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct PutSecretValueInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSecretValueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSecretValueOutputError>
}

extension PutSecretValueInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSecretValueInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), secretBinary: \(Swift.String(describing: secretBinary)), secretId: \(Swift.String(describing: secretId)), secretString: \(Swift.String(describing: secretString)), versionStages: \(Swift.String(describing: versionStages)))"}
}

extension PutSecretValueInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
        case versionStages = "VersionStages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let secretBinary = secretBinary {
            try encodeContainer.encode(secretBinary.base64EncodedString(), forKey: .secretBinary)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let secretString = secretString {
            try encodeContainer.encode(secretString, forKey: .secretString)
        }
        if let versionStages = versionStages {
            var versionStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versionStages)
            for secretversionstagestype0 in versionStages {
                try versionStagesContainer.encode(secretversionstagestype0)
            }
        }
    }
}

public struct PutSecretValueInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSecretValueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSecretValueOutputError>
}

public struct PutSecretValueInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSecretValueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSecretValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSecretValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSecretValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSecretValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSecretValueOutputError>
}

public struct PutSecretValueInput: Swift.Equatable {
    /// (Optional) Specifies a unique identifier for the new version of the secret.
    ///
    ///             If you use the Amazon Web Services CLI or one of the Amazon Web Services SDK to call this operation, then you can
    ///         leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    ///         in the request. If you don't use the SDK and instead generate a raw HTTP request to the
    ///         Secrets Manager service endpoint, then you must generate a ClientRequestToken yourself
    ///         for new versions and include that value in the request.
    ///
    ///          This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
    ///       creation of duplicate versions if there are failures and retries during the Lambda rotation
    ///       function's processing. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type value to
    ///       ensure uniqueness within the specified secret.
    ///
    ///
    ///                If the ClientRequestToken value isn't already associated with a version
    ///           of the secret then a new version of the secret is created.
    ///
    ///
    ///                If a version with this value already exists and that version's
    ///             SecretString or SecretBinary values are the same as those in
    ///           the request then the request is ignored (the operation is idempotent).
    ///
    ///
    ///                If a version with this value already exists and the version of the
    ///             SecretString and SecretBinary values are different from those
    ///           in the request then the request fails because you cannot modify an existing secret
    ///           version. You can only create new versions to store new secret values.
    ///
    ///
    ///          This value becomes the VersionId of the new version.
    public var clientRequestToken: Swift.String?
    /// (Optional) Specifies binary data that you want to encrypt and store in the new version of
    ///       the secret. To use this parameter in the command-line tools, we recommend that you store your
    ///       binary data in a file and then use the appropriate technique for your tool to pass the
    ///       contents of the file as a parameter. Either SecretBinary or
    ///         SecretString must have a value, but not both. They cannot both be empty.
    ///
    ///          This parameter is not accessible if the secret using the Secrets Manager console.
    ///
    public let secretBinary: ClientRuntime.Data?
    /// Specifies the secret to which you want to add a new version. You can specify either the
    ///       Amazon Resource Name (ARN) or the friendly name of the secret. The secret must already
    ///       exist.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?
    /// (Optional) Specifies text data that you want to encrypt and store in this new version of
    ///       the secret. Either SecretString or SecretBinary must have a value,
    ///       but not both. They cannot both be empty.
    ///
    ///          If you create this secret by using the Secrets Manager console then Secrets Manager puts the
    ///       protected secret text in only the SecretString parameter. The Secrets Manager console
    ///       stores the information as a JSON structure of key/value pairs that the default Lambda rotation
    ///       function knows how to parse.
    ///          For storing multiple values, we recommend that you use a JSON text string argument and
    ///       specify key/value pairs. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters in the CLI User Guide.
    ///           For example:
    ///
    ///             [{"username":"bob"},{"password":"abc123xyz456"}]
    ///
    ///          If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text.
    public let secretString: Swift.String?
    /// (Optional) Specifies a list of staging labels that are attached to this version of the
    ///       secret. These staging labels are used to track the versions through the rotation process by
    ///       the Lambda rotation function.
    ///          A staging label must be unique to a single version of the secret. If you specify a staging
    ///       label that's already associated with a different version of the same secret then that staging
    ///       label is automatically removed from the other version and attached to this version.
    ///          If you do not specify a value for VersionStages then Secrets Manager automatically
    ///       moves the staging label AWSCURRENT to this new version.
    public let versionStages: [Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        secretBinary: ClientRuntime.Data? = nil,
        secretId: Swift.String? = nil,
        secretString: Swift.String? = nil,
        versionStages: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.secretBinary = secretBinary
        self.secretId = secretId
        self.secretString = secretString
        self.versionStages = versionStages
    }
}

struct PutSecretValueInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let secretBinary: ClientRuntime.Data?
    public let secretString: Swift.String?
    public let versionStages: [Swift.String]?
}

extension PutSecretValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
        case versionStages = "VersionStages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretString)
        secretString = secretStringDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[Swift.String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [Swift.String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
    }
}

extension PutSecretValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSecretValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionFailure" : self = .encryptionFailure(try EncryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSecretValueOutputError: Swift.Error, Swift.Equatable {
    case encryptionFailure(EncryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSecretValueOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSecretValueOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), versionId: \(Swift.String(describing: versionId)), versionStages: \(Swift.String(describing: versionStages)))"}
}

extension PutSecretValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutSecretValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
            self.versionStages = output.versionStages
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
            self.versionStages = nil
        }
    }
}

public struct PutSecretValueOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the secret for which you just created a version.
    public let aRN: Swift.String?
    /// The friendly name of the secret for which you just created or updated a version.
    public let name: Swift.String?
    /// The unique identifier of the version of the secret you just created or updated.
    public let versionId: Swift.String?
    /// The list of staging labels that are currently attached to this version of the secret.
    ///       Staging labels are used to track a version as it progresses through the secret rotation
    ///       process.
    public let versionStages: [Swift.String]?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        versionId: Swift.String? = nil,
        versionStages: [Swift.String]? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
        self.versionStages = versionStages
    }
}

struct PutSecretValueOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
    public let versionStages: [Swift.String]?
}

extension PutSecretValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
        case versionStages = "VersionStages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[Swift.String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [Swift.String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
    }
}

public struct RemoveRegionsFromReplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRegionsFromReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRegionsFromReplicationOutputError>
}

extension RemoveRegionsFromReplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveRegionsFromReplicationInput(removeReplicaRegions: \(Swift.String(describing: removeReplicaRegions)), secretId: \(Swift.String(describing: secretId)))"}
}

extension RemoveRegionsFromReplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case removeReplicaRegions = "RemoveReplicaRegions"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let removeReplicaRegions = removeReplicaRegions {
            var removeReplicaRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeReplicaRegions)
            for removereplicaregionlisttype0 in removeReplicaRegions {
                try removeReplicaRegionsContainer.encode(removereplicaregionlisttype0)
            }
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct RemoveRegionsFromReplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRegionsFromReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRegionsFromReplicationOutputError>
}

public struct RemoveRegionsFromReplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRegionsFromReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRegionsFromReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRegionsFromReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRegionsFromReplicationOutputError>
}

public struct RemoveRegionsFromReplicationInput: Swift.Equatable {
    /// Remove replication from specific Regions.
    /// This member is required.
    public let removeReplicaRegions: [Swift.String]?
    /// Remove a secret by SecretId from replica Regions.
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        removeReplicaRegions: [Swift.String]? = nil,
        secretId: Swift.String? = nil
    )
    {
        self.removeReplicaRegions = removeReplicaRegions
        self.secretId = secretId
    }
}

struct RemoveRegionsFromReplicationInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let removeReplicaRegions: [Swift.String]?
}

extension RemoveRegionsFromReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case removeReplicaRegions = "RemoveReplicaRegions"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let removeReplicaRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeReplicaRegions)
        var removeReplicaRegionsDecoded0:[Swift.String]? = nil
        if let removeReplicaRegionsContainer = removeReplicaRegionsContainer {
            removeReplicaRegionsDecoded0 = [Swift.String]()
            for string0 in removeReplicaRegionsContainer {
                if let string0 = string0 {
                    removeReplicaRegionsDecoded0?.append(string0)
                }
            }
        }
        removeReplicaRegions = removeReplicaRegionsDecoded0
    }
}

extension RemoveRegionsFromReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveRegionsFromReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRegionsFromReplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRegionsFromReplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveRegionsFromReplicationOutputResponse(aRN: \(Swift.String(describing: aRN)), replicationStatus: \(Swift.String(describing: replicationStatus)))"}
}

extension RemoveRegionsFromReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveRegionsFromReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.replicationStatus = output.replicationStatus
        } else {
            self.aRN = nil
            self.replicationStatus = nil
        }
    }
}

public struct RemoveRegionsFromReplicationOutputResponse: Swift.Equatable {
    /// The secret ARN removed from replication regions.
    public let aRN: Swift.String?
    /// Describes the remaining replication status after you remove regions from the replication list.
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?

    public init (
        aRN: Swift.String? = nil,
        replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]? = nil
    )
    {
        self.aRN = aRN
        self.replicationStatus = replicationStatus
    }
}

struct RemoveRegionsFromReplicationOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
}

extension RemoveRegionsFromReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case replicationStatus = "ReplicationStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[SecretsManagerClientTypes.ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [SecretsManagerClientTypes.ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension SecretsManagerClientTypes.ReplicaRegionType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SecretsManagerClientTypes.ReplicaRegionType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicaRegionType(kmsKeyId: \(Swift.String(describing: kmsKeyId)), region: \(Swift.String(describing: region)))"}
}

extension SecretsManagerClientTypes {
    /// (Optional) Custom type consisting of a Region (required) and the KmsKeyId which can be an ARN, Key ID, or Alias.
    public struct ReplicaRegionType: Swift.Equatable {
        /// Can be an ARN, Key ID, or Alias.
        public let kmsKeyId: Swift.String?
        /// Describes a single instance of Region objects.
        public let region: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.region = region
        }
    }

}

public struct ReplicateSecretToRegionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReplicateSecretToRegionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReplicateSecretToRegionsOutputError>
}

extension ReplicateSecretToRegionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicateSecretToRegionsInput(addReplicaRegions: \(Swift.String(describing: addReplicaRegions)), forceOverwriteReplicaSecret: \(Swift.String(describing: forceOverwriteReplicaSecret)), secretId: \(Swift.String(describing: secretId)))"}
}

extension ReplicateSecretToRegionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addReplicaRegions = addReplicaRegions {
            var addReplicaRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addReplicaRegions)
            for addreplicaregionlisttype0 in addReplicaRegions {
                try addReplicaRegionsContainer.encode(addreplicaregionlisttype0)
            }
        }
        if forceOverwriteReplicaSecret != false {
            try encodeContainer.encode(forceOverwriteReplicaSecret, forKey: .forceOverwriteReplicaSecret)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct ReplicateSecretToRegionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReplicateSecretToRegionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReplicateSecretToRegionsOutputError>
}

public struct ReplicateSecretToRegionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReplicateSecretToRegionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReplicateSecretToRegionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReplicateSecretToRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReplicateSecretToRegionsOutputError>
}

public struct ReplicateSecretToRegionsInput: Swift.Equatable {
    /// Add Regions to replicate the secret.
    /// This member is required.
    public let addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]?
    /// (Optional) If set, Secrets Manager replication overwrites a secret with the same name in the
    ///       destination region.
    public let forceOverwriteReplicaSecret: Swift.Bool
    /// Use the Secret Id to replicate a secret to regions.
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]? = nil,
        forceOverwriteReplicaSecret: Swift.Bool = false,
        secretId: Swift.String? = nil
    )
    {
        self.addReplicaRegions = addReplicaRegions
        self.forceOverwriteReplicaSecret = forceOverwriteReplicaSecret
        self.secretId = secretId
    }
}

struct ReplicateSecretToRegionsInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let addReplicaRegions: [SecretsManagerClientTypes.ReplicaRegionType]?
    public let forceOverwriteReplicaSecret: Swift.Bool
}

extension ReplicateSecretToRegionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addReplicaRegions = "AddReplicaRegions"
        case forceOverwriteReplicaSecret = "ForceOverwriteReplicaSecret"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let addReplicaRegionsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicaRegionType?].self, forKey: .addReplicaRegions)
        var addReplicaRegionsDecoded0:[SecretsManagerClientTypes.ReplicaRegionType]? = nil
        if let addReplicaRegionsContainer = addReplicaRegionsContainer {
            addReplicaRegionsDecoded0 = [SecretsManagerClientTypes.ReplicaRegionType]()
            for structure0 in addReplicaRegionsContainer {
                if let structure0 = structure0 {
                    addReplicaRegionsDecoded0?.append(structure0)
                }
            }
        }
        addReplicaRegions = addReplicaRegionsDecoded0
        let forceOverwriteReplicaSecretDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceOverwriteReplicaSecret)
        forceOverwriteReplicaSecret = forceOverwriteReplicaSecretDecoded
    }
}

extension ReplicateSecretToRegionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReplicateSecretToRegionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReplicateSecretToRegionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReplicateSecretToRegionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicateSecretToRegionsOutputResponse(aRN: \(Swift.String(describing: aRN)), replicationStatus: \(Swift.String(describing: replicationStatus)))"}
}

extension ReplicateSecretToRegionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReplicateSecretToRegionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.replicationStatus = output.replicationStatus
        } else {
            self.aRN = nil
            self.replicationStatus = nil
        }
    }
}

public struct ReplicateSecretToRegionsOutputResponse: Swift.Equatable {
    /// Replicate a secret based on the ReplicaRegionType> consisting of a
    ///       Region(required) and a KMSKeyId (optional) which can be the ARN, KeyID, or Alias.
    public let aRN: Swift.String?
    /// Describes the secret replication status as PENDING, SUCCESS or FAIL.
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?

    public init (
        aRN: Swift.String? = nil,
        replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]? = nil
    )
    {
        self.aRN = aRN
        self.replicationStatus = replicationStatus
    }
}

struct ReplicateSecretToRegionsOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let replicationStatus: [SecretsManagerClientTypes.ReplicationStatusType]?
}

extension ReplicateSecretToRegionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case replicationStatus = "ReplicationStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let replicationStatusContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ReplicationStatusType?].self, forKey: .replicationStatus)
        var replicationStatusDecoded0:[SecretsManagerClientTypes.ReplicationStatusType]? = nil
        if let replicationStatusContainer = replicationStatusContainer {
            replicationStatusDecoded0 = [SecretsManagerClientTypes.ReplicationStatusType]()
            for structure0 in replicationStatusContainer {
                if let structure0 = structure0 {
                    replicationStatusDecoded0?.append(structure0)
                }
            }
        }
        replicationStatus = replicationStatusDecoded0
    }
}

extension SecretsManagerClientTypes.ReplicationStatusType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case lastAccessedDate = "LastAccessedDate"
        case region = "Region"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastAccessedDate = lastAccessedDate {
            try encodeContainer.encode(lastAccessedDate.timeIntervalSince1970, forKey: .lastAccessedDate)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
    }
}

extension SecretsManagerClientTypes.ReplicationStatusType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationStatusType(kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastAccessedDate: \(Swift.String(describing: lastAccessedDate)), region: \(Swift.String(describing: region)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension SecretsManagerClientTypes {
    /// A replication object consisting of a RegionReplicationStatus object and includes a Region, KMSKeyId, status, and status message.
    public struct ReplicationStatusType: Swift.Equatable {
        /// Can be an ARN, Key ID, or Alias.
        public let kmsKeyId: Swift.String?
        /// The date that you last accessed the secret in the Region.
        public let lastAccessedDate: ClientRuntime.Date?
        /// The Region where replication occurs.
        public let region: Swift.String?
        /// The status can be InProgress, Failed, or InSync.
        public let status: SecretsManagerClientTypes.StatusType?
        /// Status message such as "Secret with this name already exists in this
        ///         region".
        public let statusMessage: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            lastAccessedDate: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            status: SecretsManagerClientTypes.StatusType? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.lastAccessedDate = lastAccessedDate
            self.region = region
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension ResourceExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource with the ID you requested already exists.
public struct ResourceExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We can't find the resource that you asked for.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestoreSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreSecretOutputError>
}

extension RestoreSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreSecretInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension RestoreSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct RestoreSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreSecretOutputError>
}

public struct RestoreSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreSecretOutputError>
}

public struct RestoreSecretInput: Swift.Equatable {
    /// Specifies the secret that you want to restore from a previously scheduled deletion. You
    ///       can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct RestoreSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension RestoreSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension RestoreSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreSecretOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension RestoreSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct RestoreSecretOutputResponse: Swift.Equatable {
    /// The ARN of the secret that was restored.
    public let aRN: Swift.String?
    /// The friendly name of the secret that was restored.
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct RestoreSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
}

extension RestoreSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct RotateSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateSecretOutputError>
}

extension RotateSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateSecretInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), rotationLambdaARN: \(Swift.String(describing: rotationLambdaARN)), rotationRules: \(Swift.String(describing: rotationRules)), secretId: \(Swift.String(describing: secretId)))"}
}

extension RotateSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rotationLambdaARN = rotationLambdaARN {
            try encodeContainer.encode(rotationLambdaARN, forKey: .rotationLambdaARN)
        }
        if let rotationRules = rotationRules {
            try encodeContainer.encode(rotationRules, forKey: .rotationRules)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct RotateSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateSecretOutputError>
}

public struct RotateSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateSecretOutputError>
}

public struct RotateSecretInput: Swift.Equatable {
    /// (Optional) Specifies a unique identifier for the new version of the secret that helps
    ///       ensure idempotency.
    ///          If you use the Amazon Web Services CLI or one of the Amazon Web Services SDK to call this operation, then you can
    ///       leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    ///       in the request for this parameter. If you don't use the SDK and instead generate a raw HTTP
    ///       request to the Secrets Manager service endpoint, then you must generate a
    ///         ClientRequestToken yourself for new versions and include that value in the
    ///       request.
    ///          You only need to specify your own value if you implement your own retry logic and want to
    ///       ensure that a given secret is not created twice. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type value to
    ///       ensure uniqueness within the specified secret.
    ///          Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
    ///       there are failures and retries during the function's processing. This value becomes the
    ///         VersionId of the new version.
    public var clientRequestToken: Swift.String?
    /// (Optional) Specifies the ARN of the Lambda function that can rotate the secret.
    public let rotationLambdaARN: Swift.String?
    /// A structure that defines the rotation configuration for this secret.
    public let rotationRules: SecretsManagerClientTypes.RotationRulesType?
    /// Specifies the secret that you want to rotate. You can specify either the Amazon Resource
    ///       Name (ARN) or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        rotationLambdaARN: Swift.String? = nil,
        rotationRules: SecretsManagerClientTypes.RotationRulesType? = nil,
        secretId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rotationLambdaARN = rotationLambdaARN
        self.rotationRules = rotationRules
        self.secretId = secretId
    }
}

struct RotateSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let rotationLambdaARN: Swift.String?
    public let rotationRules: SecretsManagerClientTypes.RotationRulesType?
}

extension RotateSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let rotationLambdaARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationLambdaARN)
        rotationLambdaARN = rotationLambdaARNDecoded
        let rotationRulesDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.RotationRulesType.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
    }
}

extension RotateSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RotateSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RotateSecretOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RotateSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), versionId: \(Swift.String(describing: versionId)))"}
}

extension RotateSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RotateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
        }
    }
}

public struct RotateSecretOutputResponse: Swift.Equatable {
    /// The ARN of the secret.
    public let aRN: Swift.String?
    /// The friendly name of the secret.
    public let name: Swift.String?
    /// The ID of the new version of the secret created by the rotation started by this
    ///       request.
    public let versionId: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
    }
}

struct RotateSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
}

extension RotateSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension SecretsManagerClientTypes.RotationRulesType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticallyAfterDays = "AutomaticallyAfterDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if automaticallyAfterDays != 0 {
            try encodeContainer.encode(automaticallyAfterDays, forKey: .automaticallyAfterDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticallyAfterDaysDecoded = try containerValues.decode(Swift.Int.self, forKey: .automaticallyAfterDays)
        automaticallyAfterDays = automaticallyAfterDaysDecoded
    }
}

extension SecretsManagerClientTypes.RotationRulesType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotationRulesType(automaticallyAfterDays: \(Swift.String(describing: automaticallyAfterDays)))"}
}

extension SecretsManagerClientTypes {
    /// A structure that defines the rotation configuration for the secret.
    public struct RotationRulesType: Swift.Equatable {
        /// Specifies the number of days between automatic scheduled rotations of the secret.
        ///          Secrets Manager schedules the next rotation when the previous
        ///     one is complete. Secrets Manager schedules the date by adding the rotation interval (number of days) to the
        ///     actual date of the last rotation. The service chooses the hour within that 24-hour date window
        ///     randomly. The minute is also chosen somewhat randomly, but weighted towards the top of the hour
        ///     and influenced by a variety of factors that help distribute load.
        public let automaticallyAfterDays: Swift.Int

        public init (
            automaticallyAfterDays: Swift.Int = 0
        )
        {
            self.automaticallyAfterDays = automaticallyAfterDays
        }
    }

}

extension SecretsManagerClientTypes.SecretListEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case createdDate = "CreatedDate"
        case deletedDate = "DeletedDate"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case lastAccessedDate = "LastAccessedDate"
        case lastChangedDate = "LastChangedDate"
        case lastRotatedDate = "LastRotatedDate"
        case name = "Name"
        case owningService = "OwningService"
        case primaryRegion = "PrimaryRegion"
        case rotationEnabled = "RotationEnabled"
        case rotationLambdaARN = "RotationLambdaARN"
        case rotationRules = "RotationRules"
        case secretVersionsToStages = "SecretVersionsToStages"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let deletedDate = deletedDate {
            try encodeContainer.encode(deletedDate.timeIntervalSince1970, forKey: .deletedDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastAccessedDate = lastAccessedDate {
            try encodeContainer.encode(lastAccessedDate.timeIntervalSince1970, forKey: .lastAccessedDate)
        }
        if let lastChangedDate = lastChangedDate {
            try encodeContainer.encode(lastChangedDate.timeIntervalSince1970, forKey: .lastChangedDate)
        }
        if let lastRotatedDate = lastRotatedDate {
            try encodeContainer.encode(lastRotatedDate.timeIntervalSince1970, forKey: .lastRotatedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningService = owningService {
            try encodeContainer.encode(owningService, forKey: .owningService)
        }
        if let primaryRegion = primaryRegion {
            try encodeContainer.encode(primaryRegion, forKey: .primaryRegion)
        }
        if rotationEnabled != false {
            try encodeContainer.encode(rotationEnabled, forKey: .rotationEnabled)
        }
        if let rotationLambdaARN = rotationLambdaARN {
            try encodeContainer.encode(rotationLambdaARN, forKey: .rotationLambdaARN)
        }
        if let rotationRules = rotationRules {
            try encodeContainer.encode(rotationRules, forKey: .rotationRules)
        }
        if let secretVersionsToStages = secretVersionsToStages {
            var secretVersionsToStagesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .secretVersionsToStages)
            for (dictKey0, secretversionstostagesmaptype0) in secretVersionsToStages {
                try secretVersionsToStagesContainer.encode(secretversionstostagesmaptype0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglisttype0 in tags {
                try tagsContainer.encode(taglisttype0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let rotationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .rotationEnabled)
        rotationEnabled = rotationEnabledDecoded
        let rotationLambdaARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationLambdaARN)
        rotationLambdaARN = rotationLambdaARNDecoded
        let rotationRulesDecoded = try containerValues.decodeIfPresent(SecretsManagerClientTypes.RotationRulesType.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
        let lastRotatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastRotatedDate)
        lastRotatedDate = lastRotatedDateDecoded
        let lastChangedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastChangedDate)
        lastChangedDate = lastChangedDateDecoded
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
        let deletedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletedDate)
        deletedDate = deletedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecretsManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecretsManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let secretVersionsToStagesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .secretVersionsToStages)
        var secretVersionsToStagesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let secretVersionsToStagesContainer = secretVersionsToStagesContainer {
            secretVersionsToStagesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, secretversionstagestype0) in secretVersionsToStagesContainer {
                var secretversionstagestype0Decoded0: [Swift.String]? = nil
                if let secretversionstagestype0 = secretversionstagestype0 {
                    secretversionstagestype0Decoded0 = [Swift.String]()
                    for string1 in secretversionstagestype0 {
                        if let string1 = string1 {
                            secretversionstagestype0Decoded0?.append(string1)
                        }
                    }
                }
                secretVersionsToStagesDecoded0?[key0] = secretversionstagestype0Decoded0
            }
        }
        secretVersionsToStages = secretVersionsToStagesDecoded0
        let owningServiceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningService)
        owningService = owningServiceDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let primaryRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryRegion)
        primaryRegion = primaryRegionDecoded
    }
}

extension SecretsManagerClientTypes.SecretListEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecretListEntry(aRN: \(Swift.String(describing: aRN)), createdDate: \(Swift.String(describing: createdDate)), deletedDate: \(Swift.String(describing: deletedDate)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastAccessedDate: \(Swift.String(describing: lastAccessedDate)), lastChangedDate: \(Swift.String(describing: lastChangedDate)), lastRotatedDate: \(Swift.String(describing: lastRotatedDate)), name: \(Swift.String(describing: name)), owningService: \(Swift.String(describing: owningService)), primaryRegion: \(Swift.String(describing: primaryRegion)), rotationEnabled: \(Swift.String(describing: rotationEnabled)), rotationLambdaARN: \(Swift.String(describing: rotationLambdaARN)), rotationRules: \(Swift.String(describing: rotationRules)), secretVersionsToStages: \(Swift.String(describing: secretVersionsToStages)), tags: \(Swift.String(describing: tags)))"}
}

extension SecretsManagerClientTypes {
    /// A structure that contains the details about a secret. It does not include the encrypted
    ///         SecretString and SecretBinary values. To get those values, use the
    ///         GetSecretValue operation.
    public struct SecretListEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the secret.
        ///          For more information about ARNs in Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_iam-permissions.html#iam-resources">Policy Resources in the
        ///     Amazon Web Services Secrets Manager User Guide.
        public let aRN: Swift.String?
        /// The date and time when a secret was created.
        public let createdDate: ClientRuntime.Date?
        /// The date and time the deletion of the secret occurred. Not present on active secrets. The
        ///       secret can be recovered until the number of days in the recovery window has passed, as
        ///       specified in the RecoveryWindowInDays parameter of the DeleteSecret operation.
        public let deletedDate: ClientRuntime.Date?
        /// The user-provided description of the secret.
        public let description: Swift.String?
        /// The ARN or alias of the Amazon Web Services KMS customer master key (CMK) used to encrypt the
        ///         SecretString and SecretBinary fields in each version of the
        ///       secret. If you don't provide a key, then Secrets Manager defaults to encrypting the secret fields with
        ///       the default KMS CMK, the key named awssecretsmanager, for this account.
        public let kmsKeyId: Swift.String?
        /// The last date that this secret was accessed. This value is truncated to midnight of the
        ///       date and therefore shows only the date, not the time.
        public let lastAccessedDate: ClientRuntime.Date?
        /// The last date and time that this secret was modified in any way.
        public let lastChangedDate: ClientRuntime.Date?
        /// The most recent date and time that the Secrets Manager rotation process was successfully completed. This value is null if the secret hasn't ever rotated.
        public let lastRotatedDate: ClientRuntime.Date?
        /// The friendly name of the secret. You can use forward slashes in the name to represent a
        ///       path hierarchy. For example, /prod/databases/dbserver1 could represent the secret
        ///       for a server named dbserver1 in the folder databases in the folder
        ///         prod.
        public let name: Swift.String?
        /// Returns the name of the service that created the secret.
        public let owningService: Swift.String?
        /// The Region where Secrets Manager originated the secret.
        public let primaryRegion: Swift.String?
        /// Indicates whether automatic, scheduled rotation is enabled for this secret.
        public let rotationEnabled: Swift.Bool
        /// The ARN of an Amazon Web Services Lambda function invoked by Secrets Manager to rotate and expire the
        ///       secret either automatically per the schedule or manually by a call to RotateSecret.
        public let rotationLambdaARN: Swift.String?
        /// A structure that defines the rotation configuration for the secret.
        public let rotationRules: SecretsManagerClientTypes.RotationRulesType?
        /// A list of all of the currently assigned SecretVersionStage staging labels and
        ///       the SecretVersionId attached to each one. Staging labels are used to keep
        ///       track of the different versions during the rotation process.
        ///
        ///             A version that does not have any SecretVersionStage is considered
        ///         deprecated and subject to deletion. Such versions are not included in this list.
        ///
        public let secretVersionsToStages: [Swift.String:[Swift.String]]?
        /// The list of user-defined tags associated with the secret. To add tags to a
        ///       secret, use TagResource. To remove tags, use UntagResource.
        public let tags: [SecretsManagerClientTypes.Tag]?

        public init (
            aRN: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            deletedDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            lastAccessedDate: ClientRuntime.Date? = nil,
            lastChangedDate: ClientRuntime.Date? = nil,
            lastRotatedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owningService: Swift.String? = nil,
            primaryRegion: Swift.String? = nil,
            rotationEnabled: Swift.Bool = false,
            rotationLambdaARN: Swift.String? = nil,
            rotationRules: SecretsManagerClientTypes.RotationRulesType? = nil,
            secretVersionsToStages: [Swift.String:[Swift.String]]? = nil,
            tags: [SecretsManagerClientTypes.Tag]? = nil
        )
        {
            self.aRN = aRN
            self.createdDate = createdDate
            self.deletedDate = deletedDate
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.lastAccessedDate = lastAccessedDate
            self.lastChangedDate = lastChangedDate
            self.lastRotatedDate = lastRotatedDate
            self.name = name
            self.owningService = owningService
            self.primaryRegion = primaryRegion
            self.rotationEnabled = rotationEnabled
            self.rotationLambdaARN = rotationLambdaARN
            self.rotationRules = rotationRules
            self.secretVersionsToStages = secretVersionsToStages
            self.tags = tags
        }
    }

}

extension SecretsManagerClientTypes.SecretVersionsListEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case kmsKeyIds = "KmsKeyIds"
        case lastAccessedDate = "LastAccessedDate"
        case versionId = "VersionId"
        case versionStages = "VersionStages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let kmsKeyIds = kmsKeyIds {
            var kmsKeyIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .kmsKeyIds)
            for kmskeyidlisttype0 in kmsKeyIds {
                try kmsKeyIdsContainer.encode(kmskeyidlisttype0)
            }
        }
        if let lastAccessedDate = lastAccessedDate {
            try encodeContainer.encode(lastAccessedDate.timeIntervalSince1970, forKey: .lastAccessedDate)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
        if let versionStages = versionStages {
            var versionStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versionStages)
            for secretversionstagestype0 in versionStages {
                try versionStagesContainer.encode(secretversionstagestype0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let versionStagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versionStages)
        var versionStagesDecoded0:[Swift.String]? = nil
        if let versionStagesContainer = versionStagesContainer {
            versionStagesDecoded0 = [Swift.String]()
            for string0 in versionStagesContainer {
                if let string0 = string0 {
                    versionStagesDecoded0?.append(string0)
                }
            }
        }
        versionStages = versionStagesDecoded0
        let lastAccessedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAccessedDate)
        lastAccessedDate = lastAccessedDateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let kmsKeyIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .kmsKeyIds)
        var kmsKeyIdsDecoded0:[Swift.String]? = nil
        if let kmsKeyIdsContainer = kmsKeyIdsContainer {
            kmsKeyIdsDecoded0 = [Swift.String]()
            for string0 in kmsKeyIdsContainer {
                if let string0 = string0 {
                    kmsKeyIdsDecoded0?.append(string0)
                }
            }
        }
        kmsKeyIds = kmsKeyIdsDecoded0
    }
}

extension SecretsManagerClientTypes.SecretVersionsListEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecretVersionsListEntry(createdDate: \(Swift.String(describing: createdDate)), kmsKeyIds: \(Swift.String(describing: kmsKeyIds)), lastAccessedDate: \(Swift.String(describing: lastAccessedDate)), versionId: \(Swift.String(describing: versionId)), versionStages: \(Swift.String(describing: versionStages)))"}
}

extension SecretsManagerClientTypes {
    /// A structure that contains information about one version of a secret.
    public struct SecretVersionsListEntry: Swift.Equatable {
        /// The date and time this version of the secret was created.
        public let createdDate: ClientRuntime.Date?
        /// The KMS keys used to encrypt the secret version.
        public let kmsKeyIds: [Swift.String]?
        /// The date that this version of the secret was last accessed. Note that the resolution of
        ///       this field is at the date level and does not include the time.
        public let lastAccessedDate: ClientRuntime.Date?
        /// The unique version identifier of this version of the secret.
        public let versionId: Swift.String?
        /// An array of staging labels that are currently associated with this version of the
        ///       secret.
        public let versionStages: [Swift.String]?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            kmsKeyIds: [Swift.String]? = nil,
            lastAccessedDate: ClientRuntime.Date? = nil,
            versionId: Swift.String? = nil,
            versionStages: [Swift.String]? = nil
        )
        {
            self.createdDate = createdDate
            self.kmsKeyIds = kmsKeyIds
            self.lastAccessedDate = lastAccessedDate
            self.versionId = versionId
            self.versionStages = versionStages
        }
    }

}

extension SecretsManagerClientTypes {
    public enum SortOrderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrderType] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "asc"
            case .desc: return "desc"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrderType(rawValue: rawValue) ?? SortOrderType.sdkUnknown(rawValue)
        }
    }
}

extension SecretsManagerClientTypes {
    public enum StatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case insync
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusType] {
            return [
                .failed,
                .inprogress,
                .insync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .insync: return "InSync"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusType(rawValue: rawValue) ?? StatusType.sdkUnknown(rawValue)
        }
    }
}

public struct StopReplicationToReplicaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopReplicationToReplicaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopReplicationToReplicaOutputError>
}

extension StopReplicationToReplicaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopReplicationToReplicaInput(secretId: \(Swift.String(describing: secretId)))"}
}

extension StopReplicationToReplicaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct StopReplicationToReplicaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopReplicationToReplicaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopReplicationToReplicaOutputError>
}

public struct StopReplicationToReplicaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopReplicationToReplicaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopReplicationToReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopReplicationToReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopReplicationToReplicaOutputError>
}

public struct StopReplicationToReplicaInput: Swift.Equatable {
    /// Response to StopReplicationToReplica of a secret, based on the SecretId.
    /// This member is required.
    public let secretId: Swift.String?

    public init (
        secretId: Swift.String? = nil
    )
    {
        self.secretId = secretId
    }
}

struct StopReplicationToReplicaInputBody: Swift.Equatable {
    public let secretId: Swift.String?
}

extension StopReplicationToReplicaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension StopReplicationToReplicaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopReplicationToReplicaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopReplicationToReplicaOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopReplicationToReplicaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopReplicationToReplicaOutputResponse(aRN: \(Swift.String(describing: aRN)))"}
}

extension StopReplicationToReplicaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopReplicationToReplicaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
        } else {
            self.aRN = nil
        }
    }
}

public struct StopReplicationToReplicaOutputResponse: Swift.Equatable {
    /// Response StopReplicationToReplica of a secret, based on the ARN,.
    public let aRN: Swift.String?

    public init (
        aRN: Swift.String? = nil
    )
    {
        self.aRN = aRN
    }
}

struct StopReplicationToReplicaOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
}

extension StopReplicationToReplicaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension SecretsManagerClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecretsManagerClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SecretsManagerClientTypes {
    /// A structure that contains information about a tag.
    public struct Tag: Swift.Equatable {
        /// The key identifier, or name, of the tag.
        public let key: Swift.String?
        /// The string value associated with the key of the tag.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(secretId: \(Swift.String(describing: secretId)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglisttype0 in tags {
                try tagsContainer.encode(taglisttype0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The identifier for the secret that you want to attach tags to. You can specify either the
    ///       Amazon Resource Name (ARN) or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?
    /// The tags to attach to the secret. Each element in the list consists of a Key
    ///       and a Value.
    ///          This parameter to the API requires a JSON text string argument. For information on how to
    ///       format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters in the CLI User Guide. For the
    ///       CLI, you can also use the syntax: --Tags Key="Key1",Value="Value1"
    ///         Key="Key2",Value="Value2"[,…]
    ///
    /// This member is required.
    public let tags: [SecretsManagerClientTypes.Tag]?

    public init (
        secretId: Swift.String? = nil,
        tags: [SecretsManagerClientTypes.Tag]? = nil
    )
    {
        self.secretId = secretId
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let tags: [SecretsManagerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecretsManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecretsManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(secretId: \(Swift.String(describing: secretId)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylisttype0 in tagKeys {
                try tagKeysContainer.encode(tagkeylisttype0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The identifier for the secret that you want to remove tags from. You can specify either
    ///       the Amazon Resource Name (ARN) or the friendly name of the secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?
    /// A list of tag key names to remove from the secret. You don't specify the value. Both the
    ///       key and its associated value are removed.
    ///          This parameter to the API requires a JSON text string argument. For information on how to
    ///       format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters in the CLI User Guide.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        secretId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.secretId = secretId
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretId = "SecretId"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretOutputError>
}

extension UpdateSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSecretInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), secretBinary: \(Swift.String(describing: secretBinary)), secretId: \(Swift.String(describing: secretId)), secretString: \(Swift.String(describing: secretString)))"}
}

extension UpdateSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let secretBinary = secretBinary {
            try encodeContainer.encode(secretBinary.base64EncodedString(), forKey: .secretBinary)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let secretString = secretString {
            try encodeContainer.encode(secretString, forKey: .secretString)
        }
    }
}

public struct UpdateSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretOutputError>
}

public struct UpdateSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretOutputError>
}

public struct UpdateSecretInput: Swift.Equatable {
    /// (Optional) If you want to add a new version to the secret, this parameter specifies a
    ///       unique identifier for the new version that helps ensure idempotency.
    ///          If you use the Amazon Web Services CLI or one of the Amazon Web Services SDK to call this operation, then you can
    ///       leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    ///       in the request. If you don't use the SDK and instead generate a raw HTTP request to the Secrets Manager
    ///       service endpoint, then you must generate a ClientRequestToken yourself for new
    ///       versions and include that value in the request.
    ///          You typically only need to interact with this value if you implement your own retry logic
    ///       and want to ensure that a given secret is not created twice. We recommend that you generate a
    ///         <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type
    ///       value to ensure uniqueness within the specified secret.
    ///          Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
    ///       there are failures and retries during the Lambda rotation function's processing.
    ///
    ///
    ///                If the ClientRequestToken value isn't already associated with a version
    ///           of the secret then a new version of the secret is created.
    ///
    ///
    ///                If a version with this value already exists and that version's
    ///             SecretString and SecretBinary values are the same as those in
    ///           the request then the request is ignored (the operation is idempotent).
    ///
    ///
    ///                If a version with this value already exists and that version's
    ///             SecretString and SecretBinary values are different from the
    ///           request then an error occurs because you cannot modify an existing secret value.
    ///
    ///
    ///          This value becomes the VersionId of the new version.
    public var clientRequestToken: Swift.String?
    /// (Optional) Specifies an updated user-provided description of the secret.
    public let description: Swift.String?
    /// (Optional) Specifies an updated ARN or alias of the Amazon Web Services KMS customer master key (CMK) to be
    ///       used to encrypt the protected text in new versions of this secret.
    ///
    ///             You can only use the account's default CMK to encrypt and decrypt if you call this
    ///         operation using credentials from the same account that owns the secret. If the secret is in
    ///         a different account, then you must create a custom CMK and provide the ARN of that CMK in
    ///         this field. The user making the call must have permissions to both the secret and the CMK in
    ///         their respective accounts.
    ///
    public let kmsKeyId: Swift.String?
    /// (Optional) Specifies updated binary data that you want to encrypt and store in the new
    ///       version of the secret. To use this parameter in the command-line tools, we recommend that you
    ///       store your binary data in a file and then use the appropriate technique for your tool to pass
    ///       the contents of the file as a parameter. Either SecretBinary or
    ///         SecretString must have a value, but not both. They cannot both be empty.
    ///          This parameter is not accessible using the Secrets Manager console.
    public let secretBinary: ClientRuntime.Data?
    /// Specifies the secret that you want to modify or to which you want to add a new version.
    ///       You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    ///       secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?
    /// (Optional) Specifies updated text data that you want to encrypt and store in this new
    ///       version of the secret. Either SecretBinary or SecretString must have
    ///       a value, but not both. They cannot both be empty.
    ///          If you create this secret by using the Secrets Manager console then Secrets Manager puts the
    ///       protected secret text in only the SecretString parameter. The Secrets Manager console
    ///       stores the information as a JSON structure of key/value pairs that the default Lambda rotation
    ///       function knows how to parse.
    ///          For storing multiple values, we recommend that you use a JSON text string argument and
    ///       specify key/value pairs. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    ///         Parameters in the CLI User Guide. For example:
    ///
    ///             [{"username":"bob"},{"password":"abc123xyz456"}]
    ///
    ///          If your command-line tool or SDK requires quotation marks around the parameter, you should
    ///       use single quotes to avoid confusion with the double quotes required in the JSON text. You can
    ///       also 'escape' the double quote character in the embedded JSON text by prefacing each with a
    ///       backslash. For example, the following string is surrounded by double-quotes. All of the
    ///       embedded double quotes are escaped:
    ///
    ///             "[{\"username\":\"bob\"},{\"password\":\"abc123xyz456\"}]"
    ///
    public let secretString: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        secretBinary: ClientRuntime.Data? = nil,
        secretId: Swift.String? = nil,
        secretString: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.secretBinary = secretBinary
        self.secretId = secretId
        self.secretString = secretString
    }
}

struct UpdateSecretInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let description: Swift.String?
    public let kmsKeyId: Swift.String?
    public let secretBinary: ClientRuntime.Data?
    public let secretString: Swift.String?
}

extension UpdateSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case secretBinary = "SecretBinary"
        case secretId = "SecretId"
        case secretString = "SecretString"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretBinaryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .secretBinary)
        secretBinary = secretBinaryDecoded
        let secretStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretString)
        secretString = secretStringDecoded
    }
}

extension UpdateSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionFailure" : self = .encryptionFailure(try EncryptionFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSecretOutputError: Swift.Error, Swift.Equatable {
    case encryptionFailure(EncryptionFailure)
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSecretOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)), versionId: \(Swift.String(describing: versionId)))"}
}

extension UpdateSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
            self.versionId = output.versionId
        } else {
            self.aRN = nil
            self.name = nil
            self.versionId = nil
        }
    }
}

public struct UpdateSecretOutputResponse: Swift.Equatable {
    /// The ARN of the secret that was updated.
    ///
    ///             Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    ///         you initially create a secret. This affects only the ARN and not the actual friendly name.
    ///         This ensures that if you create a new secret with the same name as an old secret that you
    ///         previously deleted, then users with access to the old secret don't
    ///         automatically get access to the new secret because the ARNs are different.
    ///
    public let aRN: Swift.String?
    /// The friendly name of the secret that was updated.
    public let name: Swift.String?
    /// If a new version of the secret was created by this operation, then VersionId
    ///       contains the unique identifier of the new version.
    public let versionId: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
        self.versionId = versionId
    }
}

struct UpdateSecretOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
    public let versionId: Swift.String?
}

extension UpdateSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

public struct UpdateSecretVersionStageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretVersionStageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretVersionStageOutputError>
}

extension UpdateSecretVersionStageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSecretVersionStageInput(moveToVersionId: \(Swift.String(describing: moveToVersionId)), removeFromVersionId: \(Swift.String(describing: removeFromVersionId)), secretId: \(Swift.String(describing: secretId)), versionStage: \(Swift.String(describing: versionStage)))"}
}

extension UpdateSecretVersionStageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moveToVersionId = "MoveToVersionId"
        case removeFromVersionId = "RemoveFromVersionId"
        case secretId = "SecretId"
        case versionStage = "VersionStage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let moveToVersionId = moveToVersionId {
            try encodeContainer.encode(moveToVersionId, forKey: .moveToVersionId)
        }
        if let removeFromVersionId = removeFromVersionId {
            try encodeContainer.encode(removeFromVersionId, forKey: .removeFromVersionId)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
        if let versionStage = versionStage {
            try encodeContainer.encode(versionStage, forKey: .versionStage)
        }
    }
}

public struct UpdateSecretVersionStageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretVersionStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretVersionStageOutputError>
}

public struct UpdateSecretVersionStageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecretVersionStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecretVersionStageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecretVersionStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecretVersionStageOutputError>
}

public struct UpdateSecretVersionStageInput: Swift.Equatable {
    /// (Optional) The secret version ID that you want to add the staging label. If you want to
    ///       remove a label from a version, then do not specify this parameter.
    ///          If the staging label is already attached to a different version of the secret, then you
    ///       must also specify the RemoveFromVersionId parameter.
    public let moveToVersionId: Swift.String?
    /// Specifies the secret version ID of the version that the staging label is to be removed
    ///       from. If the staging label you are trying to attach to one version is already attached to a
    ///       different version, then you must include this parameter and specify the version that the label
    ///       is to be removed from. If the label is attached and you either do not specify this parameter,
    ///       or the version ID does not match, then the operation fails.
    public let removeFromVersionId: Swift.String?
    /// Specifies the secret with the version with the list of staging labels you want to modify.
    ///       You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    ///       secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    /// This member is required.
    public let secretId: Swift.String?
    /// The staging label to add to this version.
    /// This member is required.
    public let versionStage: Swift.String?

    public init (
        moveToVersionId: Swift.String? = nil,
        removeFromVersionId: Swift.String? = nil,
        secretId: Swift.String? = nil,
        versionStage: Swift.String? = nil
    )
    {
        self.moveToVersionId = moveToVersionId
        self.removeFromVersionId = removeFromVersionId
        self.secretId = secretId
        self.versionStage = versionStage
    }
}

struct UpdateSecretVersionStageInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let versionStage: Swift.String?
    public let removeFromVersionId: Swift.String?
    public let moveToVersionId: Swift.String?
}

extension UpdateSecretVersionStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moveToVersionId = "MoveToVersionId"
        case removeFromVersionId = "RemoveFromVersionId"
        case secretId = "SecretId"
        case versionStage = "VersionStage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let versionStageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionStage)
        versionStage = versionStageDecoded
        let removeFromVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .removeFromVersionId)
        removeFromVersionId = removeFromVersionIdDecoded
        let moveToVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .moveToVersionId)
        moveToVersionId = moveToVersionIdDecoded
    }
}

extension UpdateSecretVersionStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecretVersionStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSecretVersionStageOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecretVersionStageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSecretVersionStageOutputResponse(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension UpdateSecretVersionStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSecretVersionStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.name = output.name
        } else {
            self.aRN = nil
            self.name = nil
        }
    }
}

public struct UpdateSecretVersionStageOutputResponse: Swift.Equatable {
    /// The ARN of the secret with the modified staging label.
    public let aRN: Swift.String?
    /// The friendly name of the secret with the modified staging label.
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct UpdateSecretVersionStageOutputResponseBody: Swift.Equatable {
    public let aRN: Swift.String?
    public let name: Swift.String?
}

extension UpdateSecretVersionStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct ValidateResourcePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidateResourcePolicyOutputError>
}

extension ValidateResourcePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateResourcePolicyInput(resourcePolicy: \(Swift.String(describing: resourcePolicy)), secretId: \(Swift.String(describing: secretId)))"}
}

extension ValidateResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourcePolicy = resourcePolicy {
            try encodeContainer.encode(resourcePolicy, forKey: .resourcePolicy)
        }
        if let secretId = secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }
}

public struct ValidateResourcePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidateResourcePolicyOutputError>
}

public struct ValidateResourcePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateResourcePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidateResourcePolicyOutputError>
}

public struct ValidateResourcePolicyInput: Swift.Equatable {
    /// A JSON-formatted string constructed according to the grammar and syntax for an Amazon Web Services
    ///       resource-based policy. The policy in the string identifies who can access or manage this
    ///       secret and its versions. For information on how to format a JSON parameter for the various
    ///       command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
    ///         JSON for Parameters in the CLI User Guide.publi
    /// This member is required.
    public let resourcePolicy: Swift.String?
    ///  (Optional) The identifier of the secret with the resource-based policy you want to
    ///       validate. You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    ///       secret.
    ///
    ///             If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    ///         specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    ///         characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    ///         match can work as long as it uniquely matches only one secret. However, if your secret has a
    ///         name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    ///         characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    ///         Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    ///         results. To avoid this situation, we recommend that you don’t create secret names ending
    ///         with a hyphen followed by six characters.
    ///             If you specify an incomplete ARN without the random suffix, and instead provide the
    ///         'friendly name', you must not include the random suffix. If you do include the random suffix added by Secrets Manager,
    ///         you receive either a ResourceNotFoundException or an AccessDeniedException error, depending on your permissions.
    ///
    public let secretId: Swift.String?

    public init (
        resourcePolicy: Swift.String? = nil,
        secretId: Swift.String? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
        self.secretId = secretId
    }
}

struct ValidateResourcePolicyInputBody: Swift.Equatable {
    public let secretId: Swift.String?
    public let resourcePolicy: Swift.String?
}

extension ValidateResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePolicy = "ResourcePolicy"
        case secretId = "SecretId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

extension ValidateResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidateResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateResourcePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateResourcePolicyOutputResponse(policyValidationPassed: \(Swift.String(describing: policyValidationPassed)), validationErrors: \(Swift.String(describing: validationErrors)))"}
}

extension ValidateResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidateResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyValidationPassed = output.policyValidationPassed
            self.validationErrors = output.validationErrors
        } else {
            self.policyValidationPassed = false
            self.validationErrors = nil
        }
    }
}

public struct ValidateResourcePolicyOutputResponse: Swift.Equatable {
    /// Returns a message stating that your Reource Policy passed validation.
    public let policyValidationPassed: Swift.Bool
    /// Returns an error message if your policy doesn't pass validatation.
    public let validationErrors: [SecretsManagerClientTypes.ValidationErrorsEntry]?

    public init (
        policyValidationPassed: Swift.Bool = false,
        validationErrors: [SecretsManagerClientTypes.ValidationErrorsEntry]? = nil
    )
    {
        self.policyValidationPassed = policyValidationPassed
        self.validationErrors = validationErrors
    }
}

struct ValidateResourcePolicyOutputResponseBody: Swift.Equatable {
    public let policyValidationPassed: Swift.Bool
    public let validationErrors: [SecretsManagerClientTypes.ValidationErrorsEntry]?
}

extension ValidateResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyValidationPassed = "PolicyValidationPassed"
        case validationErrors = "ValidationErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyValidationPassedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .policyValidationPassed)
        policyValidationPassed = policyValidationPassedDecoded
        let validationErrorsContainer = try containerValues.decodeIfPresent([SecretsManagerClientTypes.ValidationErrorsEntry?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[SecretsManagerClientTypes.ValidationErrorsEntry]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [SecretsManagerClientTypes.ValidationErrorsEntry]()
            for structure0 in validationErrorsContainer {
                if let structure0 = structure0 {
                    validationErrorsDecoded0?.append(structure0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
    }
}

extension SecretsManagerClientTypes.ValidationErrorsEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName = "CheckName"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension SecretsManagerClientTypes.ValidationErrorsEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationErrorsEntry(checkName: \(Swift.String(describing: checkName)), errorMessage: \(Swift.String(describing: errorMessage)))"}
}

extension SecretsManagerClientTypes {
    /// Displays errors that occurred during validation of the resource policy.
    public struct ValidationErrorsEntry: Swift.Equatable {
        /// Checks the name of the policy.
        public let checkName: Swift.String?
        /// Displays error messages if validation encounters problems during validation of the resource policy.
        public let errorMessage: Swift.String?

        public init (
            checkName: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.checkName = checkName
            self.errorMessage = errorMessage
        }
    }

}
